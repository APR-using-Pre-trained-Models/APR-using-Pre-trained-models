<|startcomment|> setting alias temp directory important optional argument ? overwrite alias needed ( i e improve performance ) instances cached <|endcomment|> public void METHOD_1 ( ) { String VAR_1 = TYPE_1 . getInstance ( ) . getString ( STRING_1 , null ) ; <START> VAR_2 = TYPE_2 . METHOD_2 ( STRING_2 , VAR_1 ) ; <END> }
<|startcomment|> bloc code repeated times centralized a single method <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 != null && VAR_1 . METHOD_2 ( ) ) { <END> METHOD_3 ( ) ; } return VAR_2 . METHOD_1 ( ) ; }
<|startcomment|> StringUtils _CODE_ ( ) <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { Collection < TYPE_4 > VAR_3 = METHOD_2 ( null , null , VAR_2 . METHOD_3 ( ) , null , <START> ( VAR_2 . METHOD_3 ( ) != null ? TYPE_5 . METHOD_4 ( VAR_2 . METHOD_3 ( ) ) : "" ) , <END> null ) ; return METHOD_5 ( TYPE_1 . VAR_4 . VAR_5 , VAR_1 , VAR_3 ) ; }
<|startcomment|> I fear won t able add fail fast ( I proposal add more fail fasts : ) ) other fail fasts added PR fine <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , boolean VAR_3 , TYPE_2 < TYPE_3 > VAR_4 ) { super ( VAR_2 , VAR_3 ) ; if ( VAR_3 && ! ( VAR_4 instanceof TYPE_4 ) ) { throw new IllegalStateException ( STRING_1 + VAR_4 + STRING_2 + TYPE_4 . class . METHOD_1 ( ) + STRING_3 ) ; <START> } <END> this . VAR_4 = VAR_4 ; }
<|startcomment|> need return statement <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 outputStream ) throws IOException { if ( VAR_1 == null || outputStream == null ) { if ( outputStream != null ) { TYPE_3 . METHOD_2 ( outputStream ) ; } return ; } try { TYPE_3 . METHOD_3 ( VAR_1 , outputStream ) ; } finally { TYPE_3 . METHOD_2 ( outputStream ) ; <START> return ; <END> } }
<|startcomment|> change Assert state ( session ! = null STRING_1 ) ; <|endcomment|> protected void METHOD_1 ( ) throws Throwable { <START> if ( session == null ) { <END> throw new IllegalStateException ( STRING_1 ) ; } session . execute ( String . format ( STRING_2 + STRING_3 , VAR_1 ) ) ; session . execute ( String . format ( STRING_4 , VAR_1 ) ) ; }
<|startcomment|> needed statement handles DB care status changed instance <|endcomment|> private void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 . METHOD_3 ( ( ) - > { METHOD_4 ( ) . METHOD_5 ( VAR_1 . METHOD_6 ( ) ) ; <START> VAR_1 . METHOD_7 ( TYPE_4 . VAR_3 ) ; <END> TYPE_3 . METHOD_8 ( VAR_1 . METHOD_9 ( ) , TYPE_4 . VAR_3 ) ; METHOD_4 ( ) . METHOD_10 ( ) ; return null ; } ) ; }
<|startcomment|> s motivation swallowing exception a warning ? _CODE_ ( improved version want logging ) <|endcomment|> public synchronized void close ( ) { try { TYPE_1 VAR_1 = TYPE_1 . create ( ) ; if ( VAR_2 != null ) { VAR_1 . METHOD_1 ( VAR_2 ) ; } VAR_1 . METHOD_1 ( VAR_3 ) ; VAR_1 . close ( ) ; } catch ( IOException e ) { <START> LOG . warn ( STRING_1 , e . getMessage ( ) ) ; <END> } VAR_4 = true ; }
<|startcomment|> logging client side ll need setup log level ? I move code _CODE_ deploy ( ) method work <|endcomment|> public void METHOD_1 ( ) { <START> Logger logger = Logger . VAR_1 ( TYPE_1 . class . getName ( ) ) ; <END> Level VAR_2 = logger . VAR_3 ( ) ; logger . VAR_4 ( Level . VAR_5 ) ; new TYPE_2 ( ) . METHOD_2 ( ) ; logger . VAR_4 ( VAR_2 ) ; }
<|startcomment|> empty line <|endcomment|> public void METHOD_1 ( ) throws Exception { VAR_1 . METHOD_2 ( STRING_1 ) ; int VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_2 , 2 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_3 ) ; VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_2 , 2 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_4 ) ; VAR_2 = VAR_3 . METHOD_3 ( ) ; assertEquals ( STRING_5 , 0 , VAR_2 ) ; <START> <END> }
<|startcomment|> new HashMap < String Object > ( 0 ) Collections < String Object > _CODE_ ( ) immutable <|endcomment|> public TYPE_2 ( TYPE_1 server ) { <START> this ( server , new HashMap < String , Object > ( ) ) ; <END> }
<|startcomment|> need FQCN <|endcomment|> public TYPE_1 < TYPE_2 > execute ( final TYPE_3 context ) { final TYPE_1 < TYPE_2 > results = METHOD_1 ( context ) ; if ( ! results . getType ( ) . equals ( TYPE_1 . Type . VAR_1 ) ) { <START> final org . VAR_2 . VAR_3 . VAR_4 . VAR_5 . VAR_6 . VAR_7 . TYPE_4 VAR_7 = METHOD_2 ( context ) ; <END> VAR_7 . METHOD_3 ( VAR_9 ) ; METHOD_4 ( context ) . METHOD_3 ( VAR_9 ) ; } return results ; }
<|startcomment|> return exception exits codethrow METHOD_1 ( column ( 0 ) ) ; <|endcomment|> <START> private static void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> throw new TYPE_2 ( VAR_1 , STRING_1 ) ; }
<|startcomment|> move logic builder factories needed <|endcomment|> public static < T > TYPE_1 < T > METHOD_1 ( TYPE_2 < T > message ) { Assert . VAR_1 ( message , STRING_1 ) ; if ( message instanceof TYPE_3 ) { logger . warn ( STRING_2 + STRING_3 ) ; <START> } <END> return new TYPE_1 < T > ( message ) ; }
<|startcomment|> implies expecting code review verified integers ( break silently ) I underlying implication data type getters Integer convert integer a string safely isn t true parsing some arbitrary string IMO thoughts <|endcomment|> public TYPE_1 METHOD_1 ( Object element , int VAR_1 ) { TYPE_2 VAR_2 = ( TYPE_2 ) element ; switch ( VAR_1 ) { case 0 : return METHOD_2 ( ) ; case 1 : try { <START> return METHOD_3 ( Integer . parseInt ( VAR_2 . METHOD_4 ( ) ) ) ; <END> } catch ( Exception e ) { break ; } case 2 : try { return METHOD_5 ( Integer . parseInt ( VAR_2 . METHOD_6 ( ) ) ) ; } catch ( Exception e ) { break ; } } return null ; }
<|startcomment|> s add protected symmetric other fields accessed context scope <|endcomment|> <START> TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> logic _CODE_ : _CODE_ = _CODE_ = = null ? new ArrayList < TYPE_1 > ( ) : _CODE_ ; VAR_1 expected empty ArrayList case VAR_1 iterator ( ) ( ) fail _CODE_ <|endcomment|> public static TYPE_1 METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { <START> return VAR_1 . contains ( TYPE_1 . VAR_2 ) ? TYPE_1 . VAR_2 : VAR_1 . iterator ( ) . next ( ) ; <END> }
<|startcomment|> don t need wait tx completion responses removing local info removing local info expensive send command <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( Collection < TYPE_3 > VAR_1 , long VAR_2 ) { if ( VAR_3 != null ) { TYPE_4 VAR_4 = VAR_5 . METHOD_2 ( VAR_2 ) ; TYPE_1 < TYPE_2 > VAR_6 = METHOD_3 ( VAR_1 , VAR_4 ) ; <START> return VAR_6 . METHOD_4 ( ( ) - > METHOD_5 ( VAR_2 ) ) ; <END> } else { METHOD_5 ( VAR_2 ) ; return TYPE_5 . METHOD_6 ( ) ; } }
<|startcomment|> extracted a private static final constant <|endcomment|> public TYPE_1 apply ( List < TYPE_2 > args , TYPE_2 . TYPE_5 VAR_1 ) { if ( args . size ( ) >= 1 ) { throw new TYPE_4 ( STRING_1 , name ( ) ) ; } <START> return TYPE_1 . of ( Math . VAR_2 ) ; <END> }
<|startcomment|> rename entry <|endcomment|> public static List < TYPE_1 > METHOD_1 ( TYPE_2 project ) throws TYPE_3 { ArrayList < TYPE_1 > VAR_1 = new ArrayList < > ( ) ; for ( TYPE_4 <START> VAR_2 : <END> project . VAR_3 ( ) ) { VAR_1 . add ( TYPE_1 . METHOD_2 ( VAR_2 , project ) ) ; } return VAR_1 ; }
<|startcomment|> hmm I suprised case I intellij 14 0 2 <|endcomment|> public final List < TYPE_1 > METHOD_1 ( final TYPE_2 < TYPE_1 > VAR_1 , final List < TYPE_1 > VAR_2 ) { return this . METHOD_2 ( METHOD_3 ( TYPE_4 . VAR_4 . METHOD_4 ( ) , VAR_2 . METHOD_5 ( TYPE_3 < TYPE_1 , TYPE_1 , Boolean > METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ) ) ) ; <START> } <END>
<|startcomment|> a good set _CODE_ _CODE_ set result depends order some checking ( possibly logging ) required define a clear priority settings build method ensure <|endcomment|> public Builder METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> this . VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> return this ; }
<|startcomment|> I don t calling super I d <|endcomment|> public Integer METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; if ( TYPE_2 . METHOD_3 ( VAR_1 ) ) { return VAR_1 . METHOD_4 ( ) ; } <START> return super . METHOD_1 ( ) ; <END> }
<|startcomment|> s remove METHOD_2 s critical checks & forget remove _CODE_ fixed <|endcomment|> TYPE_4 ( TYPE_1 config , TYPE_2 < TYPE_3 > VAR_2 ) { METHOD_1 ( config , STRING_1 ) ; METHOD_1 ( VAR_2 , STRING_2 ) ; <START> METHOD_2 ( config . VAR_3 ( ) . METHOD_3 ( ) >= 10 , STRING_3 ) ; <END> METHOD_2 ( config . VAR_4 ( ) . METHOD_3 ( ) >= 10 , STRING_4 ) ; VAR_5 = METHOD_4 ( config , VAR_2 ) ; }
<|startcomment|> VAR_2 null ? NPE thrown <|endcomment|> public void METHOD_1 ( ) { <START> if ( VAR_1 ) { METHOD_2 ( ) ; } <END> VAR_2 = null ; VAR_3 = null ; VAR_4 = null ; VAR_5 = null ; VAR_6 = null ; METHOD_3 ( ) ; super . METHOD_1 ( ) ; }
<|startcomment|> minor : I m generally happy reassigning method parameters <|endcomment|> public void METHOD_1 ( Throwable error ) { if ( error == null ) { throw new TYPE_1 ( STRING_1 ) ; } if ( error instanceof TYPE_2 ) { TYPE_3 e = new TYPE_3 ( error . getMessage ( ) ) ; e . VAR_1 ( error ) ; <START> error = e ; <END> } VAR_2 . add ( error ) ; }
<|startcomment|> shouldn t test synchronized _CODE_ java <|endcomment|> protected void METHOD_1 ( ) { <START> if ( VAR_1 . isEmpty ( ) ) { <END> return ; } super . METHOD_1 ( ) ; }
<|startcomment|> I pre - existing variable capitalized Map map <|endcomment|> public String get ( String key ) { <START> Map < String , String > Map = VAR_1 . get ( ) ; <END> if ( ( Map != null ) && ( key != null ) ) { return Map . get ( key ) ; } else { return null ; } }
<|startcomment|> bekhta a left - ? I e planning revert change discussion ? question some more places TYPE_2 METHOD_6 ( ) <|endcomment|> public void METHOD_1 ( Class < ? > from , Class < ? > to ) { METHOD_2 ( ) ; boolean VAR_1 = false ; for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_2 . METHOD_3 ( ) . equals ( from ) && VAR_2 . METHOD_4 ( ) . equals ( to ) ) { VAR_1 = true ; break ; } } if ( ! VAR_1 ) { <START> METHOD_5 ( String . format ( TYPE_2 . METHOD_6 ( ) , STRING_1 , VAR_3 , from , to ) ) ; <END> } }
<|startcomment|> copy paste error <|endcomment|> public synchronized void METHOD_1 ( long VAR_1 ) { VAR_2 . put ( Long . VAR_3 , VAR_4 , VAR_5 , VAR_1 ) ; <START> VAR_6 . METHOD_2 ( VAR_1 ) ; <END> }
<|startcomment|> FYI TimeUnit VAR_3 VAR_2 ( VAR_1 METHOD_3 ( ) ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> Thread . VAR_2 ( TimeUnit . VAR_3 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ) ; <END> } catch ( InterruptedException e ) { } }
<|startcomment|> I VAR_3 isn t check VAR_1 cast connection provided <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> if ( ! ( VAR_1 instanceof TYPE_2 ) ) { throw new IllegalStateException ( STRING_1 ) ; } TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; try { VAR_1 . METHOD_3 ( null ) ; } catch ( TYPE_3 VAR_4 ) { LOG . VAR_5 ( VAR_4 ) ; } }
<|startcomment|> Integer valueOf ( ) instead <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return VAR_2 . contains ( new Integer ( VAR_1 . METHOD_2 ( ) ) ) ; <END> }
<|startcomment|> please brackets - line blocks <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 ) <END> return VAR_2 ; return super . METHOD_1 ( ) ; }
<|startcomment|> swallowing exception ? isn t caller <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 < String , TYPE_3 > VAR_1 , String VAR_2 ) { logger . debug ( STRING_1 , VAR_2 ) ; try { TYPE_4 config = METHOD_2 ( VAR_1 ) ; if ( config != null ) { return METHOD_3 ( config , VAR_3 - > StringUtils . equals ( VAR_2 , VAR_3 . getString ( VAR_4 ) ) ) ; } } catch ( TYPE_5 e ) { <START> logger . error ( STRING_2 , e ) ; <END> } return null ; }
<|startcomment|> add a null check class initialized <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( TYPE_1 . VAR_3 ) ; <END> }
<|startcomment|> setter called moved constructor <|endcomment|> public TYPE_1 METHOD_1 ( final TYPE_2 args ) { TYPE_1 VAR_1 = new TYPE_1 ( null , null , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 , VAR_8 ) ; <START> VAR_1 . METHOD_2 ( VAR_9 ) ; <END> return VAR_1 ; }
<|startcomment|> getName ( ) instead VAR_1 METHOD_1 ( ) <|endcomment|> public String toString ( ) { <START> return STRING_1 + VAR_1 . METHOD_1 ( ) + STRING_2 ; <END> }
<|startcomment|> public protected private <|endcomment|> <START> TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_2 < T > > VAR_2 ) { <END> return METHOD_1 ( VAR_1 , VAR_2 , true ) ; }
<|startcomment|> don t spam final keywords code part changeset <|endcomment|> private static synchronized TYPE_1 session ( ) { final TYPE_2 properties = new TYPE_2 ( ) ; <START> final TYPE_3 conf = TYPE_4 . METHOD_1 ( ) ; <END> properties . put ( STRING_1 , conf . VAR_1 ( ) ) ; properties . put ( STRING_2 , conf . VAR_2 ( ) ) ; properties . put ( STRING_3 , conf . VAR_3 ( ) ) ; properties . put ( STRING_4 , conf . VAR_4 ( ) ) ; VAR_5 = TYPE_1 . METHOD_2 ( properties , null ) ; return VAR_5 ; }
<|startcomment|> need mark VAR_1 final code needs JDK6 compatible <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 < String > VAR_1 = new TYPE_1 < String > ( 1 ) ; VAR_1 . add ( METHOD_2 ( TYPE_2 . class ) ) ; TYPE_3 t = new TYPE_3 ( ) { @Override public void METHOD_3 ( ) throws Throwable { <START> VAR_1 . add ( METHOD_2 ( TYPE_2 . class ) ) ; <END> } } ; t . start ( ) ; t . VAR_2 ( ) ; t . VAR_3 ( InterruptedException . VAR_4 ) ; }
<|startcomment|> trace experiment disposed UUID changed ( experiment longer children UUID computed empty string ) <|endcomment|> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( ) ; super . METHOD_1 ( VAR_1 ) ; METHOD_3 ( null ) ; if ( VAR_1 != null ) { <START> VAR_2 . remove ( VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ) ; <END> } }
<|startcomment|> other option commands exposing information user I internally stick original VAR_1 / committer / tagger <|endcomment|> private String METHOD_1 ( int line ) { TYPE_1 VAR_1 = <START> db . VAR_2 ( ) . map ( VAR_3 . METHOD_2 ( line ) ) ; <END> if ( VAR_1 == null ) return "" ; String name = VAR_4 ? VAR_1 . METHOD_3 ( ) : VAR_1 . getName ( ) ; return name != null ? name : "" ; }
<|startcomment|> avoid multiple returns <|endcomment|> <START> public void METHOD_1 ( ) { <END> View view = METHOD_2 ( ) ; if ( view == null ) { return ; } METHOD_3 ( ) . METHOD_4 ( view , this ) ; if ( VAR_1 == null ) { return ; } for ( TYPE_1 VAR_2 : VAR_1 . METHOD_5 ( ) ) { METHOD_3 ( ) . METHOD_4 ( VAR_2 , this ) ; } METHOD_3 ( ) . METHOD_4 ( VAR_1 , this ) ; VAR_1 = null ; }
<|startcomment|> isn t exact notification _CODE_ sending <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , boolean VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = new TYPE_3 < > ( ) ; VAR_5 <START> . add ( ( event , VAR_6 ) - > METHOD_1 ( this , event , VAR_6 . METHOD_2 ( ) , VAR_7 ) ) ; <END> }
<|startcomment|> don t understand aren t TYPE_1 VAR_5 <|endcomment|> public void METHOD_1 ( ) throws IOException { <START> METHOD_2 ( TYPE_2 . VAR_2 , STRING_1 ) ; <END> METHOD_2 ( TYPE_2 . VAR_3 , STRING_2 ) ; METHOD_2 ( TYPE_2 . VAR_3 , TYPE_1 . VAR_5 ) ; METHOD_2 ( TYPE_2 . VAR_6 , STRING_3 ) ; }
<|startcomment|> general PR checks needed ? guava s immutable collections don t allow null values checking null input map list options redundant <|endcomment|> public TYPE_1 METHOD_1 ( Map < String , String > VAR_1 ) { for ( Map . Entry < String , String > entry : METHOD_2 ( VAR_1 , STRING_1 ) . entrySet ( ) ) { METHOD_2 ( entry . getKey ( ) , STRING_2 ) ; METHOD_2 ( entry . getValue ( ) , STRING_3 ) ; <START> } <END> this . VAR_1 = TYPE_3 < Map < String , String > > of ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ; return this ; }
<|startcomment|> correct s wrong I block ( METHOD_2 ( method ) ) { needed anymore <|endcomment|> private String METHOD_1 ( TYPE_1 method ) { <START> if ( METHOD_2 ( method ) ) { <END> return STRING_1 ; } else if ( method . VAR_1 ( ) . METHOD_3 ( ) != null ) { TYPE_2 VAR_2 = method . VAR_1 ( ) . METHOD_3 ( ) ; return STRING_2 + VAR_2 . METHOD_4 ( ) + STRING_3 ; } return STRING_2 + method . VAR_1 ( ) . METHOD_5 ( ) + STRING_3 ; }
<|startcomment|> I a good practice create TYPE_1 _CODE_ TYPE_1 tied activity recreating activity s needs done I sense <|endcomment|> protected TYPE_1 METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) ; <END> }
<|startcomment|> doesn t StringUtils VAR_3 compare null <|endcomment|> private boolean METHOD_1 ( String value , String VAR_1 ) { boolean VAR_2 = true ; <START> if ( value != null && StringUtils . VAR_3 ( value ) ) { <END> VAR_2 = value . VAR_4 ( VAR_1 ) ; } return VAR_2 ; }
<|startcomment|> I check happen applying wrapper ( i e current status code 200 don t apply wrapper 200 don t modified ) multiple calls METHOD_1 work fail <|endcomment|> public void METHOD_1 ( int VAR_1 , String VAR_2 ) { <START> if ( super . getStatus ( ) == VAR_3 ) { <END> super . METHOD_1 ( VAR_1 , VAR_2 ) ; } status = VAR_1 ; }
<|startcomment|> define int ? optimized I introduced a bug String I a bit cautious <|endcomment|> public final TYPE_1 METHOD_1 ( ) { final int [ ] buffer = this . buffer ; for ( int start = 0 , VAR_1 = size ( ) - 1 ; start < VAR_1 ; start ++ , VAR_1 -- ) { <START> int VAR_2 = buffer [ start ] ; <END> buffer [ start ] = buffer [ VAR_1 ] ; buffer [ VAR_1 ] = VAR_2 ; } return this ; }
<|startcomment|> a Set necessary ? A treenode wrap a single eobject treenode returned _CODE_ ( ) <|endcomment|> public Collection < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { final Collection < TYPE_6 . TYPE_7 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , false ) ; <START> final Set < TYPE_1 > VAR_4 = new TYPE_4 < TYPE_1 > ( VAR_2 . size ( ) ) ; <END> for ( TYPE_6 . TYPE_7 VAR_5 : VAR_2 ) { final TYPE_5 VAR_6 = VAR_5 . METHOD_3 ( ) ; if ( VAR_6 instanceof TYPE_1 ) { VAR_4 . add ( ( TYPE_1 ) VAR_6 ) ; } } return VAR_4 ; }
<|startcomment|> branch needed <|endcomment|> public int METHOD_1 ( String name ) { <START> if ( value == null ) { <END> return TYPE_1 . METHOD_2 ( name ) ? 0 : - 1 ; } else { return value . equals ( name ) ? 0 : - 1 ; } }
<|startcomment|> private <|endcomment|> <START> public String METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = TYPE_2 . METHOD_2 ( TYPE_6 . VAR_4 ) ; TYPE_3 VAR_5 = VAR_2 . METHOD_3 ( VAR_1 ) ; File file = null ; try { file = new File ( TYPE_4 . METHOD_4 ( VAR_5 ) . METHOD_5 ( ) ) ; } catch ( TYPE_5 | IOException e ) { e . VAR_6 ( ) ; } return file . VAR_7 ( ) ; }
<|startcomment|> avoid switch common practice people dont works remove put example code understandable maintainable <|endcomment|> <START> private void METHOD_1 ( TYPE_2 . TYPE_3 . Type type , String VAR_1 ) { <END> switch ( type ) { case TYPE_5 : case TYPE_4 : VAR_4 . remove ( VAR_1 ) ; break ; case TYPE_6 : default : VAR_4 . add ( VAR_1 ) ; } VAR_6 = true ; }
<|startcomment|> please VAR_1 METHOD_3 ( ) ( null ) <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) ; <START> VAR_1 . METHOD_3 ( null ) ; <END> }
<|startcomment|> closing done driver need repeat <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; <START> client . close ( ) ; <END> }
<|startcomment|> shouldn t return true <|endcomment|> private View METHOD_1 ( int VAR_1 , int VAR_2 ) { View view = new View ( METHOD_2 ( ) ) ; view . VAR_3 ( new TYPE_3 . TYPE_4 ( VAR_1 , VAR_2 ) ) ; view . VAR_4 ( true ) ; view . VAR_5 ( new View . TYPE_5 ( ) { @Override public boolean METHOD_3 ( View v , TYPE_2 event ) { if ( event . VAR_7 ( ) == TYPE_2 . VAR_8 ) { METHOD_4 ( ) ; } <START> return false ; <END> } } ) ; return view ; }
<|startcomment|> fmt <|endcomment|> public boolean METHOD_1 ( ) { if ( VAR_1 != null ) { boolean VAR_2 = METHOD_2 ( ) ; VAR_3 . METHOD_3 ( ) ; <START> if ( ! VAR_2 ) { return false ; } <END> } return ! VAR_4 ; }
<|startcomment|> addjavasuper METHOD_1 ( ) ; don t worry future additions parent s METHOD_1 function called <|endcomment|> public void METHOD_1 ( ) { <START> offset = VAR_1 . VAR_2 . METHOD_2 ( 10 ) ; <END> }
<|startcomment|> _CODE_ ve done _CODE_ <|endcomment|> protected TYPE_1 < ? > METHOD_1 ( String VAR_1 ) { <START> List < TYPE_1 < ? > > VAR_2 = VAR_3 . query ( METHOD_2 ( TYPE_2 . VAR_5 ) , new Object [ ] { VAR_1 , VAR_6 , VAR_1 } , VAR_7 ) ; <END> Assert . VAR_8 ( VAR_2 . size ( ) == 0 || VAR_2 . size ( ) == 1 ) ; if ( VAR_2 . size ( ) > 0 ) { return VAR_2 . get ( 0 ) ; } return null ; }
<|startcomment|> move null check action method ensure throw VAR_3 = = null VAR_2 null <|endcomment|> public static boolean METHOD_1 ( long VAR_1 , TimeUnit VAR_2 ) throws InterruptedException { Thread VAR_3 = TYPE_2 . VAR_3 ; if ( VAR_3 != null ) { VAR_3 . METHOD_2 ( <START> TYPE_1 . METHOD_3 ( VAR_2 , STRING_1 ) . METHOD_4 ( VAR_1 ) ) ; <END> return ! VAR_3 . METHOD_5 ( ) ; } else { return true ; } }
<|startcomment|> I I d looped VAR_1 entry set put ( ) entry builder VAR_1 instead METHOD_2 replacing entries values <|endcomment|> public Builder METHOD_1 ( ) { Builder builder = new Builder ( type ) ; builder . VAR_1 . METHOD_2 ( VAR_1 ) ; <START> for ( Map . Entry < String , List < TYPE_1 > > entry : builder . VAR_1 . entrySet ( ) ) { <END> entry . VAR_2 ( new ArrayList < > ( entry . getValue ( ) ) ) ; } return builder ; }
<|startcomment|> isn t METHOD_2 ( null VAR_1 ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> VAR_2 . METHOD_2 ( new TYPE_2 ( null , null , null ) , VAR_1 ) ; <END> }
<|startcomment|> another file ve imported TYPE_5 statically ( MESSAGES ) umport statically <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 ) throws IOException { return METHOD_1 ( VAR_1 . METHOD_2 ( ) , <START> TYPE_5 . VAR_3 ) ; <END> }
<|startcomment|> spacing <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_2 . METHOD_2 ( ) . contains ( VAR_1 ) ) { <END> final TYPE_2 VAR_3 = METHOD_3 ( ) . METHOD_4 ( ) ; log . warn ( STRING_1 ) ; ( ( TYPE_3 ) VAR_3 ) . METHOD_5 ( TYPE_4 . VAR_5 ) ; } }
<|startcomment|> ignore result need return result <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 result = VAR_1 . METHOD_2 ( ) ; if ( result != TYPE_1 . VAR_2 ) { return result ; } <START> result = TYPE_2 . METHOD_3 ( repo , project ) ; <END> return TYPE_1 . VAR_2 ; }
<|startcomment|> StringUtils I thinking good idea bring dependency class <|endcomment|> private int METHOD_1 ( final TYPE_1 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_2 ( ) . trim ( ) . isEmpty ( ) ) { <END> return 1 ; } else { return VAR_1 . METHOD_3 ( ) . size ( ) ; } }
<|startcomment|> please remove line <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( ) . METHOD_3 ( new TYPE_2 ( METHOD_4 ( VAR_1 ) , VAR_1 . METHOD_5 ( ) . getName ( ) ) . METHOD_6 ( METHOD_7 ( VAR_1 ) ) . METHOD_8 ( TYPE_3 . METHOD_9 ( STRING_1 ) , <START> TYPE_3 . METHOD_10 ( METHOD_7 ( VAR_1 ) ) <END> ) ) ; }
<|startcomment|> default implementation supports want override default check <|endcomment|> public boolean METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> if ( super . METHOD_1 ( VAR_1 ) ) return true ; <END> for ( TYPE_1 VAR_2 : VAR_1 ) { if ( ! METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ) return false ; } return true ; }
<|startcomment|> change impl set forget changing initialization s simply good simple practice : initialize local variables instance variable automagically a sane state I dont point removing existing initializations spare some characters ? s a good practice initialize local variables a defined state <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = null ; try { boolean VAR_3 = false ; VAR_2 = new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; <START> for ( TYPE_4 entry ; ( entry = VAR_2 . METHOD_2 ( ) ) != null ; ) { <END> if ( TYPE_5 . equals ( entry . getName ( ) ) && entry . VAR_4 ( ) ) { VAR_3 = true ; break ; } } return VAR_3 ; } finally { TYPE_6 . close ( VAR_2 ) ; } }
<|startcomment|> I return null <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; }
<|startcomment|> false a valid response <|endcomment|> public Object METHOD_1 ( ) { <START> return true ; <END> }
<|startcomment|> doesnt need a line <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , Boolean VAR_2 ) throws IOException , <START> TYPE_3 { <END> TYPE_4 description = METHOD_2 ( new TYPE_5 ( VAR_1 ) , VAR_2 ) ; TYPE_6 content = METHOD_3 ( description ) ; return new TYPE_1 ( content , description . getType ( ) ) ; }
<|startcomment|> necessary ? default behaviour mocked Object returning methods <|endcomment|> private void METHOD_1 ( ) { TYPE_1 < Integer > VAR_1 = METHOD_2 ( TYPE_1 . class ) ; map = new TYPE_2 < String , Integer > ( INT_1 , true , VAR_1 ) ; <START> when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( null ) ; <END> }
<|startcomment|> static import I assume remove TYPE_2 import <|endcomment|> protected TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return VAR_2 ; } String VAR_3 = VAR_1 . substring ( VAR_1 . length ( ) - 1 ) ; switch ( VAR_3 ) { case VAR_4 : <START> return TYPE_2 . VAR_6 ; <END> case VAR_7 : return VAR_8 ; case VAR_9 : return VAR_10 ; case VAR_11 : return VAR_2 ; default : throw new IllegalArgumentException ( STRING_1 + VAR_3 ) ; } }
<|startcomment|> i start 1 s processed preceding LOC <|endcomment|> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { METHOD_2 ( VAR_1 , VAR_2 ) ; VAR_3 . get ( 0 ) . METHOD_3 ( VAR_4 , VAR_5 ) ; <START> for ( int i = 0 , s = VAR_3 . size ( ) ; s > i ; i ++ ) { <END> VAR_3 . get ( i ) . METHOD_1 ( VAR_4 , VAR_5 ) ; } }
<|startcomment|> private <|endcomment|> <START> void METHOD_1 ( double VAR_1 , double max ) <END> { this . VAR_1 = VAR_1 ; this . max = max ; }
<|startcomment|> I wouldn t wrap s short s item wrapping harder read <|endcomment|> private void METHOD_1 ( TYPE_1 TYPE_2 ) { if ( VAR_1 . values ( ) . stream ( ) . map ( TYPE_3 : : METHOD_2 ) . METHOD_3 ( TYPE_2 : : equals ) ) { throw new TYPE_4 ( VAR_2 , format ( STRING_1 , TYPE_2 . toString ( ) ) ) ; } <START> if ( VAR_3 . keySet ( ) . stream ( ) <END> . METHOD_3 ( TYPE_2 : : equals ) ) { throw new TYPE_4 ( VAR_2 , format ( STRING_2 , TYPE_2 . toString ( ) ) ) ; } }
<|startcomment|> I method need static <|endcomment|> <START> private static void METHOD_1 ( Collection < Pair < Object , String > > result , String element ) { <END> if ( element . length ( ) > 0 ) { List < String > list = Arrays . asList ( element . split ( STRING_1 ) ) ; list . forEach ( VAR_1 - > { String value = TYPE_1 . VAR_3 + VAR_1 . split ( STRING_2 ) [ 0 ] ; result . add ( new Pair < > ( value , value ) ) ; } ) ; } }
<|startcomment|> message argument unsued IMO confusing alerts panel present ( standalone / submarine ) <|endcomment|> public TYPE_1 METHOD_1 ( final String message ) { TYPE_2 . METHOD_2 ( ) ; METHOD_3 ( ) . METHOD_4 ( METHOD_5 ( TYPE_3 . VAR_2 ) ) ; <START> METHOD_6 ( METHOD_7 ( TYPE_4 ) , <END> METHOD_7 ( TYPE_5 ) , TYPE_6 . VAR_6 ) ; return this ; }
<|startcomment|> lambda <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entity ) { TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 , entity . VAR_3 ( ) , <START> new TYPE_4 < TYPE_5 , TYPE_1 > ( ) { <END> @Override public TYPE_1 apply ( TYPE_5 VAR_4 ) { return VAR_5 . METHOD_3 ( new TYPE_6 ( ) , VAR_4 ) ; } } ) ; }
<|startcomment|> aren t foreach _CODE_ ( ) ? wouldn t extra work child variable more children <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 node , Set < TYPE_3 < ? > > VAR_2 ) { TYPE_4 res = new TYPE_4 ( ) ; <START> node . forEach ( child - > { <END> res . VAR_3 ( false , METHOD_2 ( VAR_1 , child , VAR_2 ) ) ; } ) ; return res . get ( ) ; }
<|startcomment|> style - : public API return Map Set List a concrete implementation type I missed earlier review iterations <|endcomment|> <START> public HashMap < String , TYPE_1 > METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> VAR_1 shows unused variable please remove assignment <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> TYPE_1 < Integer > VAR_1 = new TYPE_1 < Integer > ( 1 , 5 , null ) ; <END> }
<|startcomment|> View VAR_3 = VAR_1 METHOD_2 ( R VAR_4 VAR_5 container false ) ; instead <|endcomment|> public View METHOD_1 ( final TYPE_1 VAR_1 , ANNOTATION_1 final TYPE_2 container , ANNOTATION_1 final TYPE_3 VAR_2 ) { <START> View VAR_3 = VAR_1 . METHOD_2 ( R . VAR_4 . VAR_5 , null ) ; <END> return VAR_3 ; }
<|startcomment|> size bytes max Integer _CODE_ i some crazy repo number Long <|endcomment|> <START> public Map < String , Integer > METHOD_1 ( ) throws IOException { <END> return VAR_1 . METHOD_2 ( ) . to ( METHOD_3 ( STRING_1 ) , HashMap . VAR_2 ) ; }
<|startcomment|> reason special case ? fall line 300 catch <|endcomment|> public static TYPE_1 METHOD_1 ( final int VAR_1 ) { <START> if ( VAR_1 < 0 || VAR_1 > INT_1 ) { <END> throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 ) ) ; } for ( TYPE_1 VAR_2 : TYPE_1 . values ( ) ) { if ( VAR_2 . VAR_1 == VAR_1 ) { return VAR_2 ; } } throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 ) ) ; }
<|startcomment|> good add a sanity check validate _CODE_ ( ) empty catch users forget call add ( ) mockito similar e g call verify ( mock ) chaining a method call mock <|endcomment|> public < R > R execute ( TYPE_1 < R > VAR_1 ) { <START> if ( VAR_2 . isEmpty ( ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } try { return VAR_1 . METHOD_1 ( ( ) - > METHOD_2 ( ) . VAR_3 , METHOD_3 ( ) ) ; } catch ( TYPE_2 e ) { throw new TYPE_3 ( STRING_2 , e , METHOD_3 ( ) ) ; } }
<|startcomment|> VAR_7 = ( VAR_7 + 1 ) <|endcomment|> private void METHOD_1 ( ) { if ( VAR_1 ) { out . VAR_2 ( STRING_1 ) ; } else if ( VAR_3 == TYPE_1 . VAR_5 ) { out . VAR_2 ( VAR_6 [ VAR_7 ] ) ; <START> VAR_8 = ( VAR_8 + 1 ) % VAR_6 . length ; <END> } else { out . VAR_9 ( STRING_2 , VAR_10 / VAR_3 ) ; } out . VAR_2 ( task ) ; if ( VAR_11 != null ) { out . VAR_9 ( STRING_3 , VAR_11 ) ; } out . VAR_2 ( CHAR_1 ) ; }
<|startcomment|> proxy plain VAR_4 method <|endcomment|> default TYPE_2 < TYPE_3 < VAR_3 > > VAR_4 ( TYPE_1 < TYPE_4 > VAR_7 , Boolean VAR_8 ) { <START> throw new TYPE_5 ( ) ; <END> }
<|startcomment|> TYPE_4 Collection agree rest code <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 path , TYPE_2 model ) { model = METHOD_2 ( path , model , <START> Arrays . asList ( TYPE_3 . TYPE_5 , TYPE_4 . Object ) ) ; <END> return METHOD_3 ( path , model ) ; }
<|startcomment|> bounds check done String constructor check line necessary <|endcomment|> public final String METHOD_1 ( ) throws IOException { int VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == VAR_2 ) { return null ; } <START> METHOD_3 ( VAR_3 , VAR_1 ) ; <END> String result = new String ( data , VAR_3 , VAR_1 , VAR_4 ) ; VAR_3 += VAR_1 ; return result ; }
<|startcomment|> type check removed storage provider types build top VAR_3 implementation a type work streaming example CHRONOPOLIS provider some spaces snapshots ( left S3 ) support _CODE_ - proposed AMAZON_ONE type fit category <|endcomment|> private TYPE_1 METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) { throw new TYPE_2 ( STRING_1 ) ; } TYPE_3 VAR_2 = VAR_1 . METHOD_3 ( ) ; TYPE_4 type = VAR_2 . getType ( ) ; <START> if ( ! type . equals ( TYPE_4 . VAR_3 ) ) { <END> throw new TYPE_2 ( STRING_2 + VAR_1 . METHOD_4 ( ) + STRING_3 + TYPE_4 . VAR_3 ) ; } return new TYPE_1 ( VAR_2 . METHOD_5 ( ) , VAR_2 . METHOD_6 ( ) , VAR_2 . METHOD_7 ( ) ) ; }
<|startcomment|> TYPE_2 <|endcomment|> private static void METHOD_1 ( ) { new TYPE_1 ( new TYPE_2 ( STRING_1 ) , TYPE_7 . VAR_2 ) ; TYPE_3 VAR_3 = new TYPE_3 ( STRING_1 ) ; String VAR_4 = VAR_3 . METHOD_2 ( ) ; new TYPE_4 ( STRING_2 ) . METHOD_3 ( ) ; <START> new TYPE_5 ( new TYPE_6 ( VAR_4 ) , TYPE_7 . VAR_2 ) ; <END> }
<|startcomment|> throw Exception <|endcomment|> public void METHOD_1 ( ) <START> throws Exception { <END> TYPE_1 . METHOD_2 ( ) ; }
<|startcomment|> IMHO copy - paste bug - METHOD_1 instead <|endcomment|> public void METHOD_1 ( TYPE_1 [ ] VAR_1 , String VAR_2 , TYPE_2 VAR_3 ) throws TYPE_3 { if ( VAR_4 instanceof TYPE_4 ) { <START> ( ( TYPE_4 ) VAR_4 ) . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <END> } else { throw new TYPE_5 ( ) ; } VAR_5 . METHOD_3 ( VAR_1 ) ; }
<|startcomment|> combine 2 lines 1 <|endcomment|> private boolean METHOD_1 ( String VAR_1 ) { <START> TYPE_1 VAR_2 = TYPE_1 . getInstance ( ) ; <END> return VAR_2 . METHOD_2 ( VAR_1 ) ; }
<|startcomment|> add check VAR_5 line null prevents another loop linked list exists <|endcomment|> public void METHOD_1 ( TYPE_1 key ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( key ) . METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ) ; try { METHOD_5 ( ) ; long VAR_3 = VAR_4 . METHOD_6 ( key ) ; if ( VAR_3 != 0 ) { TYPE_3 < TYPE_1 , TYPE_1 > VAR_5 = METHOD_7 ( VAR_3 , key ) ; <START> VAR_6 . METHOD_8 ( VAR_5 ) ; <END> METHOD_9 ( VAR_3 , key ) ; } } finally { VAR_1 . METHOD_10 ( ) ; } }
<|startcomment|> subclasses inherit a common implementation goal instance method preferred ( i e - static ) static methods inheritance purposes bit anti - pattern <|endcomment|> <START> public static TYPE_1 METHOD_1 ( int VAR_1 , byte [ ] VAR_2 ) { <END> TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; byte [ ] VAR_4 = null ; VAR_4 = TYPE_2 . METHOD_2 ( Integer . toString ( VAR_1 ) ) ; byte [ ] VAR_5 = TYPE_2 . METHOD_2 ( TYPE_3 . VAR_7 . toString ( ) . METHOD_3 ( ) ) ; VAR_3 . add ( Constants . VAR_8 , VAR_5 , VAR_4 ) ; return VAR_3 ; }
<|startcomment|> + 1 future proofing _CODE_ a adapters [ _CODE_ java ] ( ) ll want image class don t forget add [ _CODE_ ( ) ] ( ) method <|endcomment|> <START> public Map < String , Object > METHOD_1 ( ) { <END> return this . metadata ; }
<|startcomment|> check necessary compute MD5 hashes directories <|endcomment|> protected TYPE_1 [ ] METHOD_1 ( TYPE_2 t ) { TYPE_1 [ ] node = new TYPE_1 [ 1 ] ; <START> if ( t . VAR_1 ( ) ) { <END> return node ; } else { node [ 0 ] = new TYPE_3 ( new TYPE_4 ( t , false ) , TYPE_5 . METHOD_2 ( ) . METHOD_3 ( ) ) ; return node ; } }
<|startcomment|> javareturn TYPE_1 create ( b offset length ) ; <|endcomment|> public ByteBuffer METHOD_1 ( byte [ ] b , int offset , int length ) { <START> return b == null || b . length == 0 || length == 0 ? TYPE_1 . VAR_1 : new TYPE_1 ( b , offset , length ) ; <END> }
<|startcomment|> VAR_3 VAR_3 entries <|endcomment|> public List < TYPE_1 > METHOD_1 ( String VAR_1 ) { List < TYPE_1 > results = new ArrayList < > ( ) ; for ( TYPE_2 entry : VAR_2 . values ( ) ) { <START> if ( entry . VAR_3 <END> && entry . VAR_4 . METHOD_2 ( ) . < List > get ( TYPE_4 . TYPE_3 . VAR_7 ) . contains ( VAR_1 ) ) { results . add ( entry . VAR_4 ) ; } } return results ; }
<|startcomment|> doreturn ( ! TYPE_2 METHOD_3 ( VAR_2 ) && TYPE_3 TYPE_4 VAR_6 equalsIgnoreCase ( VAR_2 ) ) ; _CODE_ <|endcomment|> private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } final String VAR_2 = VAR_1 . METHOD_2 ( TYPE_3 . TYPE_4 . VAR_5 ) ; if ( ! TYPE_2 . METHOD_3 ( VAR_2 ) <START> && TYPE_3 . TYPE_4 . VAR_6 . equalsIgnoreCase ( VAR_2 ) ) { <END> return true ; } return false ; }
<|startcomment|> I existing behavior intentional parent _CODE_ other system class loader I m familiar enough part code base ; err side keeping existing functionality - else ( e g a committer ) vouch current changes wouldn t break <|endcomment|> public TYPE_1 METHOD_1 ( String name ) { if ( TYPE_2 . METHOD_2 ( name ) ) { TYPE_3 < TYPE_4 < ? > , TYPE_5 > VAR_1 = VAR_2 . get ( name ) ; if ( VAR_1 != null ) { TYPE_5 VAR_3 = VAR_1 . get ( VAR_1 . METHOD_3 ( ) ) ; <START> if ( VAR_3 instanceof TYPE_1 ) { <END> return ( TYPE_1 ) VAR_3 ; } } } return null ; }
<|startcomment|> I don t understand VAR_3 default give example <|endcomment|> private TYPE_1 ( ) { name = "" ; VAR_2 = Type . VAR_3 ; <START> } <END>
<|startcomment|> setting new a new empty TYPE_1 ? removing sufficient <|endcomment|> public void METHOD_1 ( Object instance ) { <START> VAR_1 . put ( instance . getClass ( ) . getName ( ) , new TYPE_1 < > ( ) ) ; <END> }
<|startcomment|> don t need TYPE_1 replace lines a single String format ( ) statement <|endcomment|> protected String METHOD_1 ( String VAR_1 ) { StringBuilder sb = new StringBuilder ( ) ; <START> TYPE_1 VAR_2 = new TYPE_1 ( sb , TYPE_2 . VAR_4 ) ; <END> VAR_2 . format ( STRING_1 , VAR_1 , System . currentTimeMillis ( ) ) ; return sb . toString ( ) ; }
<|startcomment|> change new String [ 0 ] s shorter <|endcomment|> TYPE_1 ( ) { <START> VAR_2 = VAR_3 . METHOD_1 ( ) . METHOD_2 ( new String [ VAR_3 . METHOD_1 ( ) . size ( ) ] ) ; <END> }
<|startcomment|> I suggest add initialization declaration instead line 148 : private List < TYPE_2 > _CODE_ = new ArrayList < > ( ) ; <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( this . VAR_2 == null ) { <START> this . VAR_2 = new ArrayList < > ( ) ; <END> } this . VAR_2 . add ( VAR_1 ) ; return this ; }
<|startcomment|> super ( ) necessary <|endcomment|> public TYPE_1 ( String VAR_2 , String name , double VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . name = name ; this . VAR_3 = VAR_3 ; }
<|startcomment|> s / VAR_2 / key / <|endcomment|> public boolean METHOD_1 ( Collection < ? > c ) { boolean VAR_1 = false ; <START> for ( Object VAR_2 : c ) { <END> VAR_1 |= remove ( VAR_2 ) ; } return VAR_1 ; }
<|startcomment|> VAR_1 - null simplified want stick _CODE_ generated form <|endcomment|> public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return VAR_1 != null ? VAR_1 . equals ( that . VAR_1 ) : that . VAR_1 == null ; <END> }
<|startcomment|> question : change scope <|endcomment|> <START> private TYPE_1 METHOD_1 ( ) { <END> final TYPE_1 VAR_1 = ( TYPE_1 ) this . VAR_2 . get ( ) . METHOD_2 ( ) ; final TYPE_2 factory = VAR_1 . METHOD_3 ( ) ; return factory . VAR_3 ( ) ; }
<|startcomment|> amend message longer represent correct error state ? A full VAR_2 call allowed ( correctly test > instead > = ) issue checking entries addition meaning VAR_2 illegal state call <|endcomment|> Pair < TYPE_1 , List < TYPE_2 > > METHOD_1 ( final List < TYPE_2 > VAR_1 ) { if ( VAR_2 . size ( ) > VAR_3 ) { throw new IllegalStateException ( <START> STRING_1 ) ; <END> } Pair < TYPE_1 , List < TYPE_2 > > VAR_4 = METHOD_2 ( ) ; VAR_2 . add ( VAR_1 ) ; return VAR_4 ; }
<|startcomment|> reduced protected <|endcomment|> <START> public Optional < Guid > <END> METHOD_1 ( ) { return METHOD_2 ( ) ? Optional . empty ( ) : Optional . VAR_1 ( METHOD_3 ( ) ) ; }
<|startcomment|> href s case sensitive please equals ( String ) instead equalsIgnoreCase ( String ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; TYPE_3 VAR_3 = null ; for ( TYPE_3 VAR_4 : METHOD_2 ( ) ) { <START> if ( VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( VAR_1 . METHOD_4 ( ) ) ) { <END> VAR_3 = VAR_4 ; break ; } } if ( VAR_3 != null ) { VAR_3 . METHOD_5 ( ) ; } else { throw new IllegalStateException ( STRING_2 ) ; } return this ; }
<|startcomment|> rename source <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 <START> VAR_2 : <END> VAR_3 ) { if ( ! METHOD_2 ( VAR_2 . getType ( ) , VAR_1 ) ) { return false ; } } return true ; }
<|startcomment|> inline call ? VAR_3 METHOD_4 ( VAR_1 METHOD_3 ( ) ) <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IOException { if ( VAR_1 . METHOD_2 ( ) ) { String VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> VAR_3 . METHOD_4 ( VAR_2 ) ; <END> TYPE_2 VAR_4 = VAR_5 . METHOD_5 ( VAR_3 ) ; if ( VAR_4 != null ) { return new TYPE_3 ( VAR_3 , VAR_4 ) ; } } return null ; }
<|startcomment|> a reason getClass ( ) instead instanceof instanceof restrictive choice <|endcomment|> public boolean equals ( final Object o ) { if ( this == o ) { return true ; } <START> if ( o == null || getClass ( ) != o . getClass ( ) ) { <END> return false ; } final TYPE_1 that = ( TYPE_1 ) o ; return VAR_1 . equals ( that . VAR_1 ) ; }
<|startcomment|> purpose wrapping Boolean a class boolean a direct VAR_4 = = VAR_5 expression <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 < Boolean > VAR_1 = METHOD_2 ( VAR_2 . VAR_3 ) ; final TYPE_2 p = METHOD_3 ( VAR_1 , VAR_1 , ( VAR_4 , VAR_5 ) - > METHOD_4 ( VAR_4 . equals ( VAR_5 ) ) <START> . METHOD_5 ( new TYPE_3 ( VAR_4 ) . METHOD_6 ( ) == new TYPE_3 ( VAR_5 ) . METHOD_6 ( ) ) ) ; <END> TYPE_4 . METHOD_7 ( p ) ; }
<|startcomment|> shouldn t pass exception logger user failure <|endcomment|> private void update ( ) { if ( VAR_1 . METHOD_1 ( false , true ) ) { try { TYPE_1 response = reader . call ( ) ; if ( response . VAR_2 ( ) ) { VAR_3 = response . VAR_4 ( ) ; METHOD_2 ( this ) ; } } catch ( Exception e ) { try { METHOD_3 ( e , this ) ; } catch ( Exception VAR_5 ) { <START> LOG . warn ( STRING_1 ) ; <END> } } finally { VAR_1 . set ( false ) ; } } }
<|startcomment|> need fully qualified class <|endcomment|> <START> public TYPE_4 . TYPE_5 . VAR_1 . VAR_2 . Response METHOD_1 ( TYPE_2 e ) { <END> TYPE_3 VAR_3 = new TYPE_3 ( ) ; VAR_3 . METHOD_2 ( STRING_1 ) ; VAR_3 . METHOD_3 ( e . getMessage ( ) ) ; return Response . status ( Response . Status . VAR_4 ) . entity ( VAR_3 ) . build ( ) ; }
<|startcomment|> return VAR_4 instead <|endcomment|> static long METHOD_1 ( final File VAR_1 ) throws IOException { final Path path = TYPE_1 . get ( VAR_1 . getPath ( ) , TYPE_5 . VAR_3 ) ; if ( ! TYPE_2 . exists ( path ) ) { final long VAR_4 = TYPE_3 . METHOD_2 ( VAR_1 ) ; TYPE_4 . METHOD_3 ( path , VAR_4 ) ; } <START> return TYPE_4 . METHOD_4 ( path ) ; <END> }
<|startcomment|> static import METHOD_2 <|endcomment|> public void METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) throws IOException { <START> int VAR_3 = TYPE_2 . METHOD_2 ( VAR_2 ) ; <END> VAR_4 = new TYPE_3 ( VAR_3 , VAR_2 ) ; }
<|startcomment|> want override singleton instance need remove _CODE_ manifest ? another <|endcomment|> @Override public boolean METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( new TYPE_1 . Builder ( METHOD_3 ( ) ) . build ( ) ) ; <END> return true ; }
<|startcomment|> correct 😈 want METHOD_2 internal delay ( expressed milliseconds ) VAR_1 client asked <|endcomment|> public long METHOD_1 ( ANNOTATION_1 TimeUnit VAR_1 ) { <START> return TimeUnit . VAR_2 . METHOD_2 ( this . METHOD_1 ( ) , VAR_1 ) ; <END> }
<|startcomment|> new HashMap ( VAR_2 ) - don t a reference caller s map - change <|endcomment|> public TYPE_2 ( Map < Class < ? > , TYPE_1 > VAR_2 , TYPE_1 VAR_3 ) { Assert . VAR_4 ( VAR_3 , STRING_1 ) ; this . VAR_3 = VAR_3 ; <START> this . VAR_2 = VAR_2 ; <END> }
<|startcomment|> final <|endcomment|> <START> public T get ( ) { <END> return METHOD_1 ( VAR_1 ) ; }
<|startcomment|> assign local variable field skip local variable field method <|endcomment|> private void METHOD_1 ( List < TYPE_1 > VAR_1 ) { VAR_2 . clear ( ) ; Collections . VAR_3 ( VAR_1 ) ; List < TYPE_2 > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_1 VAR_5 : VAR_1 ) { VAR_4 . add ( new TYPE_2 ( VAR_5 , VAR_6 , VAR_7 ) ) ; } VAR_2 . addAll ( VAR_4 , ! VAR_8 ) ; <START> VAR_9 = VAR_4 ; <END> }
<|startcomment|> nitpick : replace &&suggestionreturn VAR_1 = = options VAR_1 _CODE_ = = options VAR_2 &&unit = = options VAR_3 ; <|endcomment|> public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; TYPE_1 options = ( TYPE_1 ) o ; if ( VAR_1 != options . VAR_1 ) return false ; if ( VAR_2 != options . VAR_2 ) return false ; <START> return VAR_3 == options . VAR_3 ; <END> }
<|startcomment|> necessary rename methods <|endcomment|> <START> protected abstract TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <END> throws IOException ; protected final TYPE_3 METHOD_2 ( TYPE_2 VAR_1 , TYPE_1 VAR_2 ) throws IOException { if ( VAR_2 == null || VAR_2 instanceof TYPE_3 ) { return ( TYPE_3 ) VAR_2 ; } String path = TYPE_4 . METHOD_3 ( VAR_1 ) ; return TYPE_3 . of ( VAR_1 . METHOD_4 ( ) , path , VAR_2 ) . METHOD_5 ( this ) ; }
<|startcomment|> VAR_4 ? I s needed support multiline strings happen attribute values <|endcomment|> public TYPE_2 ( String VAR_2 , String VAR_3 ) { super ( STRING_1 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = TYPE_1 . METHOD_1 ( VAR_3 , VAR_4 ) ; <END> }
<|startcomment|> NPE - change ( VAR_3 ! = null && VAR_3 METHOD_5 ( ) ! = null ) ( happened _CODE_ groovy classpath due annoying eclipse behaviour ) <|endcomment|> public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) VAR_1 . METHOD_2 ( ) ; if ( VAR_2 != null ) TYPE_1 . METHOD_3 ( VAR_2 . METHOD_4 ( ) ) ; <START> if ( VAR_3 != null ) TYPE_1 . METHOD_3 ( VAR_3 . METHOD_5 ( ) . METHOD_4 ( ) ) ; <END> }
<|startcomment|> inline VAR_3 METHOD_3 ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 info ) { TYPE_2 group = info . VAR_1 ( ) ; if ( group != null ) { METHOD_2 ( group ) ; } Object [ ] VAR_2 = VAR_3 . METHOD_3 ( ) ; <START> for ( Object element : VAR_2 ) { <END> TYPE_3 listener = ( TYPE_3 ) element ; if ( ! METHOD_4 ( info . VAR_4 ( ) , listener . VAR_5 ( ) ) ) { listener . VAR_6 ( info ) ; } } }
<|startcomment|> obvious pass config class intrinsic _CODE_ instance ? s done static methods readability ? example : ll constructor static methods : private TYPE_3 ( TYPE_1 VAR_2 Class < ? extends TYPE_2 > VAR_3 boolean VAR_4 ) { VAR_2 = VAR_2 ; VAR_3 = VAR_3 ; VAR_4 = VAR_4 ; } public static TYPE_3 _CODE_ ( TYPE_1 VAR_2 Class < ? extends TYPE_2 > VAR_3 ) { return new TYPE_3 ( ) ; } public static TYPE_3 _CODE_ ( TYPE_1 VAR_2 Class < ? extends TYPE_2 > VAR_3 ) { return new TYPE_3 ( ) ; } <|endcomment|> <START> public TYPE_3 ( TYPE_1 VAR_2 , <END> Class < ? extends TYPE_2 > VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = false ; }
<|startcomment|> reconfigure operation fast enough don t state ? sense wait intermediate states <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( VAR_1 , 4 , TYPE_2 . TYPE_3 . name ( ) , 1 ) ; <START> METHOD_4 ( METHOD_2 ( ) , VAR_1 , TYPE_4 . VAR_3 , INT_1 * INT_2 * INT_3 , STRING_1 ) ; <END> METHOD_4 ( METHOD_2 ( ) , VAR_1 , TYPE_4 . VAR_4 , INT_1 * INT_2 * INT_3 , STRING_1 ) ; }
<|startcomment|> revert VAR_2 METHOD_3 ( ) <|endcomment|> public void run ( ) { try { log . info ( STRING_1 + getClass ( ) . METHOD_1 ( ) ) ; <START> VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> METHOD_4 ( ) ; log . info ( STRING_2 + getClass ( ) . METHOD_1 ( ) ) ; } catch ( Exception e ) { log . error ( STRING_3 + getClass ( ) , e ) ; } }
<|startcomment|> imho implemented equals comparing strings null safe I suggest : return TYPE_1 TYPE_3 equals ( TYPE_1 METHOD_2 ( ) ) ; <|endcomment|> public static final boolean METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) == TYPE_1 . TYPE_3 ; <END> }
<|startcomment|> I foresee clashes < type > + / + < > <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 entity ) { <START> return METHOD_2 ( entity . getName ( ) , entity ) ; <END> }
<|startcomment|> hm method meant GIN bindings frontend communication infra classes I d put TYPE_4 binding e g _CODE_ method <|endcomment|> private void METHOD_1 ( ) { bind ( TYPE_1 . class ) . in ( TYPE_2 . class ) ; METHOD_2 ( TYPE_1 . TYPE_9 . class ) ; <START> METHOD_2 ( TYPE_4 . class ) ; <END> bind ( TYPE_5 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_6 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_7 . class ) . to ( TYPE_8 . class ) . in ( TYPE_2 . class ) ; }
<|startcomment|> METHOD_1 ? visibility work wasn t done <|endcomment|> public TYPE_1 < TYPE_2 < ? extends T > > call ( final TYPE_1 < ? super T > child ) { TYPE_3 < T > VAR_1 = new TYPE_3 < T > ( child , VAR_2 , VAR_3 ) ; TYPE_4 < T > VAR_4 = new TYPE_4 < T > ( VAR_1 ) ; VAR_1 . VAR_4 = VAR_4 ; <START> VAR_4 . METHOD_1 ( 0 ) ; <END> child . add ( VAR_1 ) ; child . VAR_5 ( VAR_4 ) ; return VAR_1 ; }
<|startcomment|> add VAR_1 <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; TYPE_2 VAR_4 = <START> new TYPE_2 . Builder ( ) . METHOD_3 ( VAR_1 ) <END> . METHOD_4 ( TYPE_4 . VAR_6 ) . build ( ) ; List < TYPE_3 > VAR_7 = VAR_8 . METHOD_5 ( VAR_4 ) ; assertThat ( VAR_7 . size ( ) , is ( 2 ) ) ; for ( TYPE_3 VAR_9 : VAR_7 ) { assertThat ( VAR_9 . METHOD_6 ( ) , is ( TYPE_4 . VAR_6 ) ) ; } }
<|startcomment|> format able deal enum s fine need call ( ) <|endcomment|> static TYPE_1 METHOD_1 ( TYPE_2 request , Response VAR_1 , IOException VAR_2 ) { return new TYPE_1 ( <START> format ( STRING_1 , VAR_2 . getMessage ( ) , request . VAR_3 ( ) . name ( ) , request . url ( ) ) , <END> VAR_2 ) ; }
<|startcomment|> merge lines METHOD_1 return argument <|endcomment|> protected TYPE_3 ( TYPE_1 buf ) { TYPE_2 . METHOD_1 ( buf , STRING_1 ) ; <START> this . buf = buf ; <END> }
<|startcomment|> check VAR_1 ( 0 ) exists <|endcomment|> public boolean METHOD_1 ( ) { <START> return VAR_1 . size ( ) == VAR_1 . get ( 0 ) . METHOD_2 ( ) . METHOD_3 ( ) ; <END> }
<|startcomment|> private <|endcomment|> <START> public String <END> METHOD_1 ( ) { return "" + state + VAR_1 ; }
<|startcomment|> couldn t Arrays asList ( METHOD_3 ) METHOD_2 ( VAR_1 ) instead importing a new library <|endcomment|> public int METHOD_1 ( String VAR_1 ) { <START> int index = TYPE_1 . METHOD_2 ( METHOD_3 ( ) , VAR_1 ) ; <END> if ( index == TYPE_1 . VAR_2 ) { return METHOD_1 ( VAR_3 ) ; } return index ; }
<|startcomment|> I prefer junit assertion functions <|endcomment|> public void METHOD_1 ( ) { final double [ ] [ ] VAR_1 = { { FLOAT_1 , FLOAT_2 } , { FLOAT_3 , FLOAT_4 } , { FLOAT_5 , FLOAT_6 } , { FLOAT_7 , FLOAT_8 } } ; double [ ] VAR_2 = { FLOAT_9 , FLOAT_10 } ; double [ ] VAR_3 = { FLOAT_11 , FLOAT_12 } ; <START> assert ( TYPE_1 . contains ( VAR_1 , VAR_2 ) ) ; <END> assert ( ! TYPE_1 . contains ( VAR_1 , VAR_3 ) ) ; }
<|startcomment|> called concurrently rite ? need current status _CODE_ <|endcomment|> public void METHOD_1 ( ) { try { VAR_1 . METHOD_2 ( this ) ; <START> VAR_2 . METHOD_3 ( TYPE_3 . TYPE_2 . VAR_5 , client . VAR_6 ( ) ) ; <END> } catch ( TYPE_1 e ) { LOG . error ( STRING_1 , e ) ; } }
<|startcomment|> shouldn t appended VAR_1 <|endcomment|> public static void METHOD_1 ( StringBuilder buffer , int position ) { StringBuilder VAR_1 = new StringBuilder ( INT_1 ) ; VAR_1 . append ( STRING_1 ) ; buffer . append ( STRING_2 ) ; METHOD_2 ( VAR_1 , VAR_2 , VAR_3 ) ; <START> buffer . append ( STRING_3 ) ; <END> buffer . VAR_4 ( position , VAR_1 . toString ( ) ) ; }
<|startcomment|> final <|endcomment|> private void METHOD_1 ( final List < TYPE_1 > VAR_1 ) throws TYPE_2 , TYPE_3 { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; final TYPE_4 VAR_3 = new TYPE_4 ( VAR_2 , null ) ; <START> TYPE_5 VAR_4 = new TYPE_5 ( Collections . VAR_5 ( VAR_3 ) ) ; <END> VAR_4 . METHOD_3 ( false ) ; final TYPE_6 VAR_6 = TYPE_7 . getInstance ( STRING_1 ) . METHOD_4 ( VAR_1 ) ; final TYPE_8 VAR_7 = TYPE_8 . getInstance ( STRING_2 ) ; VAR_7 . METHOD_5 ( VAR_6 , VAR_4 ) ; }
<|startcomment|> change regression _CODE_ _CODE_ _CODE_ java TYPE_3 added deployment _CODE_ _CODE_ fails <|endcomment|> public Set < Class < ? > > METHOD_1 ( ) { final Set < Class < ? > > VAR_1 = new HashSet < > ( ) ; VAR_1 . add ( TYPE_1 . class ) ; VAR_1 . add ( TYPE_2 . class ) ; <START> VAR_1 . add ( TYPE_3 . class ) ; <END> VAR_1 . add ( TYPE_4 . class ) ; return VAR_1 ; }
<|startcomment|> subclasses method _protected_ code replaced a call method subclasses <|endcomment|> <START> private void METHOD_1 ( final String message ) throws TYPE_1 { try { METHOD_2 ( ) ; } catch ( final Exception e ) { throw new TYPE_1 ( message , e ) ; } } <END>
<|startcomment|> minor : pass time column selector field selector consistent buffered aggregator <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return new TYPE_3 ( name , VAR_1 . METHOD_2 ( VAR_2 ) , <START> VAR_1 . METHOD_2 ( TYPE_4 . VAR_4 ) <END> ) ; }
<|startcomment|> won t base class a _CODE_ ( ) method caller implementprotected final void METHOD_1 ( ) { ( _CODE_ ( ) ) { _CODE_ ( ) ) ; } } <|endcomment|> protected void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> if ( METHOD_2 ( METHOD_3 ( ) . message ) ) { return ; } TYPE_1 VAR_1 = new TYPE_1 ( vds . getId ( ) ) ; VAR_1 . METHOD_4 ( vds ) ; VAR_1 . METHOD_5 ( STRING_1 , METHOD_3 ( ) . message ) ; VAR_2 . log ( VAR_1 , TYPE_2 . VAR_4 ) ; }
<|startcomment|> protected package <|endcomment|> <START> protected String METHOD_1 ( TYPE_1 VAR_1 ) { <END> String VAR_2 = STRING_1 + ( int ) ( VAR_1 . VAR_3 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_4 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_5 * INT_1 ) + STRING_2 + ( int ) ( VAR_1 . VAR_6 * INT_1 ) + STRING_3 ; return VAR_2 ; }
<|startcomment|> style : missing braces style guide changed a braces single line blocks <|endcomment|> public TYPE_1 METHOD_1 ( File f , TYPE_3 . TYPE_4 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return TYPE_1 . VAR_2 ; else if ( VAR_1 . METHOD_3 ( ) ) { if ( new File ( f , Constants . VAR_3 ) . exists ( ) ) return TYPE_1 . VAR_4 ; else return TYPE_1 . VAR_5 ; } else if ( VAR_1 . METHOD_4 ( ) ) return TYPE_1 . VAR_6 ; else return TYPE_1 . VAR_7 ; }
<|startcomment|> move constructor ? a defensive copy front - load work instead <|endcomment|> public Map < String , Set < TYPE_1 > > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , TYPE_3 : : METHOD_4 ) ; <END> }
<|startcomment|> throws required <|endcomment|> <START> public void METHOD_1 ( TYPE_1 location , TYPE_2 VAR_1 ) throws TYPE_3 { <END> METHOD_2 ( location , VAR_1 , TYPE_4 . VAR_3 ) ; }
<|startcomment|> cuellar reason set 1 line number 133 ? I d prefer String [ 0 ] add some safety _CODE_ ( ) check array length ( 0 set _CODE_ ) _CODE_ needs a smarter I d suggest API call _CODE_ wipe _CODE_ stuff incoming _CODE_ <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 , TYPE_4 VAR_5 ) { this . VAR_3 = VAR_3 ; this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; <START> this . VAR_6 = new String [ 1 ] ; <END> }
<|startcomment|> default access ( modifier ) suffices <|endcomment|> public static int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( ) ; <START> } <END>
<|startcomment|> eliminate extraneous <|endcomment|> private void METHOD_1 ( String VAR_1 ) { try { if ( VAR_1 == null ) { <START> this . VAR_2 = TYPE_1 . METHOD_2 ( ) ; <END> } else { this . VAR_2 = TYPE_1 . METHOD_3 ( VAR_1 ) ; } logger . debug ( STRING_1 , this . VAR_3 , VAR_1 ) ; } catch ( TYPE_2 e ) { logger . error ( STRING_2 , this . VAR_3 , VAR_1 ) ; } }
<|startcomment|> VAR_2 need change : suggestionif ( ! isEmpty ( VAR_1 ) || VAR_2 ! = null ) { user selects expression type leaves expression blank _expression component_ wont loaded <|endcomment|> void METHOD_1 ( final String type , final String VAR_1 , final TYPE_1 VAR_2 ) { METHOD_2 ( ) . METHOD_3 ( type ) ; <START> if ( ! isEmpty ( VAR_1 ) ) { <END> METHOD_2 ( ) . METHOD_4 ( VAR_2 ) ; } else { METHOD_2 ( ) . METHOD_5 ( ) ; } }
<|startcomment|> I databases method properly constructed ? eclipse returns method return a result type boolean I add return _CODE_ false <|endcomment|> <START> public boolean METHOD_1 ( ) { <END> }
<|startcomment|> return STRING_1 <|endcomment|> public String METHOD_1 ( ) { <START> return Context . VAR_1 ( ) . getMessage ( STRING_1 ) ; <END> }
<|startcomment|> unnecessary null check path ; trivial ; ignoring <|endcomment|> public static String METHOD_1 ( Object context , String path ) { TYPE_1 . METHOD_2 ( path , STRING_1 ) ; <START> if ( path == null || path . startsWith ( STRING_2 ) || TYPE_2 . METHOD_3 ( path ) ) return path ; <END> TYPE_1 . METHOD_2 ( context , STRING_3 ) ; return METHOD_4 ( context ) + path ; }
<|startcomment|> removed <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) ; <END> TYPE_3 cmd = VAR_4 . METHOD_3 ( VAR_5 , VAR_1 ) ; try { VAR_3 . METHOD_4 ( source , cmd , TYPE_4 . NONE ) ; } catch ( Exception e ) { log . VAR_7 ( STRING_1 , source , VAR_1 ) ; } }
<|startcomment|> expensive call eviction attempt want eviction loop fast dependencies external services <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> METHOD_3 ( ) ; }
<|startcomment|> intentionally a bitwise <|endcomment|> private final void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; if ( VAR_1 == 0 ) { <START> if ( ! VAR_3 . METHOD_3 ( ) & VAR_4 ) <END> { VAR_5 . METHOD_4 ( ) . VAR_6 . VAR_7 . METHOD_5 ( ) ; } else { VAR_5 . METHOD_4 ( ) . VAR_6 . VAR_8 . METHOD_6 ( System . VAR_9 ( ) - VAR_10 ) ; } } }
<|startcomment|> parameterized constructor call instead addAll ( ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 sess , List < TYPE_3 > VAR_1 , TYPE_4 resource , TYPE_5 group , boolean VAR_2 ) throws TYPE_6 { this . METHOD_2 ( sess , group , resource ) ; List < TYPE_1 > VAR_3 = new ArrayList < > ( ) ; <START> VAR_3 . addAll ( METHOD_3 ( ) . METHOD_1 ( sess , VAR_1 , resource , group ) ) ; <END> if ( VAR_2 ) { VAR_3 . addAll ( METHOD_3 ( ) . METHOD_1 ( sess , VAR_1 , group ) ) ; } return VAR_3 ; }
<|startcomment|> open expression user specification test default _CODE_ <|endcomment|> private boolean METHOD_1 ( TYPE_1 < ? > message ) { <START> if ( message . VAR_1 ( ) . containsKey ( TYPE_2 . VAR_3 ) ) { <END> return this . VAR_4 . getValue ( this . VAR_5 , message , Boolean . VAR_6 ) ; } return false ; }
<|startcomment|> rid variable <|endcomment|> public void METHOD_1 ( ) { <START> int VAR_1 = 1 ; <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; assertEquals ( STRING_1 , VAR_2 . METHOD_3 ( ) ) ; }
<|startcomment|> split lines <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( ! VAR_2 , STRING_1 ) ; TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( VAR_4 , VAR_5 , TYPE_4 . class . METHOD_4 ( ) ) ; <START> return new TYPE_5 ( VAR_3 , METHOD_5 ( ) , VAR_6 , VAR_7 , VAR_8 , VAR_9 . METHOD_6 ( ) , VAR_10 ) ; <END> }
<|startcomment|> evtl geht auch clear ( ) dann braucht man gar keinen parameter <|endcomment|> private TYPE_1 METHOD_1 ( final TYPE_2 job , TYPE_1 VAR_1 , String VAR_2 ) { <START> if ( VAR_1 != null ) { <END> job . VAR_3 ( ) . remove ( VAR_1 ) ; } TYPE_1 VAR_4 = new TYPE_1 ( ) ; VAR_4 . METHOD_2 ( Collections . VAR_5 ( new TYPE_3 ( VAR_2 , new TYPE_4 ( ) ) ) ) ; job . VAR_3 ( ) . add ( VAR_4 ) ; return VAR_4 ; }
<|startcomment|> more PHD students PHD students switching order || improve performance <|endcomment|> public boolean METHOD_1 ( TYPE_1 user ) { if ( user == null || user . VAR_1 ( ) == null ) { return false ; } <START> return new TYPE_2 ( ) . METHOD_1 ( user ) || ( user . VAR_1 ( ) . METHOD_2 ( ) != null && user . VAR_1 ( ) <END> . METHOD_2 ( ) . METHOD_3 ( ) ) ; }
<|startcomment|> rename METHOD_3 METHOD_1 <|endcomment|> public TYPE_1 < ? > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { return VAR_1 ; } <START> return VAR_2 . METHOD_3 ( ) ; <END> }
<|startcomment|> s relation change WFLY - 19339 <|endcomment|> public Map < String , TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> }
<|startcomment|> rename entry <|endcomment|> public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { model . VAR_2 ( ) ; TYPE_1 entry ; for ( TYPE_1 <START> VAR_3 : <END> VAR_1 ) { entry = VAR_3 ; switch ( entry . VAR_4 ( ) ) { case TYPE_1 . VAR_5 : model . VAR_6 ( TYPE_2 . VAR_8 , entry ) ; break ; default : model . VAR_6 ( TYPE_2 . VAR_9 , entry ) ; break ; } } METHOD_2 ( ) ; }
<|startcomment|> a new code mved consider java7 - - resources statement : ( TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ) { return VAR_2 METHOD_2 ( ) METHOD_3 ( ) getValue ( STRING_1 ) ; } <|endcomment|> public static String METHOD_1 ( File VAR_1 ) throws IOException { <START> TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; try { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . getValue ( STRING_1 ) ; } finally { VAR_2 . close ( ) ; } <END> }
<|startcomment|> primitive boolean compared null <|endcomment|> protected String METHOD_1 ( String name ) { boolean VAR_1 = VAR_2 != null && VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; <START> if ( VAR_1 != null && VAR_1 ) { <END> return VAR_3 + STRING_1 + ( name != null ? name : VAR_4 ) ; } else { return name != null ? name : VAR_4 ; } }
<|startcomment|> s element checked viewer map other code wrong e g _CODE_ ( ) s return false <|endcomment|> public boolean METHOD_1 ( Object element ) { if ( VAR_1 . containsKey ( element ) ) { return VAR_1 . get ( element ) ; } <START> return VAR_2 . METHOD_1 ( element ) ; <END> }
<|startcomment|> swallow typo - case issue a warning ? delete VAR_1 method doesn t matter a mail doesn t exist fine rellies command change spelled VAR_1 wrong fail i <|endcomment|> <START> private void METHOD_1 ( String VAR_1 ) throws TYPE_1 , TYPE_2 { List < TYPE_3 > VAR_2 = VAR_3 . apply ( VAR_4 ) ; for ( TYPE_3 e : VAR_2 ) { if ( e . VAR_1 . equals ( VAR_1 ) ) { VAR_5 . apply ( new TYPE_5 . TYPE_6 ( user , VAR_1 ) , null ) ; } } } <END>
<|startcomment|> brackets single statements cleanup file done a separate commit mix unrelated changes <|endcomment|> private void METHOD_1 ( TYPE_1 [ ] VAR_1 ) { <START> for ( TYPE_1 job : VAR_1 ) { <END> job . VAR_2 ( ) ; } }
<|startcomment|> please swap order private static [ google code style guide ] ( ) <|endcomment|> <START> static private long METHOD_1 ( String VAR_1 ) { <END> if ( VAR_1 . contains ( STRING_1 ) ) { float value = TYPE_1 . METHOD_2 ( VAR_1 ) ; float VAR_2 = value % 1 ; return TYPE_2 . METHOD_1 ( ( long ) value ) + ( long ) ( VAR_2 * INT_1 ) ; } else { return TYPE_2 . METHOD_1 ( Long . VAR_3 ( VAR_1 ) ) ; } }
<|startcomment|> pre - mature optimization I worry data structure option view list a revolving buffer essentially maintain index oldest valid item replace increment add start search wrapping <|endcomment|> public synchronized void METHOD_1 ( List < TYPE_1 > VAR_1 ) { for ( TYPE_1 request : VAR_1 ) { if ( VAR_2 . size ( ) >= VAR_3 ) { <START> VAR_2 . remove ( 0 ) ; <END> } VAR_2 . add ( new TYPE_2 ( request , METHOD_2 ( ) . METHOD_3 ( ) ) ) ; } VAR_4 . execute ( VAR_5 ) ; }
<|startcomment|> catch Throwable ? methods shouldn t throw VAR_1 false s easy a hang exception type changed <|endcomment|> static boolean METHOD_1 ( TYPE_1 parser , boolean VAR_1 ) throws IOException { try { TYPE_2 VAR_2 = parser . VAR_2 ( ) ; if ( VAR_2 == null ) VAR_2 = parser . VAR_3 ( ) ; if ( VAR_2 == TYPE_2 . VAR_4 ) return true ; if ( VAR_1 ) { throw new IllegalArgumentException ( STRING_1 + VAR_2 ) ; } return false ; <START> } catch ( TYPE_3 e ) { <END> if ( VAR_1 ) throw e ; return false ; } }
<|startcomment|> rid injection moving initialization VAR_3 c tor _CODE_ ( ) method VAR_2 a member _CODE_ ( ) referring initialized TYPE_3 obtain _CODE_ host <|endcomment|> public TYPE_4 ( TYPE_1 parameters , boolean VAR_2 ) { super ( parameters ) ; if ( ! VAR_2 ) { <START> VAR_3 = TYPE_2 . get ( TYPE_3 . class ) . METHOD_1 ( parameters . VAR_4 ( ) ) ; <END> } }
<|startcomment|> needed <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> VAR_2 . METHOD_1 ( ) . get ( STRING_1 ) . METHOD_2 ( ) ; <END> }
<|startcomment|> annotate interface methods don t need repeat ( setting inherit annotations ) <|endcomment|> <START> public List < ANNOTATION_1 Integer > METHOD_1 ( int VAR_1 , boolean VAR_2 ) <END> throws TYPE_1 { return METHOD_2 ( ) . METHOD_1 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> VAR_1 <|endcomment|> private String METHOD_1 ( ) throws Exception { if <START> ( VAR_1 != <END> null ) { return VAR_1 ; } long VAR_2 = System . currentTimeMillis ( ) ; VAR_1 = VAR_3 . execute ( VAR_4 , VAR_5 ) ; long VAR_6 = System . currentTimeMillis ( ) ; System . out . println ( STRING_1 + ( VAR_6 - VAR_2 ) ) ; return VAR_1 ; }
<|startcomment|> lets remove / catch / log / rethrow <|endcomment|> public static String METHOD_1 ( Map conf ) throws IOException { String VAR_1 = METHOD_2 ( conf ) + VAR_2 + STRING_1 ; try { TYPE_1 . METHOD_3 ( new File ( VAR_1 ) ) ; } catch ( IOException e ) { LOG . error ( STRING_2 + VAR_1 , e ) ; <START> throw e ; <END> } return VAR_1 ; }
<|startcomment|> public <|endcomment|> <START> public TYPE_2 ( String VAR_2 , long VAR_3 , String VAR_4 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; VAR_5 = METHOD_1 ( TYPE_1 . class ) ; when ( VAR_5 . toString ( ) ) . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> Log error level ? I don t put stack trace result crashing system more issue warn <|endcomment|> public static void METHOD_1 ( String [ ] args ) { LOG . info ( STRING_1 ) ; try { TYPE_1 . METHOD_2 ( ) ; LOG . info ( STRING_2 ) ; } catch ( IllegalStateException e ) { <START> LOG . warn ( STRING_3 , e . getMessage ( ) ) ; <END> System . VAR_1 ( - 1 ) ; } System . VAR_1 ( 0 ) ; }
<|startcomment|> static <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 filter , TYPE_2 [ ] VAR_1 ) <END> { return Arrays . stream ( filter . VAR_2 ( ) ) . METHOD_2 ( channel - > VAR_1 [ channel ] != null ) ; }
<|startcomment|> static import METHOD_3 <|endcomment|> public void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . METHOD_3 ( TYPE_2 . class ) <END> . METHOD_4 ( null ) ) ; }
<|startcomment|> s break line please <|endcomment|> public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , VAR_7 ) ; <END> }
<|startcomment|> return VAR_1 METHOD_2 ( TYPE_2 class ) || VAR_1 METHOD_2 ( TYPE_3 class ) <|endcomment|> public boolean METHOD_1 ( Class < ? extends TYPE_1 > VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( TYPE_2 . class ) || VAR_1 . METHOD_2 ( TYPE_3 . class ) ) { <END> return true ; } else { return false ; } }
<|startcomment|> fluent interface <|endcomment|> public void METHOD_1 ( String VAR_1 , String VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( VAR_4 ) ; VAR_3 . METHOD_2 ( VAR_5 . METHOD_3 ( VAR_1 ) ) ; TYPE_2 VAR_6 = VAR_3 . METHOD_4 ( ) ; VAR_6 . METHOD_5 ( config . VAR_7 ( ) ) ; <START> VAR_6 . METHOD_6 ( ) ; <END> TYPE_3 . METHOD_7 ( VAR_5 . METHOD_3 ( VAR_2 ) , VAR_4 . METHOD_8 ( ) ) ; }
<|startcomment|> s issue argument ( VAR_1 ) IllegalStateException more sense <|endcomment|> public void execute ( TYPE_1 VAR_1 ) throws IOException { <START> if ( ! METHOD_1 ( ) ) throw new IllegalArgumentException ( STRING_1 ) ; <END> TYPE_2 VAR_2 = VAR_3 . METHOD_2 ( ) ; VAR_2 . METHOD_3 ( ( double ) VAR_4 . METHOD_2 ( ) ) ; VAR_1 . METHOD_4 ( VAR_2 ) ; }
<|startcomment|> please remove System println <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; assertThat ( TYPE_1 . METHOD_3 ( new File ( STRING_1 ) ) ) . METHOD_4 ( ) ; assertThat ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_4 ) ) . contains ( STRING_2 ) ; <START> System . out . println ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_3 ) ) ; <END> assertThat ( VAR_1 . METHOD_5 ( TYPE_2 . VAR_3 ) ) . METHOD_6 ( 1 ) . METHOD_7 ( s - > s . startsWith ( STRING_3 ) ) ; }
<|startcomment|> remove log warn cover log trace <|endcomment|> boolean METHOD_1 ( ) { try { return TYPE_1 . getInstance ( ) . METHOD_2 ( TYPE_3 . VAR_2 , TYPE_3 . VAR_3 ) ; } catch ( final TYPE_2 ex ) { <START> LOG . warn ( ex . VAR_4 ( ) ) ; <END> LOG . trace ( STRING_1 , ex . VAR_4 ( ) , ex ) ; } return false ; }
<|startcomment|> shouldn t users automatically friend STRING_1 signup <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( STRING_1 , STRING_2 , VAR_2 , VAR_3 ) ; TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( STRING_3 , STRING_3 , VAR_2 , VAR_3 ) ; <START> VAR_4 . METHOD_3 ( VAR_1 . VAR_5 , TYPE_3 . METHOD_4 ( ) ) . get ( ) ; <END> List < TYPE_4 > VAR_6 = VAR_1 . METHOD_5 ( ) . get ( ) ; assertTrue ( STRING_4 , VAR_6 . size ( ) > 0 ) ; }
<|startcomment|> тут ты ловишь и то что вылетит из VAR_1 METHOD_1 ( ) надо более узкий - только на METHOD_4 ( ) и METHOD_5 ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 request , TYPE_2 response , TYPE_3 VAR_1 ) throws IOException , TYPE_4 { METHOD_2 ( VAR_2 , STRING_1 ) ; try { VAR_2 . METHOD_3 ( METHOD_4 ( request ) , METHOD_5 ( request ) ) ; VAR_1 . METHOD_1 ( request , response ) ; <START> } catch ( IllegalArgumentException e ) { <END> ( ( TYPE_5 ) response ) . METHOD_6 ( TYPE_5 . VAR_3 ) ; } finally { VAR_2 . clear ( ) ; } }
<|startcomment|> throw new TYPE_5 ( e ) ; orgin exception TYPE_5 <|endcomment|> public TYPE_1 getPath ( ) { try { return new TYPE_2 ( ) . METHOD_1 ( this , METHOD_2 ( TYPE_6 . TYPE_7 . class ) ) ; } catch ( TYPE_4 e ) { <START> throw new TYPE_5 ( ) ; <END> } }
<|startcomment|> I delegate overloaded method : public void METHOD_1 ( final TYPE_1 input final TYPE_2 output final String ) throws IOException { output write ( METHOD_1 ( input ) ) ; } <|endcomment|> public void METHOD_1 ( final TYPE_1 input , final TYPE_2 output , final String name ) throws IOException { <START> final byte [ ] VAR_1 ; <END> try { VAR_1 = TYPE_3 . METHOD_2 ( input ) ; } catch ( final IOException e ) { throw METHOD_3 ( name , e ) ; } output . write ( METHOD_1 ( VAR_1 , name ) ) ; }
<|startcomment|> drop println : - ) <|endcomment|> public TYPE_2 . TYPE_3 METHOD_1 ( ) { <START> System . out . println ( STRING_1 ) ; <END> return VAR_1 ; }
<|startcomment|> fail _CODE_ test fails leave assertions tests METHOD_1 methods <|endcomment|> protected void METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; <START> assertTrue ( VAR_1 ) ; <END> }
<|startcomment|> need empty message _CODE_ ( node ( STRING_2 ) ( STRING_3 ) ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 node = METHOD_2 ( TYPE_2 . VAR_2 , STRING_1 ) ; <START> METHOD_3 ( "" , node . get ( STRING_2 ) . get ( STRING_3 ) ) ; <END> }
<|startcomment|> need VAR_2 code ? _CODE_ execute thread safe isn t <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 resource , TYPE_3 monitor ) { <START> VAR_2 . METHOD_2 ( ) ; <END> try { VAR_3 . execute ( new TYPE_4 ( VAR_1 , resource , monitor ) ) ; } finally { VAR_2 . METHOD_3 ( ) ; } }
<|startcomment|> unrelated change snuck bitching reviewing harder big refactorings <|endcomment|> private void METHOD_1 ( ) throws TYPE_1 { int VAR_1 = 0 ; for ( TYPE_2 VAR_2 : VAR_3 ) { VAR_1 += VAR_2 . METHOD_2 ( ) ; } <START> if ( VAR_1 > VAR_4 ) { <END> throw new TYPE_1 ( STRING_1 ) ; } }
<|startcomment|> VAR_3 API ( List VAR_1 ) private <|endcomment|> <START> public static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < TYPE_1 > VAR_2 ) <END> { List < TYPE_1 > VAR_3 = METHOD_2 ( VAR_1 ) . stream ( ) . filter ( VAR_2 ) . collect ( METHOD_3 ( ) ) ; return METHOD_4 ( VAR_3 ) ; }
<|startcomment|> NPE : VAR_3 null super called I don t line necessary <|endcomment|> public void METHOD_1 ( TYPE_1 parent ) { String name = METHOD_2 ( ) . METHOD_3 ( ) ; if ( name != null ) { name = TYPE_2 . METHOD_4 ( name ) ; } if ( name != null ) { VAR_1 . METHOD_5 ( name ) ; } VAR_2 = new TYPE_3 ( name ) ; <START> TYPE_4 VAR_3 = METHOD_6 ( ) ; <END> VAR_3 . METHOD_7 ( ) . METHOD_8 ( VAR_3 . METHOD_9 ( ) . METHOD_10 ( ) ) ; super . METHOD_1 ( parent ) ; }
<|startcomment|> s change signature add a separate method <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> please s unnecessary write factory <|endcomment|> public TYPE_1 METHOD_1 ( int i ) { <START> return METHOD_1 ( i , this . factory ) ; <END> }
<|startcomment|> I presume want line gitattributes ? I need a single METHOD_3 lines : METHOD_3 ( STRING_8 [ [ ] ] bar\n + STRING_10 + ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 , STRING_6 , STRING_7 ) ; METHOD_3 ( STRING_8 , STRING_9 ) ; METHOD_3 ( STRING_8 , STRING_10 ) ; METHOD_3 ( STRING_8 , STRING_11 ) ; <START> METHOD_3 ( STRING_8 , STRING_12 ) ; <END> METHOD_4 ( ) ; }
<|startcomment|> pass null parameter need mocking case <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( VAR_1 . VAR_2 ) ; TYPE_1 VAR_3 = METHOD_3 ( TYPE_1 . class ) ; TYPE_2 VAR_4 = METHOD_3 ( TYPE_2 . class ) ; TYPE_3 VAR_5 = METHOD_3 ( TYPE_3 . class ) ; <START> VAR_1 . METHOD_4 ( VAR_3 , VAR_4 , VAR_5 ) ; <END> METHOD_2 ( VAR_1 . VAR_2 ) ; VAR_1 . METHOD_5 ( ) ; assertTrue ( VAR_1 . VAR_2 ) ; }
<|startcomment|> INT_1 <|endcomment|> private static String METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ) { <START> StringBuilder VAR_3 = new StringBuilder ( VAR_2 . length ( ) + INT_1 ) ; <END> VAR_3 . append ( STRING_1 ) ; if ( ! VAR_2 . isEmpty ( ) && ! VAR_2 . startsWith ( STRING_2 ) ) { VAR_3 . append ( CHAR_1 ) ; } VAR_3 . append ( VAR_2 ) ; return VAR_3 . toString ( ) ; } else { return VAR_2 ; } }
<|startcomment|> minor : don t need call METHOD_2 ( ) s a class member <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> TYPE_2 VAR_2 = METHOD_2 ( ) ; <END> VAR_1 . put ( VAR_3 , VAR_2 . METHOD_3 ( ) + STRING_1 + VAR_2 . METHOD_4 ( ) ) ; VAR_1 . put ( VAR_4 , METHOD_5 ( ) . METHOD_6 ( ) ) ; VAR_1 . put ( VAR_5 , METHOD_7 ( ) ) ; VAR_1 . put ( VAR_6 , METHOD_8 ( ) ) ; return VAR_1 ; }
<|startcomment|> doesn t work java 6 enhancements want * add * permissions file wan t remove <|endcomment|> protected String METHOD_1 ( String value ) throws IOException { File VAR_1 = File . VAR_2 ( STRING_1 , STRING_2 ) ; String VAR_3 = VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( true , true ) ; VAR_1 . METHOD_4 ( true , true ) ; <START> VAR_1 . METHOD_5 ( false ) ; <END> TYPE_1 out = new TYPE_1 ( new TYPE_2 ( VAR_1 ) ) ; out . write ( value ) ; out . close ( ) ; return VAR_3 ; }
<|startcomment|> avoid repeating 1 places <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( 1 ) ; <END> Assert . VAR_3 ( VAR_2 . METHOD_2 ( 1 ) . METHOD_3 ( ) ) ; VAR_2 . METHOD_4 ( VAR_1 , STRING_1 ) ; Assert . assertTrue ( VAR_2 . METHOD_2 ( 1 ) . METHOD_3 ( ) ) ; }
<|startcomment|> remove ? OPENNLP - 922 changes style equals _CODE_ implementations <|endcomment|> public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final TYPE_1 < T > VAR_1 = ( TYPE_1 < T > ) obj ; <START> return TYPE_2 . equals ( this . VAR_2 , VAR_1 . VAR_2 ) && <END> this . VAR_3 == VAR_1 . VAR_3 && TYPE_2 . equals ( this . VAR_4 , VAR_1 . VAR_4 ) ; }
<|startcomment|> VAR_7 METHOD_5 ( ) returns TYPE_1 instanceof TYPE_1 a _CODE_ equals null I rid statements return VAR_7 METHOD_5 ( VAR_8 ) add a _CODE_ _CODE_ <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 session , TYPE_1 VAR_1 , TYPE_3 VAR_2 ) { Map < TYPE_4 < TYPE_1 > , Type > VAR_3 = METHOD_2 ( session , VAR_1 , VAR_2 ) ; TYPE_5 VAR_4 = TYPE_5 . METHOD_3 ( VAR_1 , metadata , session , VAR_3 ) ; Object value = VAR_4 . METHOD_4 ( TYPE_6 . VAR_6 ) ; <START> if ( value instanceof TYPE_1 ) { <END> return ( TYPE_1 ) value ; } if ( value == null ) { value = false ; } return VAR_7 . METHOD_5 ( value , VAR_8 ) ; }
<|startcomment|> incorrect case logger VAR_2 null a NPE <|endcomment|> public boolean METHOD_1 ( String VAR_1 , Object data ) { TYPE_1 event = METHOD_2 ( VAR_1 , data ) ; TYPE_2 VAR_2 = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; if ( VAR_2 == null && logger != null ) { logger . error ( TYPE_4 . bind ( TYPE_5 . VAR_4 , event . toString ( ) ) ) ; <START> return false ; <END> } VAR_2 . METHOD_5 ( event ) ; return true ; }
<|startcomment|> expected ( 1 ) parameter assertEquals <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( true ) ; VAR_1 . METHOD_4 ( STRING_1 ) ; VAR_1 . METHOD_5 ( ) ; assertEquals ( STRING_2 , VAR_1 . METHOD_6 ( ) . METHOD_7 ( new TYPE_2 < TYPE_3 > ( ) { @Override public boolean METHOD_8 ( final TYPE_3 element ) { return element . VAR_2 ( ) . METHOD_9 ( ) . equals ( STRING_3 ) ; } <START> } ) . size ( ) , 1 ) ; <END> }
<|startcomment|> ! [ redundantarraycreation ] ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . METHOD_2 ( Arrays . asList ( new TYPE_2 [ ] { METHOD_3 ( ) , METHOD_4 ( ) } ) ) ; <END> VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ; return VAR_1 ; }
<|startcomment|> package protected <|endcomment|> <START> protected List < TYPE_1 > METHOD_1 ( TYPE_2 . Type type , List < TYPE_1 . TYPE_4 > VAR_1 ) { <END> TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , type , VAR_4 , VAR_1 ) ; List < TYPE_1 > VAR_5 = new ArrayList < TYPE_1 > ( 1 ) ; VAR_5 . add ( VAR_2 ) ; return VAR_5 ; }
<|startcomment|> static <|endcomment|> <START> private TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) ; VAR_1 . METHOD_3 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_4 ( new Guid ( ) ) ; VAR_1 . METHOD_5 ( STRING_2 ) ; VAR_1 . METHOD_6 ( INT_1 ) ; return VAR_1 ; }
<|startcomment|> handle VAR_6 ? decltype ( auto ) METHOD_2 ( ) null <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = VAR_1 . METHOD_2 ( ) ; if ( VAR_2 == null ) { return null ; } int VAR_3 = VAR_1 . getType ( ) ; <START> if ( VAR_3 == TYPE_4 . VAR_5 || VAR_3 == TYPE_4 . VAR_6 ) { <END> return METHOD_1 ( VAR_2 ) ; } return VAR_2 . METHOD_3 ( ) ; }
<|startcomment|> I underscore a dash <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( VAR_1 . get ( STRING_1 ) != null ) { <END> return ( TYPE_1 ) VAR_1 . get ( STRING_2 ) ; } else { return 2 ; } }
<|startcomment|> change INFO level <|endcomment|> public void start ( ) { if ( VAR_1 . METHOD_1 ( false , true ) ) { METHOD_2 ( ) ; VAR_2 = Utils . VAR_3 ( 1 , false ) ; VAR_2 . METHOD_3 ( new TYPE_1 ( ) , 0 , config . VAR_4 , TimeUnit . VAR_5 ) ; <START> logger . trace ( STRING_1 ) ; <END> } }
<|startcomment|> point reason wouldn t throw exception return error client <|endcomment|> public String METHOD_1 ( ANNOTATION_1 ( STRING_1 ) final String id , final TYPE_1 request ) { String VAR_1 ; try { VAR_1 = TYPE_2 . METHOD_2 ( id , STRING_2 ) ; } catch ( TYPE_3 e ) { log . warn ( STRING_3 , id , e ) ; <START> VAR_1 = id ; <END> } final String path = STRING_4 + VAR_1 + STRING_5 + TYPE_4 . METHOD_3 ( request ) ; return STRING_6 + path ; }
<|startcomment|> a - integer ? a set host ? more accurate save qos parameters _CODE_ doubles saving integer bits displaying user mb I don t understand benefit sending / receiving bits doubles api vdsm <|endcomment|> private Integer METHOD_1 ( Map < String , Object > entry , String VAR_1 , int VAR_2 ) { Map < String , Double > parameters = ( Map < String , Double > ) entry . get ( VAR_1 ) ; if ( parameters == null ) { return null ; } Double VAR_3 = parameters . get ( TYPE_1 . VAR_5 ) ; <START> return ( VAR_3 == null ) ? null : ( int ) ( VAR_3 / VAR_2 ) ; <END> }
<|startcomment|> else block replaced listener VAR_3 ( ) ; <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 < TYPE_2 > listener ) { VAR_1 . METHOD_2 ( ( value , VAR_2 ) - > { <START> if ( VAR_2 == null ) { <END> listener . VAR_3 ( this ) ; } else { listener . VAR_3 ( this ) ; } } ) ; return this ; }
<|startcomment|> throw error <|endcomment|> public TYPE_1 < T > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 , List < TYPE_1 < T > > VAR_3 ) { if ( ! METHOD_2 ( VAR_1 ) ) { return METHOD_3 ( VAR_2 ) ; } try { return new TYPE_1 < > ( Optional . of ( ( T ) VAR_4 . get ( VAR_1 ) . METHOD_4 ( VAR_3 ) ) , VAR_2 , VAR_3 ) ; } <START> catch ( Throwable t ) { <END> return METHOD_3 ( VAR_2 ) ; } }
<|startcomment|> true rid variable <|endcomment|> public void METHOD_1 ( ) { Guid VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { METHOD_1 ( false , false , null ) ; } else { TYPE_1 . getInstance ( ) . METHOD_3 ( new TYPE_2 < > ( cluster - > { if ( cluster != null ) { <START> METHOD_1 ( true , cluster . VAR_2 ( ) , VAR_1 ) ; <END> } } ) , VAR_1 ) ; } }
<|startcomment|> METHOD_1 ( VAR_2 <|endcomment|> public TYPE_3 ( final String name , final TYPE_1 VAR_2 ) { METHOD_1 ( name , STRING_1 ) ; <START> METHOD_1 ( name , STRING_2 ) ; <END> this . VAR_3 = new TYPE_2 ( name , VAR_2 ) ; }
<|startcomment|> add a null check selected VAR_1 installed yielding a null menu item <|endcomment|> private void METHOD_1 ( TYPE_1 request ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( METHOD_3 ( ) ) ; TYPE_4 VAR_2 = TYPE_4 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_1 . getKey ( ) ) ; <START> if ( ! VAR_2 . METHOD_6 ( ) ) { <END> throw TYPE_5 . METHOD_7 ( ) ; } TYPE_6 . METHOD_8 ( request , VAR_2 ) ; }
<|startcomment|> String valueOf <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , String url , long VAR_2 ) { TYPE_2 VAR_3 = VAR_4 . VAR_3 ; TYPE_3 . Log log = VAR_4 . log ; if ( VAR_3 . log ( ) ) { log . log ( String . format ( STRING_1 , VAR_1 . VAR_5 , url , VAR_2 ) ) ; if ( VAR_3 . METHOD_2 ( ) >= TYPE_2 . TYPE_5 . METHOD_2 ( ) ) { <START> log . log ( VAR_1 . VAR_6 + "" ) ; <END> log . log ( STRING_2 ) ; } } }
<|startcomment|> context <|endcomment|> public void METHOD_1 ( final TYPE_1 context ) { if ( context . VAR_1 ( ) ) { return ; } TYPE_2 . METHOD_2 ( ) . METHOD_3 ( new TYPE_3 ( ) { @Override public void run ( ) { <START> synchronized ( context . VAR_2 ( ) ) { <END> if ( ! context . VAR_1 ( ) ) { context . VAR_3 ( ) ; context . VAR_4 ( ) . METHOD_4 ( ) ; context . VAR_5 ( ) ; } } } } ) ; }
<|startcomment|> reads a bit strange fall METHOD_3 request doesn t need coordinator clearer a slight restructure : _CODE_ METHOD_4 ( VAR_1 ) ; ( VAR_1 METHOD_2 ( ) ) { VAR_5 METHOD_3 ( VAR_1 ) ; } else { / / - coordinator requests VAR_2 prevent a tight loop node availabletime VAR_2 ( VAR_3 ) ; metadata VAR_4 ( ) ; } <|endcomment|> private void METHOD_1 ( TYPE_2 . TYPE_3 VAR_1 ) { if ( ! VAR_1 . METHOD_2 ( ) ) { time . VAR_2 ( VAR_3 ) ; metadata . VAR_4 ( ) ; } <START> VAR_5 . METHOD_3 ( VAR_1 ) ; <END> VAR_5 . METHOD_4 ( VAR_1 ) ; }
<|startcomment|> ( spelling ) I guess a reason t _CODE_ oppossed METHOD_5 ? semantics <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 client = new TYPE_1 ( VAR_1 . location ( ) ) ; assertNotNull ( client . VAR_2 ( ) ) ; METHOD_2 ( client . VAR_2 ( ) . METHOD_3 ( ) ) ; TYPE_2 version = client . VAR_3 ( new TYPE_3 ( ) ) ; assertTrue ( STRING_1 + VAR_1 . METHOD_4 ( ) + STRING_2 + version . toString ( ) , <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( version . toString ( ) ) == 0 ) ; <END> }
<|startcomment|> need a reference nodes setup <|endcomment|> private String METHOD_1 ( String VAR_1 ) { <START> String [ ] VAR_2 = { STRING_1 , STRING_2 , STRING_3 } ; <END> for ( String VAR_3 : VAR_2 ) { if ( new File ( VAR_3 + VAR_1 ) . exists ( ) ) { return VAR_3 + VAR_1 ; } } return null ; }
<|startcomment|> logging spammy log <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , String path , TYPE_2 VAR_2 ) throws IOException { List < TYPE_3 > VAR_3 = new ArrayList < > ( ) ; for ( TYPE_6 . TYPE_7 . VAR_4 . TYPE_3 entry : VAR_2 . METHOD_2 ( ) ) { TYPE_3 VAR_6 = METHOD_3 ( entry ) ; VAR_3 . add ( VAR_6 ) ; } try { VAR_1 . METHOD_1 ( new Path ( path ) , VAR_3 ) ; } catch ( TYPE_5 e ) { <START> LOG . warn ( STRING_1 ) ; <END> } }
<|startcomment|> lets a TAG variable <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; <START> Log . i ( STRING_1 , STRING_2 ) ; <END> }
<|startcomment|> - else dont t need increment line ? split line don t include statement line <|endcomment|> private int METHOD_1 ( ) { <START> if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) VAR_1 = TYPE_1 . VAR_2 + 1 ; <END> return VAR_1 ++ ; }
<|startcomment|> static import <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = METHOD_2 ( ) . message ( of ( STRING_1 ) ) . build ( ) ; TYPE_2 VAR_2 = METHOD_2 ( ) . message ( of ( STRING_2 ) ) . build ( ) ; assertThat ( STRING_3 , VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) , <START> METHOD_5 ( TYPE_3 . is ( VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ) ) ) ; <END> }
<|startcomment|> single <|endcomment|> private void METHOD_1 ( final TYPE_1 state ) { if ( state != null ) { <START> if ( ! VAR_1 ) { <END> METHOD_2 ( state . VAR_2 ( VAR_3 , false ) ) ; } } }
<|startcomment|> hardcode <|endcomment|> public TYPE_1 getParameters ( TYPE_2 VAR_1 , TYPE_3 entity ) { TYPE_4 VAR_2 = METHOD_1 ( VAR_3 , TYPE_4 . class ) . map ( VAR_1 , entity . VAR_4 ( ) ) ; <START> TYPE_5 VAR_5 = new TYPE_5 ( VAR_2 , STRING_1 , "" , false ) ; <END> if ( VAR_1 . METHOD_2 ( ) ) { VAR_5 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; } return VAR_5 ; }
<|startcomment|> style - : method static <|endcomment|> <START> private boolean METHOD_1 ( String a , String b ) { <END> int VAR_1 = a . VAR_2 ( CHAR_1 ) ; int VAR_3 = b . VAR_2 ( CHAR_1 ) ; return a . substring ( 0 , VAR_1 + 1 ) . equals ( b . substring ( 0 , VAR_3 + 1 ) ) ; }
<|startcomment|> need METHOD_1 ? more sense put start method ( remove field init ) <|endcomment|> public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { super . METHOD_1 ( context ) ; <START> VAR_1 = new TYPE_2 ( ) ; <END> }
<|startcomment|> I a fan move _CODE_ initialized <|endcomment|> <START> public synchronized void METHOD_1 ( ) { <END> if ( this . VAR_1 == null ) { this . VAR_1 = TYPE_1 . METHOD_2 ( METHOD_3 ( ) , this . VAR_2 ) ; if ( this . VAR_1 == null ) { throw new TYPE_2 ( STRING_1 ) ; } try { METHOD_3 ( ) . METHOD_4 ( this . VAR_1 , true , false ) ; } catch ( Exception e ) { throw new TYPE_2 ( e ) ; } } }
<|startcomment|> a live test a symptom users build - predicates2 retry construct wait server deleted consider binding guice context reused needed <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { METHOD_2 ( ) . METHOD_3 ( VAR_1 . id ( ) ) ; <START> Thread . VAR_2 ( INT_1 ) ; <END> METHOD_4 ( VAR_3 ) ; METHOD_5 ( VAR_3 . id ( ) ) ; }
<|startcomment|> improvement <|endcomment|> public Object next ( ) { if ( position >= VAR_1 ) { throw new TYPE_1 ( ) ; } Object result = TYPE_2 . get ( VAR_2 , position ) ; position ++ ; <START> return result ; <END> }
<|startcomment|> assigning 0 VAR_3 assign some line <|endcomment|> protected int METHOD_1 ( TYPE_1 VAR_1 ) { METHOD_2 ( INT_1 , TimeUnit . VAR_2 ) ; <START> int VAR_3 = 0 ; <END> try { VAR_3 = VAR_4 . METHOD_3 ( VAR_1 ) . size ( ) ; } catch ( Exception ex ) { VAR_3 = 0 ; } finally { METHOD_4 ( ) ; } return VAR_3 ; }
<|startcomment|> I don t understand testing field empty ? shouldn t removed <|endcomment|> public void set ( String field , final String value ) { <START> if ( ! "" . equals ( field ) ) { <END> if ( METHOD_1 ( field ) ) { VAR_1 . put ( field , value ) ; String VAR_2 = METHOD_2 ( field ) ; if ( VAR_2 != null ) { VAR_3 . add ( new TYPE_1 ( VAR_2 ) ) ; } field = VAR_2 ; } if ( field != null ) { values . put ( field , value ) ; } } }
<|startcomment|> merge lines METHOD_1 return argument <|endcomment|> public TYPE_3 ( String VAR_2 , TYPE_1 VAR_3 ) { TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_2 . METHOD_1 ( VAR_3 , STRING_2 ) ; this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> }
<|startcomment|> change _CODE_ ( VAR_2 ! = null && VAR_2 METHOD_2 ( ) = = TYPE_3 VAR_6 ) rid VAR_4 <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_3 ; boolean VAR_4 = ( VAR_2 != null && VAR_2 . METHOD_2 ( ) != TYPE_3 . VAR_6 ) ; <START> VAR_1 . METHOD_3 ( VAR_7 ) . METHOD_4 ( ! VAR_4 ) ; <END> VAR_1 . METHOD_3 ( VAR_8 ) . METHOD_5 ( VAR_2 != null ) ; return super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> strange <|endcomment|> public void METHOD_1 ( ) { <START> page . VAR_1 ( VAR_2 , VAR_3 ) ; <END> }
<|startcomment|> StringUtils truncate instead <|endcomment|> <START> protected static String METHOD_1 ( String VAR_1 , int VAR_2 ) { <END> if ( StringUtils . length ( VAR_1 ) <= VAR_2 ) { return VAR_1 ; } else { return VAR_1 . substring ( 0 , VAR_2 ) ; } }
<|startcomment|> style : don t braces single line blocks <|endcomment|> private void METHOD_1 ( ) { <START> if ( VAR_1 == null ) { <END> METHOD_2 ( ) ; } }
<|startcomment|> prefer isEmpty ( ) a size ( ) comparison <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 id ) { TYPE_1 VAR_1 = null ; <START> if ( id != null && id . getValue ( ) != null && id . getValue ( ) . size ( ) > 0 ) { <END> VAR_1 = id . getValue ( ) . get ( 0 ) ; } return VAR_1 ; }
<|startcomment|> improved VAR_1 check shows method mixing concerns : map lookup caching I prefer caching done a separate wrapper class ( _CODE_ ) returned _CODE_ _CODE_ called ( instead backing map unmodifiable _CODE_ ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( this . VAR_1 && this . VAR_2 != null ) { return this . VAR_2 ; } else { String value = METHOD_2 ( VAR_3 ) ; TYPE_1 VAR_4 = ( StringUtils . VAR_5 ( value ) ? TYPE_1 . METHOD_3 ( value ) : null ) ; if ( this . VAR_1 ) { this . VAR_2 = VAR_4 ; } return VAR_4 ; <START> } <END> }
<|startcomment|> change List <|endcomment|> protected String [ ] METHOD_1 ( ) { <START> ArrayList < String > <END> list = new ArrayList < > ( ) ; for ( TYPE_1 VAR_1 : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { list . add ( VAR_1 . getName ( ) ) ; } return list . VAR_2 ( new String [ 0 ] ) ; }
<|startcomment|> simplified VAR_2 ! = null && VAR_2 METHOD_1 ( ) METHOD_2 ( ) METHOD_3 ( ) <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_5 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( ) : false ; <END> this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; }
<|startcomment|> I don t putting a synchronized block line fire doesn t need a global lock type stuff I find production environments <|endcomment|> public static TYPE_1 METHOD_1 ( ) { <START> synchronized ( VAR_1 ) { <END> if ( VAR_2 == null ) { TYPE_1 c = TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; if ( c != null ) { VAR_2 = c ; } else { VAR_2 = new TYPE_3 ( ) ; } } return VAR_2 ; } }
<|startcomment|> missing return <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , Collection < TYPE_2 > VAR_2 ) { <START> METHOD_1 ( VAR_1 , <END> VAR_2 , METHOD_2 ( ) , METHOD_2 ( ) , null , null ) ; }
<|startcomment|> point TYPE_2 append stores X amount <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { <START> try { TYPE_2 VAR_1 = new TYPE_2 ( 1 ) ; VAR_1 . add ( INT_1 ) ; VAR_1 . add ( INT_2 ) ; } catch ( TYPE_1 e ) { METHOD_2 ( STRING_1 ) ; } <END> }
<|startcomment|> I don t log message adds <|endcomment|> public Double METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) . get ( TYPE_2 . VAR_4 ) ; } <START> LOG . warn ( STRING_1 , VAR_1 ) ; <END> return null ; }
<|startcomment|> - resources ? tabs fixed <|endcomment|> public static void METHOD_1 ( final TYPE_1 in , final TYPE_2 VAR_1 ) throws IOException { TYPE_3 out = null ; try { out = new TYPE_3 ( VAR_1 . out ( ) ) ; TYPE_4 . METHOD_2 ( in , out ) ; out . VAR_2 ( ) ; } finally { <START> out . close ( ) ; <END> } }
<|startcomment|> please dont { 0 } String format instead <|endcomment|> private void METHOD_1 ( TYPE_1 vm ) { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( ) . METHOD_3 ( vm . getId ( ) ) . size ( ) > 0 ) { <START> log . VAR_1 ( STRING_1 , vm . getId ( ) ) ; <END> TYPE_3 . getInstance ( ) . METHOD_4 ( TYPE_7 . TYPE_6 , new TYPE_4 ( vm . getId ( ) ) , new TYPE_5 ( METHOD_5 ( ) ) ) ; } }
<|startcomment|> please Map < ? ? > <|endcomment|> public void METHOD_1 ( Object [ ] params ) { if ( params . length != 1 ) { throw new IllegalArgumentException ( STRING_1 ) ; } <START> METHOD_1 ( ( Map < Object , TYPE_1 > ) params [ 0 ] ) ; <END> }
<|startcomment|> super ( ) ; needed <|endcomment|> public TYPE_2 ( Class < TYPE_1 > VAR_2 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> introduction 5 seconds delay a test a lot instead create a new _CODE_ _CODE_ = VAR_1 increment successful session execute change METHOD_3 : _CODE_ ( ( ) _CODE_ = = VAR_1 ) ? test characteristic waiting succeed error happen wdyt <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { int VAR_1 = VAR_2 * VAR_3 ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { METHOD_2 ( null , null ) ; } <START> TYPE_1 . METHOD_3 ( 5 ) ; <END> VAR_4 . METHOD_4 ( ) ; Throwable VAR_5 = VAR_6 . get ( ) ; if ( VAR_5 != null ) { METHOD_5 ( STRING_1 , VAR_5 ) ; } }
<|startcomment|> assertTrue ( b ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { when ( VAR_1 . getProperty ( STRING_1 , false ) ) . METHOD_2 ( true ) ; boolean b = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> assertTrue ( b == true ) ; <END> }
<|startcomment|> i don t VAR_3 null i miss null checks added dispose method <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = Status . VAR_2 ; if ( VAR_3 != null && VAR_3 . METHOD_2 ( ) != null ) { VAR_1 = VAR_3 . METHOD_2 ( ) ; } <START> return VAR_1 ; <END> }
<|startcomment|> put STRING_1 + getName ( ) a local variable avoid repetition <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_1 . class ) ; if ( VAR_1 != null ) { if ( VAR_2 . VAR_3 == null ) { cache . VAR_4 ( STRING_1 + getName ( ) ) ; <START> VAR_1 . METHOD_3 ( STRING_1 + getName ( ) ) ; <END> } if ( VAR_2 . VAR_5 == null ) { cache . VAR_6 ( STRING_2 + getName ( ) ) ; VAR_1 . METHOD_3 ( STRING_2 + getName ( ) ) ; } } }
<|startcomment|> reason formatting changes <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , List < String > VAR_3 , TYPE_3 VAR_4 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) { <END> TYPE_4 VAR_5 = METHOD_3 ( VAR_1 ) ; if ( VAR_5 != null ) { VAR_3 . add ( new TYPE_5 ( STRING_1 , VAR_5 . METHOD_4 ( ) ) . METHOD_5 ( ) ) ; } } }
<|startcomment|> whitespace < = - good enclose blocks / else { } <|endcomment|> private static String METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( STRING_1 ) <= 0 ) <END> VAR_1 = VAR_1 . METHOD_3 ( ) . trim ( ) ; else VAR_1 = VAR_1 . METHOD_3 ( ) . trim ( ) . substring ( 0 , VAR_1 . METHOD_2 ( STRING_1 ) ) ; return VAR_1 ; }
<|startcomment|> private <|endcomment|> <START> public String METHOD_1 ( String table , String path ) <END> { return METHOD_2 ( TYPE_1 . builder ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . create ( String . format ( STRING_1 , METHOD_5 ( table ) , path ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
<|startcomment|> place print I thinking useful print config file ended <|endcomment|> <START> public TYPE_1 METHOD_1 ( String VAR_1 ) { <END> try { return METHOD_2 ( VAR_1 ) ; } catch ( TYPE_2 e ) { TYPE_1 config = new TYPE_1 ( METHOD_3 ( ) ) ; config . VAR_2 ( VAR_1 ) ; return config ; } }
<|startcomment|> variable useless please return / … branches <|endcomment|> public String METHOD_1 ( ) { <START> String VAR_1 ; <END> if ( VAR_2 . VAR_3 == null || VAR_2 . VAR_3 . length ( ) == 0 ) VAR_1 = STRING_1 ; else if ( Double . VAR_4 ( METHOD_2 ( ) ) ) VAR_1 = STRING_2 ; else VAR_1 = "" + ( int ) METHOD_2 ( ) ; return VAR_1 ; }
<|startcomment|> please { } line clauses <|endcomment|> public static boolean METHOD_1 ( ) { TYPE_1 VAR_1 [ ] = TYPE_2 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ; TYPE_3 VAR_2 ; for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { if ( VAR_1 [ i ] instanceof TYPE_3 ) { VAR_2 = ( TYPE_3 ) VAR_1 [ i ] ; if ( VAR_2 . METHOD_5 ( ) ) <START> return true ; <END> } } return false ; }
<|startcomment|> oups bad rebase <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_4 . TYPE_5 VAR_2 ) { if ( METHOD_2 ( ) && VAR_1 != null && VAR_2 != null ) { if ( VAR_1 . VAR_3 != VAR_2 . VAR_4 ) { TYPE_3 . d ( TAG , VAR_1 . name + STRING_1 + VAR_1 . VAR_3 + STRING_2 + VAR_2 . VAR_4 ) ; METHOD_3 ( VAR_2 , TYPE_6 . VAR_6 ) ; <START> <END> return true ; } if ( VAR_7 ) { TYPE_3 . d ( TAG , STRING_3 + VAR_1 . name + STRING_4 ) ; } } }
<|startcomment|> _CODE_ info ( Log user + user _CODE_ ( ) ) ; <|endcomment|> TYPE_1 METHOD_1 ( TYPE_2 user , TYPE_3 < TYPE_2 > VAR_1 ) { METHOD_2 ( STRING_1 ) ; return new TYPE_4 < TYPE_2 > ( TYPE_7 . VAR_3 , VAR_1 ) { @Override public TYPE_2 run ( ) throws TYPE_5 { <START> TYPE_6 . error ( STRING_2 ) ; <END> METHOD_3 ( user ) ; return user ; } } . start ( ) ; }
<|startcomment|> please put @Override annotation line <|endcomment|> <START> @Override <END> protected Map < String , Pair < String , String > > METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; return VAR_2 . stream ( ) . collect ( Collectors . VAR_3 ( VAR_4 - > VAR_4 . getId ( ) . toString ( ) , VAR_4 - > TYPE_2 . METHOD_3 ( TYPE_3 . VAR_6 , VAR_1 ) ) ) ; }
<|startcomment|> imo added s needed message need add disk alias a message vm isn t example messages <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( TYPE_1 . VAR_2 ) ; METHOD_2 ( TYPE_1 . VAR_3 ) ; if ( METHOD_3 ( ) != null ) { METHOD_2 ( String . format ( STRING_1 , STRING_2 , METHOD_4 ( ) ) ) ; <START> } <END> }
<|startcomment|> final <|endcomment|> <START> public < TYPE_1 > TYPE_2 < TYPE_1 > map ( final TYPE_3 < TYPE_4 , TYPE_1 > f ) { <END> return bind ( a - > METHOD_1 ( f . f ( a ) ) ) ; }
<|startcomment|> remove qualifier <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_1 child ) { <START> return new TYPE_2 ( child , this . VAR_1 ) ; <END> }
<|startcomment|> _CODE_ a copy <|endcomment|> public synchronized List < TYPE_1 < ? > > METHOD_1 ( ) { <START> return TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> }
<|startcomment|> return proper ID - mimic real behavior <|endcomment|> private void METHOD_1 ( ) { when ( METHOD_2 ( ) . METHOD_3 ( ) ) . METHOD_4 ( VAR_1 ) ; when ( VAR_1 . get ( VAR_2 ) ) . METHOD_4 ( ( VAR_3 ) ) ; <START> when ( VAR_3 . METHOD_5 ( ) ) . METHOD_4 ( null ) ; <END> }
<|startcomment|> shouldn t actual < - - > expected replaced <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( TYPE_5 . TYPE_4 ) ; METHOD_3 ( cmd . VAR_3 ( TYPE_5 . TYPE_4 ) ) ; List < String > VAR_4 = cmd . VAR_5 ( ) . METHOD_4 ( ) ; <START> assertEquals ( 2 , VAR_4 . size ( ) ) ; <END> assertEquals ( VAR_4 . get ( 0 ) , TYPE_2 . TYPE_3 . toString ( ) ) ; assertEquals ( VAR_4 . get ( 1 ) , String . format ( STRING_1 , TYPE_5 . TYPE_4 ) ) ; }
<|startcomment|> replaced VAR_1 isEmpty ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) throws TYPE_2 { String VAR_1 = text == null ? "" : text . VAR_2 ( VAR_3 ) ; <START> if ( VAR_1 . equals ( "" ) ) { <END> return null ; } return new TYPE_1 ( VAR_1 , VAR_3 , type ) ; }
<|startcomment|> remove package import statements <|endcomment|> public List < String > METHOD_1 ( String VAR_1 ) { List < String > VAR_2 = VAR_3 . get ( VAR_1 ) ; if ( VAR_2 == null ) { VAR_2 = new ArrayList < String > ( 0 ) ; } <START> return new TYPE_2 . TYPE_3 . ArrayList < String > ( VAR_2 ) ; <END> }
<|startcomment|> please leave - s intentionally referencing deprecated version <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> style : braces single line blocks <|endcomment|> public Object execute ( TYPE_1 event ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_1 ( event ) ; <START> if ( VAR_1 == null ) { <END> return null ; } TYPE_4 VAR_2 = new TYPE_4 ( VAR_1 ) ; TYPE_5 VAR_3 = new TYPE_5 ( TYPE_6 . METHOD_2 ( event ) , VAR_2 ) ; VAR_3 . METHOD_3 ( false ) ; VAR_3 . METHOD_4 ( ) ; return null ; }
<|startcomment|> I remove VAR_3 field <|endcomment|> public TYPE_5 ( TYPE_1 buf ) { VAR_2 = TYPE_2 . METHOD_1 ( buf , TYPE_3 . class ) ; <START> VAR_3 = null ; <END> data = TYPE_2 . METHOD_1 ( buf , TYPE_4 . class ) ; }
<|startcomment|> need METHOD_2 ( ) methods ? concrete tests a reference obtained stats instance means time operations return stats instance updated <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( ( ) - > { <START> long VAR_1 = VAR_2 . METHOD_3 ( ) ; <END> METHOD_4 ( STRING_1 , VAR_3 , VAR_1 ) ; VAR_3 = VAR_1 ; } ) ; }
<|startcomment|> missing ! operator <|endcomment|> public List < TYPE_1 > METHOD_1 ( Guid VAR_1 , TYPE_2 VAR_2 , boolean VAR_3 ) { if ( ! METHOD_2 ( VAR_1 ) ) { throw new TYPE_3 ( TYPE_5 . TYPE_4 ) ; } if ( VAR_3 ) { <START> if ( METHOD_3 ( VAR_1 , VAR_2 ) ) { <END> throw new TYPE_3 ( TYPE_5 . VAR_6 ) ; } } else { METHOD_4 ( VAR_1 , VAR_2 ) ; } return METHOD_5 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> I wouldn t VAR_1 forces a TYPE_4 ( TYPE_2 ) constructor class doesn t need I d parameterless constructors _CODE_ _CODE_ ( ) _CODE_ ( ) TYPE_5 _CODE_ ( ) instead <|endcomment|> private static TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = TYPE_2 . METHOD_2 ( ) ; Assert . VAR_2 ( VAR_1 ) ; if ( TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( TYPE_6 . VAR_4 ) ) { return new TYPE_4 ( VAR_1 ) ; } <START> return new TYPE_5 ( VAR_1 ) ; <END> }
<|startcomment|> synchronized block part - catch block ? shouldn t catch part run synchronized block <|endcomment|> public long METHOD_1 ( ) { long VAR_1 = - 1 ; try { synchronized ( this ) { VAR_1 = VAR_2 / VAR_3 ; <START> } <END> } catch ( Exception e ) { if ( VAR_3 == 0 && VAR_2 == 0 ) { VAR_1 = 0 ; } } return VAR_1 ; }
<|startcomment|> technically need null - check ftrace other fields test fails line exploded method called null <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 . METHOD_2 ( ) ; VAR_2 = null ; VAR_3 . METHOD_2 ( ) ; VAR_4 = null ; }
<|startcomment|> call append ( VAR_1 METHOD_3 ( ) ) build ( ) ; <|endcomment|> public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> }
<|startcomment|> annotate nullable <|endcomment|> public static byte [ ] METHOD_1 ( final String string ) { if ( string == null ) { <START> return null ; <END> } try { return string . VAR_1 ( VAR_2 ) ; } catch ( TYPE_1 e ) { throw TYPE_2 . METHOD_2 ( e ) ; } }
<|startcomment|> I don t need condition TYPE_3 METHOD_3 return emptylist key isn t set fine <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 entity ) { <START> if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { <END> List < TYPE_1 > VAR_3 = TYPE_3 . METHOD_3 ( VAR_1 , VAR_2 ) ; entity . VAR_4 ( TYPE_4 . METHOD_4 ( VAR_3 , new TYPE_5 < TYPE_1 , TYPE_6 > ( ) { @Override public TYPE_6 apply ( TYPE_1 input ) { return VAR_5 . METHOD_5 ( input , new TYPE_6 ( ) ) ; } } ) ) ; } }
<|startcomment|> a chance a NPE ? METHOD_2 ( ) null <|endcomment|> public String METHOD_1 ( Object element ) { if ( element instanceof String ) { return ( String ) element ; } if ( element instanceof TYPE_1 ) { <START> return ( ( TYPE_1 ) element ) . METHOD_2 ( ) . getName ( ) ; <END> } return null ; }
<|startcomment|> needs a concurrent hashmap <|endcomment|> public TYPE_5 ( ) { this . VAR_2 = TYPE_1 . METHOD_1 ( TYPE_4 < String , TYPE_2 > create ( ) ) ; <START> this . VAR_4 = TYPE_3 . METHOD_2 ( ) ; <END> }
<|startcomment|> please final <|endcomment|> <START> public void METHOD_1 ( String VAR_1 ) { <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> consider paranoid prefix line length ( ) > 0 <|endcomment|> static String METHOD_1 ( String line ) { <START> if ( line . VAR_1 ( line . length ( ) - 1 ) == CHAR_1 ) { <END> return line . substring ( 0 , line . length ( ) - 1 ) ; } return line ; }
<|startcomment|> removed throw new TYPE_2 ( ) ; method throw exception anymore suggestionprivate TYPE_1 METHOD_1 ( ) { <|endcomment|> <START> private TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> logger . trace ( STRING_1 ) ; METHOD_2 ( TYPE_3 . METHOD_3 ( STRING_2 ) ) ; final TYPE_1 VAR_1 = TYPE_1 . METHOD_1 ( ) ; if ( ! VAR_1 . METHOD_4 ( ) && ! VAR_1 . METHOD_5 ( ) && ! VAR_1 . METHOD_6 ( ) ) { logger . warn ( STRING_3 , VAR_1 ) ; } logger . debug ( STRING_4 , VAR_1 ) ; return VAR_1 ; }
<|startcomment|> package - private <|endcomment|> <START> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) <END> { super ( VAR_2 , VAR_3 ) ; }
<|startcomment|> I atomic operation <|endcomment|> public void close ( ) throws IOException { <START> this . VAR_1 = true ; <END> for ( final TYPE_1 listener : this . VAR_2 ) { try { listener . VAR_3 ( this ) ; } catch ( Throwable t ) { logger . debug ( STRING_1 + this , t ) ; } } this . VAR_4 . METHOD_1 ( ) ; }
<|startcomment|> don t catch bare Exception <|endcomment|> public void run ( ) { log . info ( STRING_1 ) ; try { VAR_1 . METHOD_1 ( this ) ; VAR_2 = true ; METHOD_2 ( ) ; } catch ( InterruptedException VAR_3 ) { log . info ( STRING_2 ) ; Thread . VAR_4 ( ) . METHOD_3 ( ) ; <START> } catch ( Exception e ) { <END> log . error ( STRING_3 , e . getMessage ( ) , e ) ; } finally { VAR_2 = false ; VAR_1 . METHOD_4 ( this ) ; } }
<|startcomment|> I feel a factory approach coming : factory _CODE_ ( type ) abstract renaming nice ( ) btw explicit VAR_1 ! : ) <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> TYPE_3 VAR_2 = new TYPE_3 ( ) ; <END> VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( METHOD_5 ( ) ) ) ; VAR_2 . METHOD_6 ( VAR_1 . METHOD_4 ( METHOD_7 ( ) ) ) ; VAR_2 . METHOD_8 ( VAR_1 . METHOD_4 ( METHOD_9 ( ) ) ) ; VAR_2 . METHOD_10 ( VAR_1 . METHOD_4 ( METHOD_11 ( ) ) ) ; return VAR_2 . METHOD_12 ( ) ; }
<|startcomment|> please < operator > null convention <|endcomment|> public static TYPE_1 METHOD_1 ( String VAR_1 , boolean VAR_2 ) { TYPE_1 result = VAR_2 ? null : TYPE_1 . VAR_3 ; try { result = org . VAR_4 . VAR_5 . VAR_6 . TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> if ( null == result && VAR_2 ) { <END> result = TYPE_1 . VAR_3 ; } } catch ( IllegalArgumentException e ) { result = VAR_2 ? TYPE_1 . VAR_3 : null ; } return result ; }
<|startcomment|> callers conditioned METHOD_3 ( ) <|endcomment|> private void METHOD_1 ( final Set < String > VAR_1 , final String VAR_2 ) { final Collection < String > VAR_3 = METHOD_2 ( ) ; <START> if ( METHOD_3 ( ) && ! VAR_3 . equals ( VAR_1 ) ) { <END> VAR_1 . addAll ( VAR_3 ) ; VAR_4 . clear ( ) ; VAR_4 . addAll ( VAR_1 ) ; log . debug ( STRING_1 , VAR_2 , VAR_1 . size ( ) ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; } }
<|startcomment|> a typo ? ( checking VAR_1 ! = null calling method VAR_2 ) <|endcomment|> public void METHOD_1 ( ) throws Exception { super . METHOD_1 ( ) ; <START> if ( VAR_1 != null ) TYPE_1 . METHOD_2 ( VAR_2 . METHOD_3 ( ) ) ; <END> if ( VAR_3 != null ) TYPE_2 . METHOD_4 ( VAR_3 ) ; }
<|startcomment|> a new array iteration ? avoid _CODE_ multi - thread case a synchronized block more adapted <|endcomment|> public void METHOD_1 ( Collection < ? extends TYPE_1 > VAR_1 ) { <START> for ( TYPE_2 listener : TYPE_3 . METHOD_2 ( VAR_2 ) ) { <END> listener . VAR_3 ( ( Collection < TYPE_1 > ) VAR_1 ) ; } }
<|startcomment|> reason return Path ? s new API <|endcomment|> <START> public File METHOD_1 ( ) { <END> return this . VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> please invert condition additional loop breakers code reading worse <|endcomment|> protected void METHOD_1 ( Object VAR_1 ) { for ( int VAR_2 = 0 ; VAR_2 < VAR_3 . length ; VAR_2 ++ ) { Object VAR_4 = VAR_5 . METHOD_2 ( VAR_1 , VAR_3 [ VAR_2 ] ) ; <START> if ( VAR_4 == null ) { <END> continue ; } VAR_6 [ VAR_2 ] . write ( VAR_4 ) ; } }
<|startcomment|> logic correct stop CHAR_2 / / blah \r blah \r\n <|endcomment|> private void METHOD_1 ( boolean VAR_1 ) { int c = METHOD_2 ( ) ; <START> while ( c != CHAR_1 && c != VAR_2 && ( VAR_1 || ( c != CHAR_2 ) ) ) { <END> c = METHOD_2 ( ) ; } if ( c == VAR_2 || ! VAR_1 ) { METHOD_3 ( c ) ; } }
<|startcomment|> privilege Exception calling bl method need throw privilege Exception <|endcomment|> <START> private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , TYPE_7 , TYPE_8 { <END> final TYPE_9 VAR_2 = METHOD_2 ( ) ; final TYPE_1 VAR_3 = VAR_4 . METHOD_3 ( ) . METHOD_4 ( sess , VAR_1 , VAR_2 ) ; return VAR_3 ; }
<|startcomment|> missing translation VAR_3 _CODE_ ( VAR_2 - 1 ) ; allocation needs updated match <|endcomment|> private TYPE_1 METHOD_1 ( int i , long VAR_1 , long VAR_2 ) { TYPE_1 VAR_3 = TYPE_2 . buffer ( 4 + INT_1 ) ; VAR_3 . METHOD_2 ( VAR_1 ) ; <START> VAR_3 . METHOD_2 ( VAR_2 ) ; <END> VAR_3 . METHOD_3 ( i ) ; return VAR_3 ; }
<|startcomment|> METHOD_4 ( ) please apply dao calls class <|endcomment|> private void METHOD_1 ( Guid VAR_1 ) { TYPE_1 VAR_2 = getParameters ( ) . METHOD_2 ( ) ; TYPE_2 VAR_3 = new TYPE_2 ( VAR_2 . getId ( ) , VAR_1 ) ; VAR_3 . METHOD_3 ( TYPE_6 . TYPE_5 ) ; <START> TYPE_3 . getInstance ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_3 ) ; <END> TYPE_4 . METHOD_6 ( VAR_1 , VAR_2 . getId ( ) ) ; }
<|startcomment|> version a enum compare = = <|endcomment|> public double METHOD_1 ( TYPE_1 node , TYPE_2 version ) { <START> TYPE_3 VAR_1 = ( TYPE_8 . TYPE_9 . equals ( version ) ) <END> ? new TYPE_5 ( ) : new TYPE_6 ( ) ; TYPE_7 VAR_2 = ( TYPE_7 ) node . VAR_3 ( VAR_1 , new TYPE_7 ( 1 ) ) ; return ( double ) VAR_2 . getValue ( ) ; }
<|startcomment|> druid code convention METHOD_2 ( element - > VAR_3 getValue ( element ) length ( ) * TYPE_1 VAR_2 ) METHOD_3 ( ) ; <|endcomment|> public long METHOD_1 ( int [ ] key ) { long VAR_1 = ( key . length * Integer . VAR_2 ) ; VAR_1 += Arrays . stream ( key ) . filter ( element - > VAR_3 . getValue ( element ) != null ) <START> . METHOD_2 ( element - > VAR_3 . getValue ( element ) . length ( ) * TYPE_1 . VAR_2 ) . METHOD_3 ( ) ; <END> return VAR_1 ; }
<|startcomment|> nicely done ! consideration : VAR_2 information wrong ( i e actual index size list ) catching throwing a new lose information please change stacktrace message original exception passed : } catch ( TYPE_1 VAR_2 ) { VAR_1 remove ( element ) ; throw VAR_2 ; <|endcomment|> public void add ( int index , T element ) { if ( VAR_1 . add ( element ) ) { try { super . add ( index , element ) ; } catch ( TYPE_1 VAR_2 ) { VAR_1 . remove ( element ) ; <START> throw new TYPE_1 ( ) ; <END> } } }
<|startcomment|> a VAR_1 null <|endcomment|> public String METHOD_1 ( ) { final String VAR_1 = client . VAR_2 ( ) . METHOD_1 ( ) ; <START> if ( VAR_1 == null ) { <END> throw new RuntimeException ( STRING_1 ) ; } return VAR_1 ; }
<|startcomment|> redundant else <|endcomment|> public TYPE_1 METHOD_1 ( ) { String VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . equals ( VAR_2 ) ) { return null ; <START> } else { <END> return ( TYPE_1 ) VAR_3 . METHOD_3 ( VAR_1 ) ; } }
<|startcomment|> VAR_1 unused <|endcomment|> protected void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( ) ; <END> VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; VAR_1 . METHOD_2 ( STRING_3 , new TYPE_2 ( STRING_4 ) . format ( new Date ( ) ) ) ; synchronized ( this ) { VAR_2 . METHOD_3 ( VAR_3 , TYPE_3 . builder ( ) . command ( STRING_5 ) . build ( ) ) ; } }
<|startcomment|> else redundant branch returns conditionally generally prefer write expressions asjavaif ( ) { return ; } return ; <|endcomment|> private static String METHOD_1 ( TYPE_1 VAR_1 , String value ) { if ( METHOD_2 ( VAR_1 . getType ( ) ) ) { return String . format ( STRING_1 , VAR_1 . getName ( ) , value ) ; } <START> else { <END> return String . format ( STRING_2 , VAR_1 . getName ( ) , value ) ; } }
<|startcomment|> warning logged setting queue size reading I mind : <|endcomment|> int METHOD_1 ( ) { <START> log . warn ( STRING_1 ) ; <END> return VAR_1 . get ( ) ; }
<|startcomment|> art : personally I lean a guard statement javaif ( entity = = null ) { return null } <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 entity ) { <START> if ( entity != null ) { <END> Class VAR_1 ; if ( entity . VAR_2 ( ) . equals ( TYPE_5 . TYPE_7 . toString ( ) ) ) { VAR_1 = TYPE_4 . class ; } else { VAR_1 = TYPE_5 . METHOD_2 ( entity . VAR_2 ( ) ) . METHOD_3 ( ) ; } TYPE_6 VAR_3 = TYPE_6 . instance ( ) ; TYPE_1 p = VAR_3 . METHOD_4 ( entity . getId ( ) , VAR_1 ) ; return p ; } return null ; }
<|startcomment|> move VAR_2 ! = null ( add ) <|endcomment|> public static List < String > METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { Iterator < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; List < String > VAR_3 = new ArrayList < String > ( ) ; <START> while ( VAR_2 != null && VAR_2 . hasNext ( ) ) { <END> VAR_3 . add ( VAR_2 . next ( ) ) ; } LOG . debug ( STRING_1 , VAR_3 ) ; return VAR_3 ; }
<|startcomment|> return _CODE_ ? another clause <|endcomment|> private ANNOTATION_1 Map < ANNOTATION_2 String , ANNOTATION_2 TYPE_1 > METHOD_1 ( long start , long VAR_1 , TYPE_2 monitor ) { Collection < ANNOTATION_2 TYPE_3 > VAR_2 = METHOD_2 ( start , VAR_1 ) ; if ( VAR_2 == null ) { <START> return null ; <END> } if ( monitor . VAR_3 ( ) ) { return Collections . VAR_4 ; } return METHOD_3 ( VAR_2 , monitor ) ; }
<|startcomment|> override <|endcomment|> <START> protected void METHOD_1 ( StringBuilder builder ) <END> { builder . append ( this . VAR_1 ) ; }
<|startcomment|> force refreshes <|endcomment|> public void METHOD_1 ( ) { start ( ) ; <START> super . METHOD_1 ( true ) ; <END> }
<|startcomment|> else block removed information saved request URL compare <|endcomment|> private boolean METHOD_1 ( TYPE_1 request , TYPE_2 VAR_1 ) { if ( VAR_1 == null ) { return false ; <START> } else if ( VAR_1 instanceof TYPE_3 ) { <END> TYPE_3 VAR_2 = ( TYPE_3 ) VAR_1 ; return VAR_2 . METHOD_2 ( request , this . VAR_3 ) ; } else { String VAR_4 = TYPE_4 . METHOD_3 ( request ) ; return VAR_1 . METHOD_4 ( ) . equals ( VAR_4 ) ; } }
<|startcomment|> wouldn t more sense add / remove a style class instead hard coding a background color box ? change default background color application white change I a quick search I t find other disabled color application #E5E5E5 color <|endcomment|> public void METHOD_1 ( boolean VAR_1 ) { METHOD_2 ( ) . METHOD_1 ( VAR_1 ) ; <START> if ( VAR_1 ) { <END> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_1 ) ; } else { METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( STRING_2 ) ; } }
<|startcomment|> TYPE_2 - delete <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 != null ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; } <START> VAR_2 = new TYPE_2 ( VAR_1 , this ) ; <END> METHOD_4 ( VAR_1 ) ; }
<|startcomment|> ternary operator drop return intermediate variable <|endcomment|> public String toString ( ) { <START> String VAR_1 = ( TYPE_1 < 0 ) ? STRING_1 : "" ; <END> return String . format ( STRING_2 , VAR_1 , TYPE_3 , TYPE_2 , TYPE_6 , TYPE_4 , TYPE_5 ) ; }
<|startcomment|> assuming another debugging call <|endcomment|> private void METHOD_1 ( final TYPE_1 VAR_1 ) { this . VAR_2 . remove ( VAR_1 ) ; this . VAR_3 . METHOD_2 ( ) ; <START> System . out . println ( STRING_1 + this . VAR_3 . METHOD_3 ( ) ) ; <END> }
<|startcomment|> METHOD_1 METHOD_2 METHOD_2 alias METHOD_1 hmmm created infinite loop ? METHOD_1 - > METHOD_2 - > METHOD_1 ? entire logic incorrect line : TYPE_2 cloned = ( TYPE_2 ) super METHOD_1 ( ) ; cloned VAR_1 ( ) ; return cloned ; <|endcomment|> public Object METHOD_1 ( ) throws TYPE_1 { super . METHOD_1 ( ) ; TYPE_2 ctx = new TYPE_2 ( ) ; ctx . VAR_1 ( this ) ; <START> return this . METHOD_2 ( ) ; <END> }
<|startcomment|> drop lines <|endcomment|> @Override public Response execute ( TYPE_1 request ) throws IOException { TYPE_2 VAR_1 = METHOD_1 ( request ) ; TYPE_3 VAR_2 = execute ( client , VAR_1 ) ; String url = request . VAR_3 ( ) ; <START> if ( this . VAR_4 != null && this . VAR_4 . VAR_5 != null ) { <END> url = this . VAR_4 . VAR_5 . toString ( ) ; } return METHOD_2 ( url , VAR_2 ) ; }
<|startcomment|> I thought wanted practice adrian <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> VAR_1 . METHOD_1 ( ) . METHOD_2 ( true ) ; <END> return VAR_1 . METHOD_1 ( ) ; }
<|startcomment|> I return trait set avoid modifying trait a table <|endcomment|> static TYPE_1 METHOD_1 ( TYPE_2 node ) { <START> if ( node instanceof TYPE_3 ) { <END> return node . VAR_1 ( ) . METHOD_1 ( ) ; } return node . VAR_2 ( ) . METHOD_2 ( TYPE_4 . VAR_4 ) ; }
<|startcomment|> I don t manipulate correlation id I add input validator validating correlation id length <|endcomment|> public void METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null ) { this . VAR_1 = Guid . TYPE_1 ( ) . toString ( ) ; } else if ( VAR_1 . length ( ) <= 100 ) { this . VAR_1 = VAR_1 ; } else { this . VAR_1 = VAR_1 . substring ( 0 , 100 ) ; } <START> } <END>
<|startcomment|> don t assert success cli exits 0 <|endcomment|> public void METHOD_1 ( ) throws IOException , InterruptedException { try ( TYPE_1 file = new TYPE_1 ( ) ) { TYPE_2 . write ( STRING_1 , file . file ( ) , VAR_1 ) ; METHOD_2 ( STRING_2 , file . file ( ) . METHOD_3 ( ) ) ; assertThat ( METHOD_4 ( VAR_2 . METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 ) ; VAR_2 . METHOD_7 ( ) ; } <START> } <END>
<|startcomment|> / Optional < Class < TYPE_1 > > <|endcomment|> <START> static < TYPE_1 extends TYPE_2 < TYPE_1 > > Optional < Class < ? > > METHOD_1 ( Type type ) { <END> return Optional . of ( type ) . map ( TYPE_3 : : METHOD_2 ) . filter ( Class : : METHOD_3 ) . map ( c - > ( Class < TYPE_1 > ) c ) ; }
<|startcomment|> I don t random separator logic <|endcomment|> private String METHOD_1 ( ) { ImmutableList < String > VAR_1 = VAR_2 . METHOD_2 ( ) ; return TYPE_1 . METHOD_3 ( TYPE_2 . of ( STRING_1 , VAR_1 . METHOD_4 ( 0 , Math . VAR_3 ( VAR_1 . size ( ) , VAR_4 ) ) , STRING_2 , ImmutableList . VAR_5 ( VAR_1 ) , <START> STRING_3 , TYPE_3 . METHOD_5 ( ) . METHOD_6 ( ) > FLOAT_1 ? VAR_6 : VAR_7 ) ) ; <END> }
<|startcomment|> shouldn t TYPE_1 getInstance ( ) instead ? s a - op <|endcomment|> private long METHOD_1 ( long VAR_1 ) { TYPE_1 VAR_2 = <START> new TYPE_2 ( ) ; <END> VAR_2 . METHOD_2 ( VAR_1 ) ; VAR_2 . set ( TYPE_1 . VAR_3 , 0 ) ; VAR_2 . set ( TYPE_1 . VAR_4 , 0 ) ; VAR_2 . add ( TYPE_1 . VAR_5 , 1 ) ; return VAR_2 . METHOD_3 ( ) ; }
<|startcomment|> redundant assertion <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { TYPE_2 VAR_1 = db . VAR_2 ( ) ; VAR_1 . METHOD_2 ( STRING_1 ) . execute ( ) ; try { VAR_1 . METHOD_3 ( STRING_2 ) . METHOD_4 ( TYPE_3 . class ) . METHOD_5 ( ) ; METHOD_6 ( STRING_3 ) ; } catch ( IllegalArgumentException e ) { <START> assertThat ( e ) . METHOD_7 ( ) ; <END> } }
<|startcomment|> change modifies semantic meaning <|endcomment|> <START> private static void METHOD_1 ( final TYPE_1 key , final boolean value ) { <END> final TYPE_2 < TYPE_1 , Boolean > cache = TYPE_4 . TYPE_5 . get ( ) ; if ( cache != null ) { cache . put ( key , value ) ; TYPE_4 . TYPE_5 . set ( cache ) ; } }
<|startcomment|> don t need a super METHOD_1 ( ) call <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; <END> }
<|startcomment|> IOException thrown method <|endcomment|> <START> private void METHOD_1 ( ) throws IOException { <END> for ( Map . Entry < String , TYPE_1 > entry : VAR_1 . entrySet ( ) ) { String VAR_2 = entry . getKey ( ) ; TYPE_1 VAR_3 = entry . getValue ( ) ; if ( ! VAR_3 . METHOD_2 ( ) . contains ( VAR_4 ) ) { info ( STRING_1 , VAR_4 , VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_4 ) ; VAR_3 . METHOD_4 ( VAR_4 , TYPE_2 . name , TYPE_2 . build ( ) ) ; } } }
<|startcomment|> reason assigning VAR_1 rest cases instead returning <|endcomment|> private int METHOD_1 ( TYPE_1 result ) { int VAR_1 ; switch ( result ) { case VAR_2 : VAR_1 = R . VAR_3 . VAR_4 ; break ; case VAR_5 : VAR_1 = R . VAR_3 . VAR_6 ; break ; case VAR_7 : VAR_1 = R . VAR_3 . VAR_8 ; break ; default : <START> return R . VAR_3 . VAR_9 ; <END> } return context . VAR_10 ( ) . METHOD_2 ( VAR_1 ) ; }
<|startcomment|> compile error <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return super . VAR_1 ; <END> }
<|startcomment|> I protected <|endcomment|> <START> public static <END> TYPE_1 create ( long start , long VAR_1 , int VAR_2 , String value , ANNOTATION_1 TYPE_2 parent ) { if ( start > VAR_1 ) { throw new IllegalArgumentException ( Messages . TYPE_3 + CHAR_1 + start + CHAR_2 + VAR_1 + CHAR_3 ) ; } return new TYPE_1 ( start , VAR_1 , value , VAR_2 , parent ) ; }
<|startcomment|> done internally TYPE_4 ? other <|endcomment|> private TYPE_1 < Throwable , Throwable > METHOD_1 ( TYPE_2 event ) { return VAR_1 - > { Throwable VAR_2 = METHOD_2 ( VAR_1 ) ; TYPE_2 VAR_3 = event ; if ( VAR_1 instanceof TYPE_3 ) { VAR_3 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) ; } return new TYPE_3 ( VAR_3 , new TYPE_4 ( METHOD_4 ( VAR_4 , VAR_2 . getMessage ( ) ) , <START> null , VAR_5 ) , <END> VAR_5 ) ; } ; }
<|startcomment|> please move line METHOD_2 block javaif ( METHOD_2 ( ) ) { TYPE_4 METHOD_6 ( ) ; _CODE_ don t change behavior kind discuss put <|endcomment|> private void METHOD_1 ( final TYPE_1 context ) { if ( METHOD_2 ( ) ) { if ( ! ( context instanceof TYPE_2 ) ) { context . VAR_1 ( ) ; } else { TYPE_3 . METHOD_3 ( this ) . METHOD_4 ( ) . METHOD_5 ( VAR_2 , false ) . commit ( ) ; } } <START> TYPE_4 . METHOD_6 ( ) ; <END> }
<|startcomment|> loooooong line <|endcomment|> <START> public boolean METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , String VAR_5 , String VAR_6 ) { <END> return TYPE_1 . METHOD_2 ( VAR_1 . toString ( ) , VAR_2 . toString ( ) , VAR_3 . toString ( ) , VAR_4 . toString ( ) , VAR_5 . toString ( ) , VAR_6 . toString ( ) ) ; }
<|startcomment|> index field read a local variable loop <|endcomment|> public Integer METHOD_1 ( Integer VAR_1 , TYPE_1 < ? super T > VAR_2 ) { int i = VAR_1 ; <START> while ( i < index . get ( ) ) { <END> METHOD_2 ( VAR_2 , i ) ; i ++ ; } return i ; }
<|startcomment|> suggestionreturn getInstance ( ) ; <|endcomment|> public String METHOD_1 ( ) { <START> return VAR_1 + STRING_1 + VAR_2 + STRING_2 ; <END> }
<|startcomment|> fill more methods bodies copying ideas pull request classes i pointed ticket description <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> return null ; }
<|startcomment|> * Arrays VAR_5 ( ) returns a negative necessarily - 1 original code line 453 fail d check other callers * IIRC operation called * * frequently I absolutely want avoid allocating a dummy object ; ll put additional pressure GC <|endcomment|> protected int METHOD_1 ( String VAR_1 ) { TYPE_1 [ ] VAR_2 = this . VAR_3 ; TYPE_2 VAR_4 = new TYPE_2 ( VAR_1 ) ; <START> return Arrays . VAR_5 ( VAR_2 , VAR_4 , ( VAR_6 , VAR_7 ) - > VAR_6 . name . METHOD_2 ( VAR_7 . name ) ) ; <END> }
<|startcomment|> need wait METHOD_4 <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( STRING_1 ) . METHOD_4 ( INT_1 ) ; <START> METHOD_5 ( ) ; <END> Assert . assertTrue ( METHOD_3 ( STRING_2 ) . exists ( ) ) ; }
<|startcomment|> SDK t initialized internet VAR_4 don t need check <|endcomment|> @Override public void METHOD_1 ( Context context , TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IllegalStateException { <START> if ( ! METHOD_2 ( context , TYPE_4 . VAR_4 . VAR_5 ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } TYPE_3 . METHOD_3 ( context , VAR_1 . getString ( STRING_2 ) ) ; }
<|startcomment|> nitpick : complaining unnecessary VAR_3 variable 😿 <|endcomment|> public View METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_2 container , TYPE_3 VAR_2 ) { <START> TYPE_2 VAR_3 = METHOD_2 ( VAR_1 , container , VAR_2 ) ; return VAR_3 ; <END> }
<|startcomment|> formatting ( TYPE_2 VAR_1 ) ( TYPE_2 VAR_1 ) <|endcomment|> <START> public static Set < TYPE_1 > METHOD_1 ( TYPE_2 ... VAR_1 ) { <END> Set < TYPE_1 > result = new HashSet < > ( ) ; for ( TYPE_2 VAR_2 : VAR_1 ) { result . addAll ( VAR_2 . METHOD_2 ( ) ) ; } return result ; }
<|startcomment|> return a host UEFI capability satisfies return cond <|endcomment|> private Long METHOD_1 ( List < Long > VAR_1 , String VAR_2 ) { int VAR_3 = 0 ; for ( Long host : VAR_1 ) { Map < String , String > VAR_4 = VAR_5 . METHOD_2 ( host ) ; if ( VAR_4 . containsKey ( TYPE_1 . VAR_7 ) ) { if ( VAR_4 . get ( TYPE_1 . VAR_7 ) . equalsIgnoreCase ( STRING_1 ) ) { <START> VAR_3 ++ ; <END> } } } return VAR_3 > 0 ? new Long ( 1 ) : new Long ( 0 ) ; }
<|startcomment|> another access modification don t need ( _CODE_ ( ) ? ) <|endcomment|> <START> void METHOD_1 ( TYPE_1 VAR_1 ) { <END> this . VAR_2 = VAR_1 ; }
<|startcomment|> I suggest check count 0 return null ( aggregate constraint simply match ) case <|endcomment|> public Double METHOD_1 ( TYPE_1 < Double > result ) { <START> return ( result . value ) / result . count ; <END> }
<|startcomment|> assert keyword ? functional ? suggest remove switch assertNotNull ( ) <|endcomment|> public static void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = TYPE_2 . class . METHOD_2 ( ) ; <START> assert VAR_1 <END> != null ; File VAR_2 = new File ( VAR_3 . METHOD_3 ( ) , STRING_1 ) ; try ( TYPE_3 in = VAR_1 . METHOD_4 ( STRING_1 ) ; TYPE_4 out = new TYPE_5 ( VAR_2 ) ) { TYPE_6 . METHOD_5 ( in , out ) ; } VAR_4 = new TYPE_7 ( VAR_2 . METHOD_6 ( ) , VAR_1 ) ; }
<|startcomment|> I 1st check needed method doesn t TYPE_4 observer called <|endcomment|> private boolean METHOD_1 ( TYPE_1 [ ] parameters , TYPE_2 VAR_1 , TYPE_3 method ) { <START> if ( method . VAR_2 ( TYPE_4 . class ) && method . VAR_3 ( ) . METHOD_2 ( TYPE_4 . class ) . METHOD_3 ( ) ) { <END> return true ; } for ( TYPE_1 VAR_4 : parameters ) { if ( VAR_1 . get ( VAR_4 . getName ( ) ) != null ) return false ; } return true ; }
<|startcomment|> check VAR_3 null <|endcomment|> public String getValue ( TYPE_1 task ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_1 ( task . VAR_2 ( ) ) ; TYPE_4 VAR_3 = TYPE_5 . METHOD_2 ( task ) ; <START> TYPE_6 url = VAR_1 . METHOD_3 ( VAR_3 , task ) ; <END> if ( url == null ) { return task . VAR_4 ( ) ; } return url . toString ( ) ; }
<|startcomment|> call methods <|endcomment|> protected void METHOD_1 ( ) { <START> this . VAR_1 = TYPE_1 . METHOD_2 ( this . METHOD_3 ( ) ) ; <END> if ( this . VAR_2 == null ) { this . VAR_2 = new TYPE_2 ( this . VAR_3 , this . VAR_4 ) ; } this . VAR_5 = true ; }
<|startcomment|> missing a close bracket ( ) ) ; <|endcomment|> public String read ( String key ) { String data = VAR_1 . read ( key ) ; <START> return ( data == null ) ? null : VAR_2 ( VAR_3 . VAR_4 ( VAR_5 , VAR_6 ( data ) ) ; <END> }
<|startcomment|> please break line <|endcomment|> protected void METHOD_1 ( ) { try { TYPE_1 VAR_1 = <START> METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) , TYPE_2 . METHOD_5 ( getParameters ( ) . METHOD_6 ( ) ) ) ; <END> METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ; } catch ( IOException e ) { log . error ( STRING_1 , e ) ; return ; } }
<|startcomment|> cached TYPE_2 ( ) cache 0 - 127 : ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { final TYPE_1 row = VAR_1 . METHOD_1 ( ) ; if ( row . size ( ) == 1 ) { if ( VAR_2 == 0 ) { return row ; } else { return new TYPE_2 ( row . get ( 0 ) + VAR_2 ) ; } } else { <START> return new TYPE_2 ( 0 ) ; <END> } }
<|startcomment|> debugging debug logs instead <|endcomment|> public void METHOD_1 ( TYPE_1 ctx ) throws Exception { super . METHOD_1 ( ctx ) ; LOG . info ( STRING_1 , ctx ) ; <START> } <END>
<|startcomment|> shouldn t line 134 ? replacing getClass ( ) check instead obj = = null check ? user object ? I return false null return false compare TYPE_1 _CODE_ wanted comparable user object continue params comparison compare user candidate _CODE_ I implementation equivalent TYPE_1 user objects <|endcomment|> public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } <START> if ( ! ( obj instanceof TYPE_1 ) ) { <END> return false ; } if ( ! getClass ( ) . equals ( obj . getClass ( ) ) ) { return false ; } TYPE_1 VAR_1 = ( TYPE_1 ) obj ; return getId ( ) == VAR_1 . getId ( ) ; }
<|startcomment|> style - : return Collections VAR_4 avoid assignment VAR_1 <|endcomment|> public List < TYPE_1 > METHOD_1 ( final TYPE_4 . TYPE_5 id ) { List < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; VAR_1 . addAll ( METHOD_2 ( id ) ) ; VAR_1 . addAll ( METHOD_3 ( id ) ) ; Collections . VAR_2 ( VAR_1 , TYPE_1 . VAR_3 ) ; <START> VAR_1 = Collections . VAR_4 ( TYPE_3 . METHOD_4 ( VAR_1 ) ) ; <END> return VAR_1 ; }
<|startcomment|> needed <|endcomment|> public void METHOD_1 ( final String VAR_1 , final String value ) { VAR_2 . METHOD_2 ( VAR_1 , ( key , values ) - > { values . forEach ( i - > { <START> if ( ( i . getValue ( ) . equals ( value ) ) && i . VAR_3 ( ) == false ) { <END> i . VAR_4 ( true ) ; } } ) ; return values ; } ) ; }
<|startcomment|> instead remove synchronized setter variable volatile <|endcomment|> <START> public synchronized TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> int type null want Integer type null other places comparing 0 a wrong written condition <|endcomment|> public void METHOD_1 ( int id ) { try { <START> if ( ! TYPE_1 . equals ( id , null ) ) { <END> METHOD_2 ( this . VAR_1 . METHOD_3 ( ) . METHOD_4 ( id ) ) ; } } catch ( TYPE_2 e ) { TYPE_3 . METHOD_5 ( STRING_1 + id + STRING_2 , e . getMessage ( ) ) ; } }
<|startcomment|> a bit surprising TYPE_1 TYPE_2 <|endcomment|> private void METHOD_1 ( <START> String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> try ( TYPE_1 VAR_4 = VAR_3 . METHOD_2 ( ) ) { String VAR_5 = VAR_3 . METHOD_3 ( ) ; LOG . debug ( STRING_1 , VAR_5 ) ; VAR_6 . METHOD_4 ( VAR_1 , VAR_1 , VAR_2 , VAR_5 , VAR_4 ) ; } catch ( IOException e ) { LOG . error ( STRING_2 , e ) ; } }
<|startcomment|> please a logging framework instead System messages preferably slf4j <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { synchronized ( TYPE_2 . class ) { if ( VAR_1 == null ) { VAR_2 = TYPE_3 . get ( METHOD_2 ( ) . getProperty ( VAR_3 ) ) ; <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> try { VAR_1 = METHOD_3 ( ) ; } catch ( final IOException | TYPE_4 e ) { throw new TYPE_1 ( e ) ; } } VAR_4 ++ ; } }
<|startcomment|> don t need impala hdi35 s cloudera <|endcomment|> protected void METHOD_1 ( TYPE_1 configuration ) throws TYPE_2 { <START> String VAR_1 = <END> configuration . getProperty ( STRING_1 , STRING_2 ) ; TYPE_3 . put ( STRING_3 , VAR_1 ) ; }
<|startcomment|> static <|endcomment|> <START> void METHOD_1 ( TYPE_1 VAR_1 , int VAR_2 ) <END> throws IOException { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( TYPE_1 . VAR_4 , null ) ; TYPE_3 VAR_5 = new TYPE_3 ( ) ; for ( int i = 0 ; i < VAR_2 ; i ++ ) { METHOD_4 ( VAR_1 , 10 ) ; VAR_3 . METHOD_3 ( TYPE_1 . VAR_4 , null ) ; } METHOD_4 ( VAR_1 , 10 ) ; }
<|startcomment|> kill entire compat package - please don t add new dependencies common - lang s StringUtils isEmpty ( VAR_1 ) <|endcomment|> public static ArrayList < Guid > METHOD_1 ( String VAR_1 ) { <START> if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { <END> return new ArrayList < Guid > ( ) ; } return METHOD_3 ( Arrays . asList ( VAR_1 . split ( VAR_2 ) ) ) ; }
<|startcomment|> need _CODE_ VAR_4 <|endcomment|> public TYPE_1 ( Context context ) { VAR_2 = context ; <START> VAR_3 = STRING_1 ; <END> VAR_4 = TYPE_2 . VAR_6 ; VAR_7 . put ( VAR_3 , VAR_4 ) ; }
<|startcomment|> need intermediate VAR_2 variable <|endcomment|> public static TYPE_1 METHOD_1 ( Object input , String content ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( content ) ; if ( input instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) input ; <START> VAR_1 . METHOD_3 ( VAR_2 ) ; <END> } else if ( input instanceof TYPE_3 ) { VAR_1 . METHOD_4 ( ( TYPE_3 ) input ) ; } else { throw new IllegalArgumentException ( STRING_1 + input ) ; } return VAR_1 ; }
<|startcomment|> return VAR_2 ( VAR_1 ) rest <|endcomment|> private TYPE_1 < String , TYPE_2 > METHOD_1 ( List < TYPE_3 > VAR_1 ) { TYPE_1 < String , TYPE_2 > VAR_2 ; try { <START> VAR_2 = METHOD_2 ( VAR_1 ) ; <END> } catch ( TYPE_4 e ) { throw TYPE_5 . METHOD_3 ( e ) ; } return VAR_2 ; }
<|startcomment|> nice a METHOD_1 method category change : return METHOD_2 ( VAR_1 ) METHOD_1 ( ) <|endcomment|> public static boolean METHOD_1 ( int VAR_1 ) { <START> switch ( METHOD_2 ( VAR_1 ) ) { <END> case VAR_2 : case VAR_3 : return true ; default : return false ; } }
<|startcomment|> unwanted final <|endcomment|> public List < String > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { METHOD_3 ( ) ; <START> for ( final String VAR_1 : VAR_2 . METHOD_1 ( ) ) { <END> super . METHOD_4 ( VAR_1 ) ; } } return super . METHOD_1 ( ) ; }
<|startcomment|> cut && <|endcomment|> private boolean METHOD_1 ( TYPE_1 event ) { String VAR_1 = event . getType ( ) . getName ( ) ; String VAR_2 = VAR_3 ; if ( VAR_1 . equals ( VAR_2 ) ) { return true ; } <START> if ( ( VAR_2 . METHOD_2 ( TYPE_2 . VAR_5 ) && VAR_1 . startsWith ( VAR_2 . METHOD_3 ( TYPE_2 . VAR_5 , TYPE_2 . VAR_6 ) ) ) ) { <END> return true ; } return false ; }
<|startcomment|> derive prefs _CODE_ ( ) require client pass a default protocol I I prefer avoid complicating nice simple model type <|endcomment|> ANNOTATION_1 public String server ( ) { if ( server . startsWith ( STRING_1 ) ) { server = <START> STRING_2 + <END> server ; } return server ; }
<|startcomment|> I view view stupid VAR_1 variable VAR_10 component VAR_1 functionality tested unit test <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; if ( ! VAR_1 . METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( true ) ; } else { VAR_2 . METHOD_4 ( VAR_3 . format ( TYPE_3 . TYPE_4 , VAR_6 . METHOD_5 ( ) ) ) ; } VAR_7 . METHOD_4 ( VAR_6 . METHOD_6 ( ) ) ; VAR_8 . METHOD_7 ( STRING_1 , VAR_3 . METHOD_8 ( TYPE_3 . TYPE_2 ) ) ; <START> VAR_10 = new HashMap < > ( ) ; <END> }
<|startcomment|> equals ( ) instead METHOD_3 <|endcomment|> private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 , String VAR_3 ) { for ( TYPE_1 VAR_4 : VAR_2 ) { <START> if ( StringUtils . VAR_5 ( VAR_4 . METHOD_2 ( ) ) && StringUtils . VAR_5 ( VAR_3 ) && VAR_4 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) == 0 ) { <END> VAR_1 . add ( VAR_4 ) ; VAR_2 . remove ( VAR_4 ) ; return VAR_4 ; } } return null ; }
<|startcomment|> pls replace withstrings ! = null && VAR_1 isEmpty ( ) <|endcomment|> public static ArrayList < Guid > METHOD_1 ( List < String > VAR_1 ) { ArrayList < Guid > VAR_2 = new ArrayList < Guid > ( ) ; <START> if ( TYPE_1 . isEmpty ( VAR_1 ) ) { <END> for ( String VAR_3 : VAR_1 ) { VAR_2 . add ( Guid . VAR_4 ( VAR_3 ) ) ; } } return VAR_2 ; }
<|startcomment|> iterator assertion e g : assertThat ( Arrays asList ( VAR_1 ) iterator ( ) ) hasNext ( ) ; <|endcomment|> public void METHOD_1 ( ) { <START> assertThat ( Arrays . asList ( VAR_1 ) . iterator ( ) ) . METHOD_2 ( ) . contains ( VAR_1 [ 0 ] ) ; <END> }
<|startcomment|> I dont / catch necessary log message don t move message _CODE_ <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws Exception { TYPE_1 VAR_2 ; try { VAR_2 = VAR_1 . METHOD_2 ( VAR_3 ) ; } catch ( Exception e ) { log . error ( STRING_1 + VAR_1 . METHOD_3 ( ) , e ) ; <START> throw e ; <END> } return VAR_2 ; }
<|startcomment|> result call unused I don t <|endcomment|> public TYPE_1 < TYPE_2 < ? > > METHOD_1 ( TYPE_3 query ) { <START> query . VAR_1 ( METHOD_2 ( query ) ) ; <END> return VAR_2 . METHOD_1 ( query ) ; }
<|startcomment|> isn t a debug statement more info trace <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) throws TYPE_2 { if ( TYPE_3 . METHOD_2 ( VAR_2 ) ) { if ( VAR_1 . METHOD_3 ( ) == null ) { <START> LOG . debug ( STRING_1 ) ; <END> throw new TYPE_2 ( TYPE_4 . VAR_4 , STRING_2 ) ; } if ( ! VAR_1 . METHOD_4 ( ) ) { LOG . debug ( STRING_3 ) ; throw new TYPE_2 ( TYPE_4 . VAR_4 , STRING_4 ) ; } } }
<|startcomment|> remove String format <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( String . format ( STRING_1 , VAR_1 , <END> TYPE_1 . VAR_3 ) ) ; METHOD_3 ( ) . METHOD_4 ( STRING_2 , VAR_1 ) . METHOD_5 ( ) . METHOD_6 ( STRING_3 ) . METHOD_7 ( STRING_4 ) . build ( ) . run ( ) ; }
<|startcomment|> remove <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> this . VAR_1 = null ; <END> this . VAR_2 . clear ( ) ; this . VAR_3 . clear ( ) ; }
<|startcomment|> I d formatting / mark controllers put VAR_3 model attribute _CODE_ jsp <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 model , TYPE_3 request ) { TYPE_4 VAR_2 = METHOD_2 ( VAR_1 , model , request ) ; String VAR_3 = METHOD_3 ( request ) ; model . VAR_4 ( STRING_1 , STRING_2 ) ; <START> model . VAR_4 ( STRING_3 , STRING_4 <END> + VAR_3 + STRING_5 ) ; return STRING_2 ; }
<|startcomment|> I prefer leave package - private avoid a synthetic accessor <|endcomment|> <START> private TYPE_2 ( ANNOTATION_1 Set < TYPE_1 > VAR_2 , int VAR_3 , <END> ANNOTATION_1 Set < TYPE_1 > VAR_4 , long VAR_5 , ANNOTATION_1 Set < String > VAR_6 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; }
<|startcomment|> I d inline variable : return new TYPE_1 ( TYPE_3 METHOD_1 ( input ) ) ; <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 input ) { <START> TYPE_3 VAR_1 = TYPE_3 . METHOD_1 ( input ) ; <END> return new TYPE_1 ( VAR_1 ) ; }
<|startcomment|> isn t anti - pattern move a deprecated method general <|endcomment|> private void METHOD_1 ( File VAR_1 ) { if ( VAR_1 != null ) { try { TYPE_1 . METHOD_2 ( VAR_1 ) ; } catch ( IOException e ) { <START> TYPE_2 . METHOD_3 ( e ) ; <END> } } }
<|startcomment|> delete line call super METHOD_1 ( VAR_2 ) ; required assertion <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , Object ... args ) { String VAR_2 = String . format ( VAR_1 , args ) ; <START> this . VAR_3 . METHOD_2 ( info , VAR_4 , VAR_2 ) ; <END> return super . METHOD_1 ( VAR_2 ) ; }
<|startcomment|> inlined i <|endcomment|> public String METHOD_1 ( ) { if ( STRING_1 . equals ( METHOD_2 ( ) . METHOD_3 ( ) ) ) { return METHOD_2 ( ) . METHOD_1 ( ) ; } <START> Optional < String > VAR_1 = Optional . of ( METHOD_2 ( ) . METHOD_4 ( STRING_2 ) ) ; <END> return VAR_1 . METHOD_5 ( "" ) ; }
<|startcomment|> shouldn t need cast double <|endcomment|> public double METHOD_1 ( ) { <START> return ( double ) VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> please synchronize <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 , float VAR_2 ) { <END> VAR_1 . METHOD_2 ( VAR_3 ) ; if ( VAR_4 == FLOAT_1 ) { super . METHOD_3 ( false ) ; } else { super . METHOD_3 ( true ) ; } if ( VAR_5 instanceof TYPE_2 ) { VAR_5 . METHOD_1 ( VAR_1 , VAR_4 ) ; } if ( METHOD_4 ( ) && this . METHOD_5 ( ) != null ) { super . METHOD_1 ( VAR_1 , this . VAR_4 ) ; } VAR_1 . METHOD_2 ( null ) ; }
<|startcomment|> isn t redundant TYPE_2 METHOD_2 ( ) knowing _CODE_ _CODE_ _CODE_ <|endcomment|> protected boolean METHOD_1 ( TYPE_1 TYPE_2 ) { if ( TYPE_2 . METHOD_2 ( ) || TYPE_2 . METHOD_3 ( VAR_1 ) ) { return true ; } TYPE_3 VAR_2 = TYPE_4 . METHOD_4 ( TYPE_3 . class ) ; List < String > VAR_3 = VAR_2 . METHOD_5 ( ) ; <START> return VAR_3 . stream ( ) . METHOD_6 ( TYPE_2 : : METHOD_3 ) ; <END> }
<|startcomment|> minor : required <|endcomment|> void METHOD_1 ( ) { <START> this . VAR_1 = true ; <END> this . VAR_2 = true ; }
<|startcomment|> work controlled models <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . add ( VAR_1 ) ; <END> }
<|startcomment|> done <|endcomment|> public < T > TYPE_1 add ( TYPE_2 type , T VAR_1 , T VAR_2 , boolean VAR_3 ) { String VAR_4 = VAR_1 != null ? VAR_1 . toString ( ) : STRING_1 ; <START> String VAR_5 = VAR_2 != null ? VAR_2 . toString ( ) : STRING_1 ; <END> VAR_6 . add ( new TYPE_3 ( type , VAR_4 , VAR_5 , VAR_3 ) ) ; return this ; }
<|startcomment|> case table null string formed incorrectly - table = appended table ! = null <|endcomment|> public String toString ( ) { StringBuilder sb = new StringBuilder ( STRING_1 ) ; <START> if ( table != null ) { <END> sb . append ( table . getPath ( ) ) ; } if ( reader != null ) { sb . append ( STRING_2 ) . append ( TYPE_1 . METHOD_1 ( reader . getId ( ) ) ) ; } sb . append ( STRING_3 ) . append ( reader ) . append ( CHAR_1 ) ; return sb . toString ( ) ; }
<|startcomment|> import VAR_4 VAR_6 VAR_8 <|endcomment|> private static TYPE_1 METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> TYPE_1 . Builder builder = TYPE_1 . METHOD_2 ( new TYPE_2 ( Type . TYPE_4 . VAR_4 , TYPE_2 . TYPE_5 . VAR_6 , STRING_1 , TYPE_3 . VAR_8 ) ) ; <END> builder . VAR_9 ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( VAR_2 . METHOD_3 ( ) ) . METHOD_5 ( 0 ) ; return builder . build ( ) ; }
<|startcomment|> belong _CODE_ ? other _CODE_ more a POJO type class methods pulled internal helper class <|endcomment|> <START> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , ANNOTATION_1 String VAR_2 ) { <END> try { if ( TYPE_3 . METHOD_2 ( VAR_2 ) ) { VAR_2 = TYPE_1 . METHOD_3 ( VAR_1 ) ; } return new TYPE_1 ( VAR_2 ) ; } catch ( Exception e ) { logger . error ( STRING_1 , VAR_2 , e ) ; throw e ; } }
<|startcomment|> code : channel close ( ) ; <|endcomment|> public void METHOD_1 ( TYPE_1 channel ) throws IOException { <START> this . channel = channel ; <END> }
<|startcomment|> close calling super METHOD_1 <|endcomment|> public void METHOD_1 ( TYPE_1 context ) throws InterruptedException { <START> super . METHOD_1 ( context ) ; <END> VAR_1 . values ( ) . forEach ( TYPE_2 : : close ) ; }
<|startcomment|> list exceptions bring test ? t replace throws Exception <|endcomment|> void METHOD_1 ( ) <START> throws TYPE_1 , TYPE_2 , TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , <END> TYPE_7 { byte [ ] VAR_1 = STRING_1 . METHOD_2 ( STRING_2 ) ; VAR_2 . METHOD_3 ( VAR_1 ) ; TYPE_8 VAR_3 = new TYPE_8 ( VAR_1 ) ; }
<|startcomment|> I m pretty removing change line fix test failure problem I don t a subdeployment attachment case a subdeployment a management VAR_1 getName ( ) A user t assign a management a subdeployment s internal part top level deployment independently added server config <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) == null ) { return TYPE_1 . METHOD_3 ( VAR_2 , VAR_1 . METHOD_4 ( TYPE_3 . VAR_4 ) ) ; } else { <START> return METHOD_1 ( VAR_1 . METHOD_2 ( ) ) . append ( VAR_5 , VAR_1 . METHOD_4 ( TYPE_3 . VAR_4 ) ) ; <END> } }
<|startcomment|> more meaningless access changes <|endcomment|> <START> void METHOD_1 ( String id , TYPE_2 . TYPE_3 VAR_1 ) { <END> VAR_2 . put ( id , VAR_1 ) ; }
<|startcomment|> I call METHOD_1 mode ( METHOD_1 a - op wasn t started ) implement other modes don t update piece code <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( true , false ) ) { METHOD_3 ( ) ; VAR_2 . METHOD_1 ( ) ; } <START> if ( config . VAR_3 ( ) == TYPE_1 . VAR_5 ) { <END> VAR_6 . METHOD_1 ( ) ; } }
<|startcomment|> call update update apply change ignore <|endcomment|> public static synchronized void METHOD_1 ( int VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = new TYPE_1 ( VAR_1 ) ; } else if ( VAR_2 . METHOD_2 ( ) != VAR_1 ) { <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> } }
<|startcomment|> t return <|endcomment|> public String toString ( ) { <START> return String . valueOf ( value ) ; <END> }
<|startcomment|> change log <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { try { return Context . VAR_1 ( ) . METHOD_2 ( "" ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } return Collections . VAR_2 ( ) ; }
<|startcomment|> _CODE_ certificate class sending / information View <|endcomment|> public String METHOD_1 ( ) { <START> VAR_1 = StringUtils . isEmpty ( VAR_2 . METHOD_2 ( ) . getName ( ) ) ? VAR_3 <END> : VAR_2 . METHOD_2 ( ) . getName ( ) ; return VAR_1 ; }
<|startcomment|> I able constructor ? need chain constructors <|endcomment|> <START> TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , int VAR_4 , <END> TYPE_3 VAR_5 , int VAR_6 ) { super ( VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; }
<|startcomment|> handled item VAR_2 ( ) <|endcomment|> public String METHOD_1 ( final Object element ) { TYPE_1 item = ( TYPE_1 ) element ; <START> String VAR_1 = item . VAR_2 ( ) ; if ( VAR_1 == null || VAR_1 . trim ( ) . length ( ) == 0 ) { VAR_1 = item . VAR_3 ( ) . getName ( ) ; } <END> return VAR_1 ; }
<|startcomment|> please recheck condition VAR_1 = true log ( failed ) block wrong <|endcomment|> public boolean METHOD_1 ( ) { final boolean [ ] VAR_1 = { false } ; TYPE_1 . METHOD_2 ( new TYPE_2 ( ) { @Override public void run ( ) { if ( ! VAR_2 . METHOD_3 ( file . VAR_3 ( ) , false ) ) { TYPE_3 . VAR_5 . debug ( STRING_1 , STRING_2 + file ) ; <START> VAR_1 [ 0 ] = true ; <END> } } } ) ; return VAR_1 [ 0 ] ; }
<|startcomment|> isn t necessary new TYPE_1 ( file ) create file doesn t exist <|endcomment|> private void METHOD_1 ( File VAR_1 , String name , String content ) throws IOException { File file = new File ( VAR_1 , name ) ; <START> file . VAR_2 ( ) ; <END> TYPE_1 VAR_3 = null ; try { VAR_3 = new TYPE_1 ( file ) ; VAR_3 . write ( content . VAR_4 ( STRING_1 ) ) ; } finally { if ( VAR_3 != null ) VAR_3 . close ( ) ; } }
<|startcomment|> VAR_9 grouping node defined nt : unstructured cnd arg ( tko : servers type ) throws exception create attempted changing arg null create issue <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { TYPE_4 . METHOD_2 ( VAR_1 , STRING_1 ) ; TYPE_4 . METHOD_3 ( ( VAR_1 . METHOD_4 ( ) == org . VAR_2 . VAR_3 . VAR_4 . TYPE_5 . TYPE_2 . TYPE_6 . VAR_8 ) , STRING_2 ) ; METHOD_5 ( VAR_1 ) ; <START> return create ( VAR_1 , VAR_9 , TYPE_7 . VAR_11 ) ; <END> }
<|startcomment|> longer ! rip field <|endcomment|> public TYPE_5 ( TYPE_1 < T > VAR_2 , TYPE_2 < T > filter , List < TYPE_3 < T > > VAR_3 ) { this . VAR_2 = VAR_2 ; this . filter = filter ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = TYPE_4 . create ( ) ; <END> }
<|startcomment|> condition : ( ! METHOD_1 ( ) ) <|endcomment|> public TYPE_1 add ( int VAR_1 , int VAR_2 , int VAR_3 , int VAR_4 , String offset , TYPE_2 VAR_5 ) { if ( METHOD_1 ( ) ) { <START> VAR_4 = 0 ; <END> } return add ( VAR_5 , VAR_1 , VAR_2 , VAR_3 , VAR_4 , offset , INT_1 , 1 , 1 ) ; }
<|startcomment|> mentioned removing need VAR_2 parameter checking type default ? please <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 < > ( Integer . VAR_2 , VAR_3 , <END> INT_1 , new TYPE_2 < > ( 0 , 100 , false , false ) ) ; VAR_4 = - 1 ; VAR_1 . METHOD_2 ( VAR_5 - > VAR_4 = ( int ) VAR_5 . METHOD_3 ( ) ) ; }
<|startcomment|> instead METHOD_1 ( TYPE_1 METHOD_1 ( Context ( enriched others future simply a _CODE_ pass METHOD_1 _CODE_ <|endcomment|> <START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . METHOD_2 ( ) . contains ( STRING_1 ) ) return ; METHOD_3 ( ) ; METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; METHOD_4 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_4 ( VAR_1 . METHOD_7 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_5 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_6 ( ) ) ; METHOD_1 ( VAR_1 . METHOD_7 ( ) ) ; }
<|startcomment|> _CODE_ ( ) overridden toString ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , Class < ? > type , Type VAR_2 , TYPE_2 [ ] VAR_3 , TYPE_3 VAR_4 , TYPE_4 < String , Object > VAR_5 , TYPE_5 VAR_6 ) throws IOException , TYPE_6 { <START> VAR_6 . write ( VAR_1 . toString ( ) . METHOD_2 ( ) ) ; <END> }
<|startcomment|> I d move super METHOD_1 ( ) safety _CODE_ line <|endcomment|> public void METHOD_1 ( TYPE_1 context ) throws Exception { METHOD_2 ( ) ; VAR_1 = null ; super . METHOD_1 ( context ) ; VAR_2 = null ; <START> if ( VAR_3 != null ) { <END> TYPE_2 . METHOD_3 ( ) . METHOD_4 ( VAR_3 , TYPE_3 . class ) ; } }
<|startcomment|> s unsafe store lists ( reference modify list ) d worth making VAR_2 final method a clear ( ) shallow - copy list contents <|endcomment|> public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> }
<|startcomment|> a getInt variant <|endcomment|> public static TYPE_1 METHOD_1 ( byte [ ] VAR_1 ) throws TYPE_2 { final TYPE_3 obj = new TYPE_3 ( new String ( VAR_1 , TYPE_4 . VAR_3 ) ) ; <START> return new TYPE_1 ( obj . getString ( VAR_4 ) , obj . getString ( VAR_5 ) , ( int ) obj . VAR_6 ( VAR_7 ) ) ; <END> }
<|startcomment|> otherway <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( ! METHOD_2 ( ) ) { VAR_2 . VAR_3 . METHOD_3 ( ) ; throw new TYPE_2 ( STRING_1 , TYPE_5 . TYPE_4 ) ; } else { VAR_6 . add ( VAR_1 ) ; <START> TYPE_3 . METHOD_4 ( VAR_1 ) ; <END> } }
<|startcomment|> need assign a temporary variable <|endcomment|> private String METHOD_1 ( final TYPE_1 TYPE_1 ) { <START> final StringBuilder sb = new StringBuilder ( ) <END> . append ( TYPE_1 . METHOD_2 ( ) ) . append ( TYPE_1 . METHOD_3 ( ) ? STRING_1 : STRING_2 ) ; return sb . toString ( ) ; }
<|startcomment|> zeer matig geschreven methode maar bon <|endcomment|> <START> public void execute ( ) { <END> if ( ! VAR_1 ) { if ( VAR_2 ) VAR_3 . METHOD_1 ( ) ; return ; } VAR_3 . METHOD_2 ( 3 + ( VAR_2 ? 1 : 0 ) ) ; }
<|startcomment|> [ minor ] I return ( i e ) jclouds <|endcomment|> public String getName ( ) { <START> return this . name ; <END> }
<|startcomment|> call ( ) s clunky <|endcomment|> public TYPE_2 ( ) { VAR_2 = TYPE_1 . VAR_4 ; <START> VAR_5 = false ; <END> }
<|startcomment|> method previous line <|endcomment|> public void METHOD_1 ( ) throws IOException { if ( VAR_1 ) { VAR_2 . METHOD_2 ( IOException . VAR_3 ) ; VAR_2 . METHOD_3 ( STRING_1 ) ; <START> TYPE_1 . METHOD_4 ( VAR_2 ) ; <END> } TYPE_2 builder = METHOD_5 ( ) ; String [ ] args = builder . build ( ) ; METHOD_6 ( args ) ; if ( ! VAR_1 ) { METHOD_7 ( ) ; } }
<|startcomment|> more : put method method METHOD_1 doesn t METHOD_4 <|endcomment|> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException , TYPE_3 , TYPE_4 { List < TYPE_5 > VAR_3 = METHOD_2 ( VAR_1 ) ; if ( ! VAR_3 . isEmpty ( ) ) { METHOD_3 ( VAR_3 , VAR_1 , VAR_2 ) ; } <START> VAR_1 . METHOD_4 ( ) ; <END> }
<|startcomment|> need change order don t rely visitor finding <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> METHOD_2 ( VAR_1 ) ; <END> }
<|startcomment|> surround return parenthesis <|endcomment|> private boolean METHOD_1 ( ) { int VAR_1 = VAR_2 . size ( ) ; <START> return VAR_1 > 0 && VAR_1 >= Math . VAR_3 ( VAR_4 , this . VAR_5 ) ; <END> }
<|startcomment|> previous code pretty bad readability new a more expressive - - VAR_1 > = 0 <|endcomment|> public boolean METHOD_1 ( ) { <START> return -- VAR_1 >= 0 ; <END> }
<|startcomment|> ❗️ prevents a user assigning a custom display TYPE_1 INVALID_TYPE adding a restriction doesn t provide benefit user <|endcomment|> public String METHOD_1 ( int VAR_1 ) { <START> if ( VAR_1 >= TYPE_1 . VAR_3 && VAR_1 < VAR_4 . length ) { <END> String VAR_5 = VAR_4 [ VAR_1 ] ; if ( VAR_5 != null ) { return VAR_5 ; } } String VAR_6 = METHOD_2 ( VAR_1 ) ; if ( VAR_6 != null ) { return VAR_6 ; } String VAR_7 = METHOD_3 ( VAR_1 ) ; if ( VAR_7 != null ) { return VAR_7 ; } return Integer . toString ( VAR_1 ) ; }
<|startcomment|> necessary I <|endcomment|> private boolean METHOD_1 ( ) { final TYPE_1 VAR_1 = <START> this . METHOD_2 ( ) ; <END> return ( VAR_1 != null && ( VAR_1 . METHOD_3 ( TYPE_1 . VAR_2 ) || VAR_1 . METHOD_3 ( TYPE_1 . VAR_3 ) ) ) ; }
<|startcomment|> Boolean methods null return type boolean instead Boolean <|endcomment|> public Boolean METHOD_1 ( ) { <START> return ( VAR_1 != null ) ? VAR_1 : Boolean . VAR_2 ; <END> }
<|startcomment|> switching eqauls ( VAR_1 METHOD_2 ( ) ) don t need null check <|endcomment|> private boolean METHOD_1 ( ) { if <START> ( VAR_1 . METHOD_2 ( ) == null || VAR_1 . METHOD_2 ( ) . equals ( "" ) ) { <END> METHOD_3 ( STRING_1 ) ; return false ; } if ( 0 == VAR_2 . METHOD_4 ( ) . length ) { METHOD_3 ( STRING_2 ) ; return false ; } if ( ! METHOD_5 ( ) ) { METHOD_3 ( STRING_3 ) ; return false ; } METHOD_3 ( null ) ; return true ; }
<|startcomment|> please add { } <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 connection = TYPE_3 . getInstance ( ) . METHOD_2 ( ) . get ( VAR_1 . METHOD_3 ( ) ) ; <START> <END> if ( connection != null ) TYPE_3 . getInstance ( ) . METHOD_2 ( ) . remove ( connection . VAR_2 ( ) ) ; return true ; }
<|startcomment|> StringUtils <|endcomment|> public void METHOD_1 ( ) throws IOException { writer = TYPE_1 . METHOD_2 ( VAR_1 , <START> String . format ( STRING_1 , VAR_2 ) , <END> VAR_3 , VAR_4 ) ; writer . VAR_5 ( ) ; }
<|startcomment|> duplicately <|endcomment|> public TYPE_5 ( Map conf , List < String > VAR_2 , TYPE_1 VAR_3 , String VAR_4 , String id , TYPE_2 < TYPE_3 > VAR_5 , TYPE_2 < TYPE_4 > VAR_6 ) { this . conf = conf ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; this . id = id ; <START> this . VAR_5 = VAR_5 ; <END> this . VAR_6 = VAR_6 ; }
<|startcomment|> s reason need protected <|endcomment|> <START> protected Class < ? > METHOD_1 ( TYPE_1 < ? > configuration , TYPE_2 VAR_1 ) { <END> String VAR_2 = configuration . VAR_3 ( ) ; TYPE_3 VAR_4 = VAR_1 . METHOD_2 ( ) ; try { return org . VAR_5 . VAR_6 . TYPE_6 . METHOD_3 ( VAR_2 , VAR_4 ) ; } catch ( TYPE_4 | TYPE_5 e ) { LOGGER . warn ( String . format ( VAR_8 , METHOD_4 ( ) , VAR_2 , VAR_4 ) , e ) ; } return null ; }
<|startcomment|> I moved _CODE_ ( ) raise error ASAP <|endcomment|> protected void METHOD_1 ( ) { Assert . state ( this . VAR_1 != null || StringUtils . VAR_2 ( this . VAR_3 ) , <START> STRING_1 ) ; <END> }
<|startcomment|> return session VAR_6 ( VAR_2 ) ; <|endcomment|> protected TYPE_1 METHOD_1 ( boolean VAR_1 ) { TYPE_1 VAR_2 = session . VAR_3 ( STRING_1 , STRING_2 , STRING_3 ) ; if ( VAR_1 ) { VAR_2 . METHOD_2 ( VAR_4 , ( TYPE_2 ) TYPE_3 . METHOD_3 ( VAR_5 ) ) ; } <START> VAR_2 = session . VAR_6 ( VAR_2 ) ; return VAR_2 ; <END> }
<|startcomment|> static import TYPE_2 METHOD_2 <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , int VAR_3 , Object VAR_4 ) { <START> if ( VAR_4 == null && ! TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) . get ( VAR_3 ) . METHOD_4 ( TYPE_3 . class ) ) <END> throw new TYPE_4 ( format ( STRING_1 , VAR_2 , VAR_1 . METHOD_3 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) , VAR_1 . METHOD_3 ( ) . getName ( ) ) ) ; return true ; }
<|startcomment|> allowed flush events device user opt gdpr <|endcomment|> <START> public void METHOD_1 ( ) { <END> METHOD_2 ( ) . METHOD_3 ( new TYPE_2 . TYPE_3 ( VAR_1 ) ) ; if ( METHOD_4 ( ) . METHOD_5 ( ) ) { METHOD_4 ( ) . METHOD_6 ( ) ; METHOD_4 ( ) . METHOD_7 ( ) ; } VAR_2 . METHOD_8 ( ) ; synchronized ( VAR_3 ) { VAR_3 . clear ( ) ; VAR_2 . METHOD_9 ( ) ; } VAR_2 . METHOD_10 ( ) ; VAR_2 . METHOD_11 ( true ) ; }
<|startcomment|> fully qualified package <|endcomment|> <START> protected org . VAR_1 . VAR_2 . TYPE_4 METHOD_1 ( ) { <END> return super . METHOD_1 ( ) . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . class ) . METHOD_3 ( TYPE_2 . class ) . METHOD_3 ( TYPE_3 . class ) . build ( ) ; }
<|startcomment|> column refer ? plan IR shouldn t references column names column handles instead <|endcomment|> public static String METHOD_1 ( TYPE_1 value ) { return value . VAR_1 ( ) . name ( ) + STRING_1 + value . VAR_2 ( ) ; <START> } <END>
<|startcomment|> a ! missing <|endcomment|> private static void METHOD_1 ( File to ) throws IOException { <START> boolean VAR_1 = to . exists ( ) ; <END> if ( VAR_1 ) { return ; } boolean VAR_2 = to . VAR_3 ( ) ; if ( VAR_2 ) { return ; } throw new IOException ( STRING_1 + to . VAR_4 ( ) ) ; }
<|startcomment|> inline key IMO <|endcomment|> public Map . Entry < TYPE_1 , Collection < TYPE_2 > > next ( ) { final Map . Entry < TYPE_1 , Collection < TYPE_2 > > entry = super . next ( ) ; final TYPE_1 key = entry . getKey ( ) ; final Collection < TYPE_2 > value = entry . getValue ( ) ; <START> return new TYPE_3 < > ( key , value ) ; <END> }
<|startcomment|> I call future : VAR_1 METHOD_4 ( call ) ( ) <|endcomment|> public void METHOD_1 ( TYPE_1 call ) throws Exception { TYPE_2 VAR_1 = METHOD_2 ( METHOD_3 ( ) ) ; <START> VAR_1 . METHOD_4 ( call ) ; <END> }
<|startcomment|> position adjustment restore wrapped a / finally don t want buffer left invalid state exception thrown <|endcomment|> public void METHOD_1 ( ByteBuffer buf , int position ) { final int VAR_1 = buf . position ( ) ; buf . position ( position ) ; METHOD_2 ( buf ) ; <START> buf . position ( VAR_1 ) ; <END> }
<|startcomment|> add braces / else statement <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> return VAR_1 . METHOD_1 ( ) ; else return null ; }
<|startcomment|> correct VAR_1 : foo# { bar } baz meaning evaluate a template part concatenate rest strings _CODE_ _CODE_ doesn t sense deprecate private method point log warn templating deprecated more context variable <|endcomment|> private boolean METHOD_1 ( String VAR_1 ) { <START> return VAR_1 . startsWith ( TYPE_1 . METHOD_2 ( ) ) && VAR_1 . METHOD_3 ( TYPE_1 . METHOD_4 ( ) ) ; <END> }
<|startcomment|> t null <|endcomment|> public String toString ( ) { return TYPE_1 . METHOD_1 ( this ) . METHOD_2 ( ) . add ( STRING_1 , VAR_1 . getName ( ) ) <START> . add ( STRING_2 , VAR_2 . getName ( ) ) <END> . add ( STRING_3 , path ) . toString ( ) ; }
<|startcomment|> METHOD_4 method throw exception assertion redundant _CODE_ want explicit remove assertion <|endcomment|> public void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) . METHOD_3 ( ) ; assertNotNull ( VAR_1 ) ; TYPE_1 VAR_2 = TYPE_2 . METHOD_4 ( VAR_1 , new TYPE_3 < TYPE_1 > ( ) { @Override public boolean apply ( TYPE_1 input ) { return input . VAR_3 ( ) . contains ( STRING_1 ) ; } <START> } ) ; <END> assertNotNull ( VAR_2 ) ; }
<|startcomment|> need methods static private void fine <|endcomment|> private static void METHOD_1 ( ) { <START> client . VAR_1 ( TYPE_1 . VAR_3 , false ) ; <END> }
<|startcomment|> ah yeah some limitations linter thanks care <|endcomment|> private int METHOD_1 ( final String VAR_1 ) throws TYPE_1 , InterruptedException { <START> try ( TYPE_2 VAR_2 = METHOD_2 ( ) ) { <END> final TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( Collections . VAR_4 ( VAR_1 ) ) . values ( ) . get ( VAR_1 ) . get ( ) ; return VAR_3 . METHOD_4 ( ) . size ( ) ; } }
<|startcomment|> need remove leftover debug output <|endcomment|> public List < String > METHOD_1 ( String name ) { TYPE_1 < String , String > VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> System . out . println ( VAR_1 . get ( name ) ) ; <END> return VAR_1 . get ( name ) ; }
<|startcomment|> don t need synchronized <|endcomment|> public boolean METHOD_1 ( String id ) { <START> synchronized ( VAR_1 ) <END> { return METHOD_1 ( id , null ) ; } }
<|startcomment|> add a TODO response aren t side - effects <|endcomment|> public TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final Collection < TYPE_4 > VAR_3 , final TYPE_5 VAR_4 , final TYPE_6 request ) { VAR_5 . log ( STRING_1 , new TYPE_7 ( VAR_3 ) ) ; <START> final TYPE_8 VAR_6 = VAR_7 . METHOD_2 ( new TYPE_9 ( VAR_2 , VAR_4 , VAR_3 ) , VAR_1 ) ; <END> return METHOD_1 ( request , VAR_1 , VAR_3 ) ; }
<|startcomment|> needs changed support locked stream syntax <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 key , TYPE_3 < ? super TYPE_2 , ? super TYPE_1 , ? extends TYPE_1 > VAR_1 , boolean VAR_2 , TYPE_4 metadata , long VAR_3 ) { METHOD_2 ( key ) ; METHOD_3 ( VAR_1 ) ; TYPE_5 ctx = METHOD_4 ( false , 1 ) ; TYPE_6 command = VAR_4 . METHOD_5 ( key , VAR_1 , VAR_2 , metadata , VAR_3 ) ; <START> ctx . VAR_5 ( command . VAR_6 ( ) ) ; <END> return ( TYPE_1 ) METHOD_6 ( ctx , command ) ; }
<|startcomment|> put <|endcomment|> protected void METHOD_1 ( List < Object > VAR_1 ) { <START> log ( STRING_1 ) ; <END> if ( TYPE_1 . getInstance ( ) . METHOD_2 ( ) ) { TYPE_2 VAR_2 = Context . VAR_3 ( TYPE_2 . class ) ; for ( Object VAR_4 : VAR_1 ) { if ( VAR_4 instanceof TYPE_3 ) { VAR_2 . METHOD_3 ( ( TYPE_3 ) VAR_4 ) ; } } } }
<|startcomment|> able ( VAR_2 equals ( VAR_1 ) ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> for ( TYPE_1 VAR_2 : VAR_3 ) { <END> if ( VAR_2 . getId ( ) . equals ( VAR_1 . getId ( ) ) ) { return VAR_2 ; } } return null ; }
<|startcomment|> great place a lambda ; ) javareturn TYPE_3 iterator ( config - > new TYPE_4 < TYPE_2 > ( ) { TYPE_6 stream ( ) { return VAR_1 = factory apply ( config ) ; } TYPE_7 < TYPE_2 > VAR_2 ( ) { return VAR_2 ; } } ) ; <|endcomment|> public Iterator < TYPE_1 < TYPE_2 > > iterator ( ) { <START> return TYPE_3 . iterator ( new TYPE_1 < TYPE_2 > ( ) <END> { @Override public TYPE_4 < TYPE_2 > create ( TYPE_5 config ) { return new TYPE_4 < TYPE_2 > ( ) { @Override public TYPE_6 stream ( ) { return VAR_1 = factory . apply ( config ) ; } @Override public TYPE_7 < TYPE_2 > METHOD_1 ( ) { return VAR_2 ; } } ; } } ) ; }
<|startcomment|> TYPE_5 part part VAR_5 execution <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 session = TYPE_3 . METHOD_2 ( ) ; long VAR_2 = ( long ) TYPE_4 . METHOD_3 ( VAR_1 . toString ( ) ) ; TYPE_5 VAR_3 = VAR_4 . bind ( VAR_2 , VAR_1 . toString ( ) , "" ) ; TYPE_6 . Context VAR_5 = TYPE_7 . METHOD_4 ( TYPE_8 . VAR_7 ) ; try { <START> session . execute ( VAR_3 ) ; <END> } finally { VAR_5 . METHOD_5 ( ) ; } }
<|startcomment|> 2 operations ? flatmap sufficient <|endcomment|> private Set < Type > METHOD_1 ( TYPE_3 . TYPE_4 VAR_1 , TYPE_2 VAR_2 ) { return VAR_1 . METHOD_2 ( ) . stream ( ) <START> . map ( VAR_3 - > METHOD_3 ( VAR_3 , VAR_2 ) ) <END> . METHOD_4 ( VAR_4 - > METHOD_5 ( VAR_4 ) . stream ( ) ) . collect ( Collectors . VAR_5 ( ) ) ; }
<|startcomment|> fluent chaining nice <|endcomment|> <START> public void METHOD_1 ( ) { <END> METHOD_2 ( TYPE_1 . VAR_1 . VAR_2 ) ; METHOD_3 ( VAR_3 ) ; VAR_3 . METHOD_4 ( ) ; TYPE_2 . log ( STRING_1 , STRING_2 , true ) ; }
<|startcomment|> curious need change access qualifier protected <|endcomment|> <START> protected StringUtils ( ) { <END> }
<|startcomment|> ? : int VAR_6 = VAR_4 > 0 <|endcomment|> public int METHOD_1 ( ) throws Exception { TYPE_1 < ? > VAR_1 = VAR_2 . METHOD_2 ( ) ; int VAR_3 = VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; long VAR_4 = Math . VAR_5 ( VAR_3 , VAR_2 . METHOD_5 ( ) ) ; <START> int VAR_6 = 0 ; <END> if ( VAR_4 > 0 ) { VAR_6 = METHOD_6 ( VAR_1 , VAR_4 ) ; } VAR_2 . METHOD_7 ( VAR_6 ) ; return VAR_6 ; }
<|startcomment|> initialize VAR_1 <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> List < TYPE_1 > VAR_1 ; <END> try { VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( TYPE_1 VAR_3 : VAR_1 ) { METHOD_3 ( VAR_3 ) ; } } catch ( TYPE_2 e ) { throw new RuntimeException ( STRING_1 , e ) ; } return VAR_1 ; }
<|startcomment|> I replace ArrayList List ( VAR_1 instanceof List ) { List VAR_3 = ( List ) VAR_1 ; List VAR_4 = new ArrayList ( VAR_3 size ( ) ) ; ( Object VAR_5 : VAR_3 ) { VAR_4 add ( METHOD_1 ( VAR_5 ) ) ; } <|endcomment|> public static Object METHOD_1 ( Object VAR_1 ) { Object VAR_2 = VAR_1 ; if ( VAR_1 instanceof byte [ ] ) { VAR_2 = TYPE_1 . METHOD_2 ( ( byte [ ] ) VAR_1 ) ; <START> } else if ( VAR_1 instanceof ArrayList ) { ArrayList VAR_3 = ( ArrayList ) VAR_1 ; ArrayList VAR_4 = new ArrayList ( VAR_3 . size ( ) ) ; for ( Object VAR_5 : VAR_3 ) { VAR_4 . add ( METHOD_1 ( VAR_5 ) ) ; } <END> VAR_2 = VAR_4 ; } return VAR_2 ; }
<|startcomment|> ctor invoke other similar logic I DRY - other words <|endcomment|> public TYPE_3 ( TYPE_1 factory , String VAR_2 ) { VAR_3 = new TYPE_2 ( factory ) ; this . VAR_2 = ( StringUtils . VAR_4 ( VAR_2 ) ) ? VAR_2 : VAR_5 ; <START> } <END>
<|startcomment|> : METHOD_3 <|endcomment|> private void METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> VAR_3 . METHOD_2 ( ( ) - > METHOD_3 ( ) , <END> VAR_2 , VAR_1 , TimeUnit . VAR_4 ) ; }
<|startcomment|> shouldn t synchronized <|endcomment|> public void METHOD_1 ( TYPE_1 < T > VAR_1 ) { <START> TYPE_2 < T > VAR_2 = this . VAR_3 ; <END> synchronized ( this ) { VAR_3 = new TYPE_3 < > ( VAR_1 ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; } }
<|startcomment|> doc <|endcomment|> <START> public void METHOD_1 ( TYPE_1 id ) { <END> TYPE_2 VAR_1 = VAR_2 . get ( id ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_1 ( id ) ; } }
<|startcomment|> multi - catch <|endcomment|> public Class < ? > METHOD_1 ( TYPE_1 < ? > VAR_1 ) throws TYPE_2 { try { return METHOD_2 ( VAR_1 ) ; } catch ( TYPE_3 | TYPE_4 e ) { throw new TYPE_2 ( e ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; <START> } <END> }
<|startcomment|> GSON initializes classes reflection constructor default definition set field declaration <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , List < TYPE_2 > VAR_3 , float VAR_4 , int VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; int VAR_6 = 0 ; for ( TYPE_2 VAR_7 : VAR_3 ) VAR_6 += VAR_7 . METHOD_1 ( ) ; this . VAR_8 = VAR_6 ; <START> this . VAR_9 = INT_1 ; <END> }
<|startcomment|> response guaranteed - null point <|endcomment|> private byte [ ] METHOD_1 ( TYPE_1 response ) throws TYPE_2 { TYPE_3 VAR_1 = new TYPE_3 ( ) ; <START> if ( response . VAR_2 ( ) != null && response . VAR_2 ( ) . METHOD_2 ( ) != null ) { <END> METHOD_3 ( ) . METHOD_4 ( response . VAR_2 ( ) . METHOD_2 ( ) , VAR_1 ) ; } return VAR_1 . METHOD_5 ( ) ; }
<|startcomment|> expected exception matching row database ignore instead <|endcomment|> public List < TYPE_1 > METHOD_1 ( final TYPE_2 type , final Collection < TYPE_3 > VAR_1 ) { final List < TYPE_1 > result = new ArrayList < > ( VAR_1 . size ( ) ) ; for ( final TYPE_3 VAR_2 : VAR_1 ) { try { result . add ( METHOD_2 ( type , VAR_2 ) ) ; } catch ( TYPE_4 VAR_3 ) { <START> LOGGER . debug ( STRING_1 , VAR_3 . getMessage ( ) , VAR_3 . getClass ( ) . getName ( ) ) ; <END> } } return result ; }
<|startcomment|> I don t s necessary cast returned collection ArrayList assertions checking collection s total size <|endcomment|> public void METHOD_1 ( ) { byte [ ] content = VAR_1 . METHOD_2 ( VAR_2 ) ; <START> ArrayList < TYPE_1 > VAR_3 = ( ArrayList < TYPE_1 > ) VAR_1 . METHOD_3 ( content ) ; <END> METHOD_4 ( content . length , 0 ) ; assertEquals ( VAR_4 , VAR_3 . size ( ) ) ; }
<|startcomment|> METHOD_1 ( ) public <|endcomment|> <START> public static long METHOD_1 ( final long VAR_1 ) { <END> long VAR_2 = VAR_1 - 1 ; return ( VAR_2 / 4 ) - ( VAR_2 / 100 ) + ( VAR_2 / INT_1 ) ; }
<|startcomment|> cast needed ? time ( x ) method <|endcomment|> public void time ( ) throws Exception { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; <START> VAR_1 . time ( ( TYPE_2 < TYPE_3 > ) ( ) - > { <END> VAR_2 . METHOD_1 ( 10 , TimeUnit . VAR_3 ) ; return null ; } ) ; TYPE_4 VAR_4 = VAR_1 . METHOD_2 ( ) ; assertEquals ( VAR_4 . METHOD_3 ( ) , FLOAT_1 ) ; assertEquals ( VAR_4 . METHOD_4 ( ) , FLOAT_2 ) ; assertEquals ( VAR_4 . METHOD_5 ( ) , FLOAT_2 ) ; }
<|startcomment|> group _CODE_ defined easier find related methods ? need public ? protected private <|endcomment|> public boolean METHOD_1 ( ) throws TYPE_1 { return parse . VAR_1 ( VAR_2 , STRING_1 ) ; <START> } <END>
<|startcomment|> I suggest : javareturn TYPE_1 METHOD_2 ( key getName ( ) - > new TYPE_2 ( TYPE_3 METHOD_1 ( ) ) ) ; a readability note parameter METHOD_1 changed key <|endcomment|> public static Logger METHOD_1 ( Class < ? > key ) { <START> return TYPE_1 . METHOD_2 ( key . getName ( ) , name - > new TYPE_2 ( TYPE_3 . METHOD_1 ( key ) ) ) ; <END> }
<|startcomment|> justreturn else METHOD_3 ( VAR_3 VAR_1 ) ; instead else block <|endcomment|> public boolean METHOD_1 ( List < String > VAR_1 , int VAR_2 , int VAR_3 , TYPE_1 VAR_4 ) { if ( ! METHOD_2 ( VAR_1 , VAR_2 , VAR_4 ) ) { return false ; } <START> else if ( ! METHOD_3 ( VAR_3 , VAR_1 ) ) { return false ; } return true ; <END> }
<|startcomment|> ! VAR_1 equals ( ) - > ! VAR_1 isEmpty ( ) <|endcomment|> public boolean METHOD_1 ( TYPE_1 state , String [ ] params ) { <START> if ( ( this . VAR_1 != null && ! this . VAR_1 . equals ( "" ) ) && ! this . VAR_1 . equals ( params [ 1 ] ) ) { <END> return false ; } TYPE_2 VAR_2 = state . VAR_3 ( params [ 1 ] ) ; return TYPE_3 . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> I VAR_2 ( TYPE_6 TYPE_7 VAR_5 ) shouldn t necessary <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( ) ; TYPE_4 parameters = VAR_1 . parameters ( ) ; <START> if ( VAR_2 != null && VAR_2 . is ( TYPE_6 . TYPE_7 . VAR_5 ) && parameters != null ) { <END> TYPE_5 VAR_6 = ( TYPE_5 ) VAR_2 ; VAR_6 . METHOD_3 ( parameters ) ; } super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> final <|endcomment|> <START> public TYPE_1 < TYPE_2 > <END> METHOD_1 ( ) { return VAR_1 ; }
<|startcomment|> n variable <|endcomment|> public static TYPE_1 parse ( String VAR_1 ) { int n = 0 ; for ( TYPE_2 VAR_2 : VAR_3 ) { try { return METHOD_1 ( VAR_2 . parse ( VAR_1 ) ) ; } catch ( TYPE_3 VAR_4 ) { <START> n ++ ; <END> continue ; } } if ( TYPE_4 . matcher ( VAR_1 ) . METHOD_2 ( ) ) { long VAR_5 = Long . VAR_6 ( VAR_1 ) ; return TYPE_5 . METHOD_3 ( VAR_5 ) . METHOD_4 ( VAR_7 ) ; } return null ; }
<|startcomment|> copy / paste error : TYPE_5 errors tests : java lang _CODE_ : org eclipse sirius diagram business internal metamodel spec _CODE_ cast org eclipse sirius diagram _CODE_ org eclipse sirius diagram ui business internal query _CODE_ METHOD_1 ( _CODE_ java : 105 ) <|endcomment|> public Optional < TYPE_1 > METHOD_1 ( ) { TYPE_1 VAR_1 = null ; if ( VAR_2 instanceof TYPE_2 ) { VAR_1 = new TYPE_3 ( ( TYPE_2 ) VAR_2 ) . METHOD_2 ( ) . get ( ) ; } else if ( VAR_2 instanceof TYPE_4 ) { VAR_1 = ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; } else if ( VAR_2 instanceof TYPE_5 ) { VAR_1 = <START> ( ( TYPE_4 ) VAR_2 ) . METHOD_2 ( ) ; <END> } return Optional . VAR_3 ( VAR_1 ) ; }
<|startcomment|> need flush <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( VAR_2 ) . METHOD_3 ( TYPE_3 . class ) ; VAR_1 . METHOD_4 ( ) ; <START> TYPE_2 . METHOD_2 ( VAR_2 ) . METHOD_5 ( ) ; <END> }
<|startcomment|> declare function throws TYPE_2 instead - catch ? ( other functions similarly ) _CODE_ METHOD_3 throw <|endcomment|> public void METHOD_1 ( ) { try { TYPE_1 . METHOD_2 ( null , VAR_1 [ 0 ] ) ; } catch ( TYPE_2 e ) { <START> METHOD_3 ( STRING_1 ) ; <END> } }
<|startcomment|> another minor note reason merge a single check ? ( values = = null || values isEmpty ( ) ) return true ; <|endcomment|> private boolean METHOD_1 ( List < String > values ) { if ( values == null ) return true ; <START> if ( values . isEmpty ( ) ) return true ; <END> for ( String VAR_1 : values ) { if ( StringUtils . VAR_2 ( VAR_1 ) ) return true ; } return false ; }
<|startcomment|> + _CODE_ return type <|endcomment|> <START> public static < T > TYPE_1 < T > METHOD_1 ( ANNOTATION_1 Optional < T > VAR_1 ) { <END> TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) ; return VAR_1 . map ( TYPE_1 : : METHOD_3 ) . METHOD_4 ( TYPE_1 : : empty ) ; }
<|startcomment|> unused <|endcomment|> private static Map < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_3 < ? , ? > run ) { <START> TYPE_4 < ? , ? > build = null ; <END> if ( run instanceof TYPE_4 ) return ( ( TYPE_4 ) run ) . METHOD_1 ( ( TYPE_4 ) run ) ; else return TYPE_5 . METHOD_2 ( ) ; }
<|startcomment|> cast <|endcomment|> public void METHOD_1 ( TYPE_1 < TYPE_2 < ? extends TYPE_3 , ? extends TYPE_4 > > VAR_1 ) throws TYPE_5 { <START> for ( Object VAR_2 : VAR_1 ) { <END> TYPE_2 event = ( TYPE_2 ) VAR_2 ; Assert . assertEquals ( TYPE_6 . VAR_4 , event . VAR_5 ( ) ) ; this . VAR_6 . METHOD_2 ( ) ; event . getKey ( ) ; if ( event . VAR_7 ( ) ) { event . VAR_8 ( ) ; } } }
<|startcomment|> attribute required d reporting incorrect metadata work a test fixture problem <|endcomment|> TYPE_4 ( String name , TYPE_1 type , TYPE_2 VAR_2 ) { <START> this . VAR_3 = new TYPE_3 ( name , type , true ) <END> . METHOD_1 ( VAR_2 ) . METHOD_2 ( TYPE_5 . VAR_5 ) . build ( ) ; }
<|startcomment|> I ( ) stay java 6 syntax <|endcomment|> TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { if ( VAR_1 != null ) { <START> return new TYPE_4 < > ( Collections . VAR_2 ( new TYPE_2 ( ) ) , VAR_1 , 1 ) ; <END> } return new TYPE_4 < > ( Collections . VAR_3 ( ) , VAR_1 , 0 ) ; }
<|startcomment|> combine lines return String <|endcomment|> public String METHOD_1 ( ) { String VAR_1 = VAR_2 . METHOD_2 ( STRING_1 ) ; <START> return VAR_1 ; <END> }
<|startcomment|> account instead accoun <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; <START> VAR_1 . METHOD_4 ( STRING_2 ) ; <END> VAR_1 . METHOD_5 ( Integer . VAR_4 . getName ( ) ) ; VAR_1 . METHOD_6 ( STRING_3 ) ; return VAR_1 ; }
<|startcomment|> VAR_1 METHOD_3 ( new TYPE_2 ( ) ) ; / / <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_1 parent ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( parent . getId ( ) ) ; <START> VAR_1 . METHOD_3 ( new TYPE_2 ( ) ) ; <END> if ( parent . VAR_2 ( ) ) { VAR_1 . METHOD_4 ( ) . METHOD_2 ( parent . VAR_3 ( ) . getId ( ) ) ; } return VAR_1 ; }
<|startcomment|> synchronized <|endcomment|> public boolean METHOD_1 ( ) { final boolean VAR_1 = <START> VAR_2 . size ( ) <END> > 0 ; return VAR_1 ; }
<|startcomment|> reason longer version ? EDIT : hibernate String METHOD_1 java 8 <|endcomment|> public static String METHOD_1 ( String [ ] VAR_1 ) { StringBuilder sb = new StringBuilder ( ) ; boolean VAR_2 = true ; for ( String s : VAR_1 ) { if ( VAR_2 ) { VAR_2 = false ; } else { sb . append ( CHAR_1 ) ; } sb . append ( s ) ; } <START> return sb . toString ( ) ; <END> }
<|startcomment|> I imagine synchronized keyword move init private situation want locked externally <|endcomment|> <START> public synchronized void METHOD_1 ( ) { <END> VAR_1 = true ; VAR_2 = TYPE_1 . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) returns a string s need call toString ( ) [ ! [ rule ] ( ) ] ( ) <|endcomment|> private String METHOD_1 ( String VAR_1 ) throws TYPE_1 { String VAR_2 = null ; TYPE_2 VAR_3 = new TYPE_2 ( ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; List < Map < String , String > > result = VAR_3 . METHOD_4 ( ) ; if ( ! result . isEmpty ( ) ) { <START> VAR_2 = result . get ( 0 ) . get ( STRING_1 ) . toString ( ) ; <END> } return VAR_2 ; }
<|startcomment|> call _CODE_ _CODE_ ( ) method ? _CODE_ ( ) method aslo request canceling <|endcomment|> <START> public void METHOD_1 ( ) { <END> synchronized ( VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_1 ) { VAR_2 . METHOD_2 ( ) ; } VAR_1 . clear ( ) ; } METHOD_3 ( ) ; }
<|startcomment|> shouldn t set token null ? a token succesfully closed link deleted shouldn t references <|endcomment|> public boolean commit ( ) { if ( VAR_1 != null ) { METHOD_1 ( ) ; throw new IllegalStateException ( TYPE_1 . format ( TYPE_2 . get ( ) . VAR_2 , VAR_3 ) ) ; } METHOD_2 ( ) ; try { TYPE_3 . METHOD_3 ( VAR_4 , VAR_3 , TYPE_4 . VAR_6 ) ; VAR_7 = false ; <START> token . close ( ) ; <END> return true ; } catch ( IOException e ) { METHOD_1 ( ) ; return false ; } }
<|startcomment|> don t need properties don t exist apply <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 . METHOD_2 ( STRING_1 ) ; VAR_2 . METHOD_2 ( STRING_2 ) ; <START> VAR_2 . METHOD_2 ( STRING_3 ) ; <END> VAR_2 . METHOD_3 ( STRING_4 , STRING_5 + TYPE_3 . VAR_4 ) ; VAR_2 . METHOD_4 ( ) ; return VAR_2 ; }
<|startcomment|> I don t method <|endcomment|> public TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_5 METHOD_1 ( <START> TYPE_3 . TYPE_4 . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_6 VAR_7 ) { <END> LOG . info ( STRING_1 ) ; TYPE_2 VAR_8 = new TYPE_2 ( ) ; return VAR_8 . METHOD_1 ( VAR_7 ) ; }
<|startcomment|> synchronization issue <|endcomment|> <START> void remove ( TYPE_1 VAR_1 ) { <END> if ( VAR_2 != null ) { VAR_2 . remove ( VAR_1 ) ; } }
<|startcomment|> return condition s <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> if <END> ( VAR_1 . METHOD_2 ( VAR_3 ) <= 0 && VAR_2 . METHOD_2 ( VAR_4 ) >= 0 ) { return true ; } return false ; }
<|startcomment|> missing semicolon ; <|endcomment|> public void VAR_1 ( ) { <START> VAR_2 ( STRING_1 , STRING_2 ) <END> }
<|startcomment|> VAR_2 METHOD_4 ( 1 ) ( equal 2 ) I misunderstand <|endcomment|> ANNOTATION_1 public void METHOD_1 ( ) { assertThat ( METHOD_2 ( TYPE_1 . class ) , METHOD_3 ( 2 ) ) ; <START> assertThat ( TYPE_2 . VAR_2 , METHOD_4 ( 0 ) ) ; <END> }
<|startcomment|> needed <|endcomment|> private void METHOD_1 ( final long VAR_1 , final Status status ) throws InterruptedException , TYPE_1 { TYPE_2 . METHOD_2 ( STRING_1 , ( ) - > { try { return VAR_2 . getStatus ( VAR_1 ) . getStatus ( ) == status ; } catch ( Exception e ) { TYPE_3 . METHOD_3 ( e ) ; } return null ; <START> } , TYPE_4 . METHOD_4 ( ) . METHOD_5 ( 10 ) . METHOD_6 ( 10 * Constants . VAR_3 ) ) ; <END> }
<|startcomment|> message operator supported secondary index enabled check creating predicate ( done file operator ) : ( args index = = _CODE_ DISABLED ) { throw error ( secondary index enabled message : + text ) ; } <|endcomment|> public TYPE_1 < TYPE_2 > message ( String text ) { <START> return new TYPE_3 ( args . VAR_1 , args . VAR_2 , args . index , text ) ; <END> }
<|startcomment|> other setters class void <|endcomment|> public <START> boolean METHOD_1 ( boolean <END> VAR_1 ) { return this . VAR_1 = VAR_1 ; }
<|startcomment|> edge : toll = yestoll : hgv = _CODE_ result TYPE_6 VAR_8 TYPE_6 VAR_7 <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_4 . TYPE_5 VAR_3 , long VAR_4 ) { if ( VAR_2 . METHOD_2 ( STRING_1 , STRING_2 ) ) VAR_5 . METHOD_3 ( false , VAR_1 , TYPE_6 . VAR_7 ) ; if ( VAR_2 . METHOD_2 ( STRING_3 , STRING_2 ) ) <START> VAR_5 . METHOD_3 ( false , VAR_1 , TYPE_6 . VAR_8 ) ; <END> return VAR_1 ; }
<|startcomment|> fix formatter settings please disable : wink : <|endcomment|> <START> @Override public boolean METHOD_1 ( ) <END> { return false ; }
<|startcomment|> doesn t matter : javareturn new byte [ ] { ( byte ) ( val > > > INT_3 ) ( byte ) ( val > > > INT_2 ) ( byte ) ( val > > > INT_1 ) ( byte ) val } ; <|endcomment|> byte [ ] METHOD_1 ( int val ) { byte [ ] b = new byte [ 4 ] ; b [ 3 ] = ( byte ) ( val ) ; b [ 2 ] = ( byte ) ( val > > > INT_1 ) ; b [ 1 ] = ( byte ) ( val > > > INT_2 ) ; b [ 0 ] = ( byte ) ( val > > > INT_3 ) ; <START> return b ; <END> }
<|startcomment|> useful method _CODE_ <|endcomment|> <START> protected int <END> METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 text ) { int VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { TYPE_4 VAR_5 = new TYPE_4 ( VAR_6 , VAR_7 ) ; String VAR_8 = VAR_5 . get ( VAR_2 , VAR_1 , String . VAR_9 ) ; VAR_4 = METHOD_1 ( VAR_8 , VAR_4 , text ) ; } return VAR_4 ; }
<|startcomment|> variable declaration return VAR_1 METHOD_2 ( ) METHOD_3 ( ) ; <|endcomment|> private static TYPE_1 METHOD_1 ( Class < ? extends TYPE_1 > VAR_1 ) { TYPE_1 VAR_2 ; try { <START> VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> } catch ( TYPE_2 e ) { throw new IllegalStateException ( STRING_1 + VAR_1 + STRING_2 , e ) ; } return VAR_2 ; }
<|startcomment|> modifier private redundant enum constructor - needs removed <|endcomment|> <START> private VAR_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> need + <|endcomment|> public TYPE_1 append ( final boolean VAR_1 , final boolean VAR_2 ) { if ( VAR_3 != 0 ) { return this ; } if ( VAR_1 == VAR_2 ) { return this ; } if ( VAR_1 ) { <START> VAR_3 = + 1 ; <END> } else { VAR_3 = - 1 ; } return this ; }
<|startcomment|> pretty impact performance change <|endcomment|> <START> private TYPE_1 METHOD_1 ( TYPE_1 node ) { <END> TYPE_1 VAR_1 = ( TYPE_1 ) node . VAR_2 ( this ) ; while ( ! node . equals ( VAR_1 ) ) { node = VAR_1 ; VAR_1 = ( TYPE_1 ) node . VAR_2 ( this ) ; } return node ; }
<|startcomment|> variable s bounds check TYPE_1 METHOD_1 ( VAR_2 ) discard return ( IDE show a warning unused variable ? want turn general please avoid introducing new warnings avoided ( avoided ; example _CODE_ derives _CODE_ technically public API API tooling a warning s suppress ) ) <|endcomment|> public TYPE_3 ( int VAR_2 ) { try { <START> TYPE_1 s = TYPE_1 . METHOD_1 ( VAR_2 ) ; <END> value = VAR_2 ; VAR_3 = true ; } catch ( IllegalArgumentException e ) { try { TYPE_2 c = TYPE_2 . METHOD_1 ( VAR_2 ) ; value = VAR_2 ; VAR_3 = false ; } catch ( IllegalArgumentException y ) { throw new IllegalArgumentException ( STRING_1 ) ; } } }
<|startcomment|> returning true result yield true meaning instance s type METHOD_3 type a type filter included matter result unconditional filters <|endcomment|> private boolean METHOD_1 ( TYPE_1 instance ) { for ( String type : this . VAR_1 . keySet ( ) ) { if ( METHOD_2 ( instance . VAR_2 ( ) , type ) ) { for ( TYPE_2 VAR_3 : this . VAR_1 . get ( type ) ) { if ( VAR_3 . METHOD_3 ( instance ) ) return true ; } return false ; } } <START> return true ; <END> }
<|startcomment|> synchronized void didn t run mvn clean package making change else compiler caught travis error <|endcomment|> <START> public void synchronized VAR_1 ( TYPE_1 ctx ) { <END> VAR_3 ( ctx ) ; }
<|startcomment|> strictly necessary ( ) throw s VAR_1 content <|endcomment|> public void METHOD_1 ( ) throws IOException { TYPE_1 row = METHOD_2 ( STRING_1 ) ; Optional < TYPE_2 > VAR_1 = VAR_2 . METHOD_3 ( row ) ; <START> assertTrue ( VAR_1 . isPresent ( ) ) ; <END> TYPE_2 content = VAR_1 . get ( ) ; TYPE_3 VAR_3 = ( TYPE_3 ) content ; METHOD_4 ( VAR_3 . METHOD_5 ( ) ) ; }
<|startcomment|> map defined base class <|endcomment|> public TYPE_1 list ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; Set < TYPE_2 > VAR_2 = TYPE_3 . METHOD_1 ( this , version ) ; VAR_2 . forEach ( VAR_3 - > { org . VAR_4 . VAR_5 . VAR_6 . model . TYPE_5 VAR_8 = <START> METHOD_2 ( TYPE_4 . map ( VAR_3 , <END> null ) ) ; VAR_1 . METHOD_1 ( ) . add ( VAR_8 ) ; } ) ; return VAR_1 ; }
<|startcomment|> remove <|endcomment|> public TYPE_1 METHOD_1 ( Optional < TYPE_2 > VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 . METHOD_3 ( ) ) { <START> session . VAR_3 ( ) . log ( ( ) - > STRING_1 ) ; <END> VAR_2 . METHOD_4 ( session . VAR_3 ( ) . METHOD_5 ( ) ) ; VAR_4 . METHOD_6 ( Optional . empty ( ) , Optional . of ( VAR_2 ) ) ; } return VAR_2 ; }
<|startcomment|> VAR_4 isEmpty ( ) <|endcomment|> public Object execute ( TYPE_1 event ) { TYPE_2 VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) , Messages . TYPE_6 , Messages . TYPE_7 , "" , new TYPE_4 ( ) { @Override public String METHOD_3 ( String VAR_4 ) { <START> if ( "" . equals ( VAR_4 ) ) { <END> return Messages . TYPE_8 ; } return null ; } } ) ; if ( VAR_1 . METHOD_4 ( ) == TYPE_5 . VAR_7 ) { METHOD_5 ( VAR_1 . getValue ( ) ) ; } return null ; }
<|startcomment|> VAR_3 clear ( ) ; loop <|endcomment|> public void METHOD_1 ( TYPE_1 < T > VAR_1 ) { for ( TYPE_1 < T > VAR_2 : VAR_3 ) { if ( VAR_2 != VAR_1 ) { VAR_2 . METHOD_2 ( ) ; } <START> VAR_3 . clear ( ) ; <END> } }
<|startcomment|> nice chain configurable a field general more spring ( case spring filters ) implemented a List add filter places delegate other add new filters filters add ( 0 new _CODE_ ( ) ) ; WDYT <|endcomment|> protected TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = VAR_2 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_1 . METHOD_3 ( ) ; File VAR_4 = VAR_1 . METHOD_4 ( ) ; <START> if ( VAR_1 . METHOD_5 ( ) ) { <END> return new TYPE_4 ( new TYPE_5 ( new TYPE_6 ( VAR_2 . getName ( ) , VAR_4 , VAR_3 ) ) , METHOD_6 ( ) ) ; } else { return new TYPE_6 ( VAR_2 . getName ( ) , VAR_4 , VAR_3 , METHOD_6 ( ) ) ; } }
<|startcomment|> amazon implementation slightly google implementation happen gradle copy script doesn t execute properly building google variant - building project google build variants ( oba agencyx agencyy ) - generate amazon code push new version <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 . METHOD_2 ( ) ; TYPE_2 status = VAR_3 . METHOD_3 ( VAR_1 ) ; <START> String VAR_4 = VAR_5 . METHOD_4 ( ) ; <END> if ( VAR_5 != null && VAR_5 . VAR_6 != null ) { TYPE_3 . start ( VAR_7 , status . VAR_8 ( ) , VAR_4 ) ; } else { TYPE_3 . start ( VAR_7 , status . VAR_8 ( ) ) ; } }
<|startcomment|> ( factory null false false 1 ) add / remove a new parameter main constructor / needs a decision <|endcomment|> public TYPE_2 ( TYPE_1 factory ) { <START> VAR_2 = factory ; <END> VAR_3 = null ; VAR_4 = false ; VAR_5 = false ; VAR_6 = 1 ; }
<|startcomment|> I m need natural logarithmic logarithmic behaviour general ? case more efficient log2 I suppose write ( int ) ( Math log2 ( VAR_5 ) / VAR_3 ) + VAR_7 <|endcomment|> public int METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 , int VAR_4 ) { double VAR_5 = VAR_2 . METHOD_2 ( ) / VAR_1 . METHOD_2 ( ) ; <START> final int i = ( int ) ( Math . log ( VAR_5 ) / Math . log ( Math . VAR_6 ( 2 , VAR_3 ) ) ) + VAR_7 ; <END> return i ; }
<|startcomment|> _matcher_ reused multiple times - list doesn t <|endcomment|> public TYPE_2 ( List < TYPE_1 > VAR_2 ) { <START> Collections . VAR_3 ( VAR_2 , VAR_4 ) ; <END> }
<|startcomment|> VAR_1 empty point <|endcomment|> public void METHOD_1 ( ) { <START> if ( VAR_1 . get ( 0 ) . METHOD_2 ( ) != null ) { <END> VAR_1 . add ( 0 , new TYPE_1 ( ) ) ; } }
<|startcomment|> new HashSet < > ( list ) size ( ) = = list size ( ) ; <|endcomment|> public static boolean METHOD_1 ( List < String > VAR_1 ) { <START> return VAR_1 . stream ( ) . METHOD_2 ( new HashSet < > ( ) : : add ) ; <END> }
<|startcomment|> shouldn t METHOD_5 called VAR_1 control instead shell <|endcomment|> private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; VAR_1 . METHOD_3 ( ) . METHOD_2 ( ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> }
<|startcomment|> switch statement more natural hereswitch ( VAR_1 ) { case VAR_3 : return VAR_4 ; case VAR_5 : return TYPE_1 METHOD_2 ( 0 VAR_6 ) METHOD_3 ( i - > i % 2 = = 0 ? METHOD_4 ( ) : null ) collect ( METHOD_5 ( ) ) ; default : return TYPE_1 METHOD_2 ( 0 VAR_6 ) METHOD_3 ( i - > METHOD_4 ( ) ) collect ( METHOD_5 ( ) ) ; } <|endcomment|> protected final List < ? > METHOD_1 ( ) { <START> if ( VAR_1 == TYPE_2 . VAR_3 ) { <END> return VAR_4 ; } if ( VAR_1 == TYPE_2 . VAR_5 ) { return TYPE_1 . METHOD_2 ( 0 , VAR_6 ) . METHOD_3 ( i - > i % 2 == 0 ? METHOD_4 ( ) : null ) . collect ( METHOD_5 ( ) ) ; } return TYPE_1 . METHOD_2 ( 0 , VAR_6 ) . METHOD_3 ( i - > METHOD_4 ( ) ) . collect ( METHOD_5 ( ) ) ; }
<|startcomment|> ( Object item : VAR_2 ) { VAR_3 add ( item ) ; } METHOD_3 ( VAR_3 ) ; - loop redundant reset VAR_2 set VAR_1 <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 == null ) { return ; } TYPE_2 VAR_3 = ( VAR_1 == null ) ? new ArrayList ( ) : new TYPE_3 ( VAR_1 ) ; for ( Object item : VAR_2 ) { <START> METHOD_3 ( VAR_3 ) ; <END> } }
<|startcomment|> isEmpty ( ) alternatively don t check size loop run empty <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> if ( VAR_1 . size ( ) > 0 ) { <END> for ( TYPE_1 VAR_2 : VAR_1 ) { TYPE_2 VAR_3 = VAR_2 . METHOD_2 ( ) ; if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( ) ; } VAR_2 . close ( ) ; } VAR_1 . clear ( ) ; } }
<|startcomment|> ternary <|endcomment|> private T METHOD_1 ( ) { <START> if ( VAR_1 . size ( ) == 1 ) { <END> return VAR_1 . iterator ( ) . next ( ) ; } return VAR_2 ; }
<|startcomment|> need ? threadsafe <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( metadata == null ) { <START> metadata = new TYPE_1 ( ) ; <END> } return metadata ; }
<|startcomment|> _CODE_ a weird ; inline variables VAR_4 ( ) <|endcomment|> public void METHOD_1 ( long VAR_1 , long VAR_2 ) { <START> long VAR_3 = VAR_4 . METHOD_2 ( VAR_1 ) ; <END> long VAR_5 = VAR_6 . METHOD_2 ( VAR_2 ) ; VAR_7 . METHOD_3 ( VAR_8 - > Math . max ( VAR_3 , VAR_8 ) ) ; VAR_9 . METHOD_3 ( VAR_8 - > Math . max ( VAR_5 , VAR_8 ) ) ; }
<|startcomment|> [ ] ( start = 15 length = 4 ) please <|endcomment|> public final Date METHOD_1 ( ) { <START> return this . VAR_1 ; <END> }
<|startcomment|> constructor call <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , Path VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> this . VAR_5 = null ; <END> this . VAR_6 = null ; this . VAR_7 = true ; this . VAR_4 = VAR_4 ; }
<|startcomment|> existing object ids start 1 define VAR_2 / VAR_4 = 0 default safely : session VAR_1 ( VAR_2 ) || session VAR_3 ( VAR_4 ) <|endcomment|> public boolean METHOD_1 ( ) { if ( session . VAR_1 ( VAR_2 ) ) { return true ; } else { <START> return group != null && session . VAR_3 ( VAR_4 ) ; <END> } }
<|startcomment|> STRING_1 STRING_2 added STANDARD_ALIASES instead creating aliases <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 ) { VAR_1 . METHOD_2 ( STRING_1 , STRING_1 ) ; <START> VAR_1 . METHOD_2 ( STRING_2 , STRING_2 ) ; <END> return VAR_2 ? STRING_3 : STRING_4 ; }
<|startcomment|> final <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <START> List < TYPE_1 > result = VAR_3 . METHOD_2 ( ) <END> . METHOD_3 ( TYPE_1 . class ) . add ( TYPE_4 . METHOD_4 ( STRING_1 , VAR_1 ) ) . add ( TYPE_4 . METHOD_4 ( STRING_2 , VAR_2 ) ) . list ( ) ; return result == null ? new ArrayList < TYPE_1 > ( ) : result ; }
<|startcomment|> double checking intent ? change odd <|endcomment|> public static Boolean METHOD_1 ( TYPE_1 ctx , List VAR_1 , Object target ) { for ( Object VAR_2 : VAR_1 ) { Boolean r = METHOD_2 ( ctx , VAR_2 , target ) ; <START> if ( r != null && r ) return false ; <END> } return true ; }
<|startcomment|> VAR_5 sense called VAR_1 getId ( ) beginning method : null wouldn t arrived code VAR_1 parameter meant - null <|endcomment|> public Optional < TYPE_1 > METHOD_1 ( final TYPE_2 context , final TYPE_1 VAR_1 ) { METHOD_2 ( ) ; final TYPE_1 VAR_2 = VAR_3 . METHOD_3 ( VAR_1 . getId ( ) ) ; if ( VAR_2 != null ) { return Optional . of ( VAR_2 ) ; } else { if ( VAR_4 ) { throw new TYPE_3 ( STRING_1 + VAR_1 ) ; } else { <START> return Optional . VAR_5 ( VAR_1 ) ; <END> } } }
<|startcomment|> need check null ? I write return STRING_1 + VAR_1 + <|endcomment|> public String toString ( ) { <START> return STRING_1 + ( VAR_1 == null ? STRING_2 : VAR_1 ) + <END> STRING_3 + ( VAR_2 == null ? STRING_2 : VAR_2 ) + STRING_4 + ( version == null ? STRING_2 : version ) + STRING_5 + ( VAR_3 == null ? STRING_2 : VAR_3 ) + STRING_6 + Long . toString ( VAR_4 ) + STRING_7 + ( VAR_5 == null ? STRING_2 : VAR_5 . toString ( ) ) + STRING_8 ; }
<|startcomment|> I move 2508 s <|endcomment|> void METHOD_1 ( ) { final boolean VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 . VAR_3 ) ; if ( ! VAR_1 ) { METHOD_4 ( ) ; } else { <START> final int VAR_4 = Math . max ( 1 , TYPE_2 . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> METHOD_7 ( VAR_4 , ( ) - > METHOD_4 ( ) ) ; } }
<|startcomment|> change package - private access <|endcomment|> <START> public String METHOD_1 ( ) { <END> return y ; }
<|startcomment|> calls METHOD_3 a null VAR_2 delete call METHOD_3 ( build VAR_2 ) <|endcomment|> public void run ( ) { Object VAR_1 = METHOD_1 ( ) . METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_1 ) { TYPE_1 build = ( TYPE_1 ) VAR_1 ; if ( VAR_2 != null ) { METHOD_3 ( build , VAR_2 ) ; } else { <START> METHOD_3 ( build ) ; <END> } } else if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_3 = ( TYPE_2 ) VAR_1 ; METHOD_3 ( VAR_3 . METHOD_4 ( ) ) ; } }
<|startcomment|> changed ? logic <|endcomment|> private boolean METHOD_1 ( TYPE_1 token ) { boolean result = false ; if ( ! VAR_1 ) { <START> result = METHOD_2 ( token ) && METHOD_3 ( token ) ; <END> } return result ; }
<|startcomment|> rewrite a single boolean expression : javareturn TYPE_4 TYPE_3 && METHOD_2 ( ) VAR_3 ( ) && <|endcomment|> public boolean METHOD_1 ( String type , TYPE_1 uri , String VAR_1 ) { <START> boolean VAR_2 = true ; <END> VAR_2 &= TYPE_4 . TYPE_3 . toString ( ) . equalsIgnoreCase ( type ) ; VAR_2 &= METHOD_2 ( ) . METHOD_3 ( ) . equalsIgnoreCase ( uri . VAR_3 ( ) ) ; VAR_2 &= METHOD_2 ( ) . METHOD_4 ( ) . equalsIgnoreCase ( uri . VAR_4 ( ) ) ; return VAR_2 ; }
<|startcomment|> VAR_3 ! = null && VAR_3 METHOD_2 ( VAR_2 ) <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 , boolean VAR_2 , String in ) { TYPE_2 VAR_3 = TYPE_3 . get ( VAR_1 ) ; <START> return VAR_3 != null ? VAR_3 . METHOD_2 ( VAR_2 , in ) : false ; <END> }
<|startcomment|> point TYPE_1 protecting map synchronized methods <|endcomment|> private TYPE_4 ( ) { <START> VAR_2 = new TYPE_1 < TYPE_2 , TYPE_3 > ( ) ; <END> }
<|startcomment|> want throw a _CODE_ ? thinking couldn t acquire METHOD_3 return running interceptor a noop method defines <|endcomment|> public final Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { if ( ! VAR_1 ) { return METHOD_2 ( ctx , command ) ; } final Object key = command . getKey ( ) ; try { <START> VAR_2 . METHOD_3 ( key , true ) ; <END> return METHOD_2 ( ctx , command ) ; } finally { VAR_2 . METHOD_4 ( key ) ; } }
<|startcomment|> method need synchronized <|endcomment|> <START> boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> return VAR_2 . contains ( VAR_1 ) && ! VAR_2 . METHOD_2 ( VAR_1 ) . VAR_3 . isEmpty ( ) ; }
<|startcomment|> question ( matter choise ) - don t prefer set ? _CODE_ null empty _CODE_ a null empty list - s problem <|endcomment|> protected void METHOD_1 ( ) { List < TYPE_1 > VAR_1 = null ; if ( getParameters ( ) . METHOD_2 ( ) == null ) { VAR_1 = METHOD_3 ( ) . METHOD_4 ( getParameters ( ) . getId ( ) ) ; } else { VAR_1 = METHOD_3 ( ) . METHOD_5 ( getParameters ( ) . getId ( ) , getParameters ( ) . METHOD_2 ( ) ) ; } <START> if ( VAR_1 != null && VAR_1 . size ( ) > 0 ) { <END> METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; } }
<|startcomment|> package - visible <|endcomment|> <START> TYPE_1 METHOD_1 ( ) throws TYPE_2 { <END> Object VAR_1 = element . VAR_2 ( VAR_3 ) ; if ( VAR_1 instanceof TYPE_1 ) { return ( TYPE_1 ) VAR_1 ; } if ( VAR_1 instanceof TYPE_3 ) { return new TYPE_4 ( ( TYPE_3 ) VAR_1 ) ; } throw new TYPE_5 ( STRING_1 + element . VAR_4 ( ) + STRING_2 + TYPE_6 . VAR_6 + STRING_3 + TYPE_6 . VAR_7 + STRING_4 + TYPE_3 . class . getName ( ) + STRING_5 + VAR_1 . getClass ( ) . getName ( ) ) ; }
<|startcomment|> debug message useful <|endcomment|> public < TYPE_1 > TYPE_1 METHOD_1 ( Long value , Class < TYPE_1 > type , TYPE_2 options ) { <START> log . debug ( STRING_1 ) ; <END> byte [ ] VAR_1 = ByteBuffer . VAR_2 ( Long . VAR_3 ) . METHOD_2 ( value ) . METHOD_3 ( ) ; return ( TYPE_1 ) new TYPE_3 ( VAR_1 ) ; }
<|startcomment|> please add 2 1 7 - experimental <|endcomment|> <START> public final < R > R METHOD_1 ( ANNOTATION_1 TYPE_1 < ? extends R > VAR_1 ) { <END> try { return TYPE_2 . METHOD_2 ( VAR_1 , STRING_1 ) . apply ( this ) ; } catch ( Throwable ex ) { TYPE_3 . METHOD_3 ( ex ) ; throw TYPE_4 . METHOD_4 ( ex ) ; } }
<|startcomment|> a find / replace artifact ? semantically explicitly set 0 ( I imagine ve initialized please IDE / checkstyle ) <|endcomment|> public Object METHOD_1 ( TYPE_1 VAR_1 , int position ) { <START> int VAR_2 = VAR_3 ; <END> switch ( position ) { case VAR_3 : VAR_2 = R . id . VAR_4 ; break ; case VAR_5 : VAR_2 = R . id . VAR_6 ; break ; default : } return METHOD_2 ( ) . METHOD_3 ( VAR_2 ) ; }
<|startcomment|> remove <|endcomment|> public void METHOD_1 ( TYPE_1 uri , TYPE_2 configuration ) throws IOException { <START> this . VAR_1 . METHOD_1 ( uri , configuration ) ; <END> }
<|startcomment|> System VAR_1 ( METHOD_2 ( args ) ) ; <|endcomment|> public static void METHOD_1 ( String [ ] args ) { <START> int status = METHOD_2 ( args ) ; <END> System . VAR_1 ( status ) ; }
<|startcomment|> done <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 writer ) throws TYPE_3 { <START> System . out . println ( writer . VAR_2 ( ) ) ; <END> }
<|startcomment|> changing behaviour I d separately <|endcomment|> public List < ANNOTATION_1 TYPE_1 > METHOD_1 ( ) { <START> return TYPE_2 < ANNOTATION_1 TYPE_1 > METHOD_2 ( ) ; <END> }
<|startcomment|> logic part message s unnecessary check headers suffice <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 message , int VAR_2 ) { boolean VAR_3 = false ; <START> for ( String VAR_4 : message . VAR_5 ( STRING_1 ) ) { <END> if ( VAR_4 . contains ( context . getString ( R . string . VAR_6 ) ) ) VAR_3 = true ; } VAR_7 . METHOD_1 ( VAR_1 , message , VAR_2 , VAR_3 ) ; }
<|startcomment|> I m change intentional shouldn t a difference _CODE_ _CODE_ ( ) METHOD_2 ( ) abstract METHOD_3 ( ) called <|endcomment|> public void METHOD_1 ( TYPE_1 trace ) { super . METHOD_1 ( trace ) ; METHOD_2 ( ) ; <START> METHOD_3 ( ) ; <END> }
<|startcomment|> useful method return a list hadoop jobs killed method caller print <|endcomment|> <START> public static void METHOD_1 ( String VAR_1 , Logger log ) { <END> Set < String > VAR_2 = METHOD_2 ( VAR_1 , log ) ; log . info ( STRING_1 + VAR_2 ) ; for ( String VAR_3 : VAR_2 ) { try { METHOD_3 ( VAR_3 , log ) ; } catch ( Throwable t ) { log . warn ( STRING_2 + VAR_3 , t ) ; } } }
<|startcomment|> inheritance <|endcomment|> public boolean equals ( Object o ) { if ( o == null ) { return false ; } if ( this == o ) { return true ; } <START> if ( ! ( this . getClass ( ) . equals ( o . getClass ( ) ) ) ) { <END> return false ; } TYPE_1 that = ( TYPE_1 ) o ; return TYPE_2 . METHOD_1 ( VAR_1 , that . VAR_1 ) ; }
<|startcomment|> need change some other tests ? VAR_5 METHOD_3 <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( ) ; METHOD_3 ( METHOD_4 ( VAR_1 ) ) ; VAR_2 . METHOD_5 ( VAR_1 , 0 ) ; <START> client . VAR_3 ( VAR_4 ) ; <END> TYPE_1 node = VAR_5 . METHOD_6 ( ) . iterator ( ) . next ( ) ; client . VAR_6 ( node , INT_1 ) ; assertEquals ( 0 , VAR_7 . METHOD_7 ( ) ) ; time . VAR_8 ( INT_1 ) ; assertEquals ( 1 , VAR_7 . METHOD_7 ( ) ) ; }
<|startcomment|> merge lines METHOD_1 return argument <|endcomment|> public TYPE_3 ( TYPE_1 data ) { TYPE_2 . METHOD_1 ( data , STRING_1 ) ; <START> this . data = data ; <END> }
<|startcomment|> I clearer VAR_2 remove block I don t throwing IOException METHOD_3 done a problem linkedlist remove ( ) case VAR_1 close ( ) s block <|endcomment|> public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> VAR_2 . remove ( VAR_1 ) ; <END> VAR_1 . close ( ) ; } catch ( IOException VAR_3 ) { VAR_4 . VAR_5 . METHOD_2 ( VAR_1 , VAR_3 ) ; } finally { METHOD_3 ( ) ; } }
<|startcomment|> display todo a search VAR_1 a bug _CODE_ code wrong <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> String VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) ; <END> List < TYPE_2 > VAR_3 = VAR_4 . METHOD_4 ( VAR_1 ) ; List < TYPE_1 > VAR_5 = new ArrayList < TYPE_1 > ( VAR_3 . size ( ) ) ; for ( TYPE_2 VAR_6 : VAR_3 ) { VAR_5 . add ( new TYPE_3 ( VAR_6 , this ) ) ; } return VAR_5 ; }
<|startcomment|> point pass VAR_2 instead <|endcomment|> protected TYPE_4 ( TYPE_1 item , TYPE_1 VAR_2 , Integer VAR_3 , TYPE_2 config ) { this . item = item ; this . VAR_3 = VAR_3 ; if ( config instanceof TYPE_3 ) { TYPE_3 VAR_4 = ( TYPE_3 ) config ; <START> VAR_4 . METHOD_1 ( item , VAR_2 ) ; <END> this . config = VAR_4 ; } else { this . config = config ; } }
<|startcomment|> consider replacing 96 - 97 block ( line 455 ) <|endcomment|> public static void METHOD_1 ( File source , File VAR_1 ) throws IOException { <START> try ( TYPE_1 in = new TYPE_2 ( source ) ) { <END> try ( TYPE_3 out = new TYPE_4 ( new TYPE_5 ( VAR_1 ) ) ) { METHOD_2 ( in , out ) ; } } }
<|startcomment|> set ( ) care simply return result set ( ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_2 ( this ) ; TYPE_2 list = this . VAR_2 ; <START> TYPE_1 VAR_3 = list . VAR_4 ( VAR_1 . METHOD_3 ( ) ) ; <END> list . set ( VAR_1 ) ; return VAR_3 ; }
<|startcomment|> call ( VAR_2 VAR_3 data null ) <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , long VAR_3 , byte [ ] data ) { <START> this . VAR_2 = VAR_2 ; <END> this . VAR_3 = VAR_3 ; this . data = data ; this . VAR_4 = VAR_2 . VAR_5 ; }
<|startcomment|> parameter names <|endcomment|> <START> public boolean METHOD_1 ( char VAR_1 , int VAR_2 ) { <END> if ( super . METHOD_1 ( VAR_1 , VAR_2 ) || ! VAR_3 ) { return true ; } else if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { this . METHOD_3 ( TYPE_2 . toString ( VAR_1 ) ) ; return true ; } else { return false ; } }
<|startcomment|> great return empty map instead null <|endcomment|> Map < String , String > METHOD_1 ( ) throws TYPE_1 , TYPE_2 { Map < String , String > parameters ; try { parameters = TYPE_3 . METHOD_1 ( ) ; } catch ( IOException e ) { throw new TYPE_2 ( e ) ; } <START> return parameters ; <END> }
<|startcomment|> move METHOD_2 checks a separate line calling inline messy <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , List < TYPE_3 > VAR_2 ) { <START> TYPE_1 VAR_3 = new TYPE_1 ( METHOD_2 ( VAR_1 , STRING_1 ) , METHOD_2 ( VAR_2 , STRING_2 ) ) ; <END> VAR_3 . METHOD_3 ( ) ; return VAR_3 ; }
<|startcomment|> inorg eclipse mylyn commons core TYPE_2 _CODE_ ( TYPE_3 ) <|endcomment|> public static TYPE_1 METHOD_1 ( ) { TYPE_2 < TYPE_1 > reader = new TYPE_2 < TYPE_1 > ( TYPE_6 . VAR_2 , STRING_1 , STRING_1 , TYPE_1 . class ) ; TYPE_3 status = reader . read ( ) ; if ( ! status . VAR_3 ( ) ) { <START> TYPE_4 . log ( status ) ; <END> } TYPE_1 VAR_4 = reader . VAR_5 ( ) ; if ( VAR_4 != null ) { return VAR_4 ; } return new TYPE_5 ( ) ; }
<|startcomment|> s a _CODE_ buffer append ( message ) append ( STRING_1 ) ; PS : wrong ping <|endcomment|> public void METHOD_1 ( String message ) { <START> buffer . append ( message + STRING_1 ) ; <END> }
<|startcomment|> a VAR_5 I 2 VAR_3 variant information added TYPE_1 _CODE_ : added _CODE_ - adds existing variant metric removing line starts work correctly <|endcomment|> private void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 , final int VAR_3 , final Boolean VAR_4 , final String VAR_5 ) { final TYPE_2 VAR_6 = new TYPE_2 ( ) ; VAR_6 . METHOD_2 ( VAR_1 ) ; VAR_6 . METHOD_3 ( VAR_2 ) ; VAR_6 . METHOD_4 ( VAR_3 ) ; VAR_6 . METHOD_5 ( VAR_4 ) ; VAR_6 . METHOD_6 ( VAR_5 ) ; <START> VAR_1 . METHOD_7 ( ) . add ( VAR_6 ) ; <END> VAR_7 . METHOD_8 ( VAR_6 ) ; }
<|startcomment|> private <|endcomment|> <START> public void METHOD_1 ( ) { <END> VAR_1 = new TYPE_1 ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) , this ) ; TYPE_3 VAR_3 = new TYPE_3 ( ) { @Override public void METHOD_3 ( Collection < ? extends TYPE_4 > VAR_4 ) { VAR_5 . METHOD_4 ( VAR_4 ) ; VAR_5 . METHOD_5 ( ) . remove ( VAR_4 ) ; VAR_5 . METHOD_5 ( ) . METHOD_6 ( VAR_6 ) ; } } ; VAR_7 = new TYPE_5 ( ( TYPE_2 ) VAR_2 . METHOD_2 ( ) , this , VAR_3 ) ; }
<|startcomment|> move _CODE_ _CODE_ ( ) <|endcomment|> ANNOTATION_1 public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } if ( cache != null ) { cache . VAR_2 ( ) ; } client . VAR_3 ( ) . METHOD_3 ( ) ; <START> if ( client . VAR_3 ( ) . METHOD_4 ( ) > 0 ) { <END> System . out . println ( STRING_1 ) ; Thread . VAR_4 ( INT_1 ) ; System . out . println ( STRING_2 + client . VAR_3 ( ) . METHOD_4 ( ) ) ; } }
<|startcomment|> Arrays toString <|endcomment|> public void METHOD_1 ( String ... VAR_1 ) { try { METHOD_2 ( Arrays . stream ( VAR_1 ) ) ; } catch ( TYPE_1 e ) { <START> throw new TYPE_1 ( STRING_1 + VAR_1 , e . VAR_2 ( ) ) ; <END> } super . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> kind breaks clean streak new client ( ) calls arguments adhere pattern <|endcomment|> protected void METHOD_1 ( int VAR_1 ) { if ( VAR_1 == 0 ) { METHOD_2 ( ) ; } METHOD_3 ( new TYPE_1 ( ) ) ; METHOD_3 ( new TYPE_2 ( ) ) ; METHOD_3 ( new TYPE_3 ( ) ) ; METHOD_3 ( new TYPE_4 ( ) ) ; METHOD_3 ( new TYPE_5 ( ) ) ; <START> METHOD_3 ( new TYPE_6 ( new TYPE_7 ( METHOD_4 ( ) , METHOD_5 ( ) ) ) ) ; <END> }
<|startcomment|> debugging logging ? level log error <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) throws Exception { TYPE_3 . debug ( STRING_1 + VAR_1 ) ; TYPE_4 request = METHOD_2 ( VAR_1 ) . METHOD_3 ( TYPE_5 . create ( VAR_3 , VAR_2 ) ) . build ( ) ; <START> TYPE_3 . error ( VAR_1 . toString ( ) ) ; <END> TYPE_3 . error ( VAR_2 ) ; TYPE_6 call = client . VAR_4 ( request ) ; Response response = call . execute ( ) ; return TYPE_1 . from ( response ) ; }
<|startcomment|> need public - public class <|endcomment|> <START> public TYPE_1 ( List < T > VAR_2 ) { <END> this . VAR_2 = VAR_2 ; this . i = 0 ; }
<|startcomment|> haha fair enough <|endcomment|> <START> private void METHOD_1 ( TYPE_2 . TYPE_3 [ ] VAR_1 ) { <END> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { VAR_1 [ i ] . METHOD_2 ( ) ; } }
<|startcomment|> METHOD_2 handles null <|endcomment|> public void METHOD_1 ( TYPE_1 output ) throws IOException { output . VAR_1 ( VAR_2 ) ; if ( VAR_2 != null ) { output . VAR_3 ( id ) ; } output . VAR_4 ( VAR_5 ) ; <START> if ( VAR_6 != null ) { <END> TYPE_2 . METHOD_2 ( VAR_6 , output ) ; } else { assert VAR_7 != null ; TYPE_2 . METHOD_3 ( VAR_7 , output ) ; } }
<|startcomment|> good a null case _CODE_ <|endcomment|> public static TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( METHOD_2 ( ) , METHOD_3 ( 1 , INT_1 ) , METHOD_2 ( ) ) ; <END> }
<|startcomment|> function private <|endcomment|> <START> boolean METHOD_1 ( String VAR_1 ) { <END> String VAR_2 = VAR_1 + VAR_3 ; return VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . class , VAR_2 + STRING_1 ) ) && VAR_4 . remove ( TYPE_1 . name ( Log . VAR_5 , VAR_2 + STRING_2 ) ) && VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . VAR_5 , VAR_2 + STRING_3 ) ) && VAR_4 . remove ( TYPE_1 . name ( TYPE_2 . VAR_5 , VAR_2 + STRING_4 ) ) ; }
<|startcomment|> need <|endcomment|> public void METHOD_1 ( ) { <START> this . METHOD_2 ( ( ) - > { <END> log . info ( STRING_1 ) ; METHOD_3 ( ) ; METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; METHOD_4 ( ) . METHOD_5 ( VAR_2 ) ; VAR_3 = true ; } ) ; }
<|startcomment|> a regression longer works multiple repositories note extra code handles multiple repositories <|endcomment|> public boolean METHOD_1 ( ) { <START> return METHOD_2 ( ) ; <END> }
<|startcomment|> updating code replace plain asserts testing framework <|endcomment|> private void METHOD_1 ( float VAR_1 ) { METHOD_2 ( STRING_1 , VAR_1 ) ; <START> assert VAR_1 == VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> }
<|startcomment|> covered TYPE_1 <|endcomment|> public static boolean METHOD_1 ( Class < ? > VAR_1 ) { if ( VAR_1 == null ) { return false ; } else if ( VAR_1 . METHOD_2 ( ) ) { return TYPE_1 . contains ( VAR_1 ) ; } else { <START> return TYPE_2 . class . METHOD_3 ( VAR_1 ) ; <END> } }
<|startcomment|> type List < Object > <|endcomment|> public List < TYPE_1 > METHOD_1 ( TYPE_2 element , TYPE_2 VAR_1 , int VAR_2 ) { <START> ArrayList < Object > VAR_3 = new ArrayList < > ( ) ; <END> return METHOD_1 ( element , VAR_1 , VAR_3 , VAR_4 , VAR_2 ) ; }
<|startcomment|> a - avoid checking 2 conditions ( true CAS ) <|endcomment|> public final TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <START> while ( true ) { <END> TYPE_1 < TYPE_2 > VAR_2 = VAR_3 . get ( ) ; if ( VAR_3 . METHOD_2 ( VAR_2 , VAR_1 ) ) return VAR_2 ; } }
<|startcomment|> TYPE_3 implement TYPE_1 VAR_2 function return VAR_2 ; means classes lines code read a delta 🙃 <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return new TYPE_1 ( ) { @Override public boolean METHOD_2 ( ) { return TYPE_3 . this . METHOD_2 ( ) ; } @Override public TYPE_2 METHOD_3 ( ) { return TYPE_3 . VAR_2 . METHOD_3 ( ) ; } @Override public void METHOD_4 ( ) { TYPE_3 . VAR_2 . METHOD_4 ( ) ; } } ; <END> }
<|startcomment|> METHOD_2 copies elements list array I depend implementation ways loop lose type information <|endcomment|> public void METHOD_1 ( ) { <START> for ( Object VAR_1 : VAR_2 . METHOD_2 ( ) ) { <END> TYPE_1 VAR_3 = ( TYPE_1 ) VAR_1 ; VAR_3 . METHOD_3 ( TYPE_1 . TYPE_2 . VAR_5 , STRING_1 ) ; } VAR_6 . set ( false ) ; }
<|startcomment|> initial size HashMap <|endcomment|> public void METHOD_1 ( long VAR_1 , TYPE_1 location ) { <START> VAR_2 . METHOD_2 ( VAR_1 , x - > new HashMap < > ( ) ) ; <END> VAR_2 . get ( VAR_1 ) . put ( location . VAR_3 ( ) , location ) ; }
<|startcomment|> METHOD_1 ( ) method - I - <|endcomment|> public String getName ( ) { return METHOD_1 ( Constants . VAR_1 ) != null <START> ? VAR_2 . METHOD_2 ( ) . get ( Constants . VAR_1 ) <END> : METHOD_3 ( ) ; }
<|startcomment|> please diamond operator i e < > instead type parameters reduces clutter code easier maintain <|endcomment|> public TYPE_6 ( TYPE_1 project , TYPE_2 VAR_2 ) { this . project = project ; this . VAR_2 = VAR_2 ; VAR_3 = ( TYPE_3 ) TYPE_4 . METHOD_1 ( ) ; <START> parameters = new HashMap < String , List < TYPE_5 > > ( ) ; <END> }
<|startcomment|> s DRY String url = VAR_3 METHOD_4 ( ) METHOD_5 ( ) METHOD_6 ( ) ; VAR_2 METHOD_3 ( url ) ; VAR_2 METHOD_7 ( url ) ; <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { if ( ! METHOD_2 ( ) ) { VAR_2 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <START> VAR_2 . METHOD_7 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; <END> } } }
<|startcomment|> VAR_4 variable ; remove itreturn VAR_2 ; <|endcomment|> public int read ( int offset , int [ ] VAR_1 , int VAR_2 ) { VAR_3 = METHOD_1 ( VAR_3 , VAR_1 , VAR_2 ) ; <START> VAR_4 = VAR_2 ; <END> return VAR_4 ; }
<|startcomment|> method synchronized <|endcomment|> <START> public void start ( TYPE_1 ctx ) <END> throws TYPE_2 { if ( VAR_1 == null ) { VAR_1 = new TYPE_3 ( ) ; VAR_1 . start ( ) ; } }
<|startcomment|> wouldn t preferred store type case instead creating time method invoked <|endcomment|> public String getValue ( ) { <START> return name ( ) . METHOD_1 ( ) ; <END> }
<|startcomment|> start stop called time <|endcomment|> <START> public boolean start ( ) <END> { if ( ! VAR_1 . get ( ) ) { LOGGER . info ( STRING_1 , id ) ; VAR_1 . set ( VAR_2 . METHOD_1 ( ) ) ; } return VAR_1 . get ( ) ; }
<|startcomment|> moved METHOD_5 <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 , final String VAR_2 ) { try { TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { <START> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_3 ( ) ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } METHOD_5 ( VAR_1 . METHOD_3 ( ) , VAR_3 , false ) ; METHOD_5 ( VAR_1 . METHOD_3 ( ) , VAR_4 , false ) ; }
<|startcomment|> I assume VAR_2 ! = null <|endcomment|> public int METHOD_1 ( ) { final int VAR_1 = INT_1 ; int result = 1 ; result = VAR_1 * result <START> + ( ( VAR_2 == null ) ? 0 : VAR_2 . METHOD_1 ( ) ) ; <END> result = VAR_1 * result + ( ( VAR_3 == null ) ? 0 : VAR_3 . METHOD_1 ( ) ) ; return result ; }
<|startcomment|> I List fine <|endcomment|> private <START> List < TYPE_1 > list ( final <END> TYPE_2 request ) throws TYPE_3 { TYPE_4 VAR_1 = VAR_2 . get ( ) ; VAR_1 . METHOD_1 ( request . VAR_3 ( ) ) ; VAR_1 . METHOD_2 ( request . VAR_4 ( ) ) ; VAR_1 . METHOD_3 ( request . VAR_5 ( ) ) ; VAR_1 . METHOD_4 ( request . VAR_6 ( ) ) ; Map < String , TYPE_1 > result = VAR_1 . apply ( ) ; return ImmutableList . VAR_7 ( result . values ( ) ) ; }
<|startcomment|> replace 1 line : assertEquals ( _CODE_ TYPE_3 item VAR_3 ( ) ) ; <|endcomment|> public void METHOD_1 ( ) { <START> Long VAR_1 = TYPE_2 . TYPE_3 . getId ( ) ; <END> Long VAR_2 = item . VAR_3 ( ) . getId ( ) ; assertEquals ( VAR_1 , VAR_2 ) ; }
<|startcomment|> I put pause <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; <START> ( ( TYPE_1 ) METHOD_2 ( ) ) . METHOD_3 ( ) . METHOD_4 ( true ) ; <END> VAR_1 . METHOD_5 ( ) . METHOD_6 ( this ) ; }
<|startcomment|> a constuctor takes a TYPE_3 list VAR_1 VAR_1 member final class immutable <|endcomment|> <START> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { <END> logger . debug ( STRING_1 , VAR_1 ) ; TYPE_3 VAR_2 = new TYPE_3 ( this ) ; VAR_2 . VAR_1 = VAR_1 ; return VAR_2 ; }
<|startcomment|> finally <|endcomment|> private void METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = this . connection . VAR_3 ( ) ; VAR_2 . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . close ( ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> need resolve paths iteration - need resolved resolve level passing resolved parse transforms method <|endcomment|> private void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 Collection < TYPE_2 > VAR_2 , ANNOTATION_1 List < String > VAR_3 ) { for ( TYPE_2 VAR_4 : VAR_2 ) { Set < String > VAR_5 = TYPE_3 . METHOD_2 ( ) ; TYPE_4 VAR_6 = METHOD_3 ( VAR_4 ) ; METHOD_4 ( VAR_1 , VAR_6 , VAR_5 ) ; <START> VAR_5 . addAll ( METHOD_5 ( VAR_3 , VAR_1 ) ) ; <END> VAR_7 . put ( VAR_4 . getPath ( ) , TYPE_3 . METHOD_6 ( VAR_5 ) ) ; } }
<|startcomment|> line moved method <|endcomment|> public void METHOD_1 ( ) throws IOException { String [ ] VAR_1 = new String [ ] { STRING_1 , STRING_2 , STRING_3 , STRING_4 } ; <START> TYPE_1 VAR_2 = new TYPE_2 ( VAR_3 ) ; <END> List < String > VAR_4 = new ArrayList < > ( ) ; VAR_2 . METHOD_2 ( VAR_4 , VAR_1 , 3 , null ) ; Assert . assertEquals ( 2 , VAR_4 . size ( ) ) ; Assert . assertTrue ( VAR_4 . contains ( STRING_5 ) ) ; Assert . assertTrue ( VAR_4 . contains ( STRING_6 ) ) ; }
<|startcomment|> assertThat ( VAR_6 ) isEmpty ( ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = VAR_2 . create ( db , VAR_3 . METHOD_2 ( ) ) ; TYPE_4 . TYPE_5 VAR_4 = VAR_1 . to ( VAR_5 , STRING_1 ) . METHOD_3 ( ) ; List < TYPE_3 > VAR_6 = METHOD_4 ( VAR_4 ) ; <START> assertThat ( VAR_6 . size ( ) ) . METHOD_5 ( 0 ) ; <END> }
<|startcomment|> moved : _CODE_ <|endcomment|> protected void METHOD_1 ( ) { boolean VAR_1 = METHOD_2 ( ) . getStatus ( ) == TYPE_2 . TYPE_1 && METHOD_2 ( ) . METHOD_3 ( ) != null ; METHOD_4 ( VAR_1 ? METHOD_5 ( ) : METHOD_6 ( ) ) ; <START> VAR_4 . METHOD_7 ( METHOD_2 ( ) , VAR_5 , METHOD_8 ( ) ) ; <END> }
<|startcomment|> able simplify test case _CODE_ annotations <|endcomment|> <START> public void METHOD_1 ( ) { <END> try { TYPE_1 . METHOD_2 ( STRING_1 ) ; METHOD_3 ( STRING_2 ) ; } catch ( TYPE_2 e ) { } }
<|startcomment|> performance issues foreach ? <|endcomment|> public static String toString ( int VAR_1 ) { try { TYPE_1 [ ] VAR_2 = TYPE_2 . class . METHOD_1 ( ) ; <START> for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { <END> TYPE_1 field = VAR_2 [ i ] ; if ( field . getInt ( null ) == VAR_1 ) { return field . getName ( ) ; } } } catch ( TYPE_3 e ) { } return STRING_1 + VAR_1 + STRING_2 ; }
<|startcomment|> line correctly ? : ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( List < String > VAR_1 ) throws TYPE_2 { <START> if ( VAR_1 == null || ! VAR_1 . isEmpty ( ) ) { <END> throw new TYPE_2 ( STRING_1 , ( Object [ ] ) null ) ; } return VAR_2 . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> static <|endcomment|> <START> private int METHOD_1 ( final String VAR_1 , <END> final String VAR_2 ) { final TYPE_1 matcher = TYPE_2 . METHOD_2 ( VAR_2 ) . matcher ( VAR_1 ) ; final List < String > VAR_3 = new ArrayList < > ( ) ; while ( matcher . VAR_4 ( ) ) { VAR_3 . add ( matcher . group ( ) ) ; } return VAR_3 . size ( ) ; }
<|startcomment|> I don t verifies called method call throw <|endcomment|> public void METHOD_1 ( ) { String VAR_1 = STRING_1 ; when ( VAR_2 . METHOD_2 ( METHOD_3 ( ) ) ) . METHOD_4 ( null ) ; VAR_3 . METHOD_5 ( VAR_1 ) ; Assert . assertNotNull ( VAR_2 . METHOD_2 ( VAR_1 ) ) ; <START> METHOD_6 ( VAR_2 ) . METHOD_2 ( VAR_1 ) ; <END> METHOD_6 ( VAR_3 ) . METHOD_5 ( VAR_1 ) ; }
<|startcomment|> don t VAR_5 ( ) instead write logger log error ( < message > e ) ; <|endcomment|> public void run ( ) { log . info ( Thread . VAR_1 ( ) . getName ( ) + STRING_1 ) ; try { VAR_2 . METHOD_1 ( VAR_3 , VAR_4 ) ; } catch ( IOException e ) { <START> e . VAR_5 ( ) ; <END> } log . info ( Thread . VAR_1 ( ) . getName ( ) + STRING_2 ) ; }
<|startcomment|> return a copy graph instead a reference ? s point a read METHOD_3 returning reference I m worried callers alter graph some <|endcomment|> public TYPE_1 METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) ; try { <START> return VAR_2 ; <END> } finally { VAR_1 . METHOD_2 ( ) . METHOD_4 ( ) ; } }
<|startcomment|> a slow test ( 15 seconds parameterized run ) permutations overkill remove ( VAR_3 false ) give coverage lock granularities / input format API <|endcomment|> public static TYPE_1 < Object [ ] > METHOD_1 ( ) { return ImmutableList . of ( <START> new Object [ ] { TYPE_2 . VAR_2 , false } , new Object [ ] { TYPE_2 . VAR_2 , true } , new Object [ ] { TYPE_2 . VAR_3 , false } , new Object [ ] { TYPE_2 . VAR_3 , true } <END> ) ; }
<|startcomment|> add preconditions _CODE_ checks verify passed VAR_1 buffer null <|endcomment|> <START> public static ByteBuffer METHOD_1 ( final TYPE_1 VAR_1 , ByteBuffer buffer ) { <END> if ( buffer . position ( ) < buffer . VAR_2 ( ) ) { return buffer ; } ByteBuffer VAR_3 = METHOD_2 ( buffer , VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ) ; buffer . VAR_4 ( ) ; VAR_3 . put ( buffer ) ; return VAR_3 ; }
<|startcomment|> s static import assertions org junit Assert don t need prefix Assert <|endcomment|> public void METHOD_1 ( ) { TYPE_1 parser = new TYPE_1 ( ) ; String VAR_1 = STRING_1 ; String VAR_2 = STRING_2 ; Assert . assertTrue ( parser . parse ( VAR_1 ) . METHOD_2 ( ) ) ; <START> Assert . assertEquals ( parser . parse ( VAR_1 ) , parser . parse ( VAR_2 ) ) ; <END> }
<|startcomment|> suggestionthis ( TYPE_2 valueOf ( VAR_2 ) TYPE_2 VAR_6 ) ; <|endcomment|> public TYPE_4 ( double VAR_2 ) { <START> this . VAR_3 = new TYPE_1 < > ( <END> VAR_4 , TYPE_3 < String > METHOD_1 ( ) , TYPE_2 . valueOf ( VAR_2 ) , TYPE_2 . VAR_6 ) ; }
<|startcomment|> message unused remove line <|endcomment|> public boolean METHOD_1 ( TYPE_1 command , TYPE_2 response ) { boolean VAR_1 = false ; try { byte [ ] data = METHOD_2 ( response ) ; <START> String message = data != null ? new String ( data ) : null ; <END> switch ( response . VAR_2 ( ) ) { case INT_1 : case INT_2 : VAR_1 = super . METHOD_1 ( command , response ) ; break ; default : break ; } } finally { METHOD_3 ( response ) ; } return VAR_1 ; }
<|startcomment|> don t need deal else variant ? other hand TYPE_2 t implement TYPE_3 delegate ? I some overhead disable auto - recovery fill cache <|endcomment|> public static void METHOD_1 ( TYPE_1 channel ) { if ( channel instanceof TYPE_2 ) { if ( ( ( TYPE_2 ) channel ) . METHOD_2 ( ) instanceof TYPE_3 ) { <START> TYPE_3 VAR_1 = ( TYPE_3 ) ( ( TYPE_2 ) channel ) <END> . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( VAR_1 , Boolean . VAR_3 ) == null ) { VAR_1 . METHOD_4 ( VAR_4 ) ; } } } }
<|startcomment|> thinking call happen other types registered oven _CODE_ a specific reason occurs <|endcomment|> public TYPE_4 ( final TYPE_1 config , final TYPE_2 db , final File VAR_2 , final File VAR_3 ) { super ( config , db , VAR_2 , VAR_3 ) ; this . VAR_4 = new TYPE_3 ( config , db , VAR_2 , VAR_3 ) ; <START> this . METHOD_1 ( ) ; <END> }
<|startcomment|> private <|endcomment|> <START> TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) <END> { int VAR_2 = 0 ; TYPE_1 < TYPE_2 > VAR_3 = new TYPE_3 < > ( VAR_1 ? metadata . VAR_4 . METHOD_2 ( ) : metadata . VAR_4 ) ; while ( VAR_2 <= VAR_5 ) { int VAR_6 = VAR_7 . METHOD_3 ( VAR_5 / 10 ) * ( VAR_7 . METHOD_3 ( 3 ) + 2 / 3 ) ; VAR_2 += VAR_6 ; VAR_3 . add ( METHOD_4 ( VAR_2 ) ) ; } return VAR_3 ; }
<|startcomment|> getters a POJO return type private member variables expose case I d recommend VAR_2 dateformat _CODE_ Optional < > s ( member variable types getter types ) jackson YAML deserialization automatically care setting a missing field empty Optional < > resulting java object <|endcomment|> <START> public Optional < String > METHOD_1 ( ) { <END> return Optional . VAR_1 ( VAR_2 ) ; }
<|startcomment|> newline ANNOTATION_1 public s 4 instances libcore source hundreds line <|endcomment|> ANNOTATION_1 <START> public void <END> METHOD_1 ( ) { try { new TYPE_1 ( null ) { } ; METHOD_2 ( ) ; } catch ( TYPE_2 VAR_1 ) { } }
<|startcomment|> remove change please <|endcomment|> public boolean METHOD_1 ( TYPE_1 node ) throws TYPE_2 { if ( node . VAR_1 ( ) ) { if ( VAR_2 != null ) { throw new TYPE_3 ( STRING_1 ) ; } this . VAR_2 = node ; this . VAR_1 = true ; <START> } else if ( node . getClass ( ) . METHOD_2 ( TYPE_4 . class ) ) { <END> this . VAR_1 = true ; } return true ; }
<|startcomment|> TYPE_1 METHOD_2 ( VAR_1 VAR_2 VAR_3 ) ; <|endcomment|> public int METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( VAR_1 + VAR_2 + VAR_3 ) ; <END> }
<|startcomment|> return VAR_2 METHOD_2 ( VAR_1 ) = = null ; <|endcomment|> public boolean METHOD_1 ( String name , TYPE_1 VAR_1 ) { TYPE_1 value = VAR_2 . METHOD_2 ( name , VAR_1 ) ; if ( value == null ) return true ; else return false ; <START> } <END>
<|startcomment|> replace qualified import <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) != null || METHOD_3 ( ) == null ? this : org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . TYPE_2 . METHOD_1 ( METHOD_3 ( ) ) ; <END> }
<|startcomment|> move TYPE_1 <|endcomment|> private void METHOD_1 ( ) { <START> TYPE_1 . METHOD_2 ( VAR_1 , new TYPE_1 . TYPE_3 ( ) { <END> @Override public void METHOD_3 ( ) { METHOD_4 ( TYPE_4 . VAR_3 ) ; } } ) ; }
<|startcomment|> doesn t need final <|endcomment|> public < T > T METHOD_1 ( TYPE_1 < T > type ) { Assert . VAR_1 ( type , STRING_1 ) ; <START> final String url = METHOD_2 ( true ) ; <END> return VAR_2 . METHOD_3 ( url , VAR_3 , METHOD_4 ( VAR_4 ) , type ) . METHOD_5 ( ) ; }
<|startcomment|> please inline variable <|endcomment|> public TYPE_1 METHOD_1 ( List < ? extends TYPE_2 > VAR_1 ) { for ( TYPE_2 VAR_2 : VAR_1 ) { String <START> VAR_3 = <END> VAR_2 . METHOD_2 ( ) ; if ( VAR_3 != null ) { if ( ! TYPE_3 . matcher ( VAR_2 . METHOD_2 ( ) ) . METHOD_3 ( ) ) { return new TYPE_1 ( TYPE_4 . VAR_5 , String . format ( STRING_1 , VAR_2 . getName ( ) ) , String . format ( STRING_2 , VAR_2 . METHOD_2 ( ) ) ) ; } } } return TYPE_1 . VAR_6 ; }
<|startcomment|> true instead ( s a read - operation ) <|endcomment|> public List < TYPE_1 > METHOD_1 ( final TYPE_2 VAR_1 , final TYPE_3 VAR_2 , final TYPE_4 context ) throws TYPE_5 { <START> return VAR_3 . execute ( false , TYPE_5 . class , new TYPE_6 < List < TYPE_1 > > ( ) { <END> @Override public List < TYPE_1 > METHOD_2 ( final TYPE_7 VAR_4 ) throws TYPE_8 , TYPE_9 { final TYPE_10 VAR_5 = VAR_4 . METHOD_3 ( TYPE_10 . class ) ; return VAR_6 . METHOD_1 ( VAR_5 , TYPE_11 . VAR_8 , VAR_1 , VAR_2 , context ) ; } } ) ; }
<|startcomment|> return <|endcomment|> public void run ( ) { while ( true ) { METHOD_1 ( VAR_1 , Long . VAR_2 , VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) , VAR_3 . METHOD_4 ( ) . METHOD_3 ( ) ) ; synchronized ( VAR_4 ) { if ( VAR_5 ) { VAR_5 = false ; } else { VAR_4 . remove ( VAR_1 . METHOD_5 ( ) ) ; <START> break ; <END> } } } }
<|startcomment|> wouldn t Arrays asList ( ) enough ? Arrays stream a lot memory overhead <|endcomment|> public final Object METHOD_1 ( TYPE_1 ctx , TYPE_2 command ) throws Throwable { try { if ( METHOD_2 ( command ) ) { return METHOD_3 ( ctx , command ) ; } <START> METHOD_4 ( ctx , Arrays . stream ( command . VAR_1 ( ) ) , METHOD_5 ( command ) ) ; <END> return METHOD_3 ( ctx , command ) ; } finally { if ( ! ctx . VAR_2 ( ) ) { VAR_3 . METHOD_6 ( ctx ) ; } } }
<|startcomment|> esoteric s wrong - 0 0 <|endcomment|> public TYPE_1 ( double VAR_2 , double VAR_3 ) { <START> VAR_4 = VAR_3 + FLOAT_1 ; <END> VAR_5 = VAR_2 + FLOAT_1 ; if ( VAR_4 < - FLOAT_2 || VAR_4 > FLOAT_2 ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_5 < - FLOAT_3 || VAR_5 > FLOAT_3 ) { throw new IllegalArgumentException ( STRING_2 ) ; } }
<|startcomment|> TYPE_3 english ? based formats give I m effect other locales <|endcomment|> public final static TYPE_1 getInstance ( ) { try { <START> return new TYPE_1 ( ) ; <END> } catch ( TYPE_2 e ) { return new TYPE_1 ( TYPE_3 . VAR_2 ) ; } }
<|startcomment|> statement : ) <|endcomment|> private static void METHOD_1 ( ) { switch ( TYPE_1 . METHOD_2 ( ) ) { <START> case TYPE_1 . VAR_1 : <END> TYPE_2 . METHOD_3 ( ) ; break ; } }
<|startcomment|> unused <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { Date VAR_2 = METHOD_2 ( VAR_1 ) ; <START> Date VAR_3 = METHOD_3 ( VAR_1 ) ; <END> VAR_1 . METHOD_4 ( VAR_2 ) ; }
<|startcomment|> test _CODE_ ( ) _CODE_ call moved i code duplication espresso clicks test method i suspected clicks reading tests <|endcomment|> protected TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = METHOD_2 ( TYPE_1 . class ) ; <END> } return VAR_1 ; }
<|startcomment|> I final <|endcomment|> <START> public long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> set VAR_4 default create connection return statement <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , String VAR_2 ) throws TYPE_3 { TYPE_1 connection = null ; TYPE_4 VAR_3 = METHOD_2 ( VAR_1 ) ; TYPE_5 VAR_4 = TYPE_6 . get ( VAR_3 . getId ( ) ) ; if ( VAR_4 != null ) { connection = VAR_4 . METHOD_1 ( VAR_1 , VAR_2 ) ; } else { <START> connection = TYPE_7 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> } return connection ; }
<|startcomment|> I d previous patch <|endcomment|> protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = getParameters ( ) . METHOD_2 ( ) ; return METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( VAR_1 . getId ( ) ) ) && <START> METHOD_3 ( METHOD_4 ( ) . METHOD_6 ( VAR_1 . METHOD_7 ( ) , <END> VAR_1 . METHOD_8 ( ) ) ) ; }
<|startcomment|> I logic reside a service controller class A DTO properties getters setters a unit test logic <|endcomment|> public void METHOD_1 ( final String VAR_1 ) { final Integer VAR_2 = TYPE_1 . METHOD_2 ( VAR_1 ) ; <START> if ( VAR_2 > 0 ) { <END> this . VAR_1 = Integer . toString ( VAR_2 ) ; } else { this . VAR_1 = VAR_1 ; } }
<|startcomment|> won t exit loop need return <|endcomment|> protected TYPE_1 run ( TYPE_2 monitor ) { while ( ! monitor . VAR_1 ( ) ) { try { Thread . VAR_2 ( VAR_3 ) ; } catch ( InterruptedException e ) { <START> Thread . VAR_4 ( ) . METHOD_1 ( ) ; <END> } } monitor . VAR_5 ( ) ; return Status . VAR_6 ; }
<|startcomment|> t id _CODE_ check instead other ? option more flexible hard code english locale <|endcomment|> public void METHOD_1 ( TYPE_1 event , List < TYPE_2 > VAR_1 ) { String id = event . VAR_2 ( ) . getId ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { <START> if ( VAR_3 . getType ( ) . METHOD_2 ( STRING_1 , STRING_2 ) . METHOD_3 ( TYPE_3 . VAR_5 ) . equals ( id ) ) { <END> VAR_3 . close ( ) ; break ; } } }
<|startcomment|> need default constructor night <|endcomment|> public TYPE_2 ( ) { VAR_2 . put ( STRING_1 , new TYPE_1 ( ) { @Override public void run ( ) { METHOD_1 ( ) ; } } ) ; <START> } <END>
<|startcomment|> rowsize positive check - 1 necessary <|endcomment|> public void METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 == - 1 ) { <END> VAR_2 = VAR_1 ; } else { if ( VAR_2 < VAR_1 ) { VAR_2 = VAR_1 ; } } }
<|startcomment|> change longer necessary <|endcomment|> <START> public TYPE_1 ( ) { <END> VAR_2 = new ArrayList < > ( ) ; VAR_3 = new ArrayList < > ( ) ; }
<|startcomment|> test cases runs version usual route parametrized args <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> for ( TYPE_1 version : VAR_1 ) { <END> METHOD_2 ( version , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 ) ; } }
<|startcomment|> curlies needed <|endcomment|> private String METHOD_1 ( String url ) { File f = new File ( url ) ; if ( ! f . VAR_1 ( ) ) <START> if ( repo . VAR_2 ( ) ) { <END> url = new File ( repo . VAR_3 ( ) , url ) . METHOD_2 ( ) ; } else { url = new File ( repo . VAR_4 ( ) , url ) . METHOD_2 ( ) ; } return url ; }
<|startcomment|> vary dangerous methods public lead procedural programming difficult determine object a valid state private <|endcomment|> <START> public void METHOD_1 ( int VAR_1 ) { <END> size += VAR_1 ; }
<|startcomment|> AFAICT METHOD_6 _CODE_ don t need return a TYPE_1 <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { try { return TYPE_4 . METHOD_2 ( METHOD_3 ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ) , ( VAR_3 , t ) - > { if ( t != null ) { return METHOD_6 ( t , VAR_1 ) ; <START> } <END> return TYPE_5 . METHOD_7 ( ) ; } ) ; } catch ( Throwable e ) { return METHOD_6 ( e , VAR_1 ) ; } }
<|startcomment|> lossy VAR_1 text METHOD_1 lost METHOD_1 target I d prefer emit simply omit href needed e g ( VAR_2 = = null ) { VAR_2 = ; } other builders <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String text ) { <START> if ( VAR_2 != null ) { <END> METHOD_2 ( ) ; try { VAR_3 . write ( CHAR_1 ) ; METHOD_3 ( VAR_1 ) ; VAR_3 . write ( text ) ; VAR_3 . write ( CHAR_1 ) ; VAR_3 . write ( CHAR_2 ) ; VAR_3 . write ( VAR_2 ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }
<|startcomment|> redundant variable - inline <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 info ) { TYPE_3 factory = TYPE_4 . getInstance ( ) . METHOD_2 ( ) ; <START> TYPE_5 file = ( TYPE_5 ) info . file ; <END> return factory . VAR_1 ( file , info . VAR_2 , info . VAR_3 , info . VAR_4 ) ; }
<|startcomment|> check ? I don t a code path result VAR_1 null check implies happen check necessary needs locking avoid a race condition <|endcomment|> protected void METHOD_1 ( ) { <START> if ( VAR_1 != null ) <END> VAR_1 . METHOD_2 ( context , parent . VAR_2 ( ) ) ; }
<|startcomment|> need call METHOD_5 call worked ? move <|endcomment|> public void METHOD_1 ( TYPE_1 page ) { METHOD_2 ( page , STRING_1 ) ; METHOD_3 ( ! METHOD_4 ( ) , STRING_2 ) ; index . VAR_1 ( page ) ; if ( ! VAR_2 . METHOD_5 ( ( index . VAR_3 ( ) . METHOD_6 ( ) ) ) ) { index . VAR_4 ( ) ; } <START> VAR_2 . METHOD_7 ( index . VAR_3 ( ) . METHOD_6 ( ) ) ; <END> VAR_5 . METHOD_8 ( page . VAR_6 ( ) , page . VAR_7 ( ) ) ; }
<|startcomment|> inline s <|endcomment|> public TYPE_1 METHOD_1 ( ) { String VAR_1 = VAR_2 == null ? "" : VAR_2 . getName ( ) ; <START> final String s = METHOD_2 ( ) + STRING_1 + ( TYPE_3 . TYPE_4 . equals ( VAR_1 ) ? "" : VAR_1 ) ; <END> return s ; }
<|startcomment|> STRING_5 + TYPE_3 VAR_8 <|endcomment|> protected String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { String VAR_2 = METHOD_2 ( ) ; String VAR_3 = METHOD_3 ( ) ; String VAR_4 = METHOD_4 ( VAR_1 . METHOD_5 ( ) ) ; String VAR_5 = METHOD_6 ( ) ; String VAR_6 = STRING_1 + VAR_5 + STRING_2 ; <START> String command = STRING_3 + VAR_6 + VAR_3 + STRING_4 + VAR_4 + STRING_5 + TYPE_3 . VAR_8 + VAR_2 + STRING_6 ; <END> return command ; }
<|startcomment|> need case edit select firewall type configured cluster select default <|endcomment|> private void METHOD_1 ( ) { <START> TYPE_1 < TYPE_2 > VAR_1 = METHOD_2 ( ) ; <END> VAR_1 . METHOD_3 ( Arrays . asList ( TYPE_2 . values ( ) ) ) ; VAR_1 . METHOD_4 ( false ) ; VAR_1 . METHOD_5 ( TYPE_2 . VAR_2 ) ; }
<|startcomment|> I d remove check decide consider separating conjuncts separate calls moving METHOD_5 METHOD_2 ( VAR_4 + VAR_1 - 1 < VAR_3 length ) ; METHOD_2 ( VAR_3 [ VAR_4 ] > = 0 ) ; METHOD_2 ( VAR_3 [ VAR_4 + VAR_1 - 1 ] < VAR_2 METHOD_4 ( ) ) ; <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 == 0 ) { return ; } METHOD_2 ( VAR_2 != null ) ; int [ ] VAR_3 = METHOD_3 ( ) ; <START> METHOD_2 ( VAR_4 + VAR_1 - 1 < VAR_3 . length && VAR_3 [ VAR_4 ] >= 0 && <END> VAR_3 [ VAR_4 + VAR_1 - 1 ] < VAR_2 . METHOD_4 ( ) ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; VAR_5 += VAR_1 ; }
<|startcomment|> extra VAR_6 <|endcomment|> public TYPE_1 METHOD_1 ( ) throws Exception { org . VAR_1 . VAR_2 . VAR_3 . VAR_4 . context . TYPE_1 VAR_5 = TYPE_2 . METHOD_2 ( ) ; String VAR_6 = VAR_5 . METHOD_3 ( ) ; String VAR_7 = VAR_5 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( ) ; <START> TYPE_3 properties = VAR_8 . METHOD_8 ( VAR_7 + STRING_1 + VAR_6 + STRING_1 + VAR_6 ) ; <END> return new TYPE_1 ( VAR_5 . METHOD_4 ( ) , properties ) ; }
<|startcomment|> reason extract variable compilator good optimization source code simplified <|endcomment|> protected boolean METHOD_1 ( TYPE_1 properties ) { boolean VAR_1 = properties . VAR_2 ( ) != null ; <START> return VAR_1 ; <END> }
<|startcomment|> a runnable hook throw exception need test instead hardcoding exception ? imagine test cases involve setting interrupted flag expecting InterruptedException ( instance a _CODE_ proxy fetch call _CODE_ ) <|endcomment|> private void METHOD_1 ( ) throws InterruptedException { if ( TYPE_1 != null ) { TYPE_1 . run ( ) ; <START> if ( Thread . VAR_1 ( ) . METHOD_2 ( ) ) { throw new InterruptedException ( STRING_1 ) ; } <END> } }
<|startcomment|> ( 0 ) a _CODE_ ( ) VAR_3 0 <|endcomment|> public TYPE_1 METHOD_1 ( int VAR_1 ) { if ( VAR_1 == TYPE_2 . VAR_3 ) { <START> return VAR_4 ; <END> } return VAR_5 . get ( VAR_1 ) ; }
<|startcomment|> fix resource leak a - - resources block <|endcomment|> protected void METHOD_1 ( TYPE_1 props ) throws IOException { try { super . METHOD_1 ( props ) ; } catch ( TYPE_2 e ) { if ( VAR_1 != null && VAR_2 ) { TYPE_3 VAR_3 = VAR_1 . out ( ) ; props . VAR_4 ( VAR_3 , VAR_5 ) ; VAR_3 . METHOD_2 ( ) ; <START> VAR_3 . close ( ) ; <END> } } }
<|startcomment|> missing generics <|endcomment|> public Builder METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } if ( VAR_2 == null ) { <START> VAR_2 = new ArrayList ( ) ; <END> } if ( VAR_2 . contains ( VAR_1 ) ) { throw new IllegalStateException ( STRING_2 ) ; } VAR_2 . add ( VAR_1 ) ; return this ; }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) remove TYPE_3 ; deprecated [ ! [ rule ] ( ) ] ( ) <|endcomment|> private Object METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { try { return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; } catch ( TYPE_4 . TYPE_5 . TYPE_3 t ) { <START> return new TYPE_3 ( t . VAR_4 ( ) ) ; <END> } catch ( Throwable t ) { return new TYPE_3 ( t ) ; } }
<|startcomment|> static import <|endcomment|> public void METHOD_1 ( ) throws IOException { try ( TYPE_1 VAR_1 = METHOD_2 ( ) ) { TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( "" , input ) ; <START> TYPE_3 . METHOD_4 ( VAR_2 , <END> VAR_3 ) ; } }
<|startcomment|> break line <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 repo , TYPE_3 VAR_2 , TYPE_4 VAR_3 , TYPE_5 VAR_4 , TYPE_6 VAR_5 , String path , byte [ ] content ) throws IOException , TYPE_7 { switch ( VAR_1 ) { case VAR_6 : VAR_4 . add ( new TYPE_8 ( path ) ) ; break ; case VAR_7 : case VAR_8 : <START> VAR_4 . add ( METHOD_2 ( VAR_1 , repo , VAR_2 , VAR_3 , path , VAR_5 , content ) ) ; <END> } VAR_4 . METHOD_3 ( ) ; }
<|startcomment|> switching TYPE_2 order correctly determine final type <|endcomment|> public TYPE_1 METHOD_1 ( final long id ) { <START> TYPE_2 result = this . VAR_1 . get ( id , VAR_2 - > this . VAR_3 . METHOD_2 ( id ) ) ; <END> return METHOD_3 ( result ) ; }
<|startcomment|> means METHOD_2 called common case I add a private METHOD_1 ( String VAR_1 _CODE_ _CODE_ ) call rest METHOD_1 ( ) methods <|endcomment|> public Map < String , Object > METHOD_1 ( String VAR_1 ) throws TYPE_1 { <START> return this . METHOD_1 ( VAR_1 , METHOD_2 ( VAR_1 ) . getName ( ) ) ; <END> }
<|startcomment|> ! [ INFO ] ( severity : INFO ) forget remove deprecated code [ ! [ rule ] ( ) ] ( ) <|endcomment|> <START> public TYPE_1 METHOD_1 ( String name , String VAR_1 , TYPE_2 session ) { <END> return METHOD_2 ( session ) . METHOD_1 ( name , VAR_1 ) ; }
<|startcomment|> unintuitive - return number characters need allow calling function decide <|endcomment|> private int METHOD_1 ( Map < String , Object > VAR_1 , String VAR_2 , String VAR_3 , String VAR_4 , int VAR_5 ) { if ( ( VAR_5 -= METHOD_2 ( VAR_3 , VAR_1 ) ) > 0 ) { if ( VAR_4 . length ( ) > VAR_5 ) { VAR_4 = VAR_4 . substring ( 0 , VAR_5 ) ; METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; } VAR_1 . put ( VAR_3 , VAR_4 ) ; return VAR_5 - VAR_4 . length ( ) ; } <START> return 0 ; <END> }
<|startcomment|> I catch throwables _CODE_ <|endcomment|> public static TYPE_1 < TYPE_2 > METHOD_1 ( TYPE_3 VAR_1 ) { return METHOD_2 ( ( ) - > { try { VAR_1 . run ( ) ; } catch ( Exception e ) { <START> throw new TYPE_4 ( e ) ; <END> } } ) ; }
<|startcomment|> minor : don t need lines <|endcomment|> public void add ( String VAR_1 , TYPE_1 VAR_2 ) { <START> this . VAR_3 = this . VAR_3 == null ? new HashMap < > ( ) : this . VAR_3 ; <END> this . VAR_3 . put ( VAR_1 , VAR_2 ) ; }
<|startcomment|> standard convention prefix instance members - return context <|endcomment|> public Context METHOD_1 ( ) { <START> return context ; <END> }
<|startcomment|> VAR_2 INT_1 ? TYPE_3 instead <|endcomment|> private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ( ) - > { try { <START> TYPE_1 . METHOD_3 ( TYPE_2 . METHOD_4 ( ) . METHOD_5 ( 1 , VAR_2 / INT_1 ) ) ; <END> log . info ( STRING_1 ) ; METHOD_6 ( METHOD_7 ( ) ) ; } catch ( InterruptedException e ) { Thread . VAR_3 ( ) . METHOD_8 ( ) ; } catch ( Throwable t ) { log . error ( t , STRING_2 ) ; } } , 0 , VAR_2 , TimeUnit . TYPE_3 ) ; }
<|startcomment|> s log levels manipulated dynamically a thin case don t need worry <|endcomment|> private TYPE_1 < TYPE_2 , TYPE_3 < ? > > METHOD_1 ( ) { TYPE_1 < TYPE_2 , TYPE_3 < ? > > builder = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( 100 ) . METHOD_4 ( new TYPE_4 ( ) ) . METHOD_5 ( INT_1 ) ; if ( logger . VAR_1 ( ) ) <START> builder = builder . VAR_2 ( new TYPE_5 ( ) ) ; <END> return builder ; }
<|startcomment|> clear list METHOD_2 need clear <|endcomment|> public void METHOD_1 ( TYPE_1 context ) { VAR_1 = 0 ; VAR_2 = false ; VAR_3 = 0 ; <START> VAR_4 . clear ( ) ; <END> this . context = context ; METHOD_2 ( context . VAR_5 ( ) ) ; VAR_4 . clear ( ) ; }
<|startcomment|> unused variable <|endcomment|> public static TYPE_1 METHOD_1 ( String name ) { TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; if ( VAR_1 . METHOD_2 ( ) ) { <START> TYPE_1 VAR_2 = new TYPE_1 ( name ) ; <END> TYPE_1 VAR_3 ; if ( ( VAR_3 = VAR_1 . METHOD_3 ( ) . get ( name ) ) != null ) { return ( VAR_3 ) ; } } return null ; }
<|startcomment|> instead adding injected ctor I add a new class extends TYPE_6 ctor base class general ctor children injected explicit model type implemented a bit confusing <|endcomment|> <START> public TYPE_6 ( final TYPE_4 . TYPE_5 . VAR_2 . TYPE_7 < TYPE_2 > VAR_4 , <END> TYPE_3 VAR_5 ) { this ( VAR_5 , VAR_4 ) ; }
<|startcomment|> debug <|endcomment|> void METHOD_1 ( TYPE_1 event ) { <START> TYPE_2 . VAR_2 . info ( STRING_1 ) ; <END> next ( ) ; }
<|startcomment|> Exception thrown <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> final TYPE_1 VAR_1 = METHOD_2 ( TYPE_1 . class ) ; final Object VAR_2 = METHOD_2 ( Object . VAR_3 ) ; final TYPE_2 < Object > VAR_4 = METHOD_2 ( TYPE_2 . VAR_3 ) ; TYPE_3 . METHOD_3 ( VAR_1 , VAR_2 , VAR_4 ) ; METHOD_4 ( VAR_4 , METHOD_5 ( 1 ) ) . METHOD_6 ( METHOD_7 ( VAR_2 ) ) ; METHOD_4 ( VAR_1 , METHOD_5 ( 1 ) ) . METHOD_3 ( METHOD_7 ( VAR_2 ) ) ; }
<|startcomment|> public package reason restrict visibility constructor a shortcut ctor <|endcomment|> <START> static TYPE_1 <END> METHOD_1 ( String VAR_1 , String VAR_2 ) { return new TYPE_1 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> i done test possibly moved _CODE_ ( ) <|endcomment|> public void METHOD_1 ( ) throws IOException { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , VAR_3 , VAR_4 ) ; <START> VAR_1 . METHOD_2 ( VAR_5 ) ; <END> Assert . VAR_6 ( VAR_2 . METHOD_3 ( VAR_7 ) . METHOD_4 ( STRING_1 ) , VAR_4 . METHOD_5 ( VAR_3 . METHOD_6 ( ) , STRING_2 , STRING_3 , VAR_7 . METHOD_7 ( ) ) ) ; }
<|startcomment|> please dont remove explicit initialization <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 user ) throws TYPE_3 { <START> TYPE_1 VAR_1 ; <END> VAR_1 = METHOD_2 ( user ) ; if ( VAR_1 == null ) { VAR_1 = user . VAR_2 ( METHOD_3 ( ) ) ; } return VAR_1 ; }
<|startcomment|> TYPE_1 METHOD_2 ( { } ) else <|endcomment|> public void METHOD_1 ( ) { Assert . assertNotNull ( this . c . VAR_1 ( ) ) ; <START> final Set < String > VAR_2 = TYPE_1 . METHOD_2 ( ) ; <END> VAR_2 . add ( STRING_1 ) ; this . c . VAR_3 ( VAR_2 ) ; Assert . assertEquals ( VAR_2 , this . c . VAR_1 ( ) ) ; this . c . VAR_3 ( null ) ; Assert . assertThat ( this . c . VAR_1 ( ) , TYPE_2 . empty ( ) ) ; }
<|startcomment|> < T > s don t occur method signature <|endcomment|> <START> public static < T > TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , ImmutableList < TYPE_3 < ? > > args ) { <END> return new TYPE_1 ( VAR_1 , args ) ; }
<|startcomment|> typo invoked method Optional empty ( ) <|endcomment|> private void METHOD_1 ( ) { <START> Optional < Object > VAR_1 = Optional . VAR_2 ( ) ; <END> if ( ! VAR_1 . isEmpty ( ) ) { VAR_1 . get ( ) ; } }
<|startcomment|> DB table need set String valueOf ( entry VAR_3 ( ) ) return null string null <|endcomment|> public void METHOD_1 ( TYPE_1 entry ) throws TYPE_2 { if ( VAR_1 != null ) { Boolean VAR_2 = VAR_1 . apply ( entry ) ; if ( ( VAR_2 != null ) && ! VAR_2 ) { throw new TYPE_2 ( STRING_1 <START> + entry . VAR_3 ( ) + STRING_2 + entry . VAR_4 ( ) + STRING_3 + entry . VAR_5 ( ) ) ; <END> } } else { super . METHOD_1 ( entry ) ; } }
<|startcomment|> profile isn t set ll NPE <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> return Collections . VAR_1 ( new TYPE_1 ( getParameters ( ) . METHOD_2 ( ) . METHOD_3 ( ) , <END> TYPE_3 . TYPE_2 , METHOD_4 ( ) . METHOD_5 ( ) ) ) ; }
<|startcomment|> won t land expected network errors ? catch block <|endcomment|> public void METHOD_1 ( Throwable t ) { <START> TYPE_1 . METHOD_2 ( t ) ; <END> TYPE_2 . METHOD_3 ( context , t . VAR_1 ( ) , TYPE_2 . VAR_2 ) . METHOD_4 ( ) ; }
<|startcomment|> remove return VAR_1 catch <|endcomment|> public static Object METHOD_1 ( Object VAR_1 , TYPE_1 VAR_2 ) { try { VAR_2 . METHOD_2 ( ) ; } catch ( InterruptedException e ) { METHOD_3 ( ) . METHOD_4 ( ) ; <START> return VAR_1 ; <END> } return VAR_1 ; }
<|startcomment|> want VAR_1 add ( null VAR_3 ) put display TYPE_1 widget shows [ x ] foo instead foo [ x ] users a bigger click target ( label text ) mash mouse <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( Boolean . VAR_4 ( VAR_2 . value ( ) ) ) ; <START> VAR_1 . add ( METHOD_3 ( VAR_2 ) , VAR_3 ) ; <END> VAR_5 . METHOD_4 ( VAR_3 ) ; return VAR_3 ; }
<|startcomment|> removed <|endcomment|> public void METHOD_1 ( ) { Map < String , Object > VAR_1 = new HashMap < > ( ) ; TYPE_1 VAR_2 = new TYPE_1 ( STRING_1 , VAR_1 ) ; <START> assertThat ( VAR_3 ) . METHOD_2 ( ) ; <END> assertThat ( VAR_3 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_1 . class ) ; VAR_3 . execute ( VAR_2 ) ; METHOD_5 ( VAR_4 ) . METHOD_6 ( VAR_2 ) ; METHOD_5 ( VAR_5 ) . METHOD_7 ( TYPE_4 < TYPE_2 < TYPE_3 > > METHOD_8 ( ) ) ; }
<|startcomment|> _CODE_ ( ! set VAR_1 ) ; ( ) <|endcomment|> public void METHOD_1 ( boolean set ) { boolean VAR_1 = StringUtils . VAR_2 ( VAR_3 . METHOD_2 ( ) ) ; <START> if ( set ) { METHOD_3 ( VAR_1 ) ; } else { assertTrue ( VAR_1 ) ; } <END> }
<|startcomment|> call super METHOD_1 ( ) serializes ethernet headers ip headers udp headers finally elasticdata <|endcomment|> <START> public int METHOD_1 ( ByteBuffer VAR_1 ) { <END> int start = VAR_1 . position ( ) ; if ( ! VAR_2 . isPresent ( ) ) { METHOD_2 ( ) ; } VAR_1 . put ( VAR_2 . get ( ) ) ; final TYPE_1 VAR_3 = METHOD_3 ( ) ; if ( VAR_3 . METHOD_4 ( ) > 0 ) { METHOD_5 ( VAR_1 , start , VAR_3 ) ; } return VAR_4 + METHOD_6 ( ) ; }
<|startcomment|> s point calling super METHOD_1 ( ) return true <|endcomment|> protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( METHOD_2 ( ) ) ; <START> return METHOD_3 ( VAR_1 . METHOD_4 ( ) ) && super . METHOD_1 ( ) ; <END> }
<|startcomment|> more calls _CODE_ _CODE_ methods called _CODE_ shouldn t updated ? VAR_2 passed parameter methods <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < TYPE_2 > VAR_2 = METHOD_2 ( VAR_1 ) ; <END> int count = 0 ; for ( TYPE_2 VAR_3 : VAR_2 ) { if ( VAR_3 . METHOD_3 ( ) ) count ++ ; } if ( count > 1 ) METHOD_4 ( VAR_1 ) ; else METHOD_5 ( VAR_1 ) ; }
<|startcomment|> a bug logic clear METHOD_3 ( ) 1 / 8 - buffer METHOD_2 instead buffer METHOD_2 7 bytes classic pattern implementing isjavaint i = 0 ; ( ; i < = VAR_1 - Long VAR_3 ; i + = Long VAR_3 ) { VAR_2 METHOD_3 ( i INT_1 ) ; } ( ; i < VAR_1 ; i + + ) { VAR_2 put ( i ( byte ) 0 ) ; } <|endcomment|> public void METHOD_1 ( ) { final int VAR_1 = VAR_2 . METHOD_2 ( ) ; final int n = VAR_1 / Long . VAR_3 ; <START> for ( int i = 0 ; i < n ; i += Long . VAR_3 ) { <END> VAR_2 . METHOD_3 ( i , INT_1 ) ; } for ( int i = n ; i < VAR_1 ; i ++ ) { VAR_2 . put ( i , ( byte ) 0 ) ; } }
<|startcomment|> isn t check redundant <|endcomment|> private void METHOD_1 ( ) { long VAR_1 = 0 ; if ( METHOD_2 ( ) . METHOD_3 ( ) != null ) { for ( TYPE_1 VAR_2 : METHOD_2 ( ) . METHOD_3 ( ) ) { <START> if ( VAR_2 . METHOD_4 ( ) ) { <END> VAR_1 += VAR_2 . METHOD_5 ( ) ; } } } Pair < TYPE_2 , Double > VAR_3 = TYPE_3 . METHOD_6 ( VAR_1 , TYPE_2 . VAR_4 ) ; METHOD_7 ( VAR_3 ) ; }
<|startcomment|> a tiiny bit safer / nicer put config - > VAR_1 conversion METHOD_2 method <|endcomment|> public void start ( ) throws Exception { logger . info ( STRING_1 ) ; METHOD_1 ( ) ; logger . trace ( STRING_2 ) ; METHOD_2 ( ) ; <START> if ( VAR_1 == null ) { <END> VAR_1 = new ArrayList < TYPE_1 > ( ) ; if ( config != null ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 ) ; VAR_2 . METHOD_3 ( config ) ; VAR_1 . add ( VAR_2 ) ; } } for ( TYPE_1 s : VAR_1 ) { s . start ( ) ; } }
<|startcomment|> I thought changed ichi2 anki JSON classes avoid / catch throw _CODE_ ? #5550 <|endcomment|> private boolean METHOD_1 ( ) { int VAR_1 ; try { VAR_1 = METHOD_2 ( ) . getInt ( STRING_1 ) ; <START> } catch ( TYPE_1 e ) { <END> throw new RuntimeException ( e ) ; } return VAR_1 == TYPE_2 . VAR_3 ; }
<|startcomment|> I avoid declaring handle invoke execute shared handle <|endcomment|> public void METHOD_1 ( ) { <START> final TYPE_1 VAR_1 = this . VAR_2 . METHOD_2 ( ) ; <END> VAR_1 . execute ( STRING_1 ) ; }
<|startcomment|> need close - - resource <|endcomment|> public void METHOD_1 ( ) throws IOException , TYPE_1 { try ( TYPE_2 stream = VAR_1 . METHOD_2 ( STRING_1 , STRING_2 , STRING_3 ) ) { TYPE_3 . METHOD_3 ( stream ) ; <START> stream . close ( ) ; <END> } }
<|startcomment|> enough latest 3 3 version <|endcomment|> private void METHOD_1 ( ) { try ( TYPE_1 VAR_1 = db . VAR_2 ( ) ) { db . execute ( STRING_1 + VAR_3 ) ; VAR_1 . METHOD_2 ( ) ; } try ( TYPE_1 VAR_1 = db . VAR_2 ( ) ) { <START> db . VAR_4 ( ) . METHOD_3 ( 1 , TimeUnit . VAR_5 ) ; <END> VAR_1 . METHOD_2 ( ) ; } }
<|startcomment|> needed ? storing a context a good idea general <|endcomment|> public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 == null ) <END> return TYPE_2 . METHOD_2 ( STRING_1 , METHOD_3 ( ) ) . METHOD_4 ( TYPE_2 . METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; TYPE_3 VAR_3 = TYPE_3 . getInstance ( TYPE_4 . METHOD_5 ( ) ) ; return VAR_3 . METHOD_6 ( TYPE_2 . METHOD_2 ( STRING_1 , METHOD_3 ( ) ) , TYPE_2 . METHOD_2 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; }
<|startcomment|> VAR_1 set ( 0 ) ; a race condition _CODE_ method invoked time CAS operation doesn t work properly returned a incremented CAS occur causing a missed reset <|endcomment|> void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_1 . get ( ) , 0 ) ; <END> }
<|startcomment|> making method implementation : return cmd VAR_2 ( ) startsWith ( VAR_3 ) ; <|endcomment|> private boolean METHOD_1 ( final TYPE_1 cmd ) { <START> String VAR_1 = cmd . VAR_2 ( ) ; <END> if ( VAR_1 . startsWith ( VAR_3 ) ) { return true ; } return false ; }
<|startcomment|> need capture autobuild state setup restore teardown <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( true ) ; <END> TYPE_1 . METHOD_3 ( ) . METHOD_4 ( false ) ; TYPE_2 . METHOD_5 ( 100 ) ; TYPE_3 . METHOD_6 ( ) ; TYPE_4 . METHOD_7 ( ) ; TYPE_5 . METHOD_8 ( ) ; TYPE_2 . METHOD_5 ( ) ; }
<|startcomment|> I line means _CODE_ needs a METHOD_1 method <|endcomment|> public byte [ ] METHOD_1 ( ) { byte [ ] VAR_1 = VAR_2 == null ? new byte [ ] { } : StringUtils . VAR_3 ( VAR_2 ) ; <START> byte [ ] VAR_4 = StringUtils . VAR_3 ( VAR_5 . toString ( ) ) ; <END> int VAR_6 = 2 + VAR_1 . length + VAR_4 . length ; return ByteBuffer . VAR_7 ( VAR_6 ) . put ( VAR_8 ) . put ( VAR_1 ) . put ( VAR_9 ) . put ( VAR_4 ) . METHOD_2 ( ) ; }
<|startcomment|> technically setting VAR_5 = false isn t needed default a boolean <|endcomment|> public TYPE_3 ( Map < String , Object > VAR_2 , TYPE_1 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( ) ; <START> this . VAR_5 = false ; <END> this . VAR_6 = new TYPE_2 < > ( ) ; }
<|startcomment|> creating TYPE_2 omitted <|endcomment|> public void METHOD_1 ( ) { long VAR_1 = VAR_2 . value ; long VAR_3 = VAR_4 . value ; <START> TYPE_1 . time . TYPE_2 VAR_6 = TYPE_1 . time . TYPE_2 . METHOD_2 ( VAR_1 - ( VAR_1 % VAR_3 ) ) ; <END> out . value = VAR_6 . METHOD_3 ( ) ; }
<|startcomment|> forEach doesn t values avoid sending caller simply returning null <|endcomment|> public TYPE_1 METHOD_1 ( Map . Entry < TYPE_2 , TYPE_1 > entry ) { action . VAR_1 ( entry . getKey ( ) , entry . getValue ( ) ) ; <START> return entry . getValue ( ) ; <END> }
<|startcomment|> please implement a mock version _CODE_ a normal HashMap <|endcomment|> private TYPE_1 user ( TYPE_6 . TYPE_7 ... VAR_1 ) { TYPE_4 . TYPE_8 VAR_2 = new TYPE_4 . TYPE_8 ( ) { @Override public TYPE_4 create ( final TYPE_1 VAR_3 , final String VAR_4 ) { <START> return new TYPE_4 ( VAR_5 , VAR_3 , VAR_4 , null ) ; <END> } } ; return new TYPE_1 ( TYPE_9 < TYPE_6 . TYPE_7 > METHOD_1 ( ) , TYPE_9 < TYPE_6 . TYPE_7 > METHOD_1 ( ) , VAR_2 , new TYPE_5 ( VAR_1 ) , METHOD_2 ( ) ) ; }
<|startcomment|> pattern match arguments <|endcomment|> private boolean METHOD_1 ( TYPE_1 connection ) { Thread VAR_1 = Thread . VAR_1 ( ) ; String VAR_2 = VAR_1 . getName ( ) ; <START> String VAR_3 = String . format ( STRING_1 , VAR_2 , connection . VAR_4 ( ) , VAR_5 ) ; <END> VAR_1 . METHOD_2 ( VAR_3 ) ; try { return connection . VAR_6 ( ) ; } finally { VAR_1 . METHOD_2 ( VAR_2 ) ; } }
<|startcomment|> needed s called line 176 ? mention CDA s run <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( METHOD_2 ( ) ) { if ( METHOD_3 ( ) . getStatus ( ) != TYPE_4 . TYPE_2 && VAR_4 . METHOD_4 ( ) ) { return METHOD_5 ( TYPE_3 . VAR_6 ) ; } <START> if ( ! METHOD_6 ( ) ) { <END> return false ; } return METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ; } return true ; }
<|startcomment|> remove thises <|endcomment|> public TYPE_2 ( TYPE_1 from , TYPE_1 to ) { this . VAR_2 = from ; <START> this . VAR_3 = to ; <END> this . VAR_4 = TYPE_3 . VAR_6 ; }
<|startcomment|> remove VAR_4 METHOD_3 ( ) - - VAR_4 iterator ( ) calls METHOD_3 _CODE_ <|endcomment|> public void METHOD_1 ( ) { if ( state == TYPE_4 . VAR_2 ) { state = TYPE_4 . VAR_3 ; TYPE_1 < TYPE_2 > VAR_4 = METHOD_2 ( new TYPE_3 ( VAR_5 , VAR_6 , VAR_7 ) ) ; <START> VAR_4 . METHOD_3 ( ) ; <END> VAR_8 = VAR_4 . iterator ( ) ; } }
<|startcomment|> called child class METHOD_1 ( ) method <|endcomment|> public void METHOD_1 ( ) { <START> super . METHOD_1 ( ) ; <END> METHOD_2 ( VAR_1 ) ; }
<|startcomment|> I find easier read : _CODE_ < TYPE_2 < TYPE_3 > > VAR_1 = VAR_1 ; ( VAR_2 ) { VAR_1 = METHOD_1 ( VAR_1 VAR_3 - > ! VAR_3 METHOD_2 ( ) ) ; } return new TYPE_1 ( VAR_4 VAR_1 VAR_5 ) ; <|endcomment|> public TYPE_1 build ( ) { <START> List < TYPE_2 < TYPE_3 > > VAR_1 = VAR_2 ? METHOD_1 ( this . VAR_1 , VAR_3 - > ! VAR_3 . METHOD_2 ( ) ) : this . VAR_1 ; <END> return new TYPE_1 ( VAR_4 , VAR_1 , VAR_5 ) ; }
<|startcomment|> toString ( ) <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { <START> return METHOD_2 ( ) . get ( VAR_1 . toString ( ) ) ; <END> }
<|startcomment|> synchronizing synchronizing lock <|endcomment|> <START> public synchronized TYPE_1 METHOD_1 ( TYPE_1 uri , TYPE_2 VAR_1 ) { <END> TYPE_3 args = new TYPE_3 ( uri ) ; synchronized ( VAR_2 ) { TYPE_4 db = VAR_3 . METHOD_2 ( ) ; final long VAR_4 = db . VAR_5 ( args . table , null , VAR_1 ) ; if ( VAR_4 <= 0 ) return null ; uri = TYPE_5 . METHOD_3 ( uri , VAR_4 ) ; METHOD_4 ( uri ) ; return uri ; } }
<|startcomment|> need VAR_2 block : - ) <|endcomment|> protected void METHOD_1 ( TYPE_1 m ) { try { TYPE_2 VAR_1 = METHOD_2 ( new TYPE_1 [ ] { m } ) ; <START> TYPE_3 VAR_2 = METHOD_3 ( ) ; <END> boolean VAR_3 = TYPE_4 . METHOD_4 ( METHOD_5 ( ) ) ; if ( VAR_3 ) { TYPE_4 . METHOD_6 ( VAR_1 , VAR_2 ) ; TYPE_4 . METHOD_7 ( VAR_1 , VAR_2 ) ; } } catch ( TYPE_5 VAR_4 ) { TYPE_6 . log ( VAR_4 ) ; } }
<|startcomment|> t getPath instead <|endcomment|> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_2 TYPE_1 VAR_2 ) throws Exception { System . VAR_3 ( STRING_1 , STRING_2 <START> + STRING_3 ) ; <END> TYPE_2 . METHOD_2 ( STRING_4 , STRING_5 , getPath ( STRING_6 ) ) ; assertThat ( STRING_7 , VAR_2 . METHOD_3 ( ) , is ( VAR_4 ) ) ; assertThat ( STRING_8 , VAR_1 . METHOD_3 ( ) , is ( "" ) ) ; }
<|startcomment|> remove println <|endcomment|> private static Map < String , String > METHOD_1 ( final TYPE_1 < String , String > VAR_1 ) { final HashMap < String , String > result = new HashMap < > ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_2 - > { <START> System . out . println ( VAR_2 ) ; <END> result . put ( VAR_2 . key , VAR_2 . value ) ; } ) ; return result ; }
<|startcomment|> final <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 request , String name , long VAR_1 ) { <START> TYPE_1 VAR_2 ; <END> if ( VAR_3 ) { VAR_2 = new TYPE_3 ( name , VAR_1 , VAR_4 ) ; } else if ( VAR_5 ) { VAR_2 = new TYPE_4 ( name , VAR_1 , VAR_6 , VAR_4 ) ; } else { VAR_2 = new TYPE_5 ( name , VAR_1 ) ; } VAR_2 . METHOD_2 ( VAR_7 ) ; List < TYPE_6 > list = METHOD_3 ( request ) ; list . add ( VAR_2 ) ; return VAR_2 ; }
<|startcomment|> METHOD_4 ( ) checks VAR_4 = = null don t need check null <|endcomment|> public boolean METHOD_1 ( Date VAR_1 ) { if ( VAR_2 != null && VAR_3 != null && VAR_2 . METHOD_2 ( VAR_3 ) ) { throw new TYPE_1 ( STRING_1 , ( Object [ ] ) null ) ; } if ( METHOD_3 ( ) ) { return false ; } if ( VAR_1 == null ) { VAR_1 = new Date ( ) ; } <START> if ( VAR_4 == null || ! METHOD_4 ( VAR_1 ) || VAR_2 == null ) { <END> return false ; } return VAR_1 . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> readability reasons please add braces <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( ! VAR_2 . isEmpty ( ) ) for <END> ( TYPE_2 VAR_3 : VAR_2 ) { VAR_3 . METHOD_1 ( this , VAR_1 ) ; } }
<|startcomment|> pick : please consider putting top instead bottom ( I prevent / stop event handle ) <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = null ; if ( event . VAR_2 ( ) instanceof TYPE_2 ) { VAR_1 = ( TYPE_2 ) event . VAR_2 ( ) ; } if ( VAR_1 != null ) { boolean VAR_3 = VAR_1 . METHOD_2 ( ) ; METHOD_3 ( ) ; VAR_1 . METHOD_4 ( ! VAR_3 ) ; METHOD_4 ( ) ; } else { METHOD_3 ( ) ; } event . VAR_4 ( ) ; <START> event . VAR_5 ( ) ; <END> }
<|startcomment|> consistency declared throw IllegalStateException null checking I remove consistency <|endcomment|> <START> public void METHOD_1 ( TYPE_1 VAR_1 ) throws IllegalStateException { <END> if ( VAR_2 == null ) { throw new IllegalStateException ( STRING_1 ) ; } if ( VAR_1 == null ) { VAR_1 = TYPE_1 . NONE ; } if ( VAR_3 . equals ( VAR_1 ) ) { return ; } VAR_3 = VAR_1 ; TYPE_2 . METHOD_2 ( VAR_1 . getValue ( ) ) ; }
<|startcomment|> please long don t need wrap unwrap primitive <|endcomment|> <START> public synchronized Long METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> please explain need store upper case please <|endcomment|> public TYPE_2 ( TYPE_1 writer , String VAR_2 ) { this . writer = writer ; <START> this . VAR_2 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) : null ; <END> }
<|startcomment|> String valueOf ( ) instead appending empty string <|endcomment|> public String METHOD_1 ( ) { <START> return ( ( TYPE_1 ) entity . VAR_1 ( ) ) . METHOD_2 ( ) + "" ; <END> }
<|startcomment|> I selector mobile desktop please : invisible - high - impact - wrapper interstitial provider - container iframe <|endcomment|> public static Object [ ] [ ] METHOD_1 ( ) { return new Object [ ] [ ] { { new TYPE_1 ( STRING_1 , STRING_2 ) , <START> STRING_3 , <END> new TYPE_2 ( INT_1 , INT_2 ) } , } ; }
<|startcomment|> worth enforcing map wrapped empty ? _CODE_ ( ) method a copy map properly importing keys wrong impression constructor remove - insert values currently map accessible wrap a map uppercase key names members able extracted interface <|endcomment|> protected TYPE_2 ( final Map < String , TYPE_1 > VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> }
<|startcomment|> skip criteria enforced VAR_3 ( e g [ _CODE_ ] ( ) ) VAR_3 respect more data other criteria determine doesn t want continue reading VAR_3 checks auto read a more natural fit read pending check ( e g auto read enabled || asked read ) <|endcomment|> public final boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ( VAR_2 && METHOD_2 ( ) ) || VAR_3 . METHOD_1 ( VAR_1 ) ; <END> }
<|startcomment|> context VAR_5 ( resource TYPE_3 VAR_7 ) <|endcomment|> private void METHOD_1 ( org . VAR_1 . VAR_2 . VAR_3 . File resource , TYPE_1 context ) { TYPE_2 < Integer > VAR_4 = context . VAR_5 ( resource , TYPE_3 . VAR_7 ) ; if ( VAR_4 != null ) { <START> double VAR_8 = context . VAR_5 ( resource , TYPE_3 . VAR_7 ) . getValue ( ) ; <END> context . VAR_9 ( resource , METHOD_2 ( resource , context ) ) ; context . VAR_9 ( resource , VAR_10 , VAR_8 ) ; context . VAR_9 ( resource , VAR_11 , VAR_8 ) ; } }
<|startcomment|> ternary <|endcomment|> TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 resource = METHOD_2 ( METHOD_3 ( VAR_1 ) ) ; <START> if ( resource != null ) { <END> return METHOD_4 ( VAR_2 . METHOD_5 ( resource . VAR_3 ( ) ) . METHOD_6 ( ) ) ; } return null ; }
<|startcomment|> super : - picky empty line necessary I <|endcomment|> public void METHOD_1 ( ) { VAR_1 = new TYPE_1 < > ( TYPE_2 . class ) ; VAR_2 = METHOD_2 ( TYPE_3 . class ) ; <START> <END> }
<|startcomment|> button disposed <|endcomment|> public boolean METHOD_1 ( int VAR_1 ) { if ( VAR_1 == TYPE_3 . VAR_3 ) { if ( METHOD_2 ( ) != null ) { METHOD_3 ( true ) ; } else { TYPE_1 . METHOD_4 ( TYPE_2 . METHOD_5 ( ) . METHOD_6 ( ) , Messages . TYPE_4 , Messages . TYPE_5 ) ; } return true ; } else if ( VAR_1 == TYPE_3 . VAR_6 ) { <START> if ( ! VAR_7 . METHOD_7 ( ) ) { <END> METHOD_8 ( ) ; return false ; } return true ; } return false ; }
<|startcomment|> done <|endcomment|> public TYPE_1 apply ( TYPE_2 VAR_1 ) { <START> VAR_2 = true ; <END> return null ; }
<|startcomment|> s meaning 0 <|endcomment|> public boolean METHOD_1 ( Object request , Object target ) { int VAR_1 = <START> 0 ; <END> if ( request instanceof TYPE_1 ) { VAR_1 = ( ( TYPE_1 ) request ) . METHOD_2 ( ) ; } else if ( request instanceof TYPE_2 ) { VAR_1 = ( ( TYPE_2 ) request ) . VAR_2 ; } return ( VAR_1 == SWT . VAR_3 + SWT . VAR_4 ) ; }
<|startcomment|> I check null <|endcomment|> public Object METHOD_1 ( Object VAR_1 ) { <START> METHOD_2 ( ) ; <END> if ( VAR_1 == null ) return null ; return VAR_2 . METHOD_1 ( VAR_3 . METHOD_3 ( VAR_1 ) ) ; }
<|startcomment|> ImmutableList builder ( ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , int VAR_2 , TYPE_3 VAR_3 , TYPE_4 VAR_4 ) { <START> List < TYPE_5 > VAR_5 = new ArrayList < > ( ) ; <END> for ( TYPE_6 VAR_6 : VAR_7 ) { VAR_5 . add ( METHOD_2 ( VAR_1 , VAR_3 , VAR_4 , VAR_6 ) ) ; } return new TYPE_1 ( VAR_5 , VAR_8 ) ; }
<|startcomment|> I null case return type : select pg_typeof ( null : : bigint ) ; pg_typeof - - - - - - - - - - - bigint <|endcomment|> public final String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 < Object > ... args ) { assert args . length == 1 : STRING_1 + args . length ; Object VAR_2 = args [ 0 ] . value ( ) ; <START> return null != VAR_2 ? type : TYPE_4 . TYPE_5 . getName ( ) ; <END> }
<|startcomment|> gotcha ! : - ) please add braces return null ? I automatically put mentally returns indentation <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( STRING_1 ) ; if ( VAR_1 . METHOD_3 ( ) ) return null ; <START> return ( TYPE_1 ) TYPE_3 . METHOD_4 ( VAR_1 ) ; <END> }
<|startcomment|> TYPE_4 imported beginning METHOD_7 <|endcomment|> private TYPE_1 < Long > METHOD_1 ( TYPE_2 channel , TYPE_3 VAR_1 ) { return METHOD_2 ( VAR_2 . VAR_3 , VAR_4 - > VAR_5 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_1 . METHOD_5 ( ) , <START> METHOD_6 ( VAR_1 . METHOD_4 ( ) , TYPE_4 . METHOD_7 ( channel ) ) , <END> METHOD_8 ( VAR_1 ) ) , uri , LOGGER , VAR_6 ) ; }
<|startcomment|> stripe - mock <|endcomment|> public void METHOD_1 ( ) throws Exception { String VAR_1 = METHOD_2 ( STRING_1 ) ; TYPE_1 resource = TYPE_3 . TYPE_4 . METHOD_3 ( VAR_1 , TYPE_1 . class ) ; assertNotNull ( resource ) ; assertEquals ( STRING_2 , resource . getId ( ) ) ; <START> assertEquals ( STRING_3 , resource . VAR_2 ( ) ) ; <END> }
<|startcomment|> Log conflicting classes easier tracking <|endcomment|> public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; <START> throw new RuntimeException ( STRING_1 ) ; <END> }
<|startcomment|> note METHOD_4 method throws _CODE_ instead returning null VAR_3 isn t please create a test case verify behavior <|endcomment|> public void METHOD_1 ( TYPE_1 < ? > message , TYPE_2 VAR_1 ) throws Exception { if ( METHOD_2 ( VAR_1 ) ) { String VAR_2 = ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) . toString ( ) ; TYPE_4 < T > VAR_3 = METHOD_4 ( VAR_2 ) ; <START> if ( VAR_3 != null ) { <END> VAR_3 . METHOD_5 ( message ) ; } else { logger . debug ( STRING_1 , VAR_2 , message ) ; } } }
<|startcomment|> minor - TYPE_2 s METHOD_7 a null check need VAR_1 METHOD_6 ( ) ! = null <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; METHOD_3 ( ) . METHOD_4 ( VAR_1 != null && VAR_1 . METHOD_5 ( ) <START> && VAR_1 . METHOD_6 ( ) != null <END> && TYPE_2 . VAR_3 . METHOD_7 ( VAR_1 . METHOD_6 ( ) ) <= 0 ) ; }
<|startcomment|> a simple setter ( deprecated ) shouldn t mess system property favor deprecated System VAR_2 ( ) dangerous : presume a single JVM process runs 2 solver configs constructed java ( xml ) calls METHOD_1 ( true ) doesn t feel = > remove - else block <|endcomment|> public void METHOD_1 ( Boolean VAR_1 ) { if ( TYPE_1 . METHOD_2 ( VAR_1 ) ) { System . VAR_2 ( VAR_3 , STRING_1 ) ; } else { System . VAR_4 ( VAR_3 ) ; } <START> this . VAR_1 = VAR_1 ; <END> }
<|startcomment|> save a lines moving return null default case instead break <|endcomment|> public static String METHOD_1 ( final int value ) { switch ( value ) { case VAR_1 : return STRING_1 ; case VAR_2 : return STRING_2 ; case VAR_3 : return STRING_3 ; default : break ; } <START> return null ; <END> }
<|startcomment|> need check METHOD_2 ( ) null _CODE_ new audit log user skipped please usage example _CODE_ _CODE_ <|endcomment|> protected boolean METHOD_1 ( ) { <START> return StringUtils . equals ( METHOD_2 ( ) . METHOD_3 ( ) , getParameters ( ) . METHOD_4 ( ) ) ; <END> }
<|startcomment|> javafor ( int VAR_4 = 0 ; VAR_4 < INT_1 ; VAR_4 + + ) { changed code : javafor ( int VAR_4 = 0 ; VAR_4 < 100 ; VAR_4 + = 5 ) { <|endcomment|> public static boolean METHOD_1 ( TYPE_1 client , String VAR_1 , TYPE_2 VAR_2 , TYPE_3 . Status VAR_3 ) throws TYPE_4 , InterruptedException { for ( int VAR_4 = 0 ; VAR_4 < INT_1 ; VAR_4 ++ ) { TYPE_3 . Status status = METHOD_2 ( client , VAR_1 , VAR_2 ) ; logger . info ( STRING_1 + status ) ; if ( status == VAR_3 ) { return true ; } <START> TimeUnit . VAR_5 . METHOD_3 ( 5 ) ; <END> } return false ; }
<|startcomment|> forgot call super METHOD_1 ( ) <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { <START> TYPE_2 . METHOD_2 ( this , TYPE_6 . VAR_2 , TYPE_6 . VAR_3 , TYPE_5 . VAR_5 ) ; <END> VAR_6 = TYPE_3 . METHOD_3 ( TYPE_4 . class ) ; METHOD_4 ( ) ; }
<|startcomment|> recursive call METHOD_1 ( g m ) <|endcomment|> public static final void METHOD_1 ( TYPE_1 group , TYPE_2 m ) { for ( TYPE_3 VAR_1 : group . VAR_2 ( ) ) { METHOD_1 ( VAR_1 , m ) ; } for ( TYPE_1 VAR_3 : group . VAR_4 ( ) ) { <START> for ( TYPE_3 VAR_1 : VAR_3 . METHOD_2 ( ) ) { <END> METHOD_1 ( VAR_1 , m ) ; } } }
<|startcomment|> key create VAR_1 <|endcomment|> public void METHOD_1 ( TYPE_1 task ) { <START> VAR_1 . put ( task . VAR_2 ( ) , task ) ; <END> }
<|startcomment|> pattern i e return ( TYPE_1 ) TYPE_2 METHOD_2 ( TYPE_1 VAR_2 ) ; <|endcomment|> public static TYPE_1 METHOD_1 ( String value ) { <START> TYPE_1 [ ] VAR_1 = TYPE_1 . values ( ) ; <END> for ( TYPE_1 item : VAR_1 ) { if ( item . toString ( ) . equalsIgnoreCase ( value ) ) { return item ; } } return ( TYPE_1 ) TYPE_2 . METHOD_2 ( value , VAR_2 ) ; }
<|startcomment|> simplify : _CODE_ METHOD_2 ( location VAR_5 - > new HashMap < > ( ) ) METHOD_2 ( VAR_2 VAR_5 - > new ArrayList < > ( ) ) add ( VAR_3 ) ; <|endcomment|> protected static void METHOD_1 ( Map < String , Map < TYPE_1 , List < TYPE_2 > > > VAR_1 , String location , TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <START> Map < TYPE_1 , List < TYPE_2 > > VAR_4 = VAR_1 . METHOD_2 ( location , VAR_5 - > new HashMap < > ( ) ) ; List < TYPE_2 > VAR_6 = VAR_4 . METHOD_2 ( VAR_2 , VAR_5 - > new ArrayList < > ( ) ) ; <END> VAR_6 . add ( VAR_3 ) ; }
<|startcomment|> constructor private a static factory method <|endcomment|> <START> public TYPE_5 ( <END> TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 reader , TYPE_4 VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = METHOD_1 ( VAR_3 ) ; this . reader = METHOD_1 ( reader ) ; this . VAR_4 = METHOD_1 ( VAR_4 ) ; }
<|startcomment|> replace file previous version commit - remove review <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 location ) { super ( VAR_2 , TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) ) ; <START> System . out . println ( STRING_1 + TYPE_3 . METHOD_1 ( ) . METHOD_2 ( ) ) ; <END> METHOD_3 ( location , null , null , null , null ) ; }
<|startcomment|> empty string redundent <|endcomment|> private String METHOD_1 ( ) { StringBuilder VAR_1 = new StringBuilder ( "" ) ; <START> for ( TYPE_1 a : TYPE_3 < TYPE_1 > METHOD_2 ( METHOD_3 ( ) ) ) <END> { if ( a . VAR_3 ( ) == TYPE_2 . VAR_5 ) { VAR_1 . append ( a . VAR_6 ( ) ) . append ( STRING_1 ) ; } } return VAR_1 . substring ( 0 , VAR_1 . length ( ) - 2 ) ; }
<|startcomment|> setting ? class level variables <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = new TYPE_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; }
<|startcomment|> I don t understand ignoring UI event diff base popup selects another field edit mode fixes linked issue A more descriptive commit message VAR_2 widget supposed disabled invisible edit mode <|endcomment|> void METHOD_1 ( ANNOTATION_1 ( STRING_1 ) TYPE_1 e ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; <START> if ( 0 <= VAR_1 && VAR_3 == TYPE_3 . TYPE_2 . VAR_6 ) { <END> String n = VAR_2 . getValue ( VAR_1 ) ; METHOD_3 ( VAR_7 , ! n . isEmpty ( ) ? n : null ) ; } }
<|startcomment|> removed <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { VAR_2 = METHOD_2 ( ) ; } String VAR_3 = VAR_1 . getName ( ) ; final int VAR_4 ; try { VAR_4 = VAR_2 . METHOD_3 ( VAR_3 , VAR_1 ) ; <START> System . out . println ( STRING_1 + VAR_4 + STRING_2 ) ; <END> } catch ( IOException | TYPE_2 e ) { throw new RuntimeException ( e ) ; } return Integer . toString ( VAR_4 ) ; }
<|startcomment|> I testing import declaring type I assume a problem importing a declaring type : condition useless <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 != null ) { <START> if ( ! METHOD_2 ( VAR_1 , false ) && ( METHOD_3 ( VAR_1 ) || METHOD_4 ( VAR_1 ) ) ) { <END> return true ; } if ( ! METHOD_2 ( VAR_1 , false ) && METHOD_5 ( VAR_1 ) ) { return true ; } while ( VAR_1 != null ) { if ( VAR_1 . equals ( VAR_2 ) ) { return true ; } VAR_1 = VAR_1 . METHOD_6 ( ) ; } } return false ; }
<|startcomment|> + + index <|endcomment|> TYPE_3 ( final int VAR_2 ) { this . VAR_3 = new ArrayList < TYPE_1 > ( VAR_2 ) ; <START> for ( int index = 0 ; index < VAR_2 ; index += 1 ) { <END> this . VAR_3 . add ( index , new TYPE_2 ( index ) ) ; } }
<|startcomment|> left side preferred style ( annotations extra line ) <|endcomment|> <START> @Override public String METHOD_1 ( String VAR_1 ) { <END> return VAR_1 ; }
<|startcomment|> throws Exception <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) <START> throws TYPE_3 , TYPE_4 , TYPE_5 , TYPE_6 , <END> TYPE_7 { boolean VAR_2 = new TYPE_8 ( VAR_1 ) . VAR_3 || new TYPE_9 ( VAR_1 ) . VAR_4 . length ( ) > 0 ; return VAR_2 ? TYPE_1 . METHOD_2 ( new TYPE_10 ( VAR_1 ) ) : null ; }
<|startcomment|> newly added line DRY some reason : _CODE_ javareturn METHOD_1 ( String valueOf ( ) ) ; <|endcomment|> public T METHOD_1 ( int value ) { METHOD_2 ( ) . VAR_1 = String . valueOf ( value ) ; METHOD_2 ( ) . VAR_2 = TYPE_1 . TYPE_2 . VAR_5 ; <START> return METHOD_3 ( ) ; <END> }
<|startcomment|> please follow existed coding style put new line override <|endcomment|> <START> @Override public void METHOD_1 ( ) throws Exception { <END> }
<|startcomment|> ( VAR_4 ) return true ? need continue looping finding condition correct <|endcomment|> boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { boolean VAR_3 = false ; for ( TYPE_2 VAR_4 : VAR_1 . METHOD_2 ( ) ) { <START> VAR_3 |= VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) . equals ( VAR_2 . METHOD_4 ( ) ) ; <END> } return VAR_3 ; }
<|startcomment|> new echo server test a single tests suffice ? a single suffice declare variables static turn functions <|endcomment|> public void METHOD_1 ( ) <START> throws Exception { <END> VAR_1 = TYPE_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( ) ; VAR_3 = VAR_2 . METHOD_4 ( ) ; VAR_4 = new TYPE_3 ( VAR_1 , VAR_5 ) ; VAR_4 . start ( ) ; }
<|startcomment|> needed method <|endcomment|> public boolean METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 . get ( ) , STRING_1 ) ; <END> METHOD_3 ( STRING_2 ) ; Optional < Boolean > result = METHOD_4 ( this : : METHOD_5 ) ; return result . VAR_2 ( ( ) - > state . get ( ) != TYPE_1 . VAR_4 || VAR_5 . METHOD_6 ( ) ) ; }
<|startcomment|> a 3 param constructor call reduce code rep <|endcomment|> <START> public TYPE_3 ( String VAR_2 , String VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_1 ( this ) ; this . start = new TYPE_2 ( this ) ; }
<|startcomment|> kind Exception thrown ? more specific ? some other mechanism detecting problem exception detecting ? exceptions slow compared other forms flow control I m concerned a post - aggregator compute function <|endcomment|> private double METHOD_1 ( double x ) { try { TYPE_1 VAR_1 = new TYPE_1 ( ) ; return VAR_1 . METHOD_1 ( x ) ; <START> } catch ( Exception ex ) { <END> return Double . TYPE_2 ; } }
<|startcomment|> I code apply scan progress <|endcomment|> public Response METHOD_1 ( ANNOTATION_1 ( VAR_1 . VAR_2 ) TYPE_1 VAR_3 ) { <START> if ( VAR_4 . METHOD_2 ( ) < 2 ) { <END> return Response . status ( Response . Status . VAR_5 ) . build ( ) ; } return Response . VAR_6 ( ) . build ( ) ; }
<|startcomment|> work ? validate method i expects hashed passwords shouldn t validate ticket _CODE_ methods I delegate _CODE_ method validates password centralize code <|endcomment|> public void METHOD_1 ( TYPE_1 user , String VAR_1 , String VAR_2 ) throws TYPE_2 { <START> TYPE_3 . METHOD_2 ( user . VAR_3 ( ) , VAR_1 , user . VAR_4 ( ) ) ; <END> VAR_5 . METHOD_1 ( user , VAR_1 , VAR_2 ) ; }
<|startcomment|> consider adding VAR_3 _CODE_ ( VAR_4 ) shot Optional <|endcomment|> public void METHOD_1 ( long VAR_1 ) { if ( VAR_2 == null ) { <START> Optional < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ; <END> METHOD_3 ( VAR_2 . isPresent ( ) , STRING_1 ) ; this . VAR_2 = VAR_2 . get ( ) ; } if ( VAR_1 > 0 ) { VAR_2 . METHOD_4 ( VAR_1 ) ; } else { VAR_2 . METHOD_5 ( - VAR_1 ) ; } }
<|startcomment|> static import <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( ) . assertThat ( new TYPE_1 ( ) ) <START> . METHOD_3 ( p - > METHOD_4 ( p , TYPE_2 . METHOD_5 ( ) ) ) <END> . METHOD_6 ( ) ; }
<|startcomment|> synchronized <|endcomment|> <START> public void METHOD_1 ( int count ) { <END> VAR_1 = count ; }
<|startcomment|> doesn t aligned original implementation <|endcomment|> public TYPE_2 ( ) { <START> METHOD_1 ( TYPE_1 . METHOD_2 ( p - > ! VAR_2 . METHOD_3 ( ) . equals ( p ) ) ) ; <END> }
<|startcomment|> rid parenthesis <|endcomment|> private boolean METHOD_1 ( ) { <START> return ( VAR_1 == null ) <END> || ( VAR_1 . METHOD_2 ( ) == METHOD_3 ( ) ) ; }
<|startcomment|> synchronized <|endcomment|> <START> void METHOD_1 ( Object VAR_1 ) { <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> public <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <END> TYPE_3 < TYPE_2 > VAR_2 = new TYPE_4 < > ( VAR_3 ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; return new TYPE_1 ( this , VAR_2 ) ; }
<|startcomment|> equals ( ) instead METHOD_3 <|endcomment|> private TYPE_1 METHOD_1 ( List < TYPE_1 > VAR_1 , List < TYPE_1 > VAR_2 , TYPE_1 child ) { if ( null != child && TYPE_2 . METHOD_2 ( VAR_2 ) ) { for ( TYPE_1 VAR_3 : VAR_2 ) { <START> if ( child . VAR_4 ( ) . METHOD_3 ( VAR_3 . METHOD_4 ( ) ) == 0 ) { <END> VAR_1 . add ( VAR_3 ) ; VAR_2 . remove ( VAR_3 ) ; return VAR_3 ; } } } return null ; }
<|startcomment|> move private method public analyze * methods <|endcomment|> <START> private void METHOD_1 ( final byte [ ] source ) { <END> final long VAR_1 = TYPE_1 . METHOD_2 ( source ) ; final int version = TYPE_2 . read ( source ) ; final byte [ ] b = TYPE_2 . METHOD_3 ( version , source ) ; final TYPE_3 reader = new TYPE_3 ( b ) ; final TYPE_4 VAR_2 = METHOD_4 ( VAR_1 , reader . VAR_3 ( ) ) ; reader . VAR_4 ( VAR_2 , 0 ) ; }
<|startcomment|> removing configuration option simplifies methods <|endcomment|> public void close ( ) throws TYPE_1 { if ( ! VAR_1 && VAR_2 instanceof TYPE_2 ) { ( ( TYPE_2 ) VAR_2 ) . close ( ) ; } <START> } <END>
<|startcomment|> style : missing braces <|endcomment|> public TYPE_1 METHOD_1 ( File f , TYPE_3 . TYPE_4 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) ) <END> return TYPE_1 . VAR_2 ; else if ( VAR_1 . METHOD_3 ( ) ) { return TYPE_1 . VAR_3 ; } else if ( VAR_1 . METHOD_4 ( ) ) return TYPE_1 . VAR_4 ; else return TYPE_1 . VAR_5 ; }
<|startcomment|> please StringBuilder <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { String type = VAR_2 . type ( ) . name ( ) . METHOD_2 ( ) ; if ( VAR_2 . METHOD_3 ( ) ) { for ( int i = 0 ; i < VAR_2 . METHOD_4 ( ) ; i ++ ) { <START> type += STRING_1 ; <END> } } return METHOD_1 ( VAR_1 , type ) ; }
<|startcomment|> static import TYPE_3 TYPE_1 TYPE_4 VAR_5 <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( STRING_1 , VAR_1 , VAR_2 , <START> TYPE_1 . get ( TYPE_2 . METHOD_3 ( ) , TYPE_3 : : METHOD_4 ) . METHOD_5 ( TYPE_3 . TYPE_1 . TYPE_4 . VAR_5 ) ) ; <END> }
<|startcomment|> a convention typically responsibility _CODE_ ( ) method extract style change figure _CODE_ ( ) typically calls _CODE_ ( ) methods method reads style notation calls _CODE_ ( ) _CODE_ _CODE_ ( ) methods protected subclasses adapt behavior install listeners ( case I doubt ll override _CODE_ _CODE_ ) <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 VAR_1 = ( TYPE_1 ) METHOD_2 ( ) ; <START> TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( TYPE_6 . TYPE_5 . VAR_5 , STRING_1 ) ; <END> if ( VAR_2 instanceof TYPE_3 ) { METHOD_4 ( ( TYPE_3 ) VAR_2 ) ; } else { ( ( TYPE_4 ) METHOD_5 ( ) ) . METHOD_6 ( 0 ) ; } super . METHOD_1 ( ) ; }
<|startcomment|> weird calling METHOD_3 <|endcomment|> @Override public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , TYPE_1 VAR_2 , TYPE_5 . TYPE_7 VAR_3 , Context VAR_4 , TYPE_5 . TYPE_6 VAR_5 ) { if ( VAR_6 == null ) { VAR_6 = new TYPE_4 ( VAR_7 ) ; VAR_6 . METHOD_2 ( TYPE_8 . VAR_9 ) ; } VAR_6 . setText ( VAR_2 . getKey ( ) . toString ( ) ) ; <START> VAR_7 . METHOD_3 ( VAR_6 ) ; <END> VAR_5 . METHOD_4 ( ) ; }
<|startcomment|> return returned called METHOD_1 <|endcomment|> public String METHOD_1 ( TYPE_1 < ? > element ) { <START> return "" ; <END> }
<|startcomment|> _CODE_ modules throw exception _CODE_ _CODE_ ( ) instead calling System exit ( ) <|endcomment|> public TYPE_3 ( ) { <START> TYPE_1 . METHOD_1 ( ) ; <END> VAR_2 = new TYPE_2 ( ) ; }
<|startcomment|> removing public access modifier methods invisible package break code methods other packages please update PR public access modifier : <|endcomment|> <START> void METHOD_1 ( String to ) { <END> if ( to != null && ! "" . equals ( to ) ) { to = to . VAR_1 ( STRING_1 , STRING_2 ) ; props . put ( STRING_3 , to ) ; } }
<|startcomment|> I method final others similar reason final methods <|endcomment|> <START> private void METHOD_1 ( ) throws TYPE_1 { <END> when ( VAR_1 . METHOD_2 ( VAR_2 + VAR_3 , VAR_2 + VAR_4 , VAR_2 + VAR_5 , VAR_2 + VAR_6 ) ) . METHOD_3 ( new TYPE_2 ( VAR_7 ) ) ; when ( VAR_1 . METHOD_2 ( VAR_2 + VAR_3 , VAR_2 + VAR_4 , VAR_2 + VAR_5 , VAR_2 + VAR_8 ) ) . METHOD_3 ( new TYPE_2 ( VAR_9 ) ) ; }
<|startcomment|> notice : s preferable manage comparison < = instead = = <|endcomment|> public TYPE_1 METHOD_1 ( Object [ ] VAR_1 ) { String VAR_2 = "" ; <START> if ( VAR_1 . length == 0 ) { <END> VAR_2 = VAR_3 ; } else { final Object VAR_4 = VAR_1 [ 0 ] ; if ( VAR_1 . length != 1 || false == VAR_4 instanceof TYPE_2 || ( VAR_4 instanceof TYPE_2 && false == ( ( TYPE_2 ) VAR_4 ) . getType ( ) instanceof TYPE_3 ) ) { VAR_2 = Messages . TYPE_4 ; } } return METHOD_2 ( VAR_2 ) ; }
<|startcomment|> efficient looses short circuit property Boolean logic <|endcomment|> public boolean METHOD_1 ( int VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == VAR_3 ) { boolean VAR_4 = TYPE_2 . METHOD_2 ( VAR_2 ) ; boolean VAR_5 = TYPE_2 . METHOD_3 ( VAR_2 ) ; TYPE_3 filter = METHOD_4 ( ) ; boolean VAR_6 = filter == null ; boolean VAR_7 = TYPE_2 . METHOD_5 ( VAR_2 , filter ) ; <START> return VAR_4 && ( VAR_5 || VAR_6 || VAR_7 ) ; <END> } return false ; }
<|startcomment|> TYPE_5 METHOD_3 ( VAR_3 ) ; handle set default ( setting ) <|endcomment|> public TYPE_1 < TYPE_2 , TYPE_2 > METHOD_1 ( ) { return new TYPE_3 < TYPE_2 > ( ) { ANNOTATION_1 ( VAR_1 = STRING_1 , VAR_2 = STRING_2 ) @Override public TYPE_2 METHOD_2 ( TYPE_2 VAR_3 ) { <START> TYPE_4 VAR_4 = TYPE_5 . METHOD_3 ( VAR_3 ) ; <END> if ( TYPE_6 . METHOD_4 ( VAR_4 . METHOD_5 ( ) ) ) { VAR_4 . METHOD_6 ( TYPE_8 . VAR_6 ) ; } TYPE_2 VAR_7 = TYPE_5 . METHOD_7 ( VAR_4 , TYPE_7 . METHOD_8 ( ) . METHOD_9 ( ) ) ; return VAR_7 ; } } ; }
<|startcomment|> lambda insteadprivate void METHOD_1 ( ) { METHOD_2 ( ) METHOD_3 ( ) METHOD_4 ( ( ) - > { TYPE_2 VAR_1 = METHOD_2 ( ) ; ( VAR_1 ! = null && ! VAR_1 METHOD_5 ( ) ) { VAR_2 METHOD_6 ( ) ; } } ) ; } <|endcomment|> private void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( new TYPE_1 ( ) { @Override public void run ( ) <END> { TYPE_2 VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != null && ! VAR_1 . METHOD_5 ( ) ) { VAR_2 . METHOD_6 ( ) ; } } } ) ; }
<|startcomment|> Map instead HashMap left hand side <|endcomment|> private static boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) throws IOException { for ( TYPE_3 VAR_3 : TYPE_3 . METHOD_2 ( VAR_2 ) ) { if ( VAR_3 . METHOD_3 ( VAR_1 ) ) { <START> HashMap < String , TYPE_1 > VAR_4 = TYPE_4 . METHOD_4 ( ) ; <END> for ( TYPE_5 VAR_5 : VAR_3 . METHOD_5 ( VAR_1 ) ) { VAR_4 . put ( VAR_5 . name , VAR_5 . location ) ; } VAR_3 . METHOD_6 ( VAR_4 ) ; return true ; } } return false ; }
<|startcomment|> I : javaif ( uri toString ( ) startsWith ( TYPE_7 VAR_8 toString ( ) ) { uri = TYPE_7 METHOD_2 ( VAR_1 uri ) ; } avoid unnecessary assignment TYPE_3 match <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 uri ) { if ( TYPE_8 . VAR_3 . VAR_4 < TYPE_8 . VAR_5 . VAR_6 ) { final TYPE_3 VAR_7 = uri . toString ( ) . startsWith ( TYPE_6 . TYPE_7 . VAR_8 . toString ( ) ) ? TYPE_6 . TYPE_7 . METHOD_2 ( VAR_1 , uri ) <START> : uri ; <END> return METHOD_3 ( VAR_1 , VAR_7 ) ; } else { return TYPE_5 . get ( VAR_1 , uri ) ; } }
<|startcomment|> multimap returns null rid method <|endcomment|> public Collection < String > METHOD_1 ( String VAR_1 ) { <START> List < String > VAR_2 = VAR_3 . get ( VAR_1 ) ; <END> if ( VAR_2 == null ) { return Collections . VAR_4 ( ) ; } return VAR_2 ; }
<|startcomment|> style : don t braces single line blocks <|endcomment|> private void METHOD_1 ( final TYPE_1 resource ) { TYPE_2 project = resource . VAR_1 ( ) ; TYPE_3 VAR_2 = TYPE_3 . METHOD_2 ( project ) ; if ( VAR_2 == null ) return ; TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( resource ) ; if ( VAR_3 != VAR_4 ) <START> { <END> METHOD_4 ( VAR_3 ) ; } }
<|startcomment|> a length 1 ? s wrong cases <|endcomment|> public void apply ( TYPE_1 VAR_1 ) { VAR_1 . METHOD_1 ( TYPE_2 . VAR_3 ) ; <START> VAR_1 . METHOD_2 ( 1 ) ; <END> VAR_1 . METHOD_3 ( data ) ; }
<|startcomment|> simpler : return Arrays asList ( TYPE_1 VAR_3 ) ; <|endcomment|> private List < TYPE_1 > METHOD_1 ( TYPE_2 session , TYPE_3 resource , TYPE_4 VAR_1 ) { final List < TYPE_1 > VAR_2 = TYPE_5 . METHOD_2 ( ) ; VAR_2 . add ( TYPE_1 . VAR_3 ) ; <START> return VAR_2 ; <END> }
<|startcomment|> change required <|endcomment|> <START> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , byte [ ] VAR_2 ) throws TYPE_3 { <END> TYPE_4 VAR_3 = this . METHOD_2 ( null , VAR_2 , true ) ; if ( VAR_3 . VAR_4 == TYPE_5 . VAR_6 ) { return TYPE_1 . VAR_7 ; } else if ( VAR_3 . VAR_4 == TYPE_5 . VAR_8 ) { return TYPE_1 . VAR_7 ; } return TYPE_1 . METHOD_3 ( VAR_3 . VAR_9 / INT_1 , VAR_3 . VAR_10 , TYPE_6 . VAR_12 ) ; }
<|startcomment|> public methods METHOD_2 ( ) required <|endcomment|> void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> if ( this . VAR_1 != null ) { VAR_1 . METHOD_3 ( ) ; } }
<|startcomment|> need create Set VAR_2 present <|endcomment|> public void METHOD_1 ( Set < String > VAR_1 ) { Optional < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( true ) ; <START> Set < TYPE_2 > VAR_4 = new HashSet < > ( ) ; <END> if ( VAR_2 . isPresent ( ) ) { for ( String VAR_5 : VAR_1 ) { VAR_4 . addAll ( VAR_2 . get ( ) . METHOD_3 ( VAR_5 , TYPE_3 . create ( "" ) ) ) ; } } VAR_4 . forEach ( super : : METHOD_4 ) ; }
<|startcomment|> list isn t needed <|endcomment|> public boolean METHOD_1 ( String VAR_1 ) { <START> List < String > VAR_2 = ImmutableList . of ( STRING_1 ) ; <END> for ( String path : VAR_2 ) { if ( VAR_1 . startsWith ( path ) && ! VAR_1 . equals ( path ) ) { return true ; } } return false ; }
<|startcomment|> catching Exception <|endcomment|> public void execute ( TYPE_1 command ) { final TYPE_1 VAR_1 = METHOD_1 ( command , VAR_2 ) ; try { super . execute ( METHOD_2 ( VAR_1 ) ) ; <START> } catch ( TYPE_2 e ) { <END> VAR_2 . METHOD_3 ( ) ; throw e ; } }
<|startcomment|> needed <|endcomment|> public void METHOD_1 ( ) { <START> final int [ ] VAR_1 = new int [ ] { INT_1 } ; <END> assertEquals ( STRING_1 , METHOD_2 ( new TYPE_1 ( TYPE_2 . METHOD_3 ( INT_2 , VAR_1 ) ) ) ) ; }
<|startcomment|> context a TYPE_2 <|endcomment|> private void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { <START> ( ( TYPE_2 ) context ) . METHOD_2 ( ) ; <END> TYPE_3 VAR_2 = new TYPE_3 ( context , TYPE_4 . class ) ; TYPE_5 . getInstance ( ) . METHOD_3 ( VAR_1 ) ; context . VAR_3 ( VAR_2 ) ; }
<|startcomment|> please perform update explicitly image modified line ( add getId ) <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( ) . getParameters ( ) . METHOD_3 ( ) . METHOD_4 ( TYPE_2 . VAR_2 ) ; TYPE_1 . METHOD_5 ( <START> METHOD_2 ( ) . getParameters ( ) . METHOD_6 ( ) , TYPE_2 . VAR_2 ) ; <END> }
<|startcomment|> assertEquals <|endcomment|> public void METHOD_1 ( ) { Set < TYPE_1 < TYPE_2 > > VAR_1 = VAR_2 . METHOD_2 ( METHOD_3 ( ) , VAR_3 ) ; assertEquals ( VAR_4 , VAR_1 . isEmpty ( ) ) ; if ( VAR_4 ) { assertTrue ( VAR_1 . isEmpty ( ) ) ; } else { assertEquals ( 1 , VAR_1 . size ( ) ) ; <START> assertTrue ( VAR_1 . iterator ( ) . next ( ) . getMessage ( ) . equals ( message ) ) ; <END> } }
<|startcomment|> VAR_2 null statement evaluate true ? loop happen <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IOException { VAR_1 = null ; VAR_2 = null ; while ( true ) { METHOD_2 ( ) ; if ( VAR_1 != null ) { return TYPE_1 . VAR_3 ; } METHOD_3 ( ) ; if ( VAR_2 != null ) { return TYPE_1 . LOG ; } <START> if ( VAR_4 == null || VAR_4 . METHOD_4 ( ) || VAR_4 . VAR_5 . METHOD_5 ( ) ) { <END> return TYPE_1 . VAR_6 ; } } }
<|startcomment|> a good convention changing METHOD_1 ( ) able return null s more elements <|endcomment|> public boolean hasNext ( ) { if ( VAR_1 != null ) { return true ; } try { VAR_1 = METHOD_1 ( ) ; return true ; } catch ( TYPE_1 e ) { <START> return false ; <END> } }
<|startcomment|> removed TYPE_4 handle null <|endcomment|> public void METHOD_1 ( TYPE_1 monitor ) throws TYPE_2 { if ( monitor == null ) <START> monitor = new TYPE_3 ( ) ; <END> TYPE_4 VAR_1 = TYPE_4 . METHOD_2 ( monitor , STRING_1 , this . VAR_2 . length ) ; for ( TYPE_5 VAR_3 : this . VAR_2 ) { METHOD_3 ( VAR_3 , VAR_1 . METHOD_4 ( 1 ) ) ; } }
<|startcomment|> sense METHOD_3 server shared storage METHOD_3 operation failed ? avoid leaking resources <|endcomment|> public void METHOD_1 ( ) throws InterruptedException { METHOD_2 ( ) . METHOD_3 ( VAR_1 . id ( ) ) ; <START> METHOD_4 ( VAR_2 ) ; <END> METHOD_5 ( VAR_2 . id ( ) ) ; }
<|startcomment|> unnecessary <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( VAR_1 != null ) { this . VAR_1 = VAR_1 ; } <END> return this ; }
<|startcomment|> I m need remove static modifiers some valid ( notably ) <|endcomment|> <START> private boolean METHOD_1 ( Type type ) { <END> return type . VAR_1 ( VAR_2 ) || type . VAR_1 ( VAR_3 ) ; }
<|startcomment|> needs synchronized <|endcomment|> <START> public synchronized TYPE_1 METHOD_1 ( ) { <END> if ( VAR_1 == null ) { throw new TYPE_1 . TYPE_3 ( STRING_1 ) ; } return VAR_1 ; }
<|startcomment|> I remove change <|endcomment|> <START> public TYPE_1 ( String path , String VAR_2 , long VAR_3 ) { <END> this . path = METHOD_1 ( path , STRING_1 ) ; this . VAR_2 = METHOD_1 ( VAR_2 , STRING_2 , path ) ; this . VAR_3 = VAR_3 ; }
<|startcomment|> ANNOTATION_1 double [ ] <|endcomment|> public <START> double ANNOTATION_1 [ ] METHOD_1 ( ) <END> { return VAR_1 ; }
<|startcomment|> a simple loop : javafor ( int i = VAR_3 [ VAR_2 ] ; i < VAR_3 [ j + 1 ] ; i + + ) { VAR_1 apply ( VAR_4 [ i ] j values [ i ] ) ; } wrong code i = _CODE_ [ VAR_2 ] row _CODE_ [ i ] strange I guarantee fail tests <|endcomment|> <START> public void METHOD_1 ( int j , TYPE_1 VAR_1 ) { <END> int VAR_2 = VAR_3 [ j ] , i = VAR_4 [ VAR_2 ] ; while ( i < VAR_3 [ j + 1 ] ) { VAR_1 . apply ( VAR_4 [ i ] , j , values [ i ] ) ; i ++ ; } }
<|startcomment|> wrong casting <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { Assert . VAR_2 ( VAR_1 , STRING_1 ) ; if ( TYPE_3 . class . METHOD_2 ( VAR_1 . getClass ( ) ) ) { <START> this . VAR_1 = ( TYPE_3 ) VAR_1 ; <END> } else { Assert . VAR_3 ( TYPE_2 . class , VAR_1 , STRING_2 + TYPE_2 . class . getName ( ) + STRING_3 + TYPE_3 . class . getName ( ) ) ; this . VAR_1 = VAR_1 ; } return this . execute ( ) ; }
<|startcomment|> equalsIgnoreCase ( ) <|endcomment|> public static TYPE_1 METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING_1 ) ; } VAR_1 = VAR_1 . METHOD_2 ( ) ; <START> if ( VAR_1 . equals ( STRING_2 ) ) { <END> return VAR_2 ; } if ( VAR_1 . equals ( STRING_3 ) || VAR_1 . equals ( STRING_4 ) ) { return VAR_3 ; } throw new IllegalArgumentException ( STRING_5 + VAR_1 + STRING_6 ) ; }
<|startcomment|> typo <|endcomment|> protected TYPE_1 METHOD_1 ( Map < String , Integer > VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; for ( Map . Entry < String , Integer > VAR_3 : VAR_1 . entrySet ( ) ) { TYPE_2 VAR_4 = METHOD_2 ( VAR_3 . getKey ( ) ) ; TYPE_3 . METHOD_3 ( 0 , VAR_3 . getValue ( ) ) . forEach ( i - > VAR_2 . METHOD_4 ( VAR_4 ) ) ; } <START> ; <END> return VAR_2 ; }
<|startcomment|> I m a fan METHOD_6 general android advice a resort handling _CODE_ <|endcomment|> private void METHOD_1 ( byte [ ] VAR_1 , TYPE_1 VAR_2 , String VAR_3 , TYPE_5 . TYPE_6 VAR_4 ) { TYPE_3 VAR_5 = TYPE_4 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , false , VAR_4 ) ; METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( R . id . VAR_6 , VAR_5 , VAR_7 ) <START> . METHOD_6 ( ) ; <END> }
<|startcomment|> warning : METHOD_1 a nullable argumenthighlights a UT missing ( testing Optional empty ( ) returned argument null ) <|endcomment|> public TYPE_1 ( String VAR_2 , ANNOTATION_1 String VAR_3 , ANNOTATION_1 String VAR_4 , String name , String url ) { this . VAR_2 = METHOD_1 ( VAR_2 ) ; this . VAR_3 = VAR_3 ; <START> this . VAR_4 = METHOD_1 ( VAR_4 ) ; <END> this . name = METHOD_1 ( name ) ; this . url = METHOD_1 ( url ) ; }
<|startcomment|> I want result call expected modified I assignment a instance variable _CODE_ <|endcomment|> private static List < String > METHOD_1 ( final Object VAR_1 ) { if ( VAR_1 instanceof List ) { return ( List < String > ) VAR_1 ; } <START> return Collections . VAR_2 ( ( String ) VAR_1 ) ; <END> }
<|startcomment|> VAR_1 substring ( VAR_2 length ( ) ) <|endcomment|> protected String METHOD_1 ( String VAR_1 ) { if ( ! VAR_1 . startsWith ( VAR_2 ) ) { throw new IllegalArgumentException ( String . format ( STRING_1 , VAR_1 , VAR_2 ) ) ; } <START> return VAR_1 . METHOD_2 ( VAR_2 , "" ) ; <END> }
<|startcomment|> / / nitpick - mode - _CODE_ change ctx ctx ? / / nitpick - mode - <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { File VAR_2 ; String VAR_3 = TYPE_3 . METHOD_2 ( VAR_4 , VAR_1 ) ; if ( VAR_3 != null ) { VAR_2 = new File ( VAR_3 ) ; } else { <START> VAR_2 = new File ( this . ctx . VAR_5 ( ) . METHOD_3 ( ) , VAR_6 ) ; <END> } Log . d ( TAG , STRING_1 + VAR_2 . METHOD_3 ( ) ) ; return new TYPE_4 ( VAR_2 , METHOD_4 ( VAR_1 ) ) ; }
<|startcomment|> clean message <|endcomment|> public void run ( final TYPE_1 configuration , final TYPE_2 VAR_1 ) throws Exception { <START> log . info ( STRING_1 ) ; <END> METHOD_1 ( configuration , VAR_1 ) ; METHOD_2 ( VAR_1 ) ; METHOD_3 ( VAR_1 ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( VAR_1 ) ; }
<|startcomment|> potentially throw IOException <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 stream ) throws IOException , TYPE_3 { String line ; StringBuilder result = new StringBuilder ( ) ; TYPE_4 reader = new TYPE_4 ( new TYPE_5 ( stream ) ) ; try { while ( ( line = reader . VAR_1 ( ) ) != null ) { result . append ( line ) ; } } finally { <START> reader . close ( ) ; <END> } return new TYPE_1 ( result . toString ( ) ) ; }
<|startcomment|> s a testing facility I d methods package private another approach manually register a _CODE_ work _CODE_ singleton <|endcomment|> <START> public void METHOD_1 ( TYPE_1 < TYPE_2 , TYPE_3 > VAR_1 ) { <END> this . VAR_1 = VAR_1 ; }
<|startcomment|> A number tests don t throw TYPE_1 please remove throws signature unnecessary ? expectations test clearer <|endcomment|> <START> public void METHOD_1 ( ) throws TYPE_1 { <END> request . VAR_1 ( STRING_1 , STRING_2 ) ; matcher = new TYPE_2 ( new TYPE_3 ( STRING_3 , STRING_4 ) ) ; matcher . VAR_2 ( true ) ; assertThat ( matcher . VAR_3 ( request ) ) . METHOD_2 ( ) ; }
<|startcomment|> forEach gaining a lambda <|endcomment|> default void VAR_1 ( final TYPE_1 < ? super VAR_3 > filter , TYPE_3 < ? super VAR_3 , TYPE_2 < VAR_3 , VAR_6 > > action ) throws InterruptedException { <START> iterator ( ) . VAR_7 ( VAR_8 - > { <END> if ( filter == null || filter . VAR_9 ( VAR_8 . getKey ( ) ) ) { action . VAR_9 ( VAR_8 . getKey ( ) , VAR_8 ) ; } } ) ; }
<|startcomment|> set final <|endcomment|> private void METHOD_1 ( final String VAR_1 , final TYPE_1 user ) { <START> TYPE_2 VAR_2 = TYPE_2 . getInstance ( ) ; <END> try { VAR_2 . METHOD_2 ( new TYPE_3 ( ) . METHOD_3 ( TYPE_4 . format ( user . VAR_3 ( ) , STRING_1 , VAR_1 ) ) . METHOD_4 ( TYPE_7 . VAR_5 ) . METHOD_5 ( TYPE_8 . VAR_7 ) . create ( ) , list ( user . VAR_8 ( ) ) ) ; } catch ( TYPE_5 e ) { throw new TYPE_6 ( e ) ; } }
<|startcomment|> synchronized necessary <|endcomment|> <START> public synchronized void METHOD_1 ( long VAR_1 ) { <END> VAR_2 . METHOD_2 ( VAR_3 - > { if ( VAR_1 <= VAR_3 ) { return VAR_3 ; } return VAR_1 ; } ) ; }
<|startcomment|> missing braces bodies ( ) <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_1 . VAR_2 . METHOD_2 ( CHAR_1 ) == - 1 ) return false ; for ( TYPE_2 VAR_3 : VAR_4 ) { if ( VAR_3 . getPath ( ) . METHOD_3 ( VAR_1 . VAR_2 ) > 0 ) return false ; <END> if ( VAR_3 . METHOD_4 ( VAR_1 . VAR_2 ) ) { return true ; } } return false ; }
<|startcomment|> exception logged completely <|endcomment|> public void write ( TYPE_1 out ) { try { TYPE_2 . METHOD_1 ( results . VAR_1 ( ) , out ) ; } catch ( IOException e ) { <START> log . warn ( e . getMessage ( ) ) ; <END> throw new TYPE_3 ( Response . status ( Status . VAR_2 ) . entity ( STRING_1 ) . build ( ) ) ; } finally { results . VAR_3 ( ) ; } }
<|startcomment|> fit line <|endcomment|> private static Collection < ANNOTATION_1 TYPE_1 > METHOD_1 ( ) { Set < ANNOTATION_1 String > VAR_1 = <START> Collections . VAR_2 ( TYPE_3 . VAR_4 ) ; <END> TYPE_2 VAR_5 = new TYPE_2 ( StringUtils . VAR_6 , VAR_1 ) ; return Collections . VAR_2 ( VAR_5 ) ; }
<|startcomment|> static others ? function _CODE_ <|endcomment|> <START> protected boolean METHOD_1 ( boolean VAR_1 , boolean VAR_2 ) { <END> return ( TYPE_1 . instance ( ) . METHOD_2 ( ) != TYPE_2 . VAR_4 || VAR_1 || VAR_2 ) ; }
<|startcomment|> considered skipping line _CODE_ < TYPE_2 > result = new TYPE_3 ( VAR_1 ) ; <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ) { TYPE_1 < TYPE_2 > result = new TYPE_3 < > ( ) ; <START> result . addAll ( VAR_1 ) ; <END> VAR_1 . clear ( ) ; return result ; }
<|startcomment|> VAR_1 VAR_2 VAR_3 define start ? I collection a static final variable class level <|endcomment|> private void METHOD_1 ( ) throws TYPE_1 { VAR_1 . addAll ( VAR_2 ) ; <START> VAR_1 . addAll ( VAR_3 ) ; <END> TYPE_2 config = METHOD_2 ( METHOD_3 ( ) , VAR_1 ) ; log . info ( STRING_1 ) ; METHOD_4 ( STRING_2 , config ) ; }
<|startcomment|> please fix issue <|endcomment|> <START> private TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , final TYPE_2 target ) { <END> if ( target != null && METHOD_2 ( VAR_1 , target ) ) { return VAR_1 . METHOD_3 ( target . VAR_2 ( ) , TYPE_3 . VAR_4 ) ; } return VAR_1 ; }
<|startcomment|> VAR_2 throw NPE ( ) VAR_3 null s throw construction : VAR_3 = preconditions _CODE_ ( VAR_3 VAR_3 ) ; <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = VAR_2 ; <START> this . VAR_5 = VAR_3 ; <END> }
<|startcomment|> account list null empty <|endcomment|> private String METHOD_1 ( ) { TYPE_1 [ ] VAR_1 = VAR_2 . METHOD_2 ( TYPE_2 . TYPE_3 . VAR_5 ) ; <START> return VAR_1 [ 0 ] . name ; <END> }
<|startcomment|> suggest parenthesis clarify order operator evaluation <|endcomment|> private boolean METHOD_1 ( Long VAR_1 , Long VAR_2 ) { <START> return VAR_2 != - 1 && VAR_1 + VAR_2 < System . currentTimeMillis ( ) / INT_1 ; <END> }
<|startcomment|> parameter some location diff <|endcomment|> private void METHOD_1 ( ) { if ( context . VAR_1 ( ) . METHOD_2 ( ) != null ) { final String VAR_2 = context . VAR_1 ( ) . METHOD_2 ( ) ; VAR_3 . METHOD_3 ( Constants . VAR_4 . METHOD_4 ( VAR_2 ) , VAR_5 . METHOD_5 ( ) , VAR_2 , TYPE_1 . VAR_7 , ( ) - > METHOD_6 ( VAR_5 . METHOD_7 ( ) ) , ( ) - > { <START> } ) ; <END> } else { METHOD_6 ( VAR_5 . METHOD_7 ( ) ) ; } }
<|startcomment|> missing @Override annotations <|endcomment|> <START> public TYPE_1 get ( final String key ) { <END> return super . get ( key . VAR_1 ( ) ) ; }
<|startcomment|> finally restore <|endcomment|> public static byte [ ] METHOD_1 ( ByteBuffer buf ) { byte [ ] VAR_1 = new byte [ buf . VAR_2 ( ) ] ; int VAR_3 = buf . position ( ) ; buf . get ( VAR_1 ) ; <START> buf . position ( VAR_3 ) ; <END> return VAR_1 ; }
<|startcomment|> style - : braces aren t necessary <|endcomment|> private boolean METHOD_1 ( ) { if ( ! VAR_1 . METHOD_2 ( ) ) return VAR_2 . METHOD_3 ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { <START> if ( VAR_2 . METHOD_3 ( ) ) { <END> return true ; } try { Thread . VAR_3 ( 100 ) ; } catch ( InterruptedException e ) { } } return false ; }
<|startcomment|> some VAR_2 entries NULL table partitioned need handle <|endcomment|> public TYPE_1 METHOD_1 ( int VAR_1 ) throws Exception { return VAR_2 == null ? null : <START> ( TYPE_1 ) TYPE_2 . METHOD_2 ( VAR_2 . get ( VAR_1 ) , TYPE_1 . class ) ; <END> }
<|startcomment|> isn t a messaging component other side a messaging component raising a TYPE_1 prevent - throwing a correct TYPE_1 _CODE_ context simple RuntimeException enough context WDYT <|endcomment|> public void METHOD_1 ( ) { try { this . VAR_1 . METHOD_2 ( ) ; } catch ( Exception e ) { <START> throw new TYPE_1 ( STRING_1 + this . path , e ) ; <END> } }
<|startcomment|> please move method consistent <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( true ) ; for ( Map . Entry < TYPE_1 , List < TYPE_2 > > VAR_1 : METHOD_3 ( ) . entrySet ( ) ) { METHOD_4 ( VAR_1 . getKey ( ) , VAR_1 . getValue ( ) ) ; } <START> if ( TYPE_3 . METHOD_5 ( METHOD_6 ( ) . METHOD_7 ( ) ) ) { <END> METHOD_8 ( ) ; } }
<|startcomment|> create new List ? VAR_2 returns a list <|endcomment|> protected void METHOD_1 ( ) { TYPE_1 parameters = getParameters ( ) ; status = METHOD_2 ( ) . METHOD_3 ( parameters . VAR_1 ( ) , <START> new ArrayList < > ( parameters . VAR_2 ( ) ) ) ; <END> METHOD_4 ( ) ; }
<|startcomment|> setting endpoints client <|endcomment|> public static void METHOD_1 ( ) throws Exception { VAR_1 = new TYPE_1 ( ) ; TYPE_2 . METHOD_2 ( VAR_1 ) ; VAR_1 . METHOD_3 ( TYPE_3 . METHOD_4 ( ) . METHOD_5 ( ) ) ; VAR_1 . METHOD_6 ( TYPE_3 . METHOD_4 ( ) . METHOD_7 ( ) ) ; <START> VAR_2 = new TYPE_4 ( ) ; <END> VAR_3 = TYPE_2 . METHOD_8 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> I _CODE_ RFW allocated [ fragment context VAR_5 ] ( ) operator context order METHOD_3 ( ) called matters <|endcomment|> public void close ( ) { METHOD_1 ( ) ; METHOD_2 ( VAR_1 ) ; for ( TYPE_1 VAR_2 : VAR_3 ) { METHOD_2 ( VAR_2 ) ; } <START> METHOD_3 ( ) ; <END> METHOD_2 ( VAR_4 ) ; METHOD_2 ( VAR_5 ) ; }
<|startcomment|> auto - boxing auto - unboxing manually pool String / numbers java need return VAR_6 METHOD_4 ( ) <|endcomment|> public Long METHOD_1 ( String VAR_1 , final long VAR_2 ) { final TYPE_1 < TYPE_2 > VAR_3 = TYPE_3 . create ( ) ; VAR_3 . METHOD_2 ( STRING_1 , VAR_2 ) ; VAR_3 . METHOD_2 ( STRING_2 , VAR_1 ) ; VAR_3 . METHOD_2 ( STRING_3 , TYPE_5 . Type . TYPE_4 ) ; TYPE_2 VAR_6 = METHOD_3 ( VAR_3 ) ; if ( VAR_6 != null ) { <START> return ( new Long ( VAR_6 . METHOD_4 ( ) ) ) ; <END> } return null ; }
<|startcomment|> List < TYPE_2 TYPE_3 > variable declaration ( interface declaration implementation instantiation ) <|endcomment|> public List < TYPE_2 . TYPE_3 > METHOD_1 ( ) { <START> ArrayList < TYPE_2 . TYPE_3 > VAR_1 = new ArrayList < > ( super . METHOD_1 ( ) ) ; <END> VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_2 ) ; VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_3 ) ; VAR_1 . add ( TYPE_2 . TYPE_3 . VAR_4 ) ; return VAR_1 ; }
<|startcomment|> super minor : format _CODE_ test ( some autoformatting leave ) : String VAR_1 = STRING_2 + STRING_3 + STRING_4 + STRING_5 ; <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 ) ; <START> String VAR_1 = STRING_2 <END> + STRING_3 + STRING_4 + STRING_5 ; METHOD_3 ( VAR_2 + VAR_1 + VAR_1 + VAR_3 , null ) ; }
<|startcomment|> put METHOD_3 method call VAR_1 instanceof checks - perform d avoid calling synchronous method other nexus events add brackets clear status check applies events registry <|endcomment|> public boolean METHOD_1 ( TYPE_1 < ? > VAR_1 ) { return VAR_2 . METHOD_2 ( ) . METHOD_3 ( ) && ( VAR_1 instanceof TYPE_2 ) <START> || ( VAR_1 instanceof TYPE_3 ) ; <END> }
<|startcomment|> braces required coding convention <|endcomment|> public static TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) <START> return null ; <END> return VAR_2 . METHOD_3 ( ) ; }
<|startcomment|> I prefer : ( METHOD_2 ( ) ) return TYPE_1 METHOD_3 ( info VAR_1 + VAR_2 ) < < INT_1 ; elsereturn 0 ; <|endcomment|> private int METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> return 0 ; } return TYPE_1 . METHOD_3 ( info , VAR_1 + VAR_2 ) < < INT_1 ; }
<|startcomment|> VAR_3 put ( id VAR_1 ) ; <|endcomment|> protected void update ( final Map < String , Object > VAR_1 ) { final String id = ( String ) VAR_1 . get ( METHOD_1 ( ) ) ; logger . debug ( STRING_1 , id , VAR_1 ) ; final Map < String , Object > VAR_2 = VAR_3 . get ( id ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_2 ( VAR_1 ) ; } else { <START> METHOD_3 ( VAR_1 ) ; <END> } }
<|startcomment|> I able line : / <|endcomment|> private < T extends TYPE_1 > T METHOD_1 ( Class < T > VAR_1 ) { for ( TYPE_1 VAR_2 : VAR_3 ) { if ( VAR_1 . METHOD_2 ( VAR_2 . getClass ( ) ) ) { if ( VAR_2 instanceof TYPE_2 ) { <START> METHOD_3 ( ( TYPE_2 ) VAR_2 ) ; <END> } return ( T ) VAR_2 ; } } log . error ( STRING_1 + VAR_1 ) ; return null ; }
<|startcomment|> chnge error <|endcomment|> private TYPE_3 ( final String url ) { TYPE_1 VAR_2 = null ; try { VAR_2 = new TYPE_1 ( url ) ; } catch ( TYPE_2 e ) { LOG . info ( TYPE_4 . VAR_4 , e ) ; } if ( VAR_2 == null ) { return ; } VAR_5 = VAR_2 . METHOD_1 ( STRING_1 ) ; if ( VAR_5 == null ) { <START> LOG . info ( STRING_2 ) ; <END> } else { METHOD_2 ( ) ; } }
<|startcomment|> shows algorithm list moved base fb change alg type work siimple fbs <|endcomment|> public void METHOD_1 ( ) { <START> if ( VAR_1 instanceof TYPE_1 ) { ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . add ( ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . METHOD_3 ( VAR_2 ) , VAR_3 ) ; METHOD_4 ( false ) ; ( ( TYPE_1 ) VAR_1 ) . METHOD_2 ( ) . remove ( VAR_2 ) ; } <END> }
<|startcomment|> static import currentTimeMillis <|endcomment|> public long METHOD_1 ( ) { <START> return System . currentTimeMillis ( ) - VAR_1 . get ( ) ; <END> }
<|startcomment|> METHOD_9 ( ) pretty weak t METHOD_7 pass _CODE_ <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( 1 ) ; when ( VAR_1 . METHOD_3 ( ) ) . METHOD_4 ( TYPE_2 . TYPE_1 . VAR_4 ) ; METHOD_5 ( ) ; VAR_5 . METHOD_6 ( VAR_1 , VAR_6 , listener , null ) ; <START> METHOD_7 ( VAR_7 ) . METHOD_8 ( METHOD_9 ( ) ) ; <END> }
<|startcomment|> I prefer else instead return <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( R . id . VAR_3 ) ; if ( VAR_1 instanceof TYPE_2 ) { VAR_2 . METHOD_3 ( TYPE_3 . VAR_5 , 0 ) ; <START> return ; <END> } super . METHOD_1 ( ) ; }
<|startcomment|> instanceof check good case other items added view future <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 , Object parent , Object element ) { <START> TYPE_2 VAR_2 = ( TYPE_2 ) element ; <END> TYPE_3 VAR_3 = TYPE_4 . METHOD_2 ( ) . METHOD_3 ( VAR_4 . METHOD_4 ( VAR_2 ) ) ; if ( VAR_3 == null ) { return true ; } return ! VAR_3 . METHOD_5 ( ) . METHOD_6 ( ) ; }
<|startcomment|> wide catch RuntimeException : ( java lang String ) <|endcomment|> public void METHOD_1 ( TYPE_1 context ) { super . context = context ; if ( VAR_1 ) { try { VAR_2 = TYPE_2 . METHOD_2 ( VAR_3 , TYPE_2 . VAR_4 ) ; <START> } catch ( RuntimeException e ) { <END> throw new IllegalArgumentException ( STRING_1 + getClass ( ) . METHOD_3 ( ) + STRING_2 + VAR_3 , e ) ; } } else { VAR_5 = VAR_3 . split ( STRING_3 ) ; } METHOD_4 ( context . VAR_6 ( ) ) ; }
<|startcomment|> method needs enhance I true code bellow false I System METHOD_2 ( STRING_1 ) ; replaced some log <|endcomment|> private boolean METHOD_1 ( Object value ) { if ( value == null ) { System . out . METHOD_2 ( STRING_1 ) ; <START> } <END> return TYPE_1 . METHOD_3 ( value ) && ( ( value instanceof String ) || ( VAR_1 . METHOD_4 ( value . getClass ( ) ) ) ) ; }
<|startcomment|> nitpick : space <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( VAR_2 != null ) { <END> TYPE_2 . METHOD_2 ( ) ; key ( ) . METHOD_3 ( VAR_2 ) ; value ( ) . METHOD_3 ( VAR_2 ) ; } VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; }
<|startcomment|> 1 trick LOG : add exception argument logged automatically : _CODE_ info ( STRING_1 + path e ) ; 2 i throw exception swallow catch convert exception log message <|endcomment|> public static void METHOD_1 ( String path ) throws IOException { try { TYPE_1 . METHOD_2 ( TYPE_2 . get ( path ) ) ; } catch ( TYPE_3 e ) { <START> LOG . info ( STRING_1 + path + STRING_2 ) ; <END> } }
<|startcomment|> null instead <|endcomment|> public TYPE_1 ( ) { <START> this ( false , false , false , 0 , 0 , 0 , "" , "" , "" ) ; <END> VAR_2 = false ; }
<|startcomment|> I replace statements ( VAR_5 VAR_3 VAR_4 VAR_2 false ) <|endcomment|> public TYPE_1 ( int VAR_2 , long VAR_3 , long VAR_4 , List < Class < ? > > VAR_5 ) { this . VAR_6 = VAR_5 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_7 = VAR_2 ; <START> this . VAR_8 . set ( false ) ; <END> }
<|startcomment|> error message metric messy arbitrary strings long error error code–a _very_ short exception type enough exceptions <|endcomment|> public void METHOD_1 ( Exception e ) { <START> String VAR_1 = e . getMessage ( ) . METHOD_2 ( VAR_2 , STRING_1 ) ; <END> VAR_3 . METHOD_3 ( METHOD_4 ( VAR_4 , e , VAR_1 ) ) . METHOD_5 ( ) ; }
<|startcomment|> static imports form TYPE_2 <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) ; TYPE_2 . assertTrue ( VAR_1 . METHOD_3 ( ) ) ; <START> TYPE_2 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_2 ) ; <END> }
<|startcomment|> move METHOD_3 <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> METHOD_2 ( ) ; <END> int VAR_1 = 5 ; final String VAR_2 = STRING_1 ; final String VAR_3 = STRING_2 ; METHOD_3 ( VAR_1 , VAR_2 , VAR_3 ) ; }
<|startcomment|> a validate method return true case success false validation failed <|endcomment|> <START> private boolean METHOD_1 ( Set < String > VAR_1 ) { <END> for ( String VAR_2 : VAR_1 ) { if ( METHOD_2 ( ) . METHOD_3 ( VAR_2 ) . size ( ) > 0 || METHOD_2 ( ) . METHOD_4 ( VAR_2 ) . size ( ) > 0 ) { return true ; } } return false ; }
<|startcomment|> I don t VAR_3 change <|endcomment|> public void update ( ) { VAR_1 = VAR_2 . METHOD_1 ( VAR_3 ) . VAR_1 ; task . VAR_4 ( VAR_1 ) ; <START> task . VAR_5 ( VAR_3 ) ; <END> }
<|startcomment|> ah - guessing static TYPE_1 interface workarounds avoid depending static class <|endcomment|> public static String METHOD_1 ( ) { <START> return TYPE_1 . METHOD_2 ( ) . METHOD_1 ( ) ; <END> }
<|startcomment|> curly braces <|endcomment|> public TYPE_1 add ( TYPE_2 < TYPE_3 > VAR_1 ) throws TYPE_4 , TYPE_5 { <START> for ( TYPE_3 id : VAR_1 ) { <END> add ( id ) ; } return this ; }
<|startcomment|> remove public modifier injection constructors <|endcomment|> <START> public TYPE_4 ( TYPE_1 VAR_2 ) { <END> super ( VAR_2 , TYPE_2 . get ( TYPE_3 . class ) ) ; }
<|startcomment|> shouldn t private types <|endcomment|> <START> public int value ( ) { <END> return VAR_1 . METHOD_1 ( ) ; }
<|startcomment|> static import consistency ? : ) <|endcomment|> private void METHOD_1 ( ) throws IOException { if ( ! METHOD_2 ( ) . get ( VAR_1 ) ) { return ; } TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 . METHOD_3 ( TYPE_2 . class ) , <START> config . get ( TYPE_3 . VAR_5 ) . METHOD_4 ( ) , <END> config . get ( VAR_6 ) . toString ( ) , config . get ( VAR_7 ) , config . get ( VAR_8 ) ) ; VAR_9 . METHOD_5 ( VAR_2 ) ; }
<|startcomment|> METHOD_6 impacts result matter METHOD_4 <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( ) ; if ( ( METHOD_4 ( ) && ! VAR_1 . METHOD_5 ( ) ) <START> || METHOD_6 ( ) ) { <END> log . debug ( STRING_1 ) ; METHOD_7 ( VAR_2 . METHOD_8 ( ) ) ; } }
<|startcomment|> I forEach ensures done collection empty remove outer <|endcomment|> private void METHOD_1 ( Map < Integer , Map < Integer , String > > VAR_1 ) { if ( ! VAR_1 . isEmpty ( ) ) { <START> VAR_1 . forEach ( ( VAR_2 , VAR_3 ) - > { <END> model . VAR_4 ( VAR_2 , new TYPE_1 ( ) ) ; VAR_3 . forEach ( ( VAR_5 , VAR_6 ) - > model . VAR_7 ( VAR_2 , VAR_5 , ( ) - > new TYPE_2 ( new TYPE_3 ( VAR_6 ) ) ) ) ; } ) ; } }
<|startcomment|> _CODE_ 구조적으로 null을 return 하지 않음 ( ) 방어코드를 줄이기 위해 _CODE_ pattern이 쓰였는데 나중에 도입된거라 조금 아쉽게 만들어져 있긴 함 <|endcomment|> public static boolean METHOD_1 ( String VAR_1 , TYPE_1 project ) { if ( VAR_1 == null ) { return false ; } <START> TYPE_2 user = TYPE_2 . METHOD_2 ( VAR_1 ) ; <END> if ( user == null || user . VAR_2 ( ) ) { return false ; } if ( user . VAR_3 ( ) || TYPE_3 . METHOD_3 ( user . id , project . id ) ) { return true ; } return false ; }
<|startcomment|> brackets put METHOD_1 line <|endcomment|> public void METHOD_1 ( ) { VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 != null ) { VAR_2 . METHOD_1 ( ) ; } <END> }
<|startcomment|> double semicolon <|endcomment|> private void METHOD_1 ( TYPE_1 out ) throws IOException { out . VAR_1 ( VAR_2 ) ; out . VAR_1 ( VAR_3 ) ; out . VAR_1 ( VAR_4 ) ; synchronized ( VAR_5 ) { if ( VAR_6 == null ) { VAR_6 = METHOD_2 ( TYPE_2 . class , <START> VAR_7 ) ; ; <END> } } out . VAR_1 ( VAR_6 ) ; out . VAR_1 ( VAR_8 ) ; out . VAR_1 ( VAR_9 ) ; }
<|startcomment|> I prefer standard java API instead minimize dependencies usage <|endcomment|> public TYPE_2 ( ) { String VAR_2 = Context . VAR_3 ( ) . getString ( STRING_1 ) ; if ( VAR_2 != null ) { VAR_4 . addAll ( Arrays . asList ( VAR_2 . split ( STRING_2 ) ) ) ; } <START> VAR_5 = TYPE_1 . METHOD_1 ( Context . VAR_3 ( ) . getString ( STRING_3 , VAR_6 ) . split ( STRING_2 ) ) ; <END> }
<|startcomment|> checked construction time guy excluding values enum throw a beautiful IllegalArgumentException METHOD_1 declare throwing TYPE_2 <|endcomment|> public TYPE_1 METHOD_1 ( ) throws TYPE_2 { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 . isEmpty ( ) ) { <END> throw new TYPE_2 ( STRING_1 ) ; } int VAR_2 = VAR_3 . METHOD_3 ( VAR_1 . size ( ) ) ; return VAR_1 . get ( VAR_2 ) ; }
<|startcomment|> remove <|endcomment|> public void METHOD_1 ( int VAR_1 ) { <START> this . METHOD_1 ( VAR_1 , <END> VAR_1 ) ; }
<|startcomment|> A HTTP header named treated invalid I refuse construction coerce <|endcomment|> private boolean METHOD_1 ( TYPE_1 request ) { if ( VAR_1 == null <START> || VAR_1 . length ( ) == 0 ) { <END> return false ; } return request . VAR_2 ( VAR_1 ) == null ; }
<|startcomment|> METHOD_1 info level a _CODE_ another hop enable debug topology <|endcomment|> private void METHOD_1 ( List < List < Object > > VAR_1 , List < TYPE_1 > VAR_2 ) { for ( int i = 0 ; i < VAR_1 . size ( ) ; i ++ ) { TYPE_1 VAR_3 = VAR_2 . get ( i ) ; Object VAR_4 = ( ( TYPE_2 ) VAR_3 ) . METHOD_2 ( ) ; <START> LOG . debug ( STRING_1 , VAR_5 , VAR_1 . get ( i ) , VAR_4 ) ; <END> } }
<|startcomment|> omitted <|endcomment|> public TYPE_2 ( String VAR_2 , String VAR_3 , List < TYPE_1 > VAR_4 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = new ArrayList < TYPE_1 > ( VAR_4 ) ; }
<|startcomment|> change ( VAR_2 new TYPE_6 ( ) ) <|endcomment|> public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) { <START> super ( VAR_2 ) ; <END> this . response = new TYPE_4 ( ) ; this . VAR_5 = new TYPE_5 ( ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_6 = new TYPE_6 ( ) ; }
<|startcomment|> I don t feel good constructor counter - intuitive VAR_3 argument VAR_3 embededed VAR_2 object a access <|endcomment|> <START> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { <END> super ( VAR_2 ) ; VAR_4 = VAR_3 ; VAR_5 = new TYPE_3 ( VAR_4 ) ; }
<|startcomment|> I d remove guard simply return null ( VAR_1 set null session left a realm - null transport detached ) <|endcomment|> public long METHOD_1 ( ) { <START> if ( ! METHOD_2 ( ) ) { <END> throw new IllegalStateException ( STRING_1 ) ; } return VAR_1 ; }
<|startcomment|> shouldn t return TYPE_1 error ( e ) <|endcomment|> static public < T > TYPE_1 < T > METHOD_1 ( TYPE_2 < TYPE_1 < T > > VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_2 == null ) { return TYPE_1 . METHOD_2 ( ( ) - > { try { return VAR_1 . call ( ) ; } catch ( Exception e ) { <START> return TYPE_4 . error ( e ) ; <END> } } ) ; } else { return TYPE_5 . METHOD_3 ( ( ) - > VAR_1 . call ( ) , VAR_2 ) ; } }
<|startcomment|> style : missing braces <|endcomment|> public int METHOD_1 ( ) { <START> if ( VAR_1 == null ) <END> return 0 ; return VAR_1 . VAR_2 ; }
<|startcomment|> reason METHOD_1 ( VAR_1 null ) ? METHOD_3 ( ) handles null callbacks similar question similar functions <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( String VAR_1 ) { TYPE_3 < TYPE_2 > VAR_2 = new TYPE_3 < TYPE_2 > ( ) ; TYPE_4 VAR_3 = METHOD_2 ( ) ; if ( VAR_3 == null ) { METHOD_3 ( VAR_2 , null , null , VAR_4 ) ; } else { VAR_3 . METHOD_1 ( VAR_1 , VAR_2 , null ) ; } <START> return VAR_2 ; <END> }
<|startcomment|> talked real _CODE_ want <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( VAR_2 , STRING_1 ) ; <END> System . VAR_3 ( TYPE_1 . VAR_5 , STRING_2 ) ; METHOD_3 ( false ) ; }
<|startcomment|> lambda <|endcomment|> public TYPE_7 ( TYPE_1 parent , TYPE_2 VAR_2 ) { super ( parent , VAR_2 , SWT . VAR_3 | SWT . VAR_4 | SWT . VAR_5 ) ; TYPE_3 . METHOD_1 ( this ) ; METHOD_2 ( this ) ; METHOD_3 ( this ) ; TYPE_4 . METHOD_4 ( ) ; METHOD_5 ( new TYPE_5 ( ) { @Override <START> public void METHOD_6 ( TYPE_6 e ) { <END> TYPE_3 . METHOD_7 ( TYPE_7 . VAR_6 ) ; } } ) ; }
<|startcomment|> I store actual Map instead return map wrapped unmodifiable map extra allocations operation unmodifiable wrappers internally aren t needed <|endcomment|> private Map < String , TYPE_1 > METHOD_1 ( Integer s , Map < String , TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { return Collections . VAR_2 ( VAR_3 , TYPE_1 . METHOD_2 ( VAR_4 ) ) ; } else { Map < String , TYPE_1 > VAR_5 = new HashMap < > ( VAR_1 ) ; VAR_5 . METHOD_3 ( VAR_3 , this : : METHOD_4 ) ; <START> return Collections . VAR_6 ( VAR_5 ) ; <END> } }
<|startcomment|> Map <|endcomment|> <START> private HashMap < String , String > METHOD_1 ( ) { <END> HashMap < String , String > params = new HashMap < > ( ) ; params . put ( VAR_1 , METHOD_2 ( name ) ) ; params . put ( VAR_2 , VAR_3 ) ; params . put ( VAR_4 , VAR_5 ) ; return params ; }
<|startcomment|> METHOD_3 METHOD_1 <|endcomment|> public String METHOD_1 ( ) { TYPE_1 VAR_1 = this . METHOD_2 ( ) ; if ( VAR_1 == null ) return null ; <START> return VAR_1 . METHOD_3 ( ) ; <END> }
<|startcomment|> ImmutableList VAR_4 ( <|endcomment|> public TYPE_1 ( List < Type > VAR_2 , List < Type > VAR_3 ) { this . VAR_2 = ImmutableList . VAR_4 ( VAR_2 ) ; <START> this . VAR_3 = VAR_3 ; <END> }
<|startcomment|> lines moved _CODE_ class instead user _CODE_ check ( _CODE_ ) <|endcomment|> public boolean METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) ) { <START> return VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; <END> } return VAR_1 . METHOD_1 ( ) ; }
<|startcomment|> rely _CODE_ toString <|endcomment|> public void METHOD_1 ( List < String > VAR_1 ) { log . debug ( STRING_1 , <START> Arrays . toString ( VAR_1 . METHOD_2 ( ) ) ) ; <END> VAR_1 . forEach ( TYPE_1 : : METHOD_3 ) ; }
<|startcomment|> suggestionreturn VAR_2 METHOD_4 ( ) + STRING_1 + VAR_3 ; <|endcomment|> public String METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = METHOD_2 ( VAR_1 ) ; if ( VAR_2 == null ) { return null ; } String VAR_3 = VAR_2 . METHOD_3 ( ) ; if ( VAR_3 . isEmpty ( ) ) { return VAR_2 . METHOD_4 ( ) ; } <START> return VAR_2 . METHOD_4 ( ) + STRING_1 + VAR_2 . METHOD_3 ( ) ; <END> }
<|startcomment|> public static call live test avoid code duplication <|endcomment|> <START> private void METHOD_1 ( Map < String , List < String > > VAR_1 , String VAR_2 , <END> String ... VAR_3 ) { assertTrue ( VAR_1 . containsKey ( VAR_2 ) , STRING_1 + VAR_2 ) ; assertEquals ( VAR_1 . get ( VAR_2 ) . size ( ) , VAR_3 . length , STRING_2 + VAR_2 ) ; assertTrue ( VAR_1 . get ( VAR_2 ) . METHOD_2 ( Arrays . asList ( VAR_3 ) ) , STRING_3 + Arrays . asList ( VAR_3 ) ) ; }
<|startcomment|> couldn t check VAR_2 null ? wouldn t need _CODE_ variable <|endcomment|> private void METHOD_1 ( ) { if ( ! VAR_1 ) return ; <START> if ( ! METHOD_2 ( ) ) { <END> throw VAR_2 ; } }
<|startcomment|> logger <|endcomment|> public void METHOD_1 ( Class < ? > VAR_1 ) { <START> System . out . println ( STRING_1 + VAR_1 . getName ( ) ) ; <END> VAR_2 . add ( VAR_1 ) ; }
<|startcomment|> constructor called builder remove public modifier <|endcomment|> <START> public TYPE_2 ( boolean VAR_2 , TYPE_1 VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> historically String type _CODE_ s production _CODE_ please fix type String modules ( user|member : virt : loa ) thank <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( TYPE_2 . VAR_3 ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; VAR_1 . METHOD_4 ( STRING_2 ) ; <START> VAR_1 . METHOD_5 ( Integer . VAR_4 . getName ( ) ) ; <END> VAR_1 . METHOD_6 ( STRING_3 ) ; return VAR_1 ; }
<|startcomment|> suggestion useful put TYPE_2 code a special case attribute I don t issues <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_4 = ( TYPE_3 ) VAR_2 . METHOD_1 ( ) ; this . VAR_5 = VAR_3 ; this . VAR_6 = ( Integer ) VAR_5 . getValue ( VAR_7 , VAR_2 ) ; this . VAR_8 = ( Double ) VAR_5 . getValue ( VAR_9 , VAR_2 ) ; <START> this . VAR_10 = METHOD_2 ( VAR_5 . getValue ( VAR_11 , VAR_2 ) ) ; <END> this . VAR_12 = VAR_2 ; }
<|startcomment|> s public <|endcomment|> <START> TYPE_1 ( String VAR_2 ) { <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> I understand start column replaced * * calcite need check * <|endcomment|> public static List < TYPE_1 > METHOD_1 ( String ... VAR_1 ) { List < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( String name : VAR_1 ) { if ( name . equals ( TYPE_1 . VAR_3 ) || <START> name . equals ( STRING_1 ) ) { <END> VAR_2 . add ( TYPE_1 . VAR_4 ) ; } else { VAR_2 . add ( TYPE_1 . METHOD_2 ( name ) ) ; } } return VAR_2 ; }
<|startcomment|> static import <|endcomment|> private static String METHOD_1 ( TYPE_1 node ) { <START> TYPE_2 . METHOD_2 ( node . VAR_1 ( ) ) ; <END> return node . VAR_2 ( ) ? null : node . VAR_3 ( ) ; }
<|startcomment|> assertions necessary ? checking VAR_7 size ( ) = = 0 <|endcomment|> public void METHOD_1 ( ) { when ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( TYPE_2 . VAR_3 ) ; final String [ ] result = page . VAR_4 ( TYPE_1 . VAR_6 ) ; final List < String > VAR_7 = Arrays . asList ( result ) ; <START> METHOD_4 ( VAR_7 . contains ( STRING_1 ) ) ; <END> METHOD_4 ( VAR_7 . contains ( STRING_2 ) ) ; assertEquals ( 0 , VAR_7 . size ( ) ) ; }
<|startcomment|> main logic run : counter - intuitive more a style issue : _CODE_ ( ) METHOD_3 ( ) run asynchronously <|endcomment|> public static TYPE_1 < ? > METHOD_1 ( final Context context , final long VAR_1 ) { if ( TYPE_2 . METHOD_2 ( ) ) { TYPE_3 . METHOD_3 ( context , TYPE_4 . METHOD_4 ( VAR_1 ) . METHOD_5 ( ) , false ) ; } <START> return METHOD_6 ( context , VAR_1 ) ; <END> }
<|startcomment|> combine line <|endcomment|> public void METHOD_1 ( TYPE_1 response ) throws Exception { VAR_1 [ VAR_2 ] = new TYPE_2 ( VAR_3 , response ) ; <START> VAR_4 . METHOD_2 ( ) ; <END> if ( VAR_4 . get ( ) == 0 ) { VAR_5 . METHOD_1 ( VAR_1 ) ; } }
<|startcomment|> I prefer IllegalArgumentException <|endcomment|> public synchronized TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { if ( VAR_1 == null ) throw new TYPE_4 ( STRING_1 ) ; <START> if ( VAR_2 == null ) throw new TYPE_4 ( STRING_2 ) ; <END> org . VAR_3 . VAR_4 . VAR_5 . TYPE_5 project = get ( VAR_1 ) ; if ( project == null ) throw new TYPE_4 ( STRING_3 + VAR_1 + STRING_4 ) ; return project . VAR_7 ( VAR_2 ) ; }
<|startcomment|> convert conditional expression ( ? : ) <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 , Object parent , Object element ) { if ( element instanceof TYPE_2 ) { if ( METHOD_2 ( ) && VAR_1 instanceof TYPE_3 ) { TYPE_2 VAR_2 = ( TYPE_2 ) element ; <START> if ( VAR_2 . METHOD_3 ( ) . length > 0 ) { return METHOD_4 ( ( TYPE_3 ) VAR_1 , VAR_2 ) ; } return false ; <END> } } return true ; }
<|startcomment|> remove sorting don t convert a List JSON serialization prints a Set a JSON array <|endcomment|> public Response METHOD_1 ( ) throws Exception { TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_3 ( ) ) ; <START> List < String > VAR_1 = new ArrayList < String > ( session . VAR_2 ( ) . METHOD_5 ( ) ) ; <END> Collections . VAR_3 ( VAR_1 ) ; return METHOD_6 ( VAR_1 ) ; }
<|startcomment|> duplicate - null check ( done TYPE_4 ) <|endcomment|> public boolean METHOD_1 ( final TYPE_1 from , final TYPE_2 event , final TYPE_1 to ) { <START> TYPE_3 . METHOD_2 ( from , STRING_1 ) ; <END> TYPE_3 . METHOD_2 ( event , STRING_2 ) ; TYPE_3 . METHOD_2 ( to , STRING_3 ) ; TYPE_4 VAR_1 = new TYPE_4 ( from , event , to ) ; return METHOD_1 ( VAR_1 ) ; }
<|startcomment|> convulotions list array <|endcomment|> Type METHOD_1 ( List < Type > VAR_1 ) { <START> return VAR_2 . METHOD_1 ( VAR_1 . METHOD_2 ( new Type [ VAR_1 . size ( ) ] ) ) ; <END> }
<|startcomment|> thread safe needs done startup / postconstruct <|endcomment|> public Response METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 , ANNOTATION_1 TYPE_2 VAR_2 , ANNOTATION_2 ( STRING_1 ) String type , ANNOTATION_1 TYPE_3 config , ANNOTATION_1 TYPE_4 VAR_3 ) throws Exception { <START> METHOD_2 ( VAR_4 ) ; <END> Response response = super . METHOD_3 ( VAR_1 , config , VAR_3 , VAR_2 , type ) ; response . VAR_5 ( ) . add ( STRING_2 , STRING_3 ) ; return response ; }
<|startcomment|> I m builders creating children time worth differently <|endcomment|> public Optional < TYPE_1 > build ( ) { if ( this . VAR_1 ) { try { METHOD_1 ( ) ; } catch ( Exception e ) { throw logger . VAR_2 ( e ) ; } return Optional . of ( new TYPE_1 ( VAR_3 , VAR_4 ) ) ; } <START> return Optional . empty ( ) ; <END> }
<|startcomment|> METHOD_3 ( ) METHOD_4 ( ) ! = null <|endcomment|> protected void METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; final Collection < TYPE_1 > VAR_2 = VAR_3 == null ? new ArrayList < TYPE_1 > ( ) : VAR_3 ; <START> if ( METHOD_3 ( ) . METHOD_4 ( ) != VAR_2 ) { <END> METHOD_3 ( ) . METHOD_5 ( VAR_2 , VAR_1 ) ; } else { METHOD_3 ( ) . METHOD_6 ( VAR_1 ) ; } }
<|startcomment|> need a super ( ) <|endcomment|> public TYPE_1 ( ) throws IOException { <START> super ( ) ; <END> }
<|startcomment|> isn t a item present return idea ? save mapping complete list return ( IIUC ) <|endcomment|> private Guid METHOD_1 ( Guid VAR_1 , TYPE_1 type , TYPE_2 status ) { return METHOD_2 ( VAR_1 , type , <START> status ) . stream ( ) . map ( TYPE_3 : : getId ) . METHOD_3 ( ) . METHOD_4 ( Guid . TYPE_4 ) ; <END> }
<|startcomment|> doesn t need public s called file <|endcomment|> <START> public static List < TYPE_1 > METHOD_1 ( TYPE_2 query ) <END> { return TYPE_3 . METHOD_2 ( query . VAR_1 ( ) , query . VAR_2 ( ) . METHOD_3 ( query . VAR_3 ( ) ) ) ; }
<|startcomment|> I put method _CODE_ ( ) group methods logical call order <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 . is ( TYPE_7 . TYPE_6 . VAR_4 ) ) { TYPE_2 VAR_5 = ( TYPE_2 ) VAR_1 ; TYPE_3 TYPE_4 = METHOD_2 ( VAR_5 ) ; return TYPE_5 . stream ( ) . METHOD_3 ( TYPE_4 : : equals ) ; } return false ; }
<|startcomment|> removing response some figured request coming response time future <|endcomment|> private TYPE_1 METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_1 . get ( request ) ; return VAR_1 . VAR_2 ? VAR_1 : <START> TYPE_2 . METHOD_2 ( ) . METHOD_3 ( user , request , uri , response ) ; <END> }
<|startcomment|> I d put other : + 1 : need locks temp dir won t change ( shouldn t ) <|endcomment|> public File METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) ; if ( VAR_1 == null ) { VAR_1 = METHOD_3 ( ) ; <START> } <END> } return VAR_1 . METHOD_4 ( ) ; }
<|startcomment|> remove else return block <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 . getMessage ( ) . split ( STRING_1 ) [ 0 ] ; if ( VAR_2 . METHOD_1 ( VAR_3 ) ) { return VAR_1 . getMessage ( ) . contains ( VAR_4 ) == VAR_5 ; <START> } else { <END> return false ; } }
<|startcomment|> I method need static <|endcomment|> <START> private static void METHOD_1 ( Collection < Pair < Object , String > > result , String element ) { <END> if ( element . length ( ) > 0 ) { List < String > list = Arrays . asList ( element . split ( STRING_1 ) ) ; list . forEach ( VAR_1 - > { String value = VAR_1 . split ( STRING_2 ) [ 0 ] ; result . add ( new Pair < > ( value , value ) ) ; } ) ; } }
<|startcomment|> unnecessary else return VAR_4 statement <|endcomment|> public List < String > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; List < String > VAR_4 = new ArrayList < > ( ) ; if ( null != VAR_2 && ! VAR_2 . isEmpty ( ) ) { for ( TYPE_2 VAR_5 : VAR_2 ) { VAR_4 . add ( VAR_5 . METHOD_2 ( ) ) ; } return VAR_4 ; <START> } else { <END> return VAR_4 ; } }
<|startcomment|> I thought default false <|endcomment|> public void METHOD_1 ( ) { VAR_1 = VAR_2 ; VAR_3 = true ; VAR_4 = true ; VAR_5 = false ; VAR_6 = false ; <START> VAR_7 = true ; <END> VAR_8 = null ; VAR_9 = null ; VAR_10 = null ; VAR_11 = null ; }
<|startcomment|> reverse return ? I missed itteration <|endcomment|> public static boolean METHOD_1 ( final String VAR_1 , final String VAR_2 ) { if ( ! METHOD_2 ( VAR_1 ) ) { return false ; } if ( ! METHOD_3 ( VAR_2 ) ) { return false ; } final TYPE_1 VAR_3 = new TYPE_1 ( VAR_2 ) ; VAR_3 . METHOD_4 ( true ) ; final boolean VAR_4 = VAR_3 . METHOD_5 ( ) . METHOD_6 ( VAR_1 ) ; <START> return ! VAR_4 ; <END> }
<|startcomment|> isn t true default <|endcomment|> public void METHOD_1 ( final TYPE_1 object ) { super . METHOD_1 ( object ) ; if ( object . VAR_1 ( ) ) { object . VAR_2 ( ) . METHOD_2 ( 1 ) ; } <START> VAR_3 . METHOD_3 ( true ) ; <END> }
<|startcomment|> handle case ctx null consider returning null throwing a IllegalStateException similar other methods _CODE_ java <|endcomment|> public String [ ] METHOD_1 ( long VAR_1 ) { <START> ctx . VAR_2 ( VAR_1 ) ; <END> return TYPE_1 . METHOD_1 ( VAR_1 ) ; }
<|startcomment|> remove <|endcomment|> public synchronized boolean METHOD_1 ( ) { if ( ( Boolean ) METHOD_2 ( ) . get ( STRING_1 ) && METHOD_3 ( ) == null ) { METHOD_4 ( METHOD_5 ( ) ) ; <START> log . error ( STRING_2 ) ; <END> return true ; } return false ; }
<|startcomment|> convert VAR_2 a local variable _CODE_ ( ) doreturn new TYPE_1 ( VAR_4 _CODE_ ( ) ) ; <|endcomment|> public TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) throws IOException { <START> this . VAR_2 = new TYPE_1 ( VAR_2 ) ; <END> this . VAR_4 = TYPE_3 . get ( this . VAR_2 ) ; this . VAR_5 = new TYPE_4 ( this . VAR_2 ) ; this . VAR_3 = VAR_3 ; this . VAR_6 = true ; }
<|startcomment|> white space changes <|endcomment|> ANNOTATION_1 public void METHOD_1 ( ) throws TYPE_1 { final TYPE_2 parser = TYPE_2 . METHOD_2 ( STRING_1 ) ; assertEquals ( STRING_2 , parser . type . name ) ; assertEquals ( STRING_3 , parser . VAR_1 ) ; assertEquals ( STRING_4 , parser . version . toString ( ) ) ; <START> assertEquals ( STRING_5 , parser . VAR_2 ) ; <END> assertEquals ( STRING_6 , parser . VAR_3 ( ) ) ; }
<|startcomment|> related fix t rid extra _CODE_ operation METHOD_2 ( ) ctor <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> this . VAR_1 = this . VAR_2 . METHOD_2 ( ) ; <END> Assert . VAR_3 ( this . VAR_1 , STRING_1 ) ; }
<|startcomment|> status repeated I guess original code <|endcomment|> public int METHOD_1 ( ) { return TYPE_1 . METHOD_2 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , status , description , <START> status <END> ) ; }
<|startcomment|> line <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { return new TYPE_3 ( ) . METHOD_2 ( STRING_1 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_2 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_3 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_4 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_5 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_6 , new TYPE_4 ( ) ) . METHOD_2 ( STRING_7 , new TYPE_4 ( ) ) <START> . METHOD_3 ( STRING_1 ) . METHOD_3 ( STRING_6 ) ; <END> }
<|startcomment|> please import <|endcomment|> public String METHOD_1 ( ) throws IOException { if ( VAR_1 == null ) { <START> throw new TYPE_4 . TYPE_5 . TYPE_2 ( STRING_1 ) ; <END> } return ( ( TYPE_3 ) VAR_1 ) . METHOD_1 ( ) ; }
<|startcomment|> 1 means <|endcomment|> public void METHOD_1 ( final String VAR_1 ) throws IOException { try { new TYPE_1 ( this . VAR_2 . source ( ) ) . METHOD_2 ( STRING_1 ) . set ( this . VAR_3 ) . set ( VAR_1 ) <START> . set ( 1 ) <END> . METHOD_3 ( TYPE_3 . VAR_5 ) ; } catch ( final TYPE_2 ex ) { throw new IOException ( ex ) ; } }
<|startcomment|> false = > true ( changing _CODE_ ) <|endcomment|> public TYPE_2 ( TYPE_1 parameters ) { <START> super ( parameters , false ) ; <END> }
<|startcomment|> unnecessary cast long <|endcomment|> void run ( ) { if ( VAR_1 ) { return ; } TYPE_1 < ? super Long > VAR_2 = this . VAR_2 ; long e = VAR_3 ; for ( long i = index ; i != e && get ( ) == 0 ; i ++ ) { <START> VAR_2 . METHOD_1 ( ( long ) i ) ; <END> } if ( get ( ) == 0 ) { METHOD_2 ( 1 ) ; VAR_2 . METHOD_3 ( ) ; } }
<|startcomment|> a situation some VAR_3 lost I meant VAR_2 map moment call method more elements processed loop VAR_2 backed VAR_3 map <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_2 < TYPE_1 , TYPE_3 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 , true ) ; for ( TYPE_3 VAR_4 : VAR_2 . values ( ) ) VAR_4 . run ( ) ; <START> VAR_2 . clear ( ) ; <END> }
<|startcomment|> unused args <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( ) . METHOD_3 ( VAR_1 , VAR_2 ) ; <START> Object [ ] args = { VAR_3 , VAR_2 , false } ; <END> METHOD_4 ( VAR_4 . create ( VAR_3 , true ) . apply ( VAR_2 ) , STRING_1 ) ; }
<|startcomment|> a good implementation spatial reference instance shared instances geometry coming dataset VAR_3 size contribute OGC types don t enforce geometry side <|endcomment|> public long METHOD_1 ( ) { return VAR_1 + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) + <START> ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; <END> }
<|startcomment|> cases reverse ? ( i e don t instantiate logger audit logging ) <|endcomment|> public void METHOD_1 ( T request , TYPE_1 response , TYPE_2 VAR_1 , TYPE_3 target , String VAR_2 , String VAR_3 , Boolean VAR_4 , TYPE_4 VAR_5 , String VAR_6 ) { LOG . trace ( STRING_1 ) ; <START> if ( METHOD_2 ( ) != null && METHOD_3 ( VAR_6 ) ) { <END> METHOD_2 ( ) . METHOD_1 ( request , response , VAR_1 , target , VAR_2 , VAR_3 , VAR_4 , VAR_5 , VAR_6 , METHOD_4 ( ) ) ; } LOG . trace ( STRING_2 ) ; }
<|startcomment|> I VAR_8 converted a local variable ( instead member variable ) ? TYPE_6 extends layer a reference TYPE_5 superclass renderer layers METHOD_1 ( ) <|endcomment|> public TYPE_6 ( TYPE_1 map , TYPE_2 VAR_2 ) { if ( VAR_2 == null ) { throw new IllegalArgumentException ( STRING_1 ) ; } VAR_3 = null ; TYPE_3 parser = new TYPE_3 ( VAR_2 ) ; VAR_3 = parser . VAR_4 ( ) ; HashMap < TYPE_4 , Object > VAR_5 = new HashMap < > ( ) ; for ( TYPE_4 VAR_6 : parser . VAR_7 ( ) ) { VAR_5 . put ( VAR_6 , null ) ; } <START> VAR_8 = new TYPE_5 ( map , VAR_5 ) ; <END> METHOD_1 ( VAR_8 ) ; }
<|startcomment|> condition incorporated loop <|endcomment|> protected int METHOD_1 ( int [ ] VAR_1 , int VAR_2 , int VAR_3 ) { int VAR_4 = 0 ; int length = 0 ; for ( int i = VAR_2 ; i < VAR_1 . length ; i ++ ) { length ++ ; if ( VAR_5 != VAR_1 [ i ] ) { VAR_4 ++ ; } <START> if ( VAR_4 == VAR_3 ) { <END> break ; } } return length ; }
<|startcomment|> I throw TYPE_5 caller deal else want else log error <|endcomment|> <START> protected TYPE_1 METHOD_1 ( String model , TYPE_2 config , TYPE_3 session ) { <END> TYPE_4 VAR_1 = null ; try { VAR_1 = new TYPE_4 ( model , config , session ) ; } catch ( TYPE_5 e ) { TYPE_6 . METHOD_2 ( ) . METHOD_3 ( ) . log ( e . getStatus ( ) ) ; } return VAR_1 ; }
<|startcomment|> protected <|endcomment|> <START> public TYPE_1 ( ) { <END> }
<|startcomment|> I expect METHOD_2 size - 1 cases <|endcomment|> private int METHOD_1 ( Object o , int index ) { if ( o instanceof TYPE_1 ) { TYPE_2 VAR_1 = ( ( TYPE_1 ) o ) . get ( index ) ; int size ; if ( VAR_1 instanceof TYPE_3 ) size = 0 ; else <START> size = VAR_1 . METHOD_2 ( ) . size ( ) ; <END> return size ; } if ( o instanceof List ) { return ( ( List < TYPE_4 > ) o ) . get ( index ) . METHOD_1 ( ) ; } throw new IllegalStateException ( STRING_1 ) ; }
<|startcomment|> TYPE_3 METHOD_2 ( ) handle <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { final TYPE_1 VAR_2 = new TYPE_1 ( ) ; TYPE_3 . METHOD_2 ( VAR_1 , VAR_2 ) ; if ( VAR_1 . METHOD_3 ( ) != null ) { VAR_2 . METHOD_4 ( TYPE_4 . METHOD_5 ( STRING_1 , VAR_1 . METHOD_3 ( ) ) ) ; } <START> VAR_2 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; <END> return VAR_2 ; }
<|startcomment|> return <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 == this || VAR_1 instanceof TYPE_2 ) { return true ; } <START> return false ; <END> }
<|startcomment|> A minor optimization create new ArrayList VAR_1 init size node + edge <|endcomment|> private Collection < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; result . addAll ( VAR_1 ) ; <START> result . addAll ( VAR_2 ) ; <END> return result ; }
<|startcomment|> VAR_1 ! = null redundant VAR_1 instanceof TYPE_1 returns false VAR_1 null <|endcomment|> @Override public boolean equals ( Object VAR_1 ) { <START> return VAR_1 != null && ( VAR_1 instanceof TYPE_1 ) && TYPE_2 . equals ( name , ( ( TYPE_1 ) VAR_1 ) . name ) ; <END> }
<|startcomment|> I agree a lot sense topic debatable point view private static sense because1 ) emphasizes fact method doesn t depend other class members ( doesn t internal state ) 2 ) JVM doesn t pass parameter _CODE_ points call - fi : ) <|endcomment|> <START> public static boolean METHOD_1 ( String VAR_1 , String text , boolean VAR_2 ) { <END> return VAR_2 ? StringUtils . VAR_3 ( VAR_1 , text ) : StringUtils . contains ( VAR_1 , text ) ; }
<|startcomment|> File <|endcomment|> public <START> List < String > METHOD_1 ( ) <END> { return new ArrayList < > ( VAR_1 ) ; }
<|startcomment|> need METHOD_2 s implementation TYPE_1 METHOD_2 bind interface RPC REST dispatchers implementations <|endcomment|> protected void METHOD_1 ( ) { <START> METHOD_2 ( TYPE_1 . class ) . to ( builder . VAR_1 ( ) ) . in ( TYPE_2 . class ) ; <END> bind ( TYPE_3 . class ) . to ( TYPE_4 . class ) . in ( TYPE_2 . class ) ; bind ( TYPE_5 . class ) . to ( TYPE_6 . class ) . in ( TYPE_2 . class ) ; }
<|startcomment|> log necessary <|endcomment|> protected void METHOD_1 ( ) { <START> TYPE_1 . log ( this . toString ( ) + STRING_1 ) ; <END> VAR_1 . METHOD_1 ( METHOD_2 ( ) , new TYPE_2 ( view ) , context . getStatus ( ) . METHOD_3 ( ) ) ; }
<|startcomment|> super implied <|endcomment|> public TYPE_2 ( ) { <START> super ( ) ; <END> VAR_2 = new TYPE_1 ( this ) ; }
<|startcomment|> I : _CODE_ _CODE_ ( ) changes please <|endcomment|> <START> public TYPE_1 ( ) { <END> super ( ) ; }
<|startcomment|> generated a _CODE_ exception VAR_6 _CODE_ Map a id current storage managers <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , String [ ] VAR_2 ) throws TYPE_2 { final long VAR_3 = Long . VAR_4 ( VAR_1 ) ; METHOD_2 ( VAR_3 ) ; final TYPE_3 result = new TYPE_3 ( VAR_2 ) ; <START> result . VAR_5 ( VAR_6 . METHOD_3 ( VAR_3 ) ) ; <END> return result ; }
<|startcomment|> [ bit ] prefer inline conditionals kind stuff : javarequest = VAR_1 ? METHOD_1 ( request VAR_2 ) : METHOD_2 ( request ) ; <|endcomment|> public TYPE_1 filter ( TYPE_1 request ) throws TYPE_2 { if ( this . VAR_1 ) { request = METHOD_1 ( request , this . VAR_2 ) ; } else { request = METHOD_2 ( request ) ; <START> } <END> VAR_3 . METHOD_3 ( VAR_4 , request , STRING_1 ) ; return request ; }
<|startcomment|> add version check default - record - store client initiated operations caught <|endcomment|> public void METHOD_1 ( TYPE_1 key , long VAR_1 , TimeUnit VAR_2 ) { <START> if ( METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( TYPE_3 . VAR_4 ) ) { <END> throw new TYPE_2 ( STRING_1 ) ; } METHOD_6 ( key ) ; METHOD_7 ( key , VAR_1 , VAR_2 ) ; }
<|startcomment|> _CODE_ synchronized ? I need more _CODE_ stuff determine behaviour correct methods I hope provide correct answer <|endcomment|> <START> public TYPE_1 METHOD_1 ( String name ) { <END> TYPE_1 channel = this . VAR_1 . METHOD_2 ( name ) ; if ( channel == null ) { channel = this . VAR_1 . METHOD_3 ( name ) ; METHOD_4 ( name , channel ) ; } return channel ; }
<|startcomment|> METHOD_3 _CODE_ <|endcomment|> protected TYPE_1 METHOD_1 ( ANNOTATION_1 final TYPE_2 VAR_1 , ANNOTATION_1 TYPE_3 session ) { return new TYPE_1 ( ) { @Override public void METHOD_2 ( ANNOTATION_1 TYPE_4 o ) { <START> super . METHOD_2 ( o ) ; <END> METHOD_3 ( o . VAR_2 ( ) , o . VAR_3 ( ) , VAR_1 ) ; } @Override public void METHOD_4 ( ANNOTATION_1 TYPE_5 o ) { super . METHOD_4 ( o ) ; METHOD_3 ( o . VAR_2 ( ) , o . VAR_3 ( ) , VAR_1 ) ; } } ; }
<|startcomment|> sense METHOD_1 ( ) final : suggestionthis = VAR_2 METHOD_2 ( ) ; readers code methods jump understand code <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { super ( VAR_2 ) ; <START> this . name = this . METHOD_1 ( ) . METHOD_2 ( ) ; <END> }
<|startcomment|> longer <|endcomment|> public void start ( ) { VAR_1 = TYPE_1 . METHOD_1 ( cache . getName ( ) ) ; this . VAR_2 = configuration . VAR_3 ( ) . METHOD_2 ( ) . METHOD_3 ( ) ; this . VAR_4 = configuration . VAR_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <START> this . VAR_5 = configuration . VAR_6 ( ) . METHOD_6 ( ) . METHOD_7 ( ) || configuration . VAR_6 ( ) . METHOD_6 ( ) . METHOD_8 ( ) ; <END> }
<|startcomment|> I _CODE_ ( ) VAR_4 ( ) I agree stick method code loggers <|endcomment|> private TYPE_1 METHOD_1 ( ) { String VAR_1 = null ; TYPE_1 url = null ; try { VAR_1 = VAR_2 . METHOD_2 ( VAR_3 ) ; } catch ( TYPE_2 ex ) { <START> LOG . error ( STRING_1 , ex . VAR_4 ( ) , ex ) ; <END> } try { url = new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_3 ex ) { LOG . error ( STRING_2 , ex . getMessage ( ) , ex ) ; } return url ; }
<|startcomment|> _CODE_ / equals TYPE_1 correct ? I m tested <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { List < TYPE_1 > result = new ArrayList < > ( ) ; Set < TYPE_1 > VAR_1 = new HashSet < > ( ) ; for ( TYPE_2 f : METHOD_2 ( ) ) { <START> TYPE_1 VAR_2 = f . VAR_3 ( ) ; <END> if ( VAR_1 . add ( VAR_2 ) ) { result . add ( VAR_2 ) ; } } return Collections . VAR_4 ( result ) ; }
<|startcomment|> instead line don t call METHOD_1 ( VAR_1 VAR_4 ) <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 , Object content ) { TYPE_1 request = request ( TYPE_3 . VAR_3 , VAR_1 ) ; try { String VAR_4 = new TYPE_2 ( ) . METHOD_2 ( content ) ; <START> request . VAR_5 ( VAR_4 . METHOD_3 ( STRING_1 ) ) ; <END> } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return request ; }
<|startcomment|> int [ ] props including style checker happier <|endcomment|> private int [ ] METHOD_1 ( ) { <START> int props [ ] = new int [ VAR_1 ] ; <END> for ( int i = 0 ; i < VAR_1 ; i ++ ) { props [ i ] = i ; } return props ; }
<|startcomment|> null purging <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 req = request ( TYPE_2 . VAR_2 , METHOD_2 ( ) + STRING_1 + METHOD_3 ( ) ) ; req . VAR_3 ( STRING_2 , "" ) ; METHOD_4 ( req ) ; <START> METHOD_5 ( VAR_4 <END> . METHOD_6 ( Context . VAR_5 ( ) . METHOD_7 ( METHOD_3 ( ) ) ) ) ; }
<|startcomment|> Arrays VAR_4 System _CODE_ <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { METHOD_2 ( VAR_1 , STRING_1 ) ; if ( VAR_2 != VAR_1 . METHOD_3 ( ) ) { throw new IllegalArgumentException ( STRING_2 ) ; } TYPE_2 [ ] VAR_3 = Arrays . VAR_4 ( VAR_5 , VAR_5 . length + 1 ) ; <START> System . VAR_6 ( VAR_5 , 0 , VAR_3 , 0 , VAR_5 . length ) ; <END> VAR_3 [ VAR_5 . length ] = VAR_1 ; return new TYPE_1 ( VAR_3 ) ; }
<|startcomment|> empty finally block <|endcomment|> public void close ( ) { TYPE_1 . METHOD_1 ( VAR_1 ) ; try { VAR_2 . METHOD_2 ( ) ; } <START> finally { <END> } }
<|startcomment|> new ArrayList < > ( VAR_2 values ( ) ) ; <|endcomment|> private void METHOD_1 ( Throwable t ) { List < TYPE_1 > VAR_1 ; synchronized ( VAR_2 ) { <START> VAR_1 = new ArrayList < > ( VAR_2 . size ( ) ) ; <END> VAR_1 . addAll ( VAR_2 . values ( ) ) ; } for ( TYPE_1 data : VAR_1 ) { data . VAR_3 . METHOD_2 ( false ) ; data . VAR_4 ( t ) ; } }
<|startcomment|> VAR_1 ? shift ? doesn t matter <|endcomment|> <START> public final int METHOD_1 ( ) { return ( int ) ( VAR_1 > > > INT_1 ) ; } <END>
<|startcomment|> loader checked s - null similar paradigm client call close ( ) main ( ) s exception block - > case initialize fails initializing loader some reason logic initialized client connection closed leaked <|endcomment|> private void close ( ) { try { METHOD_1 ( ) ; <START> VAR_1 . close ( ) ; <END> if ( VAR_2 != null ) { VAR_2 . close ( ) ; VAR_2 = null ; } } catch ( Exception ex ) { } }
<|startcomment|> - resources takes care closing <|endcomment|> private static void METHOD_1 ( TYPE_1 VAR_1 , File file , String VAR_2 ) { byte [ ] VAR_3 = VAR_2 . METHOD_2 ( ) ; try ( TYPE_2 VAR_4 = VAR_1 . create ( file ) ) { VAR_4 . write ( ByteBuffer . VAR_5 ( VAR_3 ) ) ; <START> VAR_4 . close ( ) ; <END> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> change unnecessary PR limited _just_ s necessary achieve PR s aims <|endcomment|> public boolean METHOD_1 ( ) { <START> return VAR_1 != null && VAR_1 . METHOD_1 ( ) ; <END> }
<|startcomment|> A DB call constuctor - a good practice <|endcomment|> public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> }
<|startcomment|> space STARTS ? <|endcomment|> public String METHOD_1 ( ) { String VAR_1 = METHOD_2 ( VAR_2 [ VAR_3 ] ) ; String VAR_4 = METHOD_2 ( VAR_2 [ VAR_5 ] ) ; TYPE_1 sb = new TYPE_1 ( ) ; <START> sb . append ( VAR_1 ) . append ( CHAR_1 ) . append ( TYPE_2 . VAR_7 ) . append ( TYPE_2 . VAR_8 ) . append ( CHAR_1 ) ; <END> sb . append ( VAR_4 ) ; return sb . toString ( ) ; }
<|startcomment|> simplify : return <|endcomment|> public boolean METHOD_1 ( TYPE_1 request ) throws TYPE_2 { TYPE_3 VAR_1 = request . VAR_2 ( ) ; TYPE_4 VAR_3 = VAR_4 . METHOD_2 ( TYPE_4 . class ) ; if ( null == VAR_3 ) { return true ; } TYPE_3 [ ] VAR_5 = VAR_3 . METHOD_3 ( ) ; <START> if ( TYPE_5 . isEmpty ( VAR_5 ) || TYPE_5 . contains ( VAR_5 , VAR_1 ) ) { <END> return true ; } return false ; }
<|startcomment|> return false <|endcomment|> private boolean METHOD_1 ( String string ) { try { TYPE_1 uri = new TYPE_1 ( STRING_1 + string ) ; if ( uri . VAR_1 ( ) == null || uri . VAR_2 ( ) == - 1 ) { <START> throw new TYPE_2 ( uri . toString ( ) , STRING_2 ) ; <END> } } catch ( TYPE_2 ex ) { return false ; } return true ; }
<|startcomment|> - else increment case <|endcomment|> private int METHOD_1 ( ) { <START> if ( ! METHOD_2 ( VAR_1 ) ) VAR_1 = VAR_2 ; <END> return VAR_1 ++ ; }
<|startcomment|> VAR_2 = Arrays asList ( VAR_2 ) ; <|endcomment|> public TYPE_2 ( TYPE_1 ... VAR_2 ) { <START> this . VAR_2 = new ArrayList < > ( Arrays . asList ( VAR_2 ) ) ; <END> }
<|startcomment|> assertEquals ( ) ( useful message ) instead assertTrue ( ) ll a useful stack trace fails ? future users file example write a good _CODE_ test <|endcomment|> public void METHOD_1 ( ) { int i = VAR_1 . get ( 0 ) ; <START> assertTrue ( i == 1 ) ; <END> try { VAR_1 . get ( VAR_1 . size ( ) ) ; } catch ( TYPE_1 e ) { return ; } METHOD_2 ( STRING_1 ) ; }
<|startcomment|> needs a space needs { } else <|endcomment|> public String METHOD_1 ( TYPE_1 [ ] args , String [ ] VAR_1 ) { TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( args , VAR_1 ) ; TYPE_4 . METHOD_3 ( VAR_2 ) ; String cmd = VAR_2 . getString ( 0 ) ; <START> if ( args . length == 2 ) <END> return VAR_3 . METHOD_1 ( cmd , VAR_2 . getInt ( 1 ) ) ; else return VAR_3 . METHOD_1 ( cmd ) ; }
<|startcomment|> remove synchronized <|endcomment|> <START> public synchronized static Set < Class < ? extends TYPE_1 > > METHOD_1 ( TYPE_2 VAR_1 ) { <END> final Set < Class < ? extends TYPE_1 > > VAR_2 = VAR_1 . METHOD_2 ( TYPE_1 . class ) ; logger . debug ( STRING_1 , VAR_2 . size ( ) , VAR_2 ) ; return VAR_2 ; }
<|startcomment|> good catch null check I forgot maps null a key <|endcomment|> protected Map < String , Object > METHOD_1 ( String VAR_1 ) { Map < String , Object > VAR_2 = new TYPE_1 < String , Object > ( ) ; for ( Map . Entry < String , Object > e : VAR_3 . entrySet ( ) ) { <START> if ( e . getKey ( ) != null && e . getKey ( ) . startsWith ( VAR_1 ) ) { <END> VAR_2 . put ( e . getKey ( ) , e . getValue ( ) ) ; } } return VAR_2 ; }
<|startcomment|> s debug level instead info <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( ) ; VAR_2 = METHOD_2 ( VAR_2 ) ; if ( R . VAR_3 . METHOD_3 ( TYPE_2 . VAR_5 ) && ! R . VAR_3 . get ( TYPE_2 . VAR_5 ) . isEmpty ( ) ) { <START> LOGGER . info ( STRING_1 ) ; <END> METHOD_4 ( VAR_2 ) ; } return VAR_2 ; }
<|startcomment|> longer needs synchronized protect connections longer needed create a new TYPE_3 <|endcomment|> <START> public synchronized TYPE_1 METHOD_1 ( String VAR_1 , String host , int VAR_2 , TYPE_2 [ ] VAR_3 ) { <END> return new TYPE_3 ( VAR_4 , VAR_3 , VAR_5 , VAR_6 , host , VAR_2 , this ) ; }
<|startcomment|> cleaner rid VAR_2 filter rewrite code METHOD_2 false access filters create a _CODE_ I move VAR_1 filter TYPE_1 java file anonymization config settings <|endcomment|> <START> public static TYPE_1 get ( ) { <END> return TYPE_2 . METHOD_1 ( TYPE_3 . class ) . METHOD_2 ( ) ? VAR_1 : VAR_2 ; }
<|startcomment|> ( string comparison ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = new TYPE_2 ( METHOD_2 ( ) , STRING_1 ) ; TYPE_3 res = METHOD_3 ( ) . execute ( VAR_1 ) ; if ( res != null && res . VAR_2 ( ) ) { <START> if ( res . VAR_3 ( ) . equals ( STRING_2 ) ) { <END> return TYPE_1 . VAR_4 ; } } return TYPE_1 . VAR_5 ; }
<|startcomment|> remove remark <|endcomment|> public boolean METHOD_1 ( ) { boolean VAR_1 = false ; if <START> ( TYPE_2 . TYPE_3 . METHOD_2 ( ) . equals ( METHOD_3 ( ) ) ) <END> { VAR_1 = true ; } return VAR_1 ; }
<|startcomment|> implement ? _CODE_ Object _CODE_ ( channel channel _CODE_ ) throws IOException { return Response HEARTBEAT_EVENT ; } <|endcomment|> private void METHOD_1 ( TYPE_1 out , Object data ) throws IOException { if ( data != null ) { <START> out . VAR_1 ( data ) ; <END> } else { logger . warn ( STRING_1 ) ; } }
<|startcomment|> a need log debug transaction scope <|endcomment|> public void METHOD_1 ( ) { try { log . debug ( STRING_1 ) ; TYPE_1 . METHOD_2 ( TYPE_2 . TYPE_3 , ( ) - > { VAR_3 . METHOD_3 ( new Date ( ) ) ; VAR_4 . METHOD_4 ( VAR_3 ) ; <START> log . debug ( STRING_2 ) ; <END> return null ; } ) ; } catch ( Exception ex ) { log . error ( STRING_3 , ex . getMessage ( ) ) ; log . debug ( STRING_4 , ex ) ; } }
<|startcomment|> missing args - > TYPE_3 METHOD_2 ( VAR_1 STRING_1 ) ; <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> TYPE_3 . METHOD_2 ( STRING_1 ) ; <END> this . VAR_2 . put ( Utils . VAR_3 , VAR_1 ) ; return this ; }
<|startcomment|> considered case ? more entity relevant more block position relevant ? more d gain a smidgen performance inverting expressions <|endcomment|> private boolean METHOD_1 ( TYPE_1 entity , TYPE_2 position ) { <START> return entity . VAR_1 ( ) || VAR_2 . METHOD_2 ( position ) ; <END> }
<|startcomment|> declared unused <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { TYPE_3 VAR_3 = METHOD_2 ( VAR_1 , VAR_2 ) ; <START> TYPE_4 VAR_4 = null ; <END> if ( ( VAR_3 != null ) && ( VAR_3 instanceof TYPE_4 ) ) { return ( ( TYPE_4 ) VAR_3 ) . METHOD_3 ( ) ; } return null ; }
<|startcomment|> _CODE_ codestyle <|endcomment|> <START> @Override public String toString ( ) <END> { return STRING_1 + metadata + CHAR_1 ; }
<|startcomment|> lines merged <|endcomment|> public static TYPE_1 METHOD_1 ( final List < TYPE_2 > VAR_1 , final TYPE_3 VAR_2 ) { <START> final TYPE_1 VAR_3 = new TYPE_1 ( <END> new TYPE_4 ( STRING_1 ) , VAR_1 , VAR_2 ) ; return VAR_3 ; }
<|startcomment|> new _CODE_ ( GENERIC_RECOVERY_ERROR ) ? rethrow : ( catch _CODE_ specifically a special case ) <|endcomment|> public synchronized void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { METHOD_2 ( VAR_2 . isPresent ( ) , STRING_1 ) ; if ( VAR_3 ) { <START> throw new IllegalStateException ( STRING_2 ) ; <END> } VAR_2 . get ( ) . METHOD_3 ( VAR_1 . getId ( ) , VAR_4 ) ; }
<|startcomment|> [ 0 length ) <|endcomment|> public TYPE_1 [ ] METHOD_1 ( int start , int length ) { TYPE_2 VAR_1 = TYPE_3 . METHOD_2 ( new TYPE_4 ( ) , length ) ; <START> for ( int i = start ; i < start + length ; i ++ ) { <END> VAR_1 . METHOD_3 ( ) ; } return new TYPE_1 [ ] { VAR_1 . build ( ) } ; }
<|startcomment|> I don t need LOG info - more ; LOG debug removed <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { <START> LOG . info ( STRING_1 ) ; <END> TYPE_2 VAR_1 = new TYPE_2 ( ) ; return VAR_1 . METHOD_2 ( ) ; }
<|startcomment|> shouldn t exception logged <|endcomment|> protected void METHOD_1 ( ) { logger ( ) . debug ( STRING_1 , getName ( ) , METHOD_2 ( ) ) ; try { client . close ( ) ; VAR_1 . METHOD_3 ( ) ; } catch ( Exception e ) { <START> } <END> }
<|startcomment|> consider VAR_1 METHOD_5 ( VAR_1 METHOD_4 ( ) > 2 > View VAR_4 : View VAR_3 ) ; emphasize conditional effects function input other logic <|endcomment|> private void METHOD_1 ( String description ) { VAR_1 . setText ( description ) ; VAR_1 . METHOD_2 ( new TYPE_1 ( ) { @Override public void run ( ) { if ( ! VAR_2 . METHOD_3 ( ) ) { return ; } if ( VAR_1 . METHOD_4 ( ) > 2 ) { <START> VAR_1 . METHOD_5 ( View . VAR_3 ) ; <END> } else { VAR_1 . METHOD_5 ( View . VAR_4 ) ; } } } ) ; }
<|startcomment|> a reason protected <|endcomment|> <START> TYPE_1 METHOD_1 ( ) { <END> return TYPE_1 . this ; }
<|startcomment|> VAR_1 java 7 <|endcomment|> <START> public static String get ( ) { return props . VAR_1 ( VAR_2 , STRING_1 ) ; } <END>
<|startcomment|> ! [ MAJOR ] ( severity : MAJOR ) add @Override annotation method signature [ ! [ rule ] ( ) ] ( ) <|endcomment|> <START> protected TYPE_1 METHOD_1 ( TYPE_1 parent , TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { <END> TYPE_1 VAR_3 = METHOD_2 ( parent , VAR_2 ) ; METHOD_3 ( VAR_3 , VAR_2 ) ; METHOD_4 ( VAR_3 , VAR_2 , VAR_1 ) ; METHOD_5 ( parent , VAR_1 , VAR_2 ) ; return VAR_3 ; }
<|startcomment|> TODO : remove log release <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 . size ( ) > 0 ) { METHOD_2 ( VAR_1 ) ; } else { METHOD_3 ( VAR_1 ) ; } <START> Log . d ( getClass ( ) . METHOD_4 ( ) , STRING_1 + VAR_2 . size ( ) ) ; <END> }
<|startcomment|> decide stream <|endcomment|> private static void METHOD_1 ( File VAR_1 ) { long VAR_2 = System . currentTimeMillis ( ) - ( VAR_3 * Constants . VAR_4 ) ; File [ ] VAR_5 = VAR_1 . METHOD_2 ( ) ; for ( File file : VAR_5 ) { if ( ! TYPE_1 . METHOD_3 ( file , VAR_2 ) ) { <START> METHOD_4 ( file ) ; <END> } } }
<|startcomment|> long <|endcomment|> boolean VAR_1 ( ) throws Exception ; } public static void VAR_2 ( String message , <START> int VAR_3 , <END> TYPE_2 VAR_5 ) throws Exception { int VAR_6 = INT_1 ; final long VAR_7 = System . currentTimeMillis ( ) + VAR_3 * INT_2 ; while ( System . currentTimeMillis ( ) < VAR_7 ) { if ( VAR_5 . VAR_1 ( ) ) { return ; } TYPE_1 . VAR_9 ( ) . VAR_6 ( VAR_6 ) ; } VAR_10 ( message ) ; }
<|startcomment|> missing return <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( false ) ; if ( METHOD_3 ( ) == null ) { log . warn ( STRING_1 ) ; <START> METHOD_4 ( true ) ; <END> } METHOD_3 ( ) . METHOD_5 ( TYPE_2 . TYPE_1 ) ; METHOD_6 ( ) . METHOD_7 ( METHOD_8 ( ) ) ; METHOD_9 ( ) . update ( METHOD_3 ( ) . METHOD_10 ( ) ) ; METHOD_4 ( true ) ; }
<|startcomment|> element VAR_1 returns a _CODE_ doesn t change TYPE_1 i guess method returns a new TYPE_1 <|endcomment|> protected TYPE_1 METHOD_1 ( ) { TYPE_1 element = new TYPE_1 ( ) ; element . VAR_1 ( TYPE_2 . METHOD_2 ( METHOD_3 ( ) ) . METHOD_4 ( TYPE_3 . from ( Arrays . asList ( <START> VAR_2 . METHOD_5 ( ) ) ) . METHOD_6 ( VAR_3 ) ) ) ; <END> return element ; }
<|startcomment|> remove Log please <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; if ( VAR_1 != null ) { VAR_1 = VAR_2 . METHOD_2 ( ) . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; METHOD_5 ( VAR_1 ) ; ( ( TYPE_1 ) VAR_2 ) . METHOD_6 ( VAR_1 ) ; <START> TYPE_2 . d ( TAG , STRING_1 + VAR_1 . METHOD_7 ( ) + STRING_2 ) ; <END> } }
<|startcomment|> change Object equals Double VAR_1 part previous commit <|endcomment|> public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TYPE_1 that = ( TYPE_1 ) o ; <START> return Double . VAR_1 ( that . VAR_2 , VAR_2 ) == 0 && <END> Double . VAR_1 ( that . VAR_3 , VAR_3 ) == 0 && TYPE_2 . equals ( VAR_4 , that . VAR_4 ) ; }
<|startcomment|> suggest renaming VAR_10 getter <|endcomment|> public TYPE_2 ( final TYPE_1 VAR_2 , final TYPE_1 VAR_3 , final String VAR_4 , final String VAR_5 , final String VAR_6 , final boolean VAR_7 , final long VAR_8 , final int VAR_9 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; this . VAR_7 = VAR_7 ; this . VAR_8 = VAR_8 ; <START> this . VAR_10 = VAR_9 ; <END> }
<|startcomment|> please pass VAR_2 VAR_3 methods <|endcomment|> public void METHOD_1 ( String VAR_1 , boolean VAR_2 ) { table . VAR_3 ( STRING_1 , true ) ; <START> VAR_4 . METHOD_1 ( STRING_1 , true ) ; <END> }
<|startcomment|> commit apply question answer answers <|endcomment|> private void METHOD_1 ( String s ) { TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( TYPE_2 . getInstance ( ) ) ; TYPE_1 . TYPE_4 e = VAR_1 . METHOD_3 ( ) ; e . VAR_2 ( STRING_1 , true ) ; e . VAR_3 ( STRING_2 , s ) ; <START> e . commit ( ) ; <END> }
<|startcomment|> generally qualify making static import ; s coming ( implement some reason ? ) I tend static imports constants unit tests obvious provided custom code ( _CODE_ ( ) mock ( ) ) suggestionreturn Collections VAR_3 ( ) ; <|endcomment|> default List < TYPE_1 > VAR_2 ( ) { <START> return VAR_3 ( ) ; <END> }
<|startcomment|> I don t case required assumed VAR_5 VAR_8 invalid ( _CODE_ ( ) ) <|endcomment|> public TYPE_7 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { VAR_4 = new TYPE_3 ( VAR_2 ) ; VAR_5 = new TYPE_4 ( VAR_2 ) ; VAR_6 = new TYPE_5 ( VAR_3 ) ; VAR_7 = <START> VAR_5 . VAR_8 . equals ( TYPE_4 . VAR_9 ) <END> ? null : new TYPE_6 ( VAR_5 . VAR_8 , VAR_4 ) ; }
<|startcomment|> debug detected ll INFO branch <|endcomment|> private void METHOD_1 ( Exception ex , TYPE_1 VAR_1 , TYPE_2 < ? > message ) { if ( this . logger . VAR_2 ( ) ) { this . logger . info ( STRING_1 + VAR_1 + STRING_2 + message + STRING_3 + ex . getMessage ( ) + STRING_4 ) ; } else if ( this . logger . VAR_3 ( ) ) { this . logger . debug ( STRING_1 + VAR_1 + STRING_2 + message + <START> STRING_5 , ex ) ; <END> } }
<|startcomment|> creating location attributes idgen module startup a core function idgen module other implications implementer wants _CODE_ responsibility ensuring correct _CODE_ _CODE_ exist <|endcomment|> public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( true ) ; <START> METHOD_3 ( ) ; <END> log . info ( STRING_1 ) ; }
<|startcomment|> pls diamond new ArrayList < > ( ) ; <|endcomment|> private static List < TYPE_1 > METHOD_1 ( TYPE_2 [ ] VAR_1 ) { <START> List < TYPE_1 > VAR_2 = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_2 VAR_3 : VAR_1 ) { TYPE_3 args = new TYPE_3 ( new ArrayList < String > ( ) ) ; VAR_2 . add ( new TYPE_1 ( VAR_3 , args ) ) ; } return VAR_2 ; }
<|startcomment|> follow _CODE_ codestyle ( missing { } ) <|endcomment|> public String METHOD_1 ( String name ) throws IOException { String output = "" ; if ( METHOD_2 ( ) != null ) { try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is == null ) { output = TYPE_2 . METHOD_4 ( new File ( name ) , VAR_1 ) ; } <START> else output = TYPE_3 . toString ( is , VAR_1 ) ; <END> } } return output ; }
<|startcomment|> adding TYPE_3 <|endcomment|> public void METHOD_1 ( int VAR_1 , String startsWith ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( new TYPE_2 ( ) . METHOD_3 ( TYPE_3 . METHOD_4 ( VAR_4 , VAR_5 ) , <START> new TYPE_4 ( new TYPE_5 ( VAR_6 ) , TYPE_7 . VAR_8 , TYPE_6 . METHOD_5 ( startsWith ) ) ) ) ; <END> assertEquals ( VAR_1 , VAR_2 . size ( ) ) ; }
<|startcomment|> inverse combine lines rid entire branch <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 , List < TYPE_1 > VAR_2 ) { String VAR_3 = METHOD_2 ( VAR_1 ) ; <START> if ( null == VAR_3 ) { <END> return false ; } String VAR_4 = null ; for ( TYPE_1 VAR_5 : VAR_2 ) { VAR_4 = METHOD_2 ( VAR_5 ) ; if ( VAR_3 . equals ( VAR_4 ) ) { return true ; } } return false ; }
<|startcomment|> convert a double leave exact long <|endcomment|> public static TYPE_1 < TYPE_2 , Double > METHOD_1 ( ) { return new TYPE_1 < TYPE_2 , Double > ( ) { @Override ANNOTATION_1 public Double apply ( TYPE_2 input ) { if ( input . VAR_1 ( ) == null ) return null ; <START> return input . VAR_1 ( ) . METHOD_2 ( ) ; <END> } } ; }
<|startcomment|> isn t a result interrupt I throwing a RuntimeException IllegalStateException a fit <|endcomment|> public void METHOD_1 ( TYPE_1 request ) throws InterruptedException { TYPE_2 stream = new TYPE_2 ( request . VAR_1 ( ) ) ; try { stream . VAR_2 ( ) ; } catch ( IOException e ) { <START> throw new InterruptedException ( STRING_1 + e ) ; <END> } VAR_3 . put ( request ) ; }
<|startcomment|> need final static methods <|endcomment|> <START> public static final TYPE_1 create ( ) { <END> return new TYPE_2 ( ) ; }
<|startcomment|> reverse order prevent races blindly METHOD_2 check exists <|endcomment|> public void METHOD_1 ( ) { for ( Path file : VAR_1 ) { try { if ( VAR_2 . exists ( file ) && ! VAR_2 . METHOD_2 ( file , false ) ) { throw new IOException ( STRING_1 ) ; } } catch ( IOException e ) { log . warn ( e , STRING_2 + file ) ; } <START> } <END> VAR_3 . METHOD_1 ( ) ; }
<|startcomment|> shouldn t a simple System _CODE_ ( ) instead TYPE_1 <|endcomment|> private void METHOD_1 ( String content ) throws IOException { File VAR_1 = new File ( VAR_2 . METHOD_2 ( ) , STRING_1 ) ; write ( VAR_1 , content ) ; <START> final long VAR_3 = TYPE_1 . getInstance ( ) . METHOD_3 ( ) ; <END> final int VAR_4 = INT_1 * INT_2 ; VAR_1 . METHOD_4 ( VAR_3 - VAR_4 ) ; }
<|startcomment|> replaced unmodifiable version List ( ) <|endcomment|> protected TYPE_1 METHOD_1 ( ) { <START> return new TYPE_2 ( STRING_1 , new ArrayList < > ( ) , false , true ) ; <END> }
<|startcomment|> doesn t VAR_3 merging <|endcomment|> private void METHOD_1 ( String path , String source , String VAR_1 ) throws Exception { String VAR_2 = METHOD_2 ( path , source , VAR_1 ) ; VAR_3 . METHOD_3 ( new TYPE_1 ( VAR_2 ) , <START> TYPE_2 . METHOD_4 ( TYPE_3 . METHOD_5 ( ) ) ) ; <END> }
<|startcomment|> replace test ( VAR_2 = = null ) execute statements else block return VAR_2 field VAR_1 local variable useful <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; <START> if ( VAR_2 != null ) { <END> VAR_1 = VAR_2 ; } else { for ( TYPE_1 VAR_3 : this . METHOD_2 ( ) ) { if ( VAR_3 instanceof TYPE_2 ) { TYPE_2 VAR_4 = ( TYPE_2 ) VAR_3 ; if ( VAR_4 . METHOD_3 ( ) . METHOD_4 ( ) && ( this . METHOD_5 ( ) == VAR_4 . getValue ( ) ) ) { VAR_1 = VAR_4 ; break ; } } } } return VAR_1 ; }
<|startcomment|> constructor delegate other constructor <|endcomment|> <START> TYPE_1 ( TYPE_1 VAR_1 ) <END> { super ( VAR_1 ) ; this . id = VAR_1 . id ; this . VAR_2 = VAR_1 . VAR_2 ; this . name = VAR_1 . name ; }
<|startcomment|> return void instead TYPE_1 won t return null <|endcomment|> <START> public TYPE_1 METHOD_1 ( ANNOTATION_1 ( TYPE_2 . VAR_2 ) Long id ) { <END> VAR_3 . METHOD_1 ( id ) ; return null ; }
<|startcomment|> version check removed move 2 6 x <|endcomment|> protected TYPE_1 METHOD_1 ( ) { String version = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_1 = null ; <START> if ( version . startsWith ( STRING_1 ) && ( version . contains ( STRING_2 ) || version . contains ( STRING_3 ) ) ) { <END> VAR_1 = new TYPE_3 ( new String ( STRING_4 ) ) ; } else { VAR_1 = new TYPE_3 ( new String ( STRING_5 ) ) ; } METHOD_3 ( VAR_1 ) ; return VAR_1 ; }
<|startcomment|> extract local variable variable null - check <|endcomment|> private void METHOD_1 ( TYPE_1 event , boolean VAR_1 ) { if ( VAR_2 && METHOD_2 ( ) ) { return ; } if ( ( VAR_3 . equals ( TYPE_3 . VAR_5 ) || VAR_1 ) && VAR_6 != null ) { <START> ANNOTATION_1 TYPE_2 VAR_7 = VAR_6 ; <END> METHOD_3 ( VAR_7 , event ) ; if ( ! VAR_7 . METHOD_4 ( ) ) { METHOD_5 ( VAR_7 ) ; VAR_6 = null ; } } }
<|startcomment|> oops <|endcomment|> public boolean METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> }
<|startcomment|> I check more sense METHOD_4 method move <|endcomment|> private Guid METHOD_1 ( TYPE_1 action ) { if ( action . VAR_1 ( ) && <START> ( action . VAR_2 ( ) . METHOD_2 ( ) || action . VAR_2 ( ) . METHOD_3 ( ) ) ) { <END> return METHOD_4 ( action ) ; } return null ; }
<|startcomment|> trouble array initializers <|endcomment|> public Object [ ] factory ( ) { <START> List VAR_1 = new ArrayList < > ( ) ; <END> VAR_1 . add ( new TYPE_1 ( ) . METHOD_1 ( false ) . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_3 ( false ) ) ; VAR_1 . add ( new TYPE_1 ( ) . METHOD_1 ( true ) . METHOD_2 ( TYPE_2 . VAR_3 ) . METHOD_3 ( false ) ) ; return VAR_1 . METHOD_4 ( ) ; }
<|startcomment|> unnecessary assignment moved <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> Set < TYPE_2 > VAR_2 = null ; <END> boolean VAR_3 = false ; if ( VAR_1 != null ) { VAR_2 = VAR_1 . METHOD_2 ( ) ; for ( TYPE_2 VAR_4 : VAR_2 ) { if ( VAR_4 instanceof TYPE_3 ) { VAR_3 = true ; } } } return VAR_3 ; }
<|startcomment|> return <|endcomment|> TYPE_1 read ( long VAR_1 ) { if ( ! VAR_2 . getParameters ( ) . METHOD_1 ( ) ) { TYPE_1 data = VAR_3 . METHOD_2 ( VAR_1 ) ; if ( data == null ) { final TYPE_1 VAR_4 = METHOD_3 ( VAR_1 ) ; <START> data = VAR_3 . METHOD_4 ( ) . METHOD_5 ( VAR_1 , ( VAR_5 ) - > VAR_4 ) ; <END> } return data ; } return METHOD_3 ( VAR_1 ) ; }
<|startcomment|> VAR_1 close ( ) ; <|endcomment|> public void METHOD_1 ( ) { <START> METHOD_2 ( VAR_1 ) ; <END> VAR_1 = null ; }
<|startcomment|> method called validate method check shorter _CODE_ method <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> if ( VAR_1 != null && METHOD_3 ( VAR_1 ) ) { <END> return METHOD_4 ( ) ? TYPE_1 . VAR_2 : TYPE_1 . VAR_3 ; } else { return METHOD_4 ( ) ? TYPE_1 . VAR_4 : TYPE_1 . VAR_5 ; } }
<|startcomment|> aren t test methods require METHOD_4 <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( ) ; VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_3 ) ; <START> VAR_1 . METHOD_4 ( ) . METHOD_5 ( ) ; <END> return VAR_1 ; }
<|startcomment|> UTF8 <|endcomment|> public boolean METHOD_1 ( String key , int VAR_1 ) { <START> String VAR_2 = String . format ( TYPE_1 . VAR_4 , STRING_1 , key , VAR_1 ) ; <END> return METHOD_2 ( VAR_2 ) ; }
<|startcomment|> a static helper function _CODE_ ( VAR_1 ) ; VAR_1 instanceof TYPE_3 <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> METHOD_2 ( VAR_1 . METHOD_3 ( ) . equals ( VAR_2 ) , STRING_1 ) ; <END> return VAR_3 . METHOD_1 ( ( TYPE_3 ) VAR_1 ) ; }
<|startcomment|> I don t escape level explicitly escape title a video passing a method s move _CODE_ ( String _CODE_ ) _CODE_ <|endcomment|> public void METHOD_1 ( String VAR_1 , String VAR_2 , String value ) { METHOD_2 ( INT_1 , TimeUnit . VAR_3 ) ; try { VAR_4 . METHOD_3 ( TYPE_1 . METHOD_4 ( <START> TYPE_2 . METHOD_5 ( VAR_1 ) , VAR_2 , METHOD_6 ( value ) ) ) ; <END> } finally { METHOD_7 ( ) ; } }
<|startcomment|> А вообще надо два append ( ) делать <|endcomment|> public String parse ( ) { StringBuilder VAR_1 = new StringBuilder ( "" ) ; for ( String VAR_2 : VAR_3 ) { <START> VAR_1 . append ( VAR_2 + STRING_1 ) ; <END> } return VAR_1 . toString ( ) ; }
<|startcomment|> a - - resource pattern <|endcomment|> public void METHOD_1 ( ) throws IOException { TYPE_1 < ? > VAR_1 = new TYPE_1 < > ( new TYPE_2 < > ( ) ) ; VAR_1 . create ( TYPE_3 . create ( Type . VAR_2 ) , new TYPE_4 ( ) ) ; VAR_1 . METHOD_2 ( STRING_1 , STRING_2 ) ; <START> VAR_1 . close ( ) ; <END> }
<|startcomment|> fluent required ? a a basic setter instead <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { this . VAR_1 = VAR_1 ; <START> return this ; <END> }
<|startcomment|> method a simple converter dependent frequency dependent VAR_3 offset return VAR_1 * VAR_3 _CODE_ ( ) VAR_1 VAR_3 null <|endcomment|> <START> public long METHOD_1 ( long VAR_1 ) { <END> TYPE_1 trace = VAR_2 ; if ( trace != null ) { TYPE_2 VAR_3 = trace . VAR_4 ( ) ; return trace . VAR_5 ( VAR_1 - trace . VAR_6 ( ) ) + VAR_3 . METHOD_2 ( ) ; } return 0 ; }
<|startcomment|> dont exception propagated a error reporting generate jacoco report due methods static methods <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; try { TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ) ; TYPE_3 VAR_3 = VAR_2 . METHOD_3 ( ) ; VAR_1 = VAR_3 . METHOD_4 ( ) ; } catch ( TYPE_4 VAR_4 ) { <START> VAR_4 . METHOD_5 ( ) ; <END> } return VAR_1 ; }
<|startcomment|> _CODE_ job = VAR_2 remove ( buffer VAR_3 ( ) ) ; ( job ! = null ) { job VAR_4 ( ) ; } <|endcomment|> public TYPE_7 ( ) { TYPE_5 . TYPE_6 . METHOD_1 ( new TYPE_2 ( ) { @Override public void METHOD_2 ( TYPE_3 buffer ) { <START> TYPE_4 job = VAR_2 . get ( buffer . VAR_3 ( ) ) ; <END> if ( job != null ) { job . VAR_4 ( ) ; } VAR_2 . remove ( buffer . VAR_3 ( ) ) ; } } ) ; }
<|startcomment|> protected <|endcomment|> <START> public void METHOD_1 ( ) { <END> this . VAR_1 = new TYPE_1 ( node ) ; }
<|startcomment|> simplify avoiding temporary : VAR_3 add ( new TYPE_3 ( ) ) ; <|endcomment|> protected void METHOD_1 ( final TYPE_1 id , final int type , final byte [ ] data ) { try { super . METHOD_1 ( id , type , data ) ; } catch ( TYPE_2 e ) { <START> TYPE_3 o = new TYPE_3 ( id . VAR_1 ( ) , type , <END> e . VAR_2 ( ) ) ; VAR_3 . add ( o ) ; } }
<|startcomment|> pick : more consistent constructor behavior I d prefer dothis ( false ) <|endcomment|> public TYPE_1 ( ) { <START> this . VAR_2 = false ; <END> }
<|startcomment|> nl return <|endcomment|> public String METHOD_1 ( ) { if ( VAR_1 == null ) { return "" ; } <START> String s = VAR_1 . getName ( ) . METHOD_2 ( STRING_1 , "" ) + STRING_2 + VAR_2 ; <END> return s ; }
<|startcomment|> sole VAR_1 stormpath_token please assert parameter stormpath_token additionally public ( protected minimum ) invoked internally class created <|endcomment|> public void METHOD_1 ( String VAR_1 ) { <START> METHOD_2 ( VAR_2 , VAR_1 ) ; <END> }
<|startcomment|> other ( example item ) instead VAR_2 <|endcomment|> private static < T > void METHOD_1 ( TYPE_1 < T > VAR_1 ) { <START> for ( T VAR_2 : VAR_1 ) { <END> System . out . println ( STRING_1 + VAR_2 ) ; } }
<|startcomment|> simplified tojavareturn VAR_1 = = null ? 0 : VAR_1 METHOD_1 ( ) ; <|endcomment|> public int METHOD_1 ( ) { if ( VAR_1 == null ) { return 0 ; } else { return VAR_1 . METHOD_1 ( ) ; <START> } <END> }
<|startcomment|> return empty list ( ImmutableList ( ) ) null log = = null <|endcomment|> public Response METHOD_1 ( ) throws Exception { TYPE_1 session = METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_3 ( ) ) ; TYPE_2 VAR_1 = METHOD_4 ( ) . METHOD_5 ( ) ; String type = VAR_1 . getString ( STRING_1 ) ; TYPE_3 log = ( TYPE_3 ) session . VAR_2 ( ) . METHOD_6 ( type ) ; <START> List < TYPE_4 > VAR_3 = ( log == null ? null : log . VAR_4 ( ) ) ; <END> return METHOD_7 ( VAR_3 ) ; }
<|startcomment|> params null null null <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( "" , new String [ ] { } , null ) ; <END> }
<|startcomment|> I need / catch stuff ) ) <|endcomment|> public int getId ( ) { try { return id ; } catch ( RuntimeException e ) { throw METHOD_1 ( e ) ; } catch ( TYPE_1 e ) { throw METHOD_1 ( e ) ; } catch ( Throwable t ) { throw METHOD_1 ( t ) ; <START> } <END> }
<|startcomment|> catched ? shouldn t caller react <|endcomment|> public TYPE_3 ( HashMap < String , String > VAR_2 ) { this . VAR_2 = VAR_2 ; try { String VAR_3 = VAR_2 . get ( STRING_1 ) ; TYPE_1 url = new TYPE_1 ( VAR_3 ) ; String VAR_4 = url . VAR_5 ( ) ; VAR_6 = STRING_2 + VAR_4 ; <START> } catch ( TYPE_2 VAR_7 ) { <END> VAR_7 . METHOD_1 ( ) ; } }
<|startcomment|> test adjusted removed strlen change <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , INT_1 ) ; METHOD_2 ( STRING_2 , TYPE_1 . METHOD_3 ( ) ) ; <START> METHOD_4 ( STRING_3 , TYPE_2 . class , null ) ; <END> }
<|startcomment|> METHOD_1 ( file ) <|endcomment|> public boolean METHOD_1 ( File file , boolean VAR_1 ) { if ( VAR_1 ) { return this . METHOD_2 ( file ) ; } <START> return file . VAR_2 ( ) ; <END> }
<|startcomment|> program interface implementation please List instead ArrayList I m mentioning <|endcomment|> public ArrayList < TYPE_1 > METHOD_1 ( int resource ) { <START> ArrayList < TYPE_1 > VAR_1 = new ArrayList < TYPE_1 > ( ) ; <END> for ( TYPE_1 VAR_2 : VAR_3 ) { if ( ( VAR_2 . METHOD_2 ( ) & resource ) > 0 ) { VAR_1 . add ( VAR_2 ) ; } } return VAR_1 ; }
<|startcomment|> line moved block TYPE_1 instance created ? code instance VAR_1 = VAR_1 rid VAR_2 method I assuming status need set server variable null true <|endcomment|> public static TYPE_1 getInstance ( final TYPE_2 VAR_1 ) { if ( instance == null ) { instance = new TYPE_1 ( ) ; } <START> instance . VAR_2 ( VAR_1 ) ; <END> return instance ; }
<|startcomment|> meiner meinung nach ist die überprüfung überflüssig VAR_1 darf null sein und es mag auch fälle geben wo ein request * ohne * VAR_1 gemacht werden soll die abfrage METHOD_1 ( null ) ist m E ein gültiger verwendung <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) { <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) <END> this . VAR_1 = VAR_1 ; return this ; }
<|startcomment|> final <|endcomment|> <START> public void <END> METHOD_1 ( TYPE_1 VAR_1 ) { VAR_2 = VAR_1 ; }
<|startcomment|> null check necessary clear called super class constructor <|endcomment|> <START> public synchronized void clear ( ) { <END> VAR_1 . METHOD_1 ( INT_1 , INT_1 ) ; VAR_1 . METHOD_2 ( INT_1 , INT_1 ) ; VAR_1 . METHOD_3 ( ) ; super . clear ( ) ; }
<|startcomment|> s point <|endcomment|> public List < Object > METHOD_1 ( ) { <START> Set < Object > VAR_1 = METHOD_2 ( new TYPE_1 < > ( VAR_2 ) ) ; <END> for ( List < Object > VAR_3 : VAR_4 ) { if ( VAR_3 != null ) { VAR_1 . addAll ( VAR_3 ) ; } } return new ArrayList < > ( VAR_1 ) ; }
<|startcomment|> please ! string isEmpty ( ) <|endcomment|> public void METHOD_1 ( String VAR_1 ) { METHOD_2 ( ) ; VAR_2 = VAR_1 ; if ( VAR_3 != null && VAR_1 != null && <START> VAR_1 . length ( ) > 0 ) { <END> TYPE_1 VAR_4 = TYPE_2 . METHOD_3 ( VAR_3 , TYPE_3 . VAR_6 , TYPE_3 . OS ) ; VAR_4 . METHOD_4 ( VAR_1 ) ; } else { METHOD_5 ( TYPE_3 . VAR_6 , TYPE_3 . OS ) ; } }
<|startcomment|> stray doublenewline _CODE_ newlines individual _CODE_ m confused isn t formatted _CODE_ event I referencing ? javareturn new TYPE_2 ( damager ! = null && damager VAR_2 ( ) ? damager VAR_3 ( ) : entity VAR_2 ( ) ? entity VAR_3 ( ) : null damager ! = null && damager VAR_4 ( ) ? damager VAR_5 ( ) : entity VAR_4 ( ) ? entity VAR_5 ( ) : null ) ; <|endcomment|> public TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( VAR_1 . METHOD_2 ( ) ? VAR_1 . METHOD_3 ( ) : ( entity . VAR_2 ( ) ? entity . VAR_3 ( ) : null ) , <START> <END> VAR_1 . METHOD_4 ( ) ? VAR_1 . METHOD_5 ( ) : ( entity . VAR_4 ( ) ? entity . VAR_5 ( ) : null ) ) ; }
<|startcomment|> doesn t matter val - var - TYPE_3 pass false VAR_1 conceptually pass false <|endcomment|> public TYPE_1 METHOD_1 ( Boolean VAR_1 , TYPE_2 VAR_2 ) { for ( TYPE_3 VAR_3 : VAR_2 . METHOD_2 ( ) ) { <START> VAR_3 . METHOD_3 ( this , VAR_1 ) ; <END> } return null ; }
<|startcomment|> s expected benefit change ? method typically called VM - - s prioritize simplicity - traffic methods <|endcomment|> public TYPE_1 METHOD_1 ( List < TYPE_2 > VAR_1 ) { synchronized ( VAR_2 ) { this . VAR_1 . clear ( ) ; this . VAR_1 . addAll ( VAR_1 ) ; <START> } <END> return this ; }
<|startcomment|> VAR_6 variable avoided <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_1 VAR_1 , Collection < TYPE_2 > VAR_2 , List < TYPE_2 > VAR_3 ) { VAR_2 = METHOD_2 ( VAR_2 , VAR_1 ) ; List < TYPE_2 > VAR_4 = METHOD_3 ( VAR_1 ) ; Set < TYPE_2 > VAR_5 = METHOD_4 ( VAR_2 , VAR_4 , VAR_3 ) ; TYPE_1 VAR_6 = METHOD_5 ( VAR_1 , VAR_5 ) ; <START> return VAR_6 ; <END> }
<|startcomment|> remove return types ingest methods aren t <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 parent , TYPE_3 VAR_1 , TYPE_3 VAR_2 ) throws TYPE_4 , IOException { if ( METHOD_2 ( VAR_2 ) ) { <START> return null ; <END> } TYPE_5 VAR_3 = ( TYPE_5 ) parent ; TYPE_1 obj = METHOD_3 ( VAR_3 , VAR_2 ) ; METHOD_4 ( obj ) ; METHOD_5 ( obj ) ; METHOD_6 ( VAR_3 ) ; METHOD_7 ( 1 ) ; log . info ( STRING_1 , obj . VAR_4 ( ) , METHOD_8 ( ) ) ; return obj ; }
<|startcomment|> shouldn t METHOD_2 ( super METHOD_1 VAR_1 ) changes super class break <|endcomment|> public int METHOD_1 ( ) { <START> return METHOD_2 ( METHOD_3 ( ) , METHOD_4 ( ) , METHOD_5 ( ) , METHOD_6 ( ) , METHOD_7 ( ) , VAR_1 ) ; <END> }
<|startcomment|> simpler rewrite block ( VAR_2 ! = 1 ) <|endcomment|> public void METHOD_1 ( TYPE_1 < ? super TYPE_2 > s ) { VAR_1 = s ; ++ VAR_2 ; s . VAR_3 ( new TYPE_3 ( ) { @Override public void request ( long n ) { <START> if ( VAR_2 == 1 ) { <END> } else { METHOD_2 ( n ) ; } } @Override public void METHOD_3 ( ) { VAR_4 = 0 ; } } ) ; }
<|startcomment|> please remove TYPE_2 TYPE_3 <|endcomment|> protected static boolean METHOD_1 ( Guid VAR_1 ) { <START> boolean VAR_2 = ! METHOD_2 ( VAR_1 , new TYPE_2 . TYPE_3 . ArrayList < String > ( ) ) ; <END> VAR_2 = VAR_2 && METHOD_3 ( VAR_1 ) ; return VAR_2 ; }
<|startcomment|> state reference part object monitor VAR_4 cover states object remove synchronized block extract a local variable <|endcomment|> public void METHOD_1 ( Object VAR_1 ) { VAR_2 = VAR_1 ; TYPE_1 [ ] input = VAR_3 . METHOD_2 ( VAR_1 ) ; synchronized ( VAR_4 ) { <START> VAR_5 = null ; <END> } if ( VAR_6 != null ) { METHOD_3 ( input ) ; METHOD_4 ( 0 ) ; VAR_7 = SWT . VAR_8 ; VAR_9 = SWT . VAR_8 ; VAR_10 = null ; METHOD_5 ( input ) ; } }
<|startcomment|> remove VAR_5 outputs production <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { if ( event . VAR_1 ( ) ) { index = 0 ; METHOD_2 ( ) ; METHOD_3 ( VAR_2 ) . METHOD_4 ( VAR_3 , new TYPE_2 ( ) { @Override public void f ( ) { <START> TYPE_3 . VAR_5 . log ( STRING_1 ) ; <END> VAR_6 = false ; METHOD_3 ( STRING_2 , VAR_2 ) . remove ( ) ; } } ) ; } else { METHOD_3 ( VAR_2 ) . METHOD_5 ( VAR_3 ) ; } }
<|startcomment|> info <|endcomment|> public int METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { if ( LOG . VAR_2 ( ) ) { <START> LOG . trace ( STRING_1 + VAR_1 + STRING_2 ) ; <END> } return 0 ; }
<|startcomment|> constructor pass TYPE_3 <|endcomment|> public void update ( TYPE_1 name , String VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = new TYPE_3 ( name , VAR_1 ) ; Map < String , String > VAR_3 = VAR_2 . METHOD_1 ( ) ; <START> TYPE_4 conf = new TYPE_4 ( VAR_3 , VAR_2 ) ; <END> try { VAR_4 . METHOD_2 ( conf ) ; } catch ( TYPE_5 e ) { throw new TYPE_2 ( e ) ; } builder . VAR_5 ( name . VAR_6 ( ) ) ; }
<|startcomment|> superfluous <|endcomment|> @Override public Pair < TYPE_1 , TYPE_2 > METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_3 { <START> final TYPE_1 VAR_2 = this . METHOD_2 ( VAR_1 ) ; <END> final TYPE_2 type = VAR_3 . METHOD_3 ( VAR_2 ) ; return Pair . of ( VAR_2 , type ) ; }
<|startcomment|> I return null similar default _CODE_ implementation _CODE_ <|endcomment|> public Object METHOD_1 ( Object instance ) throws TYPE_1 { <START> return instance ; <END> }
<|startcomment|> please negate condition move #121 - clause <|endcomment|> private void METHOD_1 ( TYPE_1 action ) { <START> if ( ! ( action . VAR_1 ( ) && action . VAR_2 ( ) . METHOD_2 ( ) ) ) { return ; } action . VAR_2 ( ) . METHOD_3 ( ) . forEach ( this : : METHOD_4 ) ; <END> }
<|startcomment|> catch instance packagemanager <|endcomment|> public TYPE_1 METHOD_1 ( Context context ) { final TYPE_2 VAR_1 = context . VAR_2 ( ) ; TYPE_3 VAR_3 ; try { <START> if ( VAR_4 . VAR_5 != null ) { <END> return new TYPE_4 ( VAR_4 . VAR_5 ) ; } VAR_3 = VAR_1 . METHOD_2 ( VAR_4 . VAR_6 ) ; final int id = VAR_3 . METHOD_3 ( VAR_4 . VAR_7 , null , null ) ; return VAR_3 . METHOD_1 ( id ) ; } catch ( TYPE_5 e ) { } return null ; }
<|startcomment|> dianne remove logspam <|endcomment|> protected boolean METHOD_1 ( String VAR_1 , String VAR_2 ) { <START> Log . d ( TAG , STRING_1 ) ; Log . d ( TAG , STRING_2 + VAR_1 ) ; <END> return false ; }
<|startcomment|> style - : don t cuddle line isn t shorter ? TYPE_1 VAR_1 = ( TYPE_1 ) o ; return group equals ( VAR_1 group ) && VAR_2 equals ( VAR_1 VAR_2 ) ; <|endcomment|> public boolean equals ( Object o ) { TYPE_1 VAR_1 = ( TYPE_1 ) o ; <START> if ( ! group . equals ( VAR_1 . group ) ) return false ; <END> if ( ! VAR_2 . equals ( VAR_1 . VAR_2 ) ) return false ; return true ; }
<|startcomment|> step handler change needed avoid some memory leak ? isn t enough assign new <|endcomment|> public void METHOD_1 ( final TYPE_1 < TYPE_2 > VAR_1 ) { input . VAR_2 = null ; <START> input . VAR_2 = event - > { <END> VAR_1 . METHOD_2 ( event ) ; return this ; } ; }
<|startcomment|> context immutable return false <|endcomment|> public boolean METHOD_1 ( Object key ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> }
<|startcomment|> remove curly braces <|endcomment|> protected TYPE_1 METHOD_1 ( ) { return ( ) <START> - > { return ImmutableList . of ( METHOD_2 ( Messages . TYPE_5 , TYPE_2 . METHOD_3 ( TYPE_3 : : getName ) ) , new TYPE_4 ( Messages . TYPE_6 ) ) ; } ; <END> }
<|startcomment|> odd <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , int VAR_3 ) { VAR_4 = VAR_1 ; VAR_5 = VAR_2 ; <START> VAR_6 . add ( new TYPE_2 ( TYPE_4 . TYPE_5 . METHOD_2 ( TYPE_6 . VAR_8 ) , <END> STRING_1 , TYPE_7 . VAR_10 , FLOAT_1 ) ) ; if ( VAR_3 == 0 ) { METHOD_3 ( ) ; } else { METHOD_4 ( ) ; } }
<|startcomment|> close channel I s useless remove publisher VAR_3 channel garbage collected <|endcomment|> protected void METHOD_1 ( ) { logger . debug ( STRING_1 ) ; try { VAR_1 . METHOD_2 ( ) ; } catch ( Exception t ) { logger . error ( t . getMessage ( ) , t ) ; } VAR_2 . METHOD_3 ( VAR_1 . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( channel ) ; <START> channel . VAR_3 ( ) . remove ( TYPE_1 . class ) ; <END> }
<|startcomment|> a null check VAR_1 prior calling METHOD_2 method List < String > VAR_2 = ( VAR_1 ! = null ) ? VAR_1 METHOD_2 ( ) : null ; <|endcomment|> public static List < String > METHOD_1 ( TYPE_1 VAR_1 ) { <START> List < String > VAR_2 = VAR_1 . METHOD_2 ( ) ; <END> if ( VAR_2 == null || VAR_2 . isEmpty ( ) ) { VAR_2 = new ArrayList < > ( ) ; VAR_2 . add ( "" ) ; } return VAR_2 ; }
<|startcomment|> legacy extensions _CODE_ <|endcomment|> public void METHOD_1 ( TYPE_1 trace ) { TYPE_2 VAR_1 = METHOD_2 ( ) ; <START> if ( ! ( VAR_1 instanceof TYPE_3 ) ) { <END> return ; } try { VAR_1 . METHOD_3 ( trace ) ; VAR_1 . METHOD_4 ( ) ; if ( VAR_2 != null ) { VAR_2 . METHOD_5 ( ) ; } VAR_2 = ( TYPE_3 ) VAR_1 ; } catch ( TYPE_4 e ) { TYPE_5 . METHOD_6 ( ) . METHOD_7 ( STRING_1 , e ) ; } }
<|startcomment|> formatting <|endcomment|> @Override public void METHOD_1 ( Context context , TYPE_1 VAR_1 ) { String action = VAR_1 . METHOD_2 ( ) ; TYPE_2 VAR_2 = VAR_1 . METHOD_3 ( ) ; if ( TYPE_3 . equals ( action ) ) { if ( VAR_2 != null ) { <START> METHOD_4 ( VAR_2 . METHOD_5 ( VAR_3 , false ) ) ; <END> } } else if ( TYPE_4 . equals ( action ) ) { METHOD_6 ( VAR_4 . METHOD_7 ( ) ) ; } }
<|startcomment|> instead adding a METHOD_6 consider a _CODE_ changes observed ( I _CODE_ ? ) allow remove tab change logic <|endcomment|> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { METHOD_2 ( VAR_1 ) ; TYPE_1 . TYPE_3 . METHOD_3 ( VAR_1 ) ; VAR_2 . METHOD_4 ( VAR_1 , VAR_3 . size ( ) ) ; METHOD_5 ( ) ; <START> if ( METHOD_6 ( ) != null ) { <END> METHOD_6 ( ) . METHOD_7 ( ) ; } }
<|startcomment|> I m pretty a factory making public constructor required ( a lot refactoring achieve s uphold flag ) <|endcomment|> <START> public TYPE_1 ( int VAR_2 , int ... VAR_3 ) <END> { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> _CODE_ response = Optional ( token ) map ( VAR_1 : : METHOD_2 ) <|endcomment|> public Map < String , Object > METHOD_1 ( String token ) { <START> TYPE_1 response = Optional . of ( this . VAR_1 . METHOD_2 ( token ) ) <END> . map ( this : : METHOD_3 ) . map ( this : : METHOD_4 ) . map ( this : : METHOD_5 ) . map ( this : : METHOD_6 ) . filter ( TYPE_1 : : METHOD_7 ) . METHOD_8 ( ( ) - > new TYPE_2 ( STRING_1 + token + STRING_2 ) ) ; return METHOD_9 ( response ) ; }
<|startcomment|> shouldn t perform cold reboot volatile runs <|endcomment|> private boolean METHOD_1 ( ) { boolean VAR_1 = ( METHOD_2 ( ) . METHOD_3 ( ) && <START> ! METHOD_2 ( ) . METHOD_4 ( ) ) <END> || METHOD_2 ( ) . METHOD_5 ( ) ; log . info ( STRING_1 , METHOD_2 ( ) . getName ( ) , VAR_1 ? STRING_2 : STRING_3 , METHOD_2 ( ) . METHOD_3 ( ) , METHOD_2 ( ) . METHOD_4 ( ) , METHOD_2 ( ) . METHOD_5 ( ) ) ; return VAR_1 ; }
<|startcomment|> I don t understand needed ? isn t _CODE_ <|endcomment|> public void METHOD_1 ( ) { super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( false ) ; <START> VAR_2 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . getValue ( ) ) ; <END> }
<|startcomment|> please rename VAR_1 <|endcomment|> protected void METHOD_1 ( ) { <START> VAR_1 = METHOD_2 ( ) . METHOD_3 ( getParameters ( ) . METHOD_4 ( ) . toString ( ) ) ; <END> METHOD_5 ( ) ; TYPE_1 VAR_2 = METHOD_6 ( VAR_1 . VAR_3 ) ; VAR_2 . METHOD_7 ( getParameters ( ) . METHOD_4 ( ) ) ; METHOD_8 ( VAR_2 ) ; }
<|startcomment|> Boolean a reason ( boolean ) ? asking Boolean mind a tri - boolean ( true false null ) <|endcomment|> <START> Boolean METHOD_1 ( ) { <END> final String VAR_1 = TYPE_2 . VAR_3 ; final TYPE_1 user = VAR_4 . METHOD_2 ( ) ; return VAR_5 . METHOD_3 ( VAR_1 , user ) ; }
<|startcomment|> a bug cinder disks exists return call ( null ) parameter added previous patch <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( ) ? null : new TYPE_2 ( ) ; <END> }
<|startcomment|> - resources <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws IOException { TYPE_3 VAR_2 = METHOD_2 ( VAR_3 , TYPE_4 . class ) ; TYPE_5 VAR_4 = VAR_2 . in ( ) ; try { return new TYPE_6 ( VAR_4 ) . build ( ) ; } finally { VAR_4 . close ( ) ; <START> } <END> }
<|startcomment|> want specific edge - case fixtures ensure deserialization works needed <|endcomment|> public void METHOD_1 ( ) throws Exception { String data = METHOD_2 ( STRING_1 ) ; TYPE_1 resource = TYPE_3 . TYPE_4 . METHOD_3 ( data , TYPE_1 . class ) ; assertNotNull ( resource ) ; <START> assertNotNull ( resource . getId ( ) ) ; <END> }
<|startcomment|> flip constructor VAR_2 call constructor parameter ? don t pass null constructor functionally difference reads a nicer IMO <|endcomment|> public TYPE_1 ( String VAR_2 ) { <START> this . VAR_2 = VAR_2 ; <END> VAR_3 = true ; }
<|startcomment|> I m concerned inlined <|endcomment|> private int METHOD_1 ( int VAR_1 ) { <START> if ( VAR_2 ) VAR_3 . METHOD_2 ( ) ; <END> if ( VAR_1 == VAR_4 ) { VAR_1 = 0 ; Thread . VAR_5 ( ) ; } else { VAR_1 ++ ; TYPE_1 . METHOD_3 ( ) ; } return VAR_1 ; }
<|startcomment|> need assign a variable <|endcomment|> private static String METHOD_1 ( ) { <START> final StringBuilder sb = new StringBuilder ( ) <END> . append ( METHOD_2 ( VAR_1 ) ) . append ( STRING_1 ) . append ( METHOD_2 ( VAR_2 ) ) ; return sb . toString ( ) ; }
<|startcomment|> correctly cycles pager button pressed position reached button effect ( i e dialog close pressed ) handle final case add else : else { super METHOD_1 ( ) ; } <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 . METHOD_2 ( ) > 0 ) { VAR_1 . METHOD_3 ( VAR_1 . METHOD_2 ( ) - 1 , true ) ; <START> } <END> }
<|startcomment|> ditto readability : int result = = = null ? 0 : VAR_1 ( ) ; <|endcomment|> public int METHOD_1 ( ) { <START> int result = name != null ? name . VAR_1 ( ) : 0 ; <END> result = INT_1 * result + ( VAR_2 != null ? VAR_2 . METHOD_1 ( ) : 0 ) ; result = INT_1 * result + ( VAR_3 != null ? VAR_3 . METHOD_1 ( ) : 0 ) ; return result ; }
<|startcomment|> done start ( ) <|endcomment|> public TYPE_3 ( ) { VAR_2 = this ; <START> VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_1 ( new TYPE_2 ( ) ) ; <END> }
<|startcomment|> + 1 : <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 < ? > VAR_1 , boolean VAR_2 ) { if ( VAR_1 . equals ( METHOD_2 ( ) ) ) { return this ; <START> } else if ( TYPE_3 . METHOD_3 ( VAR_1 ) . equals ( TYPE_6 . TYPE_7 ) <END> && METHOD_2 ( ) . id ( ) == TYPE_6 . TYPE_7 . id ( ) ) { return this ; } return TYPE_5 . METHOD_4 ( this , VAR_1 , VAR_2 ) ; }
<|startcomment|> LOG warn ( STRING_1 VAR_2 ) ; <|endcomment|> public static boolean METHOD_1 ( ) { boolean VAR_1 = true ; for ( Map . Entry < String , String > entry : METHOD_2 ( ) . entrySet ( ) ) { String VAR_2 = entry . getKey ( ) ; if ( ! TYPE_1 . METHOD_3 ( VAR_2 ) ) { <START> LOG . warn ( STRING_1 + VAR_2 ) ; <END> VAR_1 = false ; } } return VAR_1 ; }
<|startcomment|> wrapping else body a new method cleaner <|endcomment|> public String METHOD_1 ( ) { if ( VAR_1 != null ) { METHOD_2 ( ) ; } else { synchronized ( this ) { <START> log . info ( STRING_1 ) ; <END> METHOD_3 ( TYPE_1 . VAR_3 ) ; try { METHOD_4 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; } catch ( Exception e ) { log . error ( STRING_2 , e ) ; } finally { METHOD_3 ( TYPE_1 . VAR_4 ) ; log . info ( STRING_3 ) ; } } } return METHOD_7 ( ) ; }
<|startcomment|> bytecode equivalent - syntax array <|endcomment|> static List < TYPE_1 > list ( Type [ ] VAR_1 ) { List < TYPE_1 > result = new ArrayList < > ( VAR_1 . length ) ; <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> result . add ( get ( VAR_1 [ i ] ) ) ; } return result ; }
<|startcomment|> NULL Boolean VAR_2 ( ) return FALSE I understand more explicit <|endcomment|> private boolean METHOD_1 ( ) { String value = Optional . VAR_1 ( TYPE_1 . getProperty ( STRING_1 ) ) <START> . METHOD_2 ( STRING_2 ) ; <END> return Boolean . VAR_2 ( value ) ; }
<|startcomment|> entire body synchronized put synchronized method <|endcomment|> public Map < String , Integer > METHOD_1 ( ) { <START> synchronized ( this ) { <END> Map < String , Integer > VAR_1 = new HashMap < String , Integer > ( ) ; VAR_1 . put ( STRING_1 , VAR_2 . size ( ) ) ; VAR_1 . put ( STRING_2 , VAR_3 . size ( ) ) ; return VAR_1 ; } }
<|startcomment|> remove <|endcomment|> public void next ( ) { <START> TYPE_1 VAR_1 = ( TYPE_1 ) this . METHOD_1 ( ) ; <END> TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_3 ( VAR_3 ) ; if ( VAR_2 != null ) new TYPE_5 . TYPE_4 ( VAR_4 , VAR_2 , VAR_5 ) . execute ( ) ; }
<|startcomment|> please inline variable <|endcomment|> public void METHOD_1 ( ) throws IOException { final TYPE_1 VAR_1 = TYPE_2 . METHOD_2 ( ) ; final TYPE_3 VAR_2 = new TYPE_3 ( ) ; try { VAR_1 . METHOD_3 ( ) ; VAR_2 . METHOD_4 ( STRING_1 ) ; <START> final int VAR_3 = VAR_2 . METHOD_5 ( ) ; <END> TYPE_4 . assertThat ( TYPE_5 . METHOD_6 ( VAR_3 ) , TYPE_6 . METHOD_7 ( true ) ) ; TYPE_4 . assertThat ( VAR_2 . METHOD_8 ( ) , TYPE_6 . METHOD_7 ( true ) ) ; } finally { VAR_1 . close ( ) ; } }
<|startcomment|> put a finally local - - resources case VAR_1 close ( ) throws some reason s extremely careful <|endcomment|> @Override public void close ( ) { TYPE_1 VAR_1 = TYPE_2 . get ( STRING_1 ) ; if ( VAR_1 != null ) { VAR_1 . close ( ) ; TYPE_2 . METHOD_1 ( STRING_1 ) ; } <START> factory . close ( ) ; <END> }
<|startcomment|> I m work a concurrent environment isn t a shared channel ? instead [ ] ( ) <|endcomment|> void METHOD_1 ( long VAR_1 , long size ) throws IOException { long VAR_2 = Math . VAR_3 ( size , METHOD_2 ( ) . METHOD_3 ( ) - VAR_1 ) ; VAR_4 = ByteBuffer . VAR_5 ( ( int ) VAR_2 ) ; <START> METHOD_4 ( ) . position ( offset . VAR_6 ( ) + VAR_1 ) ; <END> METHOD_4 ( ) . read ( VAR_4 ) ; VAR_7 = VAR_1 ; }
<|startcomment|> returns VAR_2 combine line <|endcomment|> public TYPE_2 ( String VAR_2 , TYPE_1 VAR_3 ) { super ( VAR_3 ) ; <START> METHOD_1 ( VAR_2 , STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> final <|endcomment|> public TYPE_1 build ( ) throws IllegalArgumentException { <START> List < long [ ] > cache = new ArrayList < long [ ] > ( ) ; <END> for ( byte [ ] VAR_1 : VAR_2 ) { long [ ] result = new long [ 2 ] ; result [ 0 ] = VAR_3 . apply ( VAR_1 , 0 ) ; result [ 1 ] = VAR_3 . apply ( VAR_1 , 1 ) - result [ 0 ] ; cache . add ( result ) ; } return new TYPE_1 ( VAR_3 , cache ) ; }
<|startcomment|> remove extra space consistent formattingsuggestionpublic Object METHOD_1 ( Object parent ) { <|endcomment|> <START> public Object METHOD_1 ( Object parent ) { <END> if ( parent == null ) { return this ; } if ( parent instanceof TYPE_1 ) { this . VAR_1 = ( TYPE_2 ) parent ; return this . VAR_1 ; } else { throw new IllegalArgumentException ( STRING_1 + parent . getClass ( ) . getName ( ) + STRING_2 ) ; } }
<|startcomment|> lambda <|endcomment|> public TYPE_1 < TYPE_2 , TYPE_3 < TYPE_4 > , TYPE_5 > METHOD_1 ( ) { <START> return bind ( a - > METHOD_2 ( ) . map ( new TYPE_6 < TYPE_3 < TYPE_4 > , TYPE_3 < TYPE_4 > > ( ) { <END> public TYPE_3 < TYPE_4 > f ( final TYPE_3 < TYPE_4 > VAR_1 ) { return VAR_1 . METHOD_3 ( a ) ; } } ) ) ; }
<|startcomment|> line more lisibility <|endcomment|> public String METHOD_1 ( ) { <START> if ( null == this . VAR_1 ) { return "" ; } return this . VAR_1 ; <END> }
<|startcomment|> formatting VAR_1 ( ) 1 bad component break components <|endcomment|> public boolean execute ( short a , TYPE_1 b ) { try { <START> for ( TYPE_2 c : b . values ( ) ) { <END> c . VAR_1 ( ) ; } } catch ( Exception e ) { TYPE_3 . METHOD_1 ( ) . log ( Level . VAR_2 , STRING_1 , e ) ; } return true ; }
<|startcomment|> 1 correct ? I guess _CODE_ - > 0 <|endcomment|> protected static double METHOD_1 ( TYPE_1 node , TYPE_2 key , TYPE_3 version , boolean VAR_1 ) { List < TYPE_4 > VAR_2 = METHOD_2 ( node , VAR_1 ) ; double VAR_3 = 0 ; for ( TYPE_4 VAR_4 : VAR_2 ) { double val = TYPE_5 . get ( key , VAR_4 , version ) ; <START> VAR_3 += val == Double . TYPE_6 ? 1 : val ; <END> } return VAR_3 / VAR_2 . size ( ) ; }
<|startcomment|> I add a final : suggestionfinal TYPE_2 element = VAR_1 METHOD_2 ( ) ; <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { type . VAR_2 = "" ; <START> TYPE_2 element = VAR_1 . METHOD_2 ( ) ; <END> if ( element instanceof TYPE_3 ) { new TYPE_4 ( ( TYPE_3 ) element , STRING_1 ) . METHOD_3 ( ) ; } type . VAR_3 ( VAR_1 . METHOD_2 ( ) ) ; }
<|startcomment|> counterintuitive need reassign VAR_1 ? VAR_2 METHOD_2 ( ) false returning true <|endcomment|> public boolean METHOD_1 ( ) { <START> VAR_1 = VAR_1 || VAR_2 . METHOD_2 ( ) ; <END> return VAR_1 ; }
<|startcomment|> I validate method return Set < TYPE_2 > avoiding double VAR_3 call addition I add vararg methods java config convenience done separate JIRA <|endcomment|> public void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( TYPE_2 . class , VAR_1 ) ; final Set < String > VAR_2 = StringUtils <START> . VAR_3 ( VAR_1 ) ; <END> Assert . VAR_4 ( VAR_2 , STRING_1 ) ; this . VAR_2 = VAR_2 ; }
<|startcomment|> method change state ( others ) I prefer declare static <|endcomment|> <START> final TYPE_1 METHOD_1 ( TYPE_1 VAR_1 ) { <END> while ( VAR_1 != null && ( VAR_1 . getType ( ) == TYPE_1 . VAR_2 || VAR_1 . getType ( ) == TYPE_1 . VAR_3 || VAR_1 . getType ( ) == TYPE_1 . VAR_4 ) ) { VAR_1 = VAR_1 . METHOD_2 ( ) ; } return VAR_1 ; }
<|startcomment|> return VAR_1 = = null || = = null ; <|endcomment|> public boolean METHOD_1 ( ) { <START> if ( this . VAR_1 == null || VAR_2 == null ) { <END> return true ; } else { return false ; } }
<|startcomment|> shouldn t VAR_1 instead VAR_1 ? overload METHOD_1 instead changing signature <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 < String , TYPE_3 > VAR_1 ) { <START> return new TYPE_1 ( this . VAR_1 ) ; <END> }
<|startcomment|> TYPE_2 handled left _CODE_ METHOD_3 ( ) needs check a custom marshaller defined TYPE_2 <|endcomment|> public boolean METHOD_1 ( Object o ) { if ( o instanceof String || o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof TYPE_1 <START> || o instanceof Boolean || o instanceof byte [ ] || o instanceof TYPE_2 ) { <END> return true ; } return METHOD_2 ( ) . METHOD_3 ( o . getClass ( ) ) ; }
<|startcomment|> static import METHOD_2 METHOD_3 <|endcomment|> private void METHOD_1 ( ) { TYPE_1 VAR_1 = <START> TYPE_2 . METHOD_2 ( false , TYPE_3 . create ( new TYPE_4 ( STRING_1 ) ) ) ; <END> VAR_2 = TYPE_2 . METHOD_3 ( VAR_1 , new TYPE_4 ( STRING_2 ) ) ; }
<|startcomment|> add safety checks null empty strings plz <|endcomment|> public Builder METHOD_1 ( String VAR_1 ) { <START> this . VAR_2 . add ( VAR_1 ) ; <END> return this ; }
<|startcomment|> doesn t work e g want build deep representation a method : javapublic void _CODE_ ( provider < ? extends T > provider ) { } result METHOD_1 : void _CODE_ ( javax inject provider ) voidprovider { } <|endcomment|> <START> public String METHOD_1 ( TYPE_1 VAR_1 ) { <END> TYPE_2 VAR_2 = new TYPE_2 ( ) ; VAR_2 . METHOD_2 ( VAR_1 ) ; return VAR_2 . METHOD_3 ( ) ; }
<|startcomment|> please check verify VAR_2 computed means processing production definition ? work expected <|endcomment|> public TYPE_1 ( Context context ) { super ( TYPE_1 . class . getName ( ) , context ) ; <START> for ( String VAR_1 : context . VAR_2 ) { <END> TYPE_2 VAR_3 = new TYPE_2 ( new TYPE_3 ( VAR_1 ) ) ; VAR_4 . add ( VAR_3 ) ; } }
<|startcomment|> order colors changed content changed ( e g checking / unchecking a counter ) <|endcomment|> protected void METHOD_1 ( ) { <START> VAR_1 . clear ( ) ; <END> METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( 0 ) . METHOD_5 ( ) . METHOD_6 ( null ) ; super . METHOD_1 ( ) ; }
<|startcomment|> call METHOD_5 ( ) <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( ) . toString ( ) . isEmpty ( ) ) { Log . i ( TAG , STRING_1 ) ; VAR_2 . setText ( "" ) ; } if ( METHOD_3 ( ) ) { METHOD_4 ( false ) ; } <START> TYPE_2 . this . METHOD_5 ( ) ; <END> }
<|startcomment|> method static <|endcomment|> <START> private void METHOD_1 ( String VAR_1 ) throws TYPE_1 { <END> if ( ! VAR_1 . equalsIgnoreCase ( STRING_1 ) ) { throw new TYPE_1 ( STRING_2 + VAR_1 + STRING_3 ) ; } }
<|startcomment|> lines happen branch ? I don t need VAR_1 VAR_2 compact <|endcomment|> public byte [ ] METHOD_1 ( ) { <START> Object VAR_1 = VAR_2 . METHOD_2 ( ) ; <END> METHOD_3 ( VAR_1 instanceof byte [ ] , STRING_1 , VAR_1 . getClass ( ) ) ; byte [ ] VAR_3 = ( byte [ ] ) VAR_1 ; if ( VAR_2 . METHOD_4 ( ) ) { return VAR_3 ; } return VAR_2 . METHOD_5 ( ) ; }
<|startcomment|> check _CODE_ configured extension ID ( e g _CODE_ ( ) ! = - 1 ) <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_1 . METHOD_2 ( ) && VAR_1 . METHOD_3 ( ) <END> == METHOD_4 ( ) ) { return VAR_1 . METHOD_5 ( METHOD_4 ( ) ) ; } return null ; }
<|startcomment|> ( rawtypes ) <|endcomment|> <START> public TYPE_3 ( TYPE_1 VAR_2 ) { <END> Assert . VAR_3 ( VAR_2 , STRING_1 ) ; this . VAR_4 = new TYPE_2 ( ) ; this . VAR_4 . METHOD_1 ( VAR_2 ) ; this . VAR_4 . METHOD_2 ( false ) ; this . VAR_4 . METHOD_3 ( ) ; }
<|startcomment|> I s nicer call TYPE_1 constructor suggested earlier sole parameter TYPE_1 constructor pull _CODE_ _CODE_ <|endcomment|> public TYPE_1 build ( ) { <START> try { <END> return VAR_1 ; } finally { VAR_1 = null ; } }
<|startcomment|> e VAR_4 ( ) please doesn t provide info pollutes logs CI builds <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { try { TYPE_2 method = TYPE_3 . class . METHOD_2 ( STRING_1 ) ; method . VAR_2 ( true ) ; method . VAR_3 ( VAR_1 ) ; } catch ( Exception e ) { <START> e . VAR_4 ( ) ; <END> METHOD_3 ( STRING_2 + e . toString ( ) ) ; } }
<|startcomment|> nitpick : redundant <|endcomment|> public TYPE_1 ( String VAR_2 , String val , String VAR_3 ) { <START> super ( ) ; <END> this . VAR_2 = VAR_2 ; this . val = val ; this . VAR_3 = VAR_3 ; }
<|startcomment|> method deprecated VAR_4 version ( ) instead <|endcomment|> private TYPE_1 METHOD_1 ( ) { org . VAR_1 . client . VAR_2 . configuration . TYPE_4 VAR_4 = super . METHOD_2 ( VAR_5 . get ( 0 ) . METHOD_3 ( ) ) ; VAR_4 . METHOD_4 ( new TYPE_2 ( ) ) ; <START> VAR_4 . METHOD_5 ( METHOD_6 ( ) ) ; <END> return new TYPE_3 ( VAR_4 . build ( ) ) ; }
<|startcomment|> visibility missing synchronized _CODE_ return TYPE_1 ? return a List < _CODE_ > <|endcomment|> <START> static synchronized TYPE_1 < TYPE_2 > METHOD_1 ( ) { <END> return new ArrayList < TYPE_2 > ( VAR_1 ) ; }
<|startcomment|> ( enable ) loop gracefully s > 0 <|endcomment|> private void METHOD_1 ( final boolean VAR_1 , final TYPE_1 ... VAR_2 ) { for ( TYPE_1 VAR_3 : VAR_2 ) { VAR_3 . METHOD_2 ( VAR_1 ) ; } if ( VAR_2 . length > 0 <START> && VAR_1 ) <END> { for ( TYPE_1 VAR_3 : VAR_2 ) { if ( VAR_3 instanceof TYPE_2 ) { VAR_3 . METHOD_3 ( ) ; break ; } } } }
<|startcomment|> yea A METHOD_2 : ) <|endcomment|> public Object METHOD_1 ( Object VAR_1 , TYPE_1 method , Object [ ] args ) throws Throwable { Object object = method . VAR_2 ( VAR_3 , args ) ; if ( method . getName ( ) . equals ( STRING_1 ) && VAR_4 . contains ( object . getClass ( ) ) ) { <START> object = METHOD_2 ( object ) ; <END> } return object ; }
<|startcomment|> filter filter enabled please careful test code submitting <|endcomment|> private boolean METHOD_1 ( TYPE_1 position ) { return VAR_1 && ! position . VAR_2 ( ) <START> || position . VAR_3 ( ) > INT_1 || position . VAR_4 ( ) > INT_2 <END> || position . VAR_3 ( ) < - INT_1 || position . VAR_4 ( ) < - INT_2 ; }
<|startcomment|> _CODE_ ( ) null set container calling method <|endcomment|> public TYPE_8 ( final TYPE_1 VAR_2 , final TYPE_2 VAR_3 , final TYPE_3 VAR_4 , final TYPE_4 source , final TYPE_4 target ) { this ( VAR_2 , VAR_3 ) ; VAR_5 = new TYPE_5 ( VAR_4 , VAR_3 , source , target , TYPE_6 . METHOD_1 ( METHOD_2 ( ) ) ) ; <START> this . container = ( TYPE_7 ) source ; <END> }
<|startcomment|> declare VAR_4 Map <|endcomment|> public static TYPE_1 METHOD_1 ( final String VAR_1 , final String VAR_2 ) { final TYPE_1 VAR_3 = new TYPE_1 ( 1 ) ; <START> final TYPE_2 < String , List < TYPE_3 > > VAR_4 = new TYPE_2 < > ( ) ; <END> final List < TYPE_3 > VAR_5 = new ArrayList < > ( ) ; VAR_5 . add ( new TYPE_3 ( VAR_1 , 1 , VAR_2 ) ) ; VAR_4 . put ( VAR_1 , VAR_5 ) ; VAR_3 . METHOD_2 ( VAR_4 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; return VAR_3 ; }
<|startcomment|> metadata dump need reset table parameters related stats false <|endcomment|> public TYPE_1 < TYPE_2 > table ( final String VAR_1 , TYPE_3 conf ) throws TYPE_4 { <START> boolean VAR_2 = ! conf . VAR_3 ( TYPE_3 . TYPE_5 . VAR_5 ) ; <END> return new TYPE_1 < > ( VAR_6 , ( ) - > db . VAR_7 ( VAR_8 , VAR_1 , false , false , VAR_2 ) ) ; }
<|startcomment|> returning a Set emphasis specific order returned collection <|endcomment|> <START> public List < TYPE_1 > METHOD_1 ( TYPE_2 session ) { <END> return METHOD_2 ( session ) . METHOD_1 ( ) ; }
<|startcomment|> calles TYPE_7 METHOD_4 please remove <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_4 configuration = METHOD_2 ( ) ; VAR_2 . METHOD_3 ( configuration ) ; configuration . set ( STRING_1 , STRING_2 ) ; try { <START> TYPE_5 . METHOD_4 ( configuration ) ; <END> } catch ( IOException exception ) { throw new TYPE_6 ( exception ) ; } TYPE_7 . METHOD_4 ( configuration ) ; return new TYPE_1 ( VAR_1 ) ; }
<|startcomment|> _CODE_ care cleanup automagically ? reasons <|endcomment|> public void METHOD_1 ( ) throws Exception { if ( this . VAR_1 != null ) { this . VAR_1 . close ( ) ; } final Path VAR_2 = TYPE_1 . METHOD_2 ( ) ; if ( TYPE_2 . exists ( VAR_2 ) ) { <START> TYPE_2 . METHOD_3 ( TYPE_1 ) ; <END> } }
<|startcomment|> didn t 2 lines ? I thought added cover happy path ? removed <|endcomment|> public List < String > METHOD_1 ( final String ... args ) { final List < String > list = new ArrayList < String > ( args . length ) ; list . addAll ( Arrays . asList ( args ) ) ; <START> final List < String > result = new TYPE_1 < > ( ) ; <END> result . addAll ( list . VAR_1 ( 0 , TYPE_2 . VAR_3 ) ) ; return result ; }
<|startcomment|> List <|endcomment|> List < Object > METHOD_1 ( int VAR_1 ) { <START> ArrayList < Object > result = new ArrayList < Object > ( ) ; <END> for ( Object [ ] VAR_2 : VAR_3 ) { result . add ( VAR_2 [ VAR_1 ] ) ; } return result ; }
<|startcomment|> else ternary <|endcomment|> private static TYPE_1 METHOD_1 ( Context context ) { final int VAR_1 = R . string . VAR_2 ; final String VAR_3 = context . getString ( R . string . TYPE_3 ) ; final String VAR_5 = context . getString ( R . string . TYPE_4 ) ; if ( TYPE_2 . METHOD_2 ( context ) ) return context . getString ( VAR_1 , VAR_3 ) ; <START> return context . getString ( VAR_1 , VAR_5 ) ; <END> }
<|startcomment|> initially load data callback ? loading manually ? prevent loading <|endcomment|> public void METHOD_1 ( TYPE_1 view , int VAR_1 , int VAR_2 , int VAR_3 ) { if ( VAR_3 < VAR_4 ) { VAR_5 = VAR_6 ; VAR_4 = VAR_3 ; if ( VAR_3 == 0 ) { <START> VAR_7 = true ; <END> } } if ( VAR_7 && ( VAR_3 > VAR_4 ) ) { VAR_7 = false ; VAR_4 = VAR_3 ; VAR_5 ++ ; } if ( ! VAR_7 && ( VAR_3 - VAR_2 ) <= ( VAR_1 + VAR_8 ) ) { VAR_7 = METHOD_2 ( VAR_5 + 1 , VAR_3 ) ; } }
<|startcomment|> return String VAR_3 creating new String <|endcomment|> private String METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> String VAR_2 = String . VAR_3 ( STRING_1 , VAR_1 . stream ( ) . map ( t - > t . id ( ) ) . collect ( Collectors . VAR_4 ( ) ) ) ; <END> return VAR_2 ; }
<|startcomment|> a tiny micro - optimization I ll mention add readability : sets _CODE_ ( s split ( STRING_1 ) <|endcomment|> public void METHOD_1 ( String s ) { if ( s != null && ! s . equals ( "" ) ) <START> VAR_1 = new HashSet < String > ( Arrays . asList ( s . split ( STRING_1 ) ) ) ; <END> }
<|startcomment|> I m a bit confused exception catching METHOD_2 t fail error null isn t TYPE_1 ; cases handled a check <|endcomment|> private Throwable METHOD_1 ( Object error ) { try { return ( ( TYPE_1 ) error ) . METHOD_2 ( ) ; <START> } catch ( Exception e ) { <END> return ( Throwable ) error ; } }
<|startcomment|> swallowing exception ? intentionally mistake <|endcomment|> public void run ( ) { try { this . VAR_1 . METHOD_1 ( ) ; } catch ( final InterruptedException ex ) { Thread . VAR_2 ( ) . METHOD_2 ( ) ; Logger . warn ( this , STRING_1 , ex ) ; } catch ( final Throwable ex ) { <START> Logger . error ( this , STRING_1 , TYPE_1 . METHOD_3 ( ex ) ) ; <END> } }
<|startcomment|> VAR_3 null method <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> return VAR_3 . METHOD_1 ( VAR_1 , VAR_2 ) ; <END> }
<|startcomment|> set field declaration <|endcomment|> public TYPE_1 ( ) { <START> this . VAR_2 = METHOD_1 ( 100 ) ; <END> }
<|startcomment|> private - > protected <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { <END> return VAR_1 . METHOD_2 ( ) || VAR_1 . METHOD_3 ( ) . contains ( VAR_2 ) ; }
<|startcomment|> call METHOD_1 <|endcomment|> public void start ( ) throws Exception { <START> METHOD_1 ( ) ; <END> TYPE_1 . METHOD_2 ( METHOD_3 ( ) . METHOD_4 ( ) ) ; }
<|startcomment|> change ( i = length - 1 ; i > = 0 ; i - - ) don t extra subtraction <|endcomment|> public static TYPE_1 METHOD_1 ( String ... VAR_1 ) { TYPE_2 s = null ; final int length = VAR_1 . length ; <START> for ( int i = 0 ; i < length ; i ++ ) { <END> s = new TYPE_2 ( VAR_1 [ length - 1 - i ] , s ) ; } return new TYPE_1 ( s ) ; }
<|startcomment|> code METHOD_2 ( ) done constructor TYPE_2 <|endcomment|> private void METHOD_1 ( ) { this . VAR_1 = new TYPE_1 ( session ) ; this . VAR_1 . METHOD_2 ( ) ; this . VAR_2 = new TYPE_2 ( session ) ; <START> this . VAR_2 . METHOD_2 ( ) ; <END> }
<|startcomment|> suggest retaining untranslated strings translating rendering <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> VAR_2 . METHOD_3 ( VAR_1 ) ; <END> VAR_1 . METHOD_4 ( ) ; }
<|startcomment|> unnecessary <|endcomment|> public void METHOD_1 ( ByteBuffer buffer ) { <START> VAR_1 = null ; <END> VAR_1 = buffer ; }
<|startcomment|> don t want VAR_1 ( [ _CODE_ ] ( ) ) reason VAR_1 VAR_1 ( ) fact throw a RuntimeException METHOD_3 some unexpected results ( s - entrant METHOD_3 more level intended example ) <|endcomment|> protected TYPE_1 < ? > METHOD_1 ( Map < String , String > map , int key ) { return ( ( ) - > { try { <START> VAR_1 . METHOD_2 ( ) ; <END> return map . put ( STRING_1 + key , STRING_2 + key ) ; } finally { VAR_1 . METHOD_3 ( ) ; } } ) ; }
<|startcomment|> thos changes <|endcomment|> public void METHOD_1 ( ) { VAR_1 = new TYPE_1 ( ) ; TYPE_2 VAR_2 = TYPE_2 . getInstance ( ) ; <START> TYPE_3 VAR_3 = TYPE_3 . getInstance ( null ) ; <END> VAR_3 . METHOD_2 ( new TYPE_4 ( ) ) ; VAR_3 . METHOD_3 ( VAR_2 ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; VAR_1 . METHOD_3 ( VAR_2 ) ; VAR_2 . METHOD_5 ( METHOD_6 ( ) ) ; VAR_2 . METHOD_5 ( METHOD_7 ( ) ) ; VAR_2 . METHOD_5 ( METHOD_8 ( ) ) ; }
<|startcomment|> move <|endcomment|> public void METHOD_1 ( final String name , final TYPE_1 info ) throws TYPE_2 , IOException { final String id = getId ( name ) ; final TYPE_3 out = METHOD_2 ( name , info , id ) ; METHOD_3 ( name , info , id , out ) ; <START> out . close ( ) ; <END> }
<|startcomment|> variable <|endcomment|> private String METHOD_1 ( String text ) { StringBuilder VAR_1 = new StringBuilder ( ) ; <START> for ( char VAR_2 : text . VAR_3 ( ) ) { <END> if ( VAR_2 != INT_1 && VAR_2 != INT_2 ) { VAR_1 . append ( VAR_2 ) ; } } return VAR_1 . toString ( ) ; }
<|startcomment|> remove extra brackets <|endcomment|> public void METHOD_1 ( ) { <START> ( new TYPE_1 ( VAR_1 , VAR_2 , VAR_3 ) ) . log ( TYPE_2 . VAR_5 ) ; <END> }
<|startcomment|> please remove redundant final modifiers parameters <|endcomment|> public TYPE_4 ( final TYPE_1 session , final TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> this ( session , VAR_2 , VAR_3 , null ) ; <END> }
<|startcomment|> i simply ( method ) : ( TYPE_3 VAR_2 = VAR_3 METHOD_2 ( VAR_4 TYPE_4 TYPE_5 VAR_7 ) ) { return METHOD_3 ( VAR_1 VAR_2 ) ; } <|endcomment|> public TYPE_1 < TYPE_2 > METHOD_1 ( ANNOTATION_1 ( STRING_1 ) List < String > VAR_1 ) throws Exception { <START> TYPE_1 < TYPE_2 > stream ; <END> try ( TYPE_3 VAR_2 = VAR_3 . METHOD_2 ( VAR_4 , TYPE_4 . TYPE_5 . VAR_7 ) ) { stream = METHOD_3 ( VAR_1 , VAR_2 ) ; } return stream ; }
<|startcomment|> _CODE_ represent exchange premature adaptation <|endcomment|> public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) String id , ANNOTATION_1 ( STRING_2 ) TYPE_1 VAR_2 , ANNOTATION_1 ( STRING_3 ) TYPE_2 VAR_3 ) { this . id = id ; <START> this . VAR_2 = VAR_2 != null ? VAR_2 . METHOD_1 ( ) : null ; <END> this . VAR_3 = VAR_3 ; }
<|startcomment|> put line <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 , SWT . VAR_3 ) ; TYPE_2 VAR_4 ; for ( int i = 0 ; i < VAR_5 . length ; i ++ ) { VAR_4 = new TYPE_2 ( VAR_1 , SWT . NONE ) ; VAR_4 . setText ( VAR_5 [ i ] ) ; final int column = i ; VAR_4 . METHOD_2 ( METHOD_3 ( e - > { <START> METHOD_4 ( column ) ; <END> } ) ) ; } return VAR_1 ; }
<|startcomment|> a - - resources <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 f ) throws IOException { TYPE_3 in = f . in ( ) ; try { return METHOD_2 ( in ) ; } finally { <START> in . close ( ) ; <END> } }
<|startcomment|> Optional return parameter enums <|endcomment|> <START> public static TYPE_1 METHOD_1 ( ANNOTATION_1 String VAR_1 ) { <END> return TYPE_2 . get ( VAR_1 ) . get ( ) ; }
<|startcomment|> wondering warm VAR_1 cache a miss l1 cache hit l2 cache <|endcomment|> public byte [ ] get ( TYPE_1 key ) { byte [ ] res = VAR_1 . get ( key ) ; if ( res == null ) { <START> res = VAR_2 . get ( key ) ; <END> } if ( res == null ) { VAR_3 . METHOD_1 ( ) ; } else { put ( key , res ) ; VAR_4 . METHOD_1 ( ) ; } return res ; }
<|startcomment|> private <|endcomment|> <START> public TYPE_1 <END> METHOD_1 ( TYPE_2 page ) { return METHOD_2 ( create ( STRING_1 + page . VAR_1 ( ) + STRING_2 , STRING_3 , VAR_2 , NONE , VAR_3 ) , page . VAR_4 ( ) ) ; }
<|startcomment|> imho equals check constructor store result field reduce overhead more <|endcomment|> private void METHOD_1 ( TYPE_1 s ) { <START> if ( TYPE_3 . TYPE_4 . equals ( VAR_1 ) ) { <END> METHOD_2 ( s ) ; } else { METHOD_3 ( s ) ; } }
<|startcomment|> necessary JVM initializes object fields null <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { this . VAR_2 = VAR_2 ; VAR_3 = null ; <START> VAR_4 = null ; <END> }
<|startcomment|> Assert assertTrue ( METHOD_3 ( STRING_1 ) exists ( ) ) ; Assert assertEquals ( METHOD_3 ( STRING_1 ) text ( ) STRING_2 ) ; <|endcomment|> public void METHOD_1 ( ) { <START> METHOD_2 ( ) ; <END> Assert . assertEquals ( METHOD_3 ( STRING_1 ) . text ( ) , STRING_2 ) ; }
<|startcomment|> final <|endcomment|> public void METHOD_1 ( String VAR_1 , TYPE_1 listener ) throws TYPE_2 { <START> TYPE_3 VAR_2 = <END> new TYPE_3 ( VAR_1 , listener , this , VAR_3 ) ; synchronized ( VAR_4 ) { TYPE_3 VAR_5 = VAR_6 . put ( listener , VAR_2 ) ; if ( VAR_5 != null ) { throw new IllegalArgumentException ( STRING_1 ) ; } } VAR_2 . start ( ) ; }
<|startcomment|> I extend _CODE_ interface a METHOD_1 ( ) & hibernate implementation call clear ties context object close hibernate implementation ( I want avoid want drop hibernate ) <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { <START> ( ( TYPE_2 ) this . METHOD_2 ( ) . METHOD_3 ( ) ) . clear ( ) ; <END> }
<|startcomment|> RuntimeException <|endcomment|> private Optional < TYPE_1 > METHOD_1 ( ) { try { return Optional . of ( VAR_1 . get ( ) ) ; } <START> catch ( Exception VAR_2 ) { <END> } return Optional . empty ( ) ; }
<|startcomment|> missing filter expression <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 ) { if ( TYPE_2 . METHOD_2 ( VAR_2 ) ) { return true ; } else { try { return VAR_3 . METHOD_3 ( VAR_1 . METHOD_4 ( ) , VAR_2 ) ; } catch ( TYPE_3 e ) { <START> LOG . warn ( STRING_1 , e ) ; <END> } } return false ; }
<|startcomment|> _CODE_ ( r VAR_4 METHOD_7 ( STRING_1 ) ) ; obvious node’s change <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = r . VAR_2 ( STRING_1 , "" , null ) ; TYPE_1 VAR_3 = r . VAR_2 ( STRING_2 , "" , null ) ; r . VAR_4 . METHOD_2 ( VAR_1 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_4 ( VAR_1 , VAR_3 ) ; r . VAR_4 . METHOD_3 ( ) . METHOD_5 ( ) ; <START> METHOD_6 ( r . VAR_4 . METHOD_7 ( VAR_1 . METHOD_8 ( ) ) ) ; <END> }
<|startcomment|> don t a parameter ! I guess easier copy paste code delegate View interface <|endcomment|> protected void METHOD_1 ( ) { if ( METHOD_2 ( ) ) { view . VAR_1 ( TYPE_3 . TYPE_4 . METHOD_3 ( ) , Constants . VAR_2 . METHOD_4 ( ) , new TYPE_2 ( ) { @Override public void execute ( ) { METHOD_1 ( true ) ; } } , new TYPE_2 ( ) { @Override public void execute ( ) { METHOD_1 ( false ) ; } } , <START> new TYPE_2 ( ) { <END> @Override public void execute ( ) { } } ) ; } else { METHOD_1 ( false ) ; } }
<|startcomment|> I m clear needed <|endcomment|> public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws TYPE_2 { <START> synchronized ( VAR_2 ) { <END> if ( VAR_1 != null && VAR_1 . length > 0 ) { TYPE_3 target = TYPE_4 . METHOD_2 ( VAR_1 [ 0 ] , TYPE_3 . class ) ; Set < TYPE_1 > set = VAR_2 . get ( target ) ; if ( set != null ) { set . VAR_3 ( Arrays . asList ( VAR_1 ) ) ; if ( set . isEmpty ( ) ) { VAR_2 . remove ( target ) ; } } } } }
<|startcomment|> doesn t store object suggest removing <|endcomment|> public Collection < TYPE_1 > METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_1 > VAR_2 = new TYPE_2 < TYPE_1 > ( ) ; <START> VAR_1 . METHOD_2 ( ) ; <END> Object action = METHOD_3 ( VAR_1 ) ; for ( Object VAR_3 : VAR_4 . METHOD_4 ( ) . METHOD_5 ( action , TYPE_4 . TYPE_3 ) ) { if ( ! VAR_3 . equals ( VAR_1 ) ) { VAR_2 . add ( VAR_4 . METHOD_6 ( ) . METHOD_7 ( VAR_3 ) ) ; } } return VAR_2 ; }
<|startcomment|> iterator method _CODE_ signature : public synchronized TYPE_1 iterator ( String query ) people added more iterator methods some synchronized some I methods connection synchronized ; means need synchronized other iterator methods call don t need <|endcomment|> <START> public TYPE_1 iterator ( String query , int VAR_1 , int VAR_2 ) throws TYPE_2 { <END> try { METHOD_1 ( ) ; TYPE_3 VAR_3 = METHOD_2 ( VAR_2 ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; logger . trace ( query ) ; return METHOD_4 ( VAR_3 , query ) ; } catch ( final TYPE_4 e ) { throw e ; } catch ( final Exception e ) { throw new TYPE_2 ( STRING_1 , e ) ; } }
<|startcomment|> suggest changing VAR_7 = = i ? true : false VAR_7 = = i <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { if ( VAR_4 != null ) { VAR_2 . get ( i ) . METHOD_3 ( VAR_4 ) ; } <START> METHOD_4 ( VAR_2 . get ( i ) , VAR_5 , VAR_6 , VAR_7 == i ? true : false , <END> VAR_1 , time ) ; } }
<|startcomment|> object VAR_4 ? set type null a idea <|endcomment|> public TYPE_2 ( final Object data , final TYPE_1 VAR_2 , final String VAR_3 ) { if ( null == data ) { <START> this . type = Object . VAR_4 . getName ( ) ; <END> } else { this . type = data . getClass ( ) . getName ( ) ; } this . data = data ; this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; }
<|startcomment|> nitpick : e - > e getKey ( ) replaced TYPE_2 : : getKey change ps more efficient <|endcomment|> public TYPE_1 < TYPE_2 < TYPE_3 , TYPE_4 > > iterator ( ) { return new TYPE_5 < > ( new TYPE_6 < > ( TYPE_7 . iterator ( stream ( ) ) , cache , <START> e - > e . getKey ( ) ) , e - > new TYPE_8 < > ( cache , e ) ) ; <END> }
<|startcomment|> _CODE_ = 0 ; <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 = null ; <END> }
<|startcomment|> need 2 lines <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> VAR_1 . METHOD_2 ( ) . remove ( STRING_1 ) ; <END> METHOD_3 ( VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ) ; String result = ( String ) VAR_2 . METHOD_4 ( STRING_2 , new TYPE_1 ( ) . cache ( VAR_1 . METHOD_2 ( STRING_3 ) ) . METHOD_5 ( STRING_1 , STRING_4 ) ) . get ( ) ; assertEquals ( STRING_5 , result ) ; assertEquals ( STRING_4 , VAR_1 . METHOD_2 ( ) . get ( STRING_1 ) ) ; }
<|startcomment|> please remove unnecessary brackets : return ( TYPE_1 ) super METHOD_1 ( ) ; <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return ( TYPE_1 ) ( super . METHOD_1 ( ) ) ; <END> }
<|startcomment|> idem <|endcomment|> public void METHOD_1 ( long VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 . stream ( ) . forEach ( VAR_3 - > VAR_3 . METHOD_2 ( this , VAR_1 ) ) ; <END> }
<|startcomment|> addAll ( ) <|endcomment|> public Set < Integer > METHOD_1 ( ) { synchronized ( VAR_1 ) { Set < Integer > VAR_2 = new HashSet < Integer > ( VAR_1 ) ; <START> VAR_2 . addAll ( VAR_1 ) ; <END> return VAR_2 ; } }
<|startcomment|> VAR_1 METHOD_2 ( null ) instead done patch set 2 <|endcomment|> public void METHOD_1 ( ) { <START> this . VAR_1 . METHOD_2 ( null ) ; <END> this . parent . VAR_2 ( ) ; this . VAR_1 = null ; this . VAR_3 = null ; this . parent = null ; }
<|startcomment|> I contentlet METHOD_1 ( ) method recreating <|endcomment|> private boolean METHOD_1 ( final TYPE_1 VAR_1 ) { return VAR_1 instanceof TYPE_2 || <START> ( VAR_1 instanceof TYPE_3 && TYPE_2 . class . METHOD_2 ( ) . equals ( ( ( TYPE_3 ) VAR_1 ) . METHOD_3 ( ) . name ( ) ) ) || <END> ( null != VAR_1 && VAR_1 instanceof TYPE_4 && TYPE_2 . class . getName ( ) . equals ( TYPE_4 . class . METHOD_4 ( VAR_1 ) . getType ( ) ) ) ; }
<|startcomment|> don t need parens VAR_1 METHOD_5 ( ) METHOD_6 ( ) equals ( METHOD_4 ( ) METHOD_6 ( ) ) <|endcomment|> public boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( ) != null ? METHOD_2 ( ) . METHOD_3 ( ) : null ; return METHOD_4 ( ) != null && VAR_1 != null <START> && ( VAR_1 . METHOD_5 ( ) == METHOD_4 ( ) || ( VAR_1 . METHOD_5 ( ) != null && ( VAR_1 . METHOD_5 ( ) . METHOD_6 ( ) . equals ( METHOD_4 ( ) . METHOD_6 ( ) ) ) ) ) ; <END> }
<|startcomment|> ss I catch IOException METHOD_2 <|endcomment|> private void METHOD_1 ( String VAR_1 ) { TYPE_1 context ; <START> try { <END> context = METHOD_2 ( new TYPE_2 ( STRING_1 , VAR_1 ) ) ; VAR_2 . METHOD_3 ( context ) ; TYPE_3 VAR_3 = new TYPE_3 ( ImmutableList . of ( ( TYPE_4 ) VAR_2 ) ) ; VAR_3 . METHOD_4 ( context ) ; } catch ( IOException e ) { TYPE_5 . METHOD_5 ( e ) ; } }
<|startcomment|> meh : a vararg method I METHOD_2 ( 1 2 3 4 5 ) <|endcomment|> public void METHOD_1 ( ) throws Exception { long [ ] VAR_1 = b . VAR_2 ( STRING_1 , STRING_2 , STRING_3 , STRING_4 , STRING_5 ) ; <START> assertThat ( VAR_1 ) . METHOD_2 ( new long [ ] { 1 , 2 , 3 , 4 , 5 } ) ; <END> }
<|startcomment|> exists statically imported <|endcomment|> public void METHOD_1 ( ) throws Exception { METHOD_2 ( asList ( TYPE_1 . add ( INT_1 , index , STRING_1 ) , TYPE_1 . add ( INT_2 , index , STRING_1 ) , TYPE_1 . add ( INT_3 , index , STRING_2 ) ) ) ; assertThat ( query ( METHOD_3 ( 1 , STRING_1 ) ) , METHOD_4 ( asList ( INT_1 , INT_2 ) ) ) ; <START> assertThat ( query ( TYPE_2 . exists ( 1 ) ) , METHOD_4 ( asList ( INT_1 , INT_2 , INT_3 ) ) ) ; <END> }
<|startcomment|> shouldn t clearing entry _CODE_ similarly compensate complete callbacks finish successfully <|endcomment|> Response METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 ) { <START> return METHOD_2 ( VAR_3 , VAR_1 , VAR_2 , VAR_4 ) ; <END> }
<|startcomment|> I overlap concurrent updates authorities other threads <|endcomment|> <START> private void METHOD_1 ( String VAR_1 ) { <END> TYPE_1 VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; Collection < ? extends TYPE_2 > VAR_4 = VAR_2 . METHOD_3 ( ) ; Object VAR_5 = METHOD_4 ( VAR_1 ) ; VAR_6 . METHOD_5 ( VAR_5 ) . forEach ( VAR_7 - > METHOD_1 ( VAR_7 , VAR_4 ) ) ; }
<|startcomment|> similar approach condition simpler : { METHOD_2 ( ) ; } finally { ( METHOD_4 ( ) = = TYPE_1 VAR_2 ) { METHOD_5 ( ) ; } } <|endcomment|> private void METHOD_1 ( ) { log . error ( STRING_1 , getClass ( ) . getName ( ) ) ; METHOD_2 ( ) ; METHOD_3 ( ) ; <START> if ( METHOD_4 ( ) == TYPE_1 . VAR_2 ) { <END> METHOD_5 ( ) ; } }
<|startcomment|> continue reuse a single TYPE_2 <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 builder = new TYPE_1 ( ) ; final String input = STRING_1 ; <START> final TYPE_2 < String , Object > VAR_1 = new TYPE_2 < > ( ) ; <END> builder . table ( input , VAR_2 ) . METHOD_2 ( TYPE_3 . METHOD_3 ( ) , VAR_3 ) . count ( ) . METHOD_4 ( ) . METHOD_5 ( VAR_1 ) ; METHOD_6 ( builder , input , VAR_1 ) ; }
<|startcomment|> new IllegalArgumentException more <|endcomment|> private static TYPE_1 METHOD_1 ( String path ) { try { return new TYPE_1 ( path ) ; } catch ( TYPE_2 e ) { try { return new File ( path ) . METHOD_2 ( ) . METHOD_3 ( ) ; } catch ( TYPE_2 VAR_1 ) { <START> throw new IllegalStateException ( VAR_1 ) ; <END> } } }
<|startcomment|> unchecked cast class s a checked cast isn t necessary <|endcomment|> protected void METHOD_1 ( final TYPE_1 filter , final TYPE_2 VAR_1 ) { <START> ( ( TYPE_3 ) VAR_1 ) . METHOD_2 ( filter . VAR_2 ( ) ) ; <END> VAR_3 . METHOD_3 ( new TYPE_4 ( METHOD_4 ( ) , filter , VAR_1 ) ) ; }
<|startcomment|> protected <|endcomment|> <START> void METHOD_1 ( Set < String > VAR_1 ) throws Exception { <END> if ( VAR_2 != null ) { for ( TYPE_1 VAR_3 : VAR_2 ) { METHOD_2 ( factory . VAR_4 ( VAR_3 ) , VAR_1 , false ) ; } } }
<|startcomment|> deadlock : remove call METHOD_4 ( ) s events arrive <|endcomment|> private void METHOD_1 ( ) { TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) ; while ( VAR_1 . METHOD_3 ( ) ) { } <START> VAR_1 . METHOD_4 ( ) ; <END> return ; }
<|startcomment|> thanks size improvement synchronized issue s open a jira <|endcomment|> private Map < String , List < Entry < T > > > METHOD_1 ( final Map < String , List < Entry < T > > > VAR_1 ) { final Map < String , List < Entry < T > > > VAR_2 = new HashMap < > ( ) ; VAR_1 . forEach ( ( key , value ) - > VAR_2 . put ( key , new TYPE_1 < > ( value ) ) ) ; <START> return VAR_2 ; <END> }
<|startcomment|> leave double avoid auto boxing <|endcomment|> @Override public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> Double value = VAR_1 . properties ( ) . METHOD_2 ( STRING_1 , Double . VAR_2 ) ; <END> if ( value . equals ( Double . VAR_2 ) ) { TYPE_2 . METHOD_1 ( VAR_1 . event ( ) ) ; } else { TYPE_2 . METHOD_1 ( VAR_1 . event ( ) , value ) ; } }
<|startcomment|> constructor private <|endcomment|> <START> public TYPE_2 ( ) { <END> super ( null , TYPE_1 . VAR_3 ) ; }
<|startcomment|> check responses VAR_1 <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_2 ( null ) ; <END> METHOD_2 ( new TYPE_3 ( VAR_1 ) ) ; }
<|startcomment|> I wrong : return true maps integer keys need create separate subclasses find another distinguish list element deletions other cases <|endcomment|> TYPE_6 ( String VAR_2 , String table , List < TYPE_1 > VAR_3 ) { super ( VAR_2 ) ; this . table = table ; this . VAR_3 = VAR_3 ; this . VAR_4 = new TYPE_2 ( this ) ; this . VAR_5 = new TYPE_3 ( this ) ; this . VAR_6 = new TYPE_4 ( this ) ; for ( TYPE_1 VAR_7 : VAR_3 ) { if ( VAR_7 instanceof TYPE_5 ) { <START> if ( ( ( TYPE_5 ) VAR_7 ) . key instanceof Integer ) { <END> METHOD_1 ( ) ; } } } }
<|startcomment|> minor : put conditions a && <|endcomment|> File remove ( long VAR_1 ) { File VAR_2 = null ; TYPE_1 < File > VAR_3 = VAR_4 . get ( VAR_1 ) ; <START> if ( VAR_3 != null ) { <END> if ( VAR_3 . size ( ) != 0 ) { VAR_2 = VAR_3 . remove ( ) ; } } return VAR_2 ; }
<|startcomment|> shouldn t _CODE_ < TYPE_2 > VAR_1 = new ArrayList < TYPE_2 > ( VAR_1 size ( ) ) ; instead TYPE_3 removing adding tail <|endcomment|> public TYPE_1 create ( ) { <START> List < TYPE_2 > VAR_1 = new TYPE_3 < TYPE_2 > ( ) ; <END> for ( TYPE_4 < ? , ? > VAR_2 : this . VAR_1 ) VAR_1 . add ( VAR_2 . create ( ) ) ; return new TYPE_1 ( VAR_3 , VAR_1 ) ; }
<|startcomment|> container <|endcomment|> <START> private void METHOD_1 ( TYPE_1 VAR_1 , String VAR_2 , String VAR_3 , TYPE_2 container , <END> String VAR_4 , String VAR_5 ) throws TYPE_3 { METHOD_1 ( VAR_1 , VAR_2 , VAR_3 , container , VAR_4 , VAR_5 , true , true ) ; }
<|startcomment|> simplify : javaif ( args isEmpty ( ) ) { <|endcomment|> public void METHOD_1 ( List < TYPE_1 > args ) { <START> if ( ! ( args . size ( ) > 0 ) ) { <END> throw new TYPE_2 ( STRING_1 , name ( ) ) ; } }
<|startcomment|> I d remove empty lines <|endcomment|> public boolean METHOD_1 ( T VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( VAR_1 ) ) return false ; TYPE_1 event = new TYPE_1 ( this , id . toString ( ) , this . value , VAR_1 ) ; <START> this . value = VAR_1 ; <END> METHOD_3 ( event ) ; return true ; }
<|startcomment|> issue line 208 ( METHOD_3 void ) <|endcomment|> public void METHOD_1 ( ) throws Exception { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; <START> final TYPE_2 VAR_2 = TYPE_2 . METHOD_2 ( ( ) - > { <END> } ) . METHOD_3 ( ) ; TYPE_2 . METHOD_2 ( ( ) - > { METHOD_4 ( VAR_1 . get ( ) ) ; VAR_1 . set ( true ) ; VAR_2 . METHOD_5 ( ) ; VAR_2 . METHOD_6 ( ) ; } ) . METHOD_3 ( ) ; METHOD_7 ( ) ; assertTrue ( VAR_1 . get ( ) ) ; }
<|startcomment|> a _CODE_ remove synchronized public methods <|endcomment|> TYPE_2 ( String name ) { this . name = name ; <START> VAR_2 = new HashMap < String , TYPE_1 > ( ) ; <END> }
<|startcomment|> simpler : Double [ ] params = { VAR_1 VAR_2 } <|endcomment|> public void METHOD_1 ( ) { Double [ ] params = new Double [ 2 ] ; params [ 0 ] = VAR_1 ; <START> params [ 1 ] = VAR_2 ; <END> TYPE_1 VAR_3 = new TYPE_1 ( ) ; VAR_3 . METHOD_2 ( params ) ; METHOD_3 ( VAR_3 ) ; }
<|startcomment|> I t s blocking shouldn t ( ) <|endcomment|> <START> public void METHOD_1 ( final TYPE_1 VAR_1 ) throws IOException { <END> final byte [ ] data = VAR_1 . METHOD_2 ( ) ; if ( data != null ) { final String key = VAR_2 . METHOD_3 ( VAR_3 . getId ( ) ) ; VAR_4 . set ( key , METHOD_4 ( VAR_3 . METHOD_5 ( ) ) , data ) ; } else { VAR_5 . warn ( STRING_1 + VAR_1 . getStatus ( ) + STRING_2 + VAR_3 . METHOD_6 ( ) + STRING_3 + STRING_4 ) ; } }
<|startcomment|> method needs assign null VAR_1 <|endcomment|> public void METHOD_1 ( ) throws Exception { if ( VAR_1 != null ) { <START> VAR_1 . METHOD_2 ( ) ; <END> } }
<|startcomment|> replaced _CODE_ <|endcomment|> protected void METHOD_1 ( final TYPE_1 request ) { <START> if ( VAR_1 == null || VAR_1 . METHOD_2 ( ) ) { <END> request . VAR_2 ( ) ; return ; } TYPE_2 VAR_3 = new TYPE_2 ( this , request ) ; if ( TYPE_3 . METHOD_3 ( ) ) { TYPE_3 . METHOD_4 ( request , STRING_1 ) ; } VAR_1 . execute ( VAR_3 ) ; }
<|startcomment|> implement equals TYPE_1 <|endcomment|> public boolean METHOD_1 ( ANNOTATION_1 TYPE_1 item ) { for ( TYPE_1 VAR_1 : VAR_2 ) { <START> if ( item . VAR_3 == VAR_1 . VAR_3 <END> && item . VAR_4 == VAR_1 . VAR_4 && item . name . equals ( VAR_1 . name ) ) { return true ; } } return false ; }
<|startcomment|> inline <|endcomment|> public void METHOD_1 ( ) { <START> long r = get ( ) ; <END> if ( r != Long . VAR_1 ) { VAR_2 . METHOD_1 ( ) ; } }
<|startcomment|> initializer repeated additional constructors added <|endcomment|> public TYPE_2 ( ) { <START> VAR_2 = new TYPE_1 < > ( ) ; <END> }
<|startcomment|> needed <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 out = new TYPE_1 ( ) ; TYPE_2 . get ( ) . METHOD_2 ( out ) ; <START> System . out . println ( out . toString ( ) ) ; <END> assertThat ( out . toString ( ) , METHOD_3 ( STRING_1 ) ) ; assertThat ( out . toString ( ) , METHOD_3 ( STRING_2 ) ) ; }
<|startcomment|> missing a blank _CODE_ returns empty list check ( ! VAR_1 isEmpty ( ) ) <|endcomment|> private TYPE_1 < String > METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> return e - > VAR_1 . contains ( e ) ; } else if ( VAR_2 != null ) { return e - > ! VAR_2 . contains ( e ) ; } else { return e - > true ; } }
<|startcomment|> missing INT_1 < = <|endcomment|> public void METHOD_1 ( ) { <START> for ( int VAR_1 = 1 ; VAR_1 < INT_1 ; VAR_1 ++ ) { <END> METHOD_2 ( METHOD_3 ( VAR_1 ) + STRING_1 ) ; } }
<|startcomment|> need set null <|endcomment|> public void METHOD_1 ( TYPE_1 event ) { <START> Map < String , Object > VAR_1 = null ; <END> if ( event . VAR_2 ( ) ) { VAR_1 = METHOD_2 ( ) . METHOD_3 ( STRING_1 , METHOD_4 ( event ) ) ; } else { VAR_1 = METHOD_2 ( ) . METHOD_3 ( STRING_2 , METHOD_5 ( event ) ) ; } event . VAR_3 ( ( Integer ) VAR_1 . get ( STRING_3 ) ) ; }
<|startcomment|> critical VAR_4 ( ) method implicitly performs client VAR_4 ( ) run method queries need return result ( check _CODE_ class ) <|endcomment|> public void METHOD_1 ( ) throws Exception { try { client . VAR_1 ( TYPE_1 . VAR_3 , 1 ) ; <START> client . VAR_4 ( ) <END> . METHOD_2 ( STRING_1 + STRING_2 , VAR_5 ) . run ( ) ; } finally { client . VAR_6 ( TYPE_1 . VAR_3 ) ; } }
<|startcomment|> VAR_2 forEach ( - > TYPE_2 add ( ) ) ; more concise <|endcomment|> private static void METHOD_1 ( TYPE_1 TYPE_2 , TYPE_3 VAR_1 , List < String > VAR_2 ) { TYPE_2 . METHOD_2 ( ) ; <START> for ( String name : VAR_2 ) { TYPE_2 . add ( name ) ; } <END> TYPE_2 . METHOD_3 ( ( null == VAR_1 ) ? VAR_2 . size ( ) - 1 : TYPE_2 . METHOD_4 ( VAR_1 . getName ( ) ) ) ; }
<|startcomment|> I closed a recovery reader I need a coffee : ) <|endcomment|> boolean METHOD_1 ( ) { <START> return ! METHOD_2 ( ) . METHOD_3 ( ) ; <END> }
<|startcomment|> don t leave empty - add call _super ( ) _ - implicit enables placing a debug breakpoint constructor <|endcomment|> public VAR_1 ( ) <START> { } <END>
<|startcomment|> I a _CODE_ derived tests _CODE_ java util _CODE_ java util _CODE_ _CODE_ ( vector java : 1210 ) java util _CODE_ ( vector java : 1163 ) org eclipse jface tests viewers _CODE_ METHOD_1 ( _CODE_ java : 40 ) org eclipse jface tests viewers _CODE_ _CODE_ ( _CODE_ java : 134 ) org eclipse jface tests viewers _CODE_ _CODE_ ( _CODE_ java : 128 ) org eclipse jface tests viewers _CODE_ _CODE_ ( _CODE_ java : 164 ) sun reflect _CODE_ invoke0 ( native method ) sun reflect _CODE_ invoke ( _CODE_ java : 62 ) sun reflect _CODE_ invoke ( _CODE_ java : 43 ) java lang reflect method invoke ( method java : 498 ) junit framework _CODE_ _CODE_ ( _CODE_ java : 176 ) junit framework _CODE_ _CODE_ ( _CODE_ java : 141 ) junit framework _CODE_ protect ( _CODE_ java : 122 ) junit framework _CODE_ _CODE_ ( _CODE_ java : 142 ) junit framework _CODE_ run ( _CODE_ java : 125 ) junit framework _CODE_ run ( _CODE_ java : 129 ) junit framework _CODE_ _CODE_ ( _CODE_ java : 252 ) junit framework _CODE_ run ( _CODE_ java : 247 ) org junit internal runners _CODE_ run ( _CODE_ java : 86 ) org junit runners suite _CODE_ ( suite java : 128 ) org junit runners suite _CODE_ ( suite java : 27 ) org junit runners _CODE_ run ( _CODE_ java : 290 ) org junit runners _CODE_ schedule ( _CODE_ java : 71 ) org junit runners _CODE_ _CODE_ ( _CODE_ java : 288 ) org junit runners _CODE_ access$000 ( _CODE_ java : 58 ) org junit runners _CODE_ evaluate ( _CODE_ java : 268 ) org junit runners _CODE_ run ( _CODE_ java : 363 ) org junit runners suite _CODE_ ( suite java : 128 ) org junit runners suite _CODE_ ( suite java : 27 ) org junit runners _CODE_ run ( _CODE_ java : 290 ) org junit runners _CODE_ schedule ( _CODE_ java : 71 ) org junit runners _CODE_ _CODE_ ( _CODE_ java : 288 ) org junit runners _CODE_ access$000 ( _CODE_ java : 58 ) org junit runners _CODE_ evaluate ( _CODE_ java : 268 ) org junit runners _CODE_ run ( _CODE_ java : 363 ) org eclipse jdt internal junit4 runner _CODE_ run ( _CODE_ java : 89 ) org eclipse jdt internal junit runner _CODE_ run ( _CODE_ java : 41 ) org eclipse jdt internal junit runner _CODE_ _CODE_ ( _CODE_ java : 542 ) org eclipse jdt internal junit runner _CODE_ _CODE_ ( _CODE_ java : 764 ) org eclipse jdt internal junit runner _CODE_ run ( _CODE_ java : 464 ) org eclipse jdt internal junit runner _CODE_ main ( _CODE_ java : 210 ) <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> for ( TYPE_2 listener : VAR_2 ) { <END> listener . VAR_3 ( VAR_1 ) ; } }
<|startcomment|> btw : ) wouldn treturn path VAR_7 ( ) ? path VAR_8 ( ) : Double VAR_9 ; slightly ternary op line <|endcomment|> public double METHOD_1 ( int VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , VAR_4 , VAR_5 ) ; Path path = VAR_6 ? VAR_2 . METHOD_2 ( to , VAR_1 ) : VAR_2 . METHOD_2 ( VAR_1 , to ) ; <START> if ( path . VAR_7 ( ) ) return path . VAR_8 ( ) ; else return Double . VAR_9 ; <END> }
<|startcomment|> call isEmpty ( ) <|endcomment|> public boolean METHOD_1 ( String user , List < ByteBuffer > VAR_1 ) throws TYPE_1 { <START> if ( VAR_1 . size ( ) == 0 ) { <END> return true ; } TYPE_2 VAR_2 = METHOD_2 ( user ) ; for ( ByteBuffer VAR_3 : VAR_1 ) { if ( ! VAR_2 . contains ( TYPE_3 . METHOD_3 ( VAR_3 ) ) ) { return false ; } } return true ; }
<|startcomment|> VAR_1 thread safety <|endcomment|> public synchronized long METHOD_1 ( final int offset ) { TYPE_1 VAR_1 = VAR_2 ; if ( VAR_1 != null ) { return <START> VAR_2 . VAR_3 <END> + Math . VAR_4 ( VAR_1 . VAR_5 * offset ) ; } return 0 ; }
<|startcomment|> I lines 71 - 74 don t need block nice order block small <|endcomment|> private String METHOD_1 ( TYPE_1 VAR_1 ) { try { <START> TYPE_2 VAR_2 = TYPE_3 . METHOD_2 ( ) . METHOD_3 ( VAR_1 ) ; <END> if ( VAR_2 == null ) { throw new TYPE_4 ( STRING_1 ) ; } TYPE_5 element = VAR_2 . METHOD_4 ( VAR_1 ) ; return TYPE_6 . METHOD_5 ( element ) ; } catch ( Exception e ) { throw new TYPE_4 ( e ) ; } }
<|startcomment|> personal opinion helps code readability <|endcomment|> public boolean METHOD_1 ( ) { <START> return VAR_1 != null ? VAR_1 : ( parent != null && parent . VAR_1 ( ) ) ; <END> }
<|startcomment|> notice a method reference : VAR_5 = Optional VAR_6 ( ( TYPE_2 ) TYPE_3 METHOD_1 ( ) ) map ( TYPE_2 : : METHOD_2 ) ; <|endcomment|> public TYPE_4 ( Map < String , String > VAR_2 , TYPE_1 [ ] VAR_3 , String VAR_4 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = Optional . VAR_6 ( ( TYPE_2 ) TYPE_3 . METHOD_1 ( ) ) <START> . map ( VAR_7 - > VAR_7 . METHOD_2 ( ) ) ; <END> }
<|startcomment|> minor : need add explicit type argument <|endcomment|> TYPE_1 ( int VAR_2 ) { <START> this . list = new ArrayList < T > ( VAR_2 ) ; <END> }
<|startcomment|> checks moved a common parent class repeated _CODE_ <|endcomment|> protected boolean METHOD_1 ( ) { if ( ! super . METHOD_1 ( ) ) { return false ; } if ( Guid . VAR_1 ( getParameters ( ) . METHOD_2 ( ) ) ) { METHOD_3 ( TYPE_1 . VAR_3 ) ; return false ; } if ( METHOD_4 ( ) == null ) { METHOD_3 ( TYPE_1 . VAR_4 ) ; return false ; <START> } <END> if ( METHOD_5 ( ) . isEmpty ( ) ) { METHOD_3 ( TYPE_1 . VAR_5 ) ; return false ; } return true ; }
<|startcomment|> logger <|endcomment|> private void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) throws Exception { <START> System . out . println ( STRING_1 ) ; <END> System . out . println ( STRING_2 ) ; System . out . println ( VAR_2 + STRING_3 + VAR_1 + STRING_4 ) ; System . out . println ( STRING_5 + VAR_3 ) ; System . out . println ( STRING_1 ) ; }
<|startcomment|> doesn t work anymore need implement behavior database code <|endcomment|> static TYPE_1 METHOD_1 ( ) { return new TYPE_2 ( ) { @Override protected void METHOD_2 ( ) { final String VAR_1 = VAR_2 ; final TYPE_3 < TYPE_4 < TYPE_6 . TYPE_9 , TYPE_6 > > type = new TYPE_3 < TYPE_4 < TYPE_6 . TYPE_9 , TYPE_6 > > ( ) { } ; METHOD_3 ( type , VAR_1 ) . METHOD_4 ( INT_1 ) <START> . METHOD_5 ( INT_2 , VAR_3 ) <END> . METHOD_6 ( TYPE_10 . VAR_5 ) ; bind ( TYPE_7 . class ) . in ( TYPE_8 . class ) ; } } ; }
<|startcomment|> TYPE_2 Context METHOD_2 ( ) request ( ) METHOD_3 ( VAR_1 ) ; tu pourras donc aussi enlever le import de TYPE_3 <|endcomment|> private void METHOD_1 ( ) { TYPE_2 . TYPE_4 session = TYPE_2 . Context . METHOD_2 ( ) . session ( ) ; String VAR_1 = session . get ( TYPE_5 . VAR_3 ) ; <START> TYPE_3 . request ( ) . METHOD_3 ( VAR_1 ) ; <END> }
<|startcomment|> Optional : written TYPE_3 TYPE_4 equals ( VAR_1 VAR_2 ) TYPE_3 TYPE_4 null <|endcomment|> private boolean METHOD_1 ( ) { <START> return TYPE_1 . equals ( VAR_1 . VAR_2 , <END> TYPE_3 . TYPE_4 ) && VAR_3 ; }
<|startcomment|> I remove log number entries removed 0 <|endcomment|> private synchronized int METHOD_1 ( long VAR_1 , int VAR_2 ) { int n = new TYPE_1 ( ) . METHOD_2 ( VAR_1 , VAR_2 ) ; if ( n == 0 ) { <START> log . trace ( STRING_1 ) ; <END> } else { log . info ( STRING_2 , n ) ; } return n ; }
<|startcomment|> return VAR_1 f ( ) FJ special case null imput : protecting input parameter null litter code garbage impact perf case hide root issue propagating a null dedicated _CODE_ option _CODE_ explicitly deal null <|endcomment|> public TYPE_1 value ( ) { <START> return VAR_1 != null ? VAR_1 . f ( ) : null ; <END> }
<|startcomment|> please move annotation line <|endcomment|> <START> @Override public void METHOD_1 ( ) { <END> super . METHOD_1 ( ) ; if ( VAR_1 != null ) { VAR_1 . METHOD_2 ( ) ; } }
<|startcomment|> ? happen <|endcomment|> void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = METHOD_2 ( ) . METHOD_3 ( ) ; int VAR_3 = ( VAR_2 == null ) ? 0 : VAR_2 . size ( ) ; <START> if ( VAR_3 < 0 ) <END> return ; TYPE_4 . METHOD_1 ( VAR_1 , VAR_3 , VAR_2 ) ; }
<|startcomment|> odd return null explicitly set FALSE <|endcomment|> public Boolean METHOD_1 ( ) { <START> return ( VAR_1 != null && VAR_1 ) ? VAR_1 : null ; <END> }
<|startcomment|> a C style equality check account case mismatches conside ( STRING_2 equalsIgnoreCase ( VAR_1 ) ) instead <|endcomment|> private void METHOD_1 ( String VAR_1 ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> boolean VAR_2 = false ; <END> if ( VAR_1 . METHOD_3 ( STRING_2 ) == 0 ) { VAR_2 = true ; } else if ( VAR_1 . METHOD_3 ( STRING_3 ) == 0 ) { VAR_2 = true ; } else if ( VAR_1 . METHOD_3 ( STRING_4 ) == 0 ) { VAR_2 = true ; } if ( ! VAR_2 ) { throw new TYPE_2 ( STRING_5 ) ; } }
<|startcomment|> include VAR_1 properties break ties <|endcomment|> public int METHOD_1 ( TYPE_1 VAR_1 ) { <START> return this . getName ( ) . METHOD_1 ( VAR_1 . getName ( ) ) ; <END> }
<|startcomment|> static <|endcomment|> <START> private TYPE_1 < TYPE_2 > METHOD_1 ( boolean VAR_1 ) { <END> return VAR_1 ? new TYPE_3 < > ( ) : new TYPE_4 < > ( ) ; }
<|startcomment|> missing braces <|endcomment|> public void run ( ) { <START> if ( VAR_1 . METHOD_1 ( ) == null ) <END> return ; VAR_2 = new TYPE_1 ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) , VAR_1 . METHOD_1 ( ) , VAR_1 . VAR_3 ) ; if ( VAR_2 . METHOD_5 ( ) == TYPE_2 . VAR_5 ) { VAR_1 . METHOD_6 ( VAR_1 . METHOD_7 ( ) ) ; } }
<|startcomment|> null getString ( ) passed a default <|endcomment|> public String METHOD_1 ( ) { <START> return METHOD_2 ( VAR_1 , getString ( VAR_1 , VAR_2 ) ) ; <END> }
<|startcomment|> I m added benefit _CODE_ displays information necessary <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 e ) { <START> if ( logger . VAR_1 ( ) ) { <END> logger . debug ( STRING_1 + e . getMessage ( ) ) ; } if ( e instanceof TYPE_3 ) { return new TYPE_4 ( e . getMessage ( ) , e ) ; } else { return new TYPE_5 ( e . getMessage ( ) , e ) ; } }
<|startcomment|> pass root creating new exception <|endcomment|> private void METHOD_1 ( String VAR_1 ) { try { new TYPE_1 ( VAR_1 ) ; } catch ( TYPE_2 e ) { <START> throw new IllegalArgumentException ( STRING_1 ) ; <END> } }
<|startcomment|> BTW written more concisely effectively final variable : _CODE_ VAR_2 = user VAR_3 ( ) ; TYPE_4 VAR_1 = VAR_6 VAR_3 ( VAR_2 ) ; { return TYPE_6 METHOD_1 ( run ) ; } finally { TYPE_7 METHOD_3 ( VAR_1 ) ; } ( newer overloads closures suitable java 8 lambdas ) <|endcomment|> private boolean METHOD_1 ( ANNOTATION_1 TYPE_1 user , ANNOTATION_1 TYPE_2 < ? , ? > run ) throws TYPE_3 { TYPE_4 VAR_1 = null ; try { TYPE_5 VAR_2 = user . VAR_3 ( ) ; VAR_1 = VAR_4 . VAR_5 . VAR_6 . METHOD_2 ( VAR_2 ) ; return TYPE_6 . METHOD_1 ( run ) ; } finally { if ( VAR_1 != null ) { TYPE_7 . METHOD_3 ( VAR_1 ) ; } <START> } <END> }
<|startcomment|> error a warning ? system proceeds giving I a warning <|endcomment|> public void METHOD_1 ( int index , long VAR_1 , long size ) { try { VAR_2 . get ( index ) . METHOD_1 ( VAR_1 , size ) ; } catch ( Exception e ) { <START> logger . error ( STRING_1 , e ) ; <END> } }
<|startcomment|> removed <|endcomment|> public void METHOD_1 ( int VAR_1 ) throws InterruptedException { <START> System . out . println ( STRING_1 + VAR_2 ) ; <END> if ( ! VAR_2 . METHOD_2 ( VAR_1 , TimeUnit . VAR_3 ) ) { throw new RuntimeException ( STRING_2 ) ; } }
<|startcomment|> simplify a single line replacing method s body : return METHOD_2 ( METHOD_3 ( ) ) && METHOD_2 ( METHOD_4 ( ) ) ; <|endcomment|> <START> protected boolean METHOD_1 ( ) { <END> if ( ! ( METHOD_2 ( METHOD_3 ( ) ) && METHOD_2 ( METHOD_4 ( ) ) ) ) { return false ; } return true ; }
<|startcomment|> changing returning null returning empty collection changes SDK s interface affect applications I d prefer a breaking change s absolutely neccessary <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 ) { <START> return Collections . VAR_2 ( ) ; <END> } return METHOD_2 ( VAR_3 ) ; }
<|startcomment|> METHOD_2 ( ) ; METHOD_7 ( ) ; METHOD_5 ( ) ; METHOD_6 ( ) ; METHOD_7 ( ) ; METHOD_2 ( ) ; <|endcomment|> TYPE_5 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , String name ) { this . VAR_3 = VAR_3 ; this . name = name ; METHOD_1 ( new TYPE_3 ( VAR_2 ) ) ; METHOD_2 ( ) ; METHOD_3 ( false ) ; METHOD_4 ( new TYPE_4 ( ) ) ; METHOD_5 ( ) ; <START> METHOD_6 ( ) ; <END> METHOD_7 ( ) ; }
<|startcomment|> shouldn t _CODE_ a potential null pointer Exception <|endcomment|> public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> TYPE_2 = VAR_1 ; <END> }
<|startcomment|> a lot work verify json valid some 3rd party utility ? consider <|endcomment|> public String METHOD_1 ( ) { return VAR_1 . get ( VAR_2 ) ; <START> } <END>
<|startcomment|> synchronized METHOD_2 <|endcomment|> public void METHOD_1 ( TYPE_1 msg ) { switch ( msg . VAR_1 ) { case VAR_2 : <START> synchronized ( this ) { <END> TYPE_2 VAR_3 = ( TYPE_2 ) msg . obj ; List < TYPE_3 > VAR_4 = ( List < TYPE_3 > ) VAR_3 . result ; METHOD_2 ( VAR_4 ) ; } break ; default : METHOD_3 ( STRING_1 + msg . VAR_1 ) ; break ; } }
<|startcomment|> null check ? null operation doesn t sense t access session <|endcomment|> private void METHOD_1 ( String state , String VAR_1 , TYPE_1 request ) { if ( request != null ) { request . VAR_2 ( ) . METHOD_2 ( STRING_1 + VAR_1 , state ) ; <START> } <END> }
<|startcomment|> ! [ MAJOR ] ( ) METHOD_1 a static method [ ! [ rule ] ( ) ] ( ) <|endcomment|> <START> private void METHOD_1 ( TYPE_1 resource , TYPE_2 VAR_1 ) { <END> if ( LOG . VAR_2 ( ) ) { TYPE_2 VAR_3 = TYPE_3 . get ( resource ) ; if ( VAR_3 == null ) { TYPE_3 . put ( resource , VAR_1 ) ; } else { LOG . debug ( STRING_1 , VAR_1 , resource ) ; } } }
<|startcomment|> rid null check _CODE_ METHOD_1 removed <|endcomment|> <START> private List < TYPE_1 > METHOD_1 ( ) { <END> if ( VAR_1 == null ) { return Collections . VAR_2 ( ) ; } return VAR_1 ; }
<|startcomment|> braces { } - <|endcomment|> private String METHOD_1 ( String VAR_1 ) { TYPE_1 key = VAR_2 . METHOD_2 ( VAR_1 ) ; if ( key != null ) { TYPE_2 VAR_3 = VAR_4 . METHOD_3 ( key ) ; if ( VAR_3 != null ) <START> return VAR_3 . getValue ( ) ; <END> } return null ; }
<|startcomment|> TYPE_2 max ( ) 1 8 won t work android GWT Math max ( ) instead <|endcomment|> public float METHOD_1 ( ) { VAR_1 = new TYPE_1 ( VAR_2 . VAR_3 , model . getValue ( ) . toString ( ) ) ; <START> return TYPE_2 . max ( VAR_2 . VAR_4 . METHOD_2 ( ) , <END> VAR_2 . VAR_4 . METHOD_3 ( ) + VAR_2 . VAR_4 . METHOD_4 ( ) + VAR_1 . VAR_5 ) ; }
<|startcomment|> need wait TYPE_4 wait <|endcomment|> private void METHOD_1 ( ) { new TYPE_1 ( STRING_1 ) . METHOD_2 ( ) ; <START> new TYPE_2 ( new TYPE_3 ( STRING_2 ) ) ; <END> new TYPE_4 ( STRING_2 ) ; new TYPE_1 ( STRING_3 ) . METHOD_2 ( ) ; }
<|startcomment|> logged debug enabled block want reorder statementsif ( ! VAR_4 remove ( VAR_1 VAR_2 ) ) < log info message > else ( log METHOD_2 ( ) ) < log closed message > <|endcomment|> public synchronized void METHOD_1 ( String VAR_1 , int VAR_2 ) { boolean VAR_3 = VAR_4 . remove ( VAR_1 , VAR_2 ) ; if ( VAR_5 . METHOD_2 ( ) ) { if ( VAR_3 ) { VAR_5 . debug ( STRING_1 + VAR_1 + STRING_2 + VAR_2 ) ; } else { <START> VAR_5 . info ( STRING_3 + VAR_1 + STRING_2 + VAR_2 + STRING_4 ) ; <END> } } }
<|startcomment|> shouldn t a default <|endcomment|> public String METHOD_1 ( ) { String VAR_1 = System . getProperty ( VAR_2 , null ) ; if ( VAR_1 == null ) { TYPE_1 VAR_3 = TYPE_2 . METHOD_2 ( ) ; try { VAR_1 = VAR_3 . getValue ( VAR_2 , new TYPE_3 ( ) ) ; } catch ( TYPE_4 e ) { <START> throw new RuntimeException ( e ) ; <END> } } return VAR_1 ; }
<|startcomment|> need METHOD_2 ( ) METHOD_1 ( VAR_1 ) <|endcomment|> public void METHOD_1 ( boolean VAR_1 ) { <START> METHOD_2 ( ) . METHOD_1 ( true == VAR_1 ) ; <END> }
<|startcomment|> call <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; <START> TYPE_3 . bind ( this . VAR_2 ) ; <END> METHOD_1 ( ) ; }
<|startcomment|> - resources I a refactoring opportunity clean code <|endcomment|> public TYPE_1 METHOD_1 ( ) throws IOException , TYPE_2 { TYPE_1 VAR_1 = METHOD_2 ( ) ; <START> TYPE_3 VAR_2 = null ; <END> try { VAR_2 = new TYPE_4 ( new File ( VAR_3 ) ) ; VAR_1 . METHOD_3 ( VAR_2 , METHOD_4 ( VAR_4 ) ) ; return VAR_1 ; } finally { METHOD_5 ( VAR_2 ) ; } }
<|startcomment|> return VAR_1 <|endcomment|> private List < TYPE_1 > METHOD_1 ( Set < TYPE_1 > VAR_1 , Set < TYPE_1 > VAR_2 ) { List < TYPE_1 > VAR_3 = new ArrayList < TYPE_1 > ( ) ; <START> VAR_1 . METHOD_2 ( VAR_2 ) ; <END> VAR_3 . addAll ( VAR_1 ) ; return VAR_3 ; }
<|startcomment|> please diamond operator initialization <|endcomment|> public TYPE_3 ( ) { VAR_2 = <START> new TYPE_1 < TYPE_2 , org . VAR_3 . VAR_4 . VAR_5 . TYPE_4 > ( ) ; <END> }
<|startcomment|> doesn t belong <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { this . VAR_1 = VAR_1 ; <START> METHOD_2 ( ) ; <END> }
<|startcomment|> ( VAR_6 < VAR_5 ) rid extra break condition <|endcomment|> public void METHOD_1 ( int VAR_1 ) { long VAR_2 = TYPE_1 . currentTimeMillis ( ) ; int VAR_3 = METHOD_2 ( size ( ) , VAR_1 ) ; int VAR_4 = 0 ; int VAR_5 = 3 ; int VAR_6 = 0 ; <START> while ( true ) { <END> VAR_4 += METHOD_3 ( VAR_3 , VAR_2 ) ; if ( VAR_4 >= VAR_3 ) { break ; } VAR_6 ++ ; if ( VAR_6 > VAR_5 ) { break ; } } }
<|startcomment|> METHOD_2 call required org jboss ide eclipse management as71 declared a dependency test plugin <|endcomment|> public static TYPE_1 METHOD_1 ( String VAR_1 ) { METHOD_2 ( STRING_1 ) ; <START> METHOD_2 ( STRING_2 ) ; <END> METHOD_2 ( STRING_3 ) ; try { return TYPE_2 . METHOD_3 ( VAR_1 ) ; } catch ( TYPE_3 VAR_2 ) { return null ; } }
<|startcomment|> break line dot <|endcomment|> private List < Iterator < Entry < TYPE_1 > > > METHOD_1 ( boolean VAR_1 ) { return VAR_2 . stream ( ) . map ( VAR_3 - > { synchronized ( VAR_3 ) { return VAR_3 . iterator ( VAR_1 ) ; } <START> } ) . collect ( Collectors . VAR_4 ( ) ) ; <END> }
<|startcomment|> shouldn t return error code case <|endcomment|> private void METHOD_1 ( ) { VAR_1 . METHOD_2 ( ) ; try { boolean VAR_2 = VAR_1 . METHOD_3 ( VAR_3 + VAR_4 , TimeUnit . VAR_5 ) ; String VAR_6 = VAR_2 ? STRING_1 : STRING_2 ; TYPE_1 . METHOD_4 ( STRING_3 + VAR_6 , false ) ; if ( ! VAR_2 ) { <START> System . VAR_7 ( 0 ) ; <END> } } catch ( InterruptedException e ) { Thread . VAR_8 ( ) . METHOD_5 ( ) ; } finally { VAR_9 . METHOD_6 ( ) ; VAR_10 . METHOD_6 ( ) ; } }
<|startcomment|> I run ( key ) more faster TYPE_1 run ( String byte [ ] ) <|endcomment|> public Boolean METHOD_1 ( final String VAR_1 , final String key ) { return new TYPE_1 < Boolean > ( VAR_2 , VAR_3 , VAR_4 ) { @Override public Boolean execute ( TYPE_2 connection ) { return connection . VAR_5 ( VAR_1 ) ; } <START> } . run ( 1 , key ) ; <END> }
<|startcomment|> some sort map ? avoid potential bounds exceptions adds new subscription doesn t update declaration <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> VAR_2 = new TYPE_2 [ 2 ] ; <END> VAR_3 = ( TYPE_3 ) METHOD_2 ( ) . METHOD_3 ( STRING_1 ) ; VAR_4 = METHOD_2 ( ) . getString ( STRING_2 ) ; }
<|startcomment|> brackets put METHOD_4 line <|endcomment|> public void METHOD_1 ( ) { if ( TYPE_2 . VAR_2 ) Log . d ( TAG , STRING_1 ) ; VAR_3 . METHOD_2 ( ) . METHOD_3 ( TYPE_1 . VAR_5 ) ; <START> if ( VAR_6 != null ) { VAR_6 . METHOD_4 ( ) ; } <END> }
<|startcomment|> categories change VAR_2 unmodifiable start <|endcomment|> public Collection < String > METHOD_1 ( ) { <START> return Collections . VAR_1 ( VAR_2 ) ; <END> }
<|startcomment|> shouldn t METHOD_2 controller <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { VAR_1 = true ; List < TYPE_1 > VAR_2 = new TYPE_2 < > ( ) ; VAR_2 . addAll ( VAR_3 . METHOD_1 ( ) ) ; VAR_2 . addAll ( VAR_4 ) ; <START> VAR_5 . METHOD_2 ( ) ; <END> return VAR_2 ; }
<|startcomment|> style - : don t assign replace instead a proper - else : ( user VAR_4 ) { return VAR_3 METHOD_2 ( ) ; } else { return VAR_3 METHOD_1 ( ) ; } <|endcomment|> public TYPE_3 . TYPE_4 get ( ) { TYPE_2 user = VAR_1 . get ( ) ; <START> TYPE_3 . TYPE_4 VAR_2 = VAR_3 . METHOD_1 ( ) ; <END> if ( user . VAR_4 ( ) ) { VAR_2 = VAR_3 . METHOD_2 ( ) ; } return VAR_2 ; }
<|startcomment|> reason explicitly set default <|endcomment|> final TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) throws TYPE_3 { return TYPE_4 . builder ( ) . METHOD_2 ( VAR_1 ) <START> . METHOD_3 ( TYPE_4 . VAR_2 ) <END> . build ( ) ; }
<|startcomment|> suggestionreturn writer VAR_4 ( ) toString ( ) ; <|endcomment|> public static String METHOD_1 ( TYPE_1 VAR_1 ) throws IOException { TYPE_2 VAR_2 = METHOD_2 ( ) ; TYPE_3 writer = new TYPE_3 ( ) ; TYPE_4 VAR_3 = VAR_2 . METHOD_3 ( writer ) ; VAR_3 . METHOD_4 ( ) ; VAR_3 . METHOD_5 ( VAR_1 ) ; <START> String result = writer . VAR_4 ( ) . toString ( ) ; <END> return result ; }
<|startcomment|> please squash commit <|endcomment|> private String METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( STRING_1 , server . url ( STRING_2 ) . uri ( ) , null , null , ImmutableList . of ( new TYPE_2 ( STRING_3 , TYPE_5 . VAR_3 ) ) , ImmutableList . of ( ImmutableList . of ( INT_1 ) ) , TYPE_3 . builder ( ) . METHOD_2 ( STRING_4 ) . build ( ) , null , null , <START> null , <END> null ) ; return TYPE_4 . METHOD_3 ( VAR_1 ) ; }
<|startcomment|> program interface implementation - please change return type Map < String Object > <|endcomment|> <START> protected HashMap < String , Object > METHOD_1 ( String url , <END> String VAR_1 , String VAR_2 , boolean VAR_3 ) { return new HashMap < String , Object > ( ) { { put ( STRING_1 , url ) ; put ( VAR_4 , TYPE_2 . TYPE_3 . toString ( ) ) ; put ( STRING_2 , true ) ; put ( STRING_3 , VAR_1 ) ; put ( STRING_4 , VAR_2 ) ; put ( VAR_5 , VAR_3 ) ; } } ; }
<|startcomment|> m_ <|endcomment|> public void METHOD_1 ( List < TYPE_1 > VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> }
<|startcomment|> need clear cache user switching occurs <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 . METHOD_2 ( VAR_1 ) ; TYPE_3 . METHOD_3 ( VAR_1 ) ; <START> TYPE_4 . getInstance ( ) . METHOD_4 ( VAR_1 ) ; <END> }
<|startcomment|> I m missing constructor a Throwable <|endcomment|> protected static int METHOD_1 ( String string , int VAR_1 , String text ) { if ( string == null || string . length ( ) == 0 ) { return 0 ; } try { string = ( string + STRING_1 ) . substring ( 0 , INT_1 ) ; return Integer . parseInt ( string ) * VAR_1 ; } catch ( TYPE_1 | TYPE_2 e ) { <START> throw ( TYPE_3 ) new TYPE_3 ( <END> STRING_2 , text , 0 ) . METHOD_2 ( e ) ; } }
<|startcomment|> please curly braces statements <|endcomment|> public TYPE_1 [ ] METHOD_1 ( ) { TYPE_1 [ ] result = new TYPE_1 [ VAR_1 + ( VAR_2 == null ? 1 : 2 ) ] ; int VAR_3 = 0 ; <START> for ( TYPE_2 VAR_4 : METHOD_2 ( ) ) <END> if ( VAR_4 instanceof TYPE_1 ) result [ VAR_3 ++ ] = ( TYPE_1 ) VAR_4 ; else throw new TYPE_3 ( STRING_1 + STRING_2 + STRING_3 ) ; if ( VAR_2 != null ) result [ VAR_1 + 1 ] = VAR_2 ; return result ; }
<|startcomment|> catches ? I d return a message instead ; <|endcomment|> private String METHOD_1 ( Object VAR_1 , TYPE_1 e ) { String VAR_2 = VAR_3 . METHOD_2 ( e . VAR_4 ( ) ) ; if ( VAR_1 instanceof TYPE_2 ) { return TYPE_3 . getInstance ( ) . METHOD_3 ( ) . METHOD_4 ( VAR_2 ) ; } else if ( VAR_1 instanceof TYPE_4 ) { return TYPE_3 . getInstance ( ) . METHOD_3 ( ) . METHOD_5 ( VAR_2 ) ; } <START> throw new IllegalArgumentException ( STRING_1 + VAR_1 . getClass ( ) . getName ( ) ) ; <END> }
<|startcomment|> [ ] ( start = 8 length = 4 ) please <|endcomment|> public final void METHOD_1 ( final Date VAR_1 ) { <START> this . VAR_2 = VAR_1 ; <END> }
<|startcomment|> I put failure path : ( ! d VAR_3 ( ) ) { ( VAR_1 && d VAR_2 ( ) ) return ; throw new IOException ( ) ; } odds caller wants a new directory assume doesn t exist ll fail VAR_3 check mode a directory fine fail <|endcomment|> public static void METHOD_1 ( final File d , boolean VAR_1 ) throws IOException { <START> if ( VAR_1 && d . exists ( ) && d . VAR_2 ( ) ) <END> return ; if ( ! d . VAR_3 ( ) ) throw new IOException ( TYPE_1 . format ( TYPE_2 . get ( ) . VAR_4 , d . VAR_5 ( ) ) ) ; }
<|startcomment|> IMHO a - argument C tor <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( new TYPE_1 ( new <START> TYPE_2 ( null , null ) ) ) ; <END> }
<|startcomment|> remove statement set user entity METHOD_2 function choose template <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> if ( this . METHOD_2 ( ) ) <END> { set ( VAR_2 , VAR_1 ) ; } }
<|startcomment|> prefer put else return codebase <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 node , TYPE_3 context ) { METHOD_2 ( node . VAR_1 ( ) == VAR_2 , STRING_1 ) ; if ( node . VAR_3 ( ) . isPresent ( ) ) { return METHOD_3 ( node , context ) ; } else { return METHOD_4 ( node , context ) ; <START> } <END> }
<|startcomment|> typed TYPE_2 < ? extends TYPE_3 ? extends TYPE_4 > cast wouldn t needed line <|endcomment|> public void METHOD_1 ( TYPE_1 < TYPE_2 < ? extends TYPE_3 , ? extends TYPE_4 > > VAR_1 ) throws TYPE_5 { <START> for ( Object VAR_2 : VAR_1 ) { <END> TYPE_2 event = ( TYPE_2 ) VAR_2 ; Assert . assertEquals ( TYPE_6 . VAR_4 , event . VAR_5 ( ) ) ; this . VAR_6 . METHOD_2 ( ) ; event . getKey ( ) ; event . getValue ( ) ; event . VAR_7 ( ) ; } }
<|startcomment|> line redundant VAR_1 <|endcomment|> private static TYPE_1 METHOD_1 ( Context context , long VAR_1 ) { TYPE_2 VAR_2 = new TYPE_2 ( VAR_3 ) ; VAR_2 . METHOD_2 ( VAR_4 , VAR_1 ) ; <START> long VAR_5 = VAR_1 ; <END> return TYPE_1 . METHOD_3 ( context , ( int ) VAR_5 , VAR_2 , TYPE_1 . VAR_6 ) ; }
<|startcomment|> sense declare throws RuntimeException <|endcomment|> <START> public boolean METHOD_1 ( ) throws RuntimeException <END> { File [ ] VAR_1 = VAR_2 . METHOD_2 ( TYPE_1 . VAR_4 ) ; if ( VAR_1 == null ) { throw new RuntimeException ( STRING_1 ) ; } return VAR_1 . length > 0 ; }
<|startcomment|> ? ? ? work ? super IDEA shows recursion <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_1 ( VAR_1 ) ; <END> }
<|startcomment|> I remember parser some funky stuff internally token _CODE_ classes I persuaded sense route please clear developers call constructor parser kernel <|endcomment|> <START> public TYPE_2 ( TYPE_1 VAR_2 , String value ) { <END> super ( VAR_2 , null ) ; this . value = value ; }
<|startcomment|> a duplicated check invoked command VAR_2 ( ) true required invoke absolutely want check I d opt forjavaif ( VAR_2 ! = null ) { } easier read <|endcomment|> private void METHOD_1 ( final TYPE_1 VAR_1 , final Boolean VAR_2 ) { <START> if ( VAR_2 == null ) { <END> return ; } VAR_1 . add ( TYPE_2 . METHOD_2 ( STRING_1 , VAR_2 ) ) ; }
<|startcomment|> good return empty list instead avoids _CODE_ <|endcomment|> public List < String > METHOD_1 ( final String VAR_1 ) throws TYPE_1 { List < TYPE_2 > VAR_2 = VAR_3 . METHOD_1 ( VAR_1 ) ; if ( null != VAR_2 && ! VAR_2 . isEmpty ( ) ) { List < String > VAR_4 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_5 : VAR_2 ) { VAR_4 . add ( VAR_5 . METHOD_2 ( ) ) ; } return VAR_4 ; <START> } else { <END> return null ; } }
<|startcomment|> test needed event bundle filtered VAR_1 defined trigger listener descriptor <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { for ( TYPE_2 event : VAR_1 ) { <START> if ( TYPE_3 . equals ( event . getName ( ) ) ) { <END> TYPE_4 context = ( TYPE_4 ) event . VAR_2 ( ) ; TYPE_5 VAR_3 = context . VAR_4 ( ) ; if ( TYPE_6 . equals ( VAR_3 . getType ( ) ) ) { METHOD_2 ( context . VAR_5 ( ) , VAR_3 . getId ( ) ) ; } } } }
<|startcomment|> assuming a _CODE_ ordering based _CODE_ VAR_1 <|endcomment|> public Set < TYPE_1 > METHOD_1 ( ) { if ( VAR_1 == null ) { <START> VAR_1 = new TYPE_2 < TYPE_1 > ( ) ; <END> } return VAR_1 ; }
<|startcomment|> call put extracted - else statement order remove duplication <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( ) ; TYPE_3 value = VAR_3 . getValue ( VAR_2 ) ; if ( value == null ) { value = VAR_4 . METHOD_3 ( VAR_1 ) ; VAR_3 = VAR_3 . METHOD_4 ( value ) ; METHOD_5 ( VAR_1 , value ) ; VAR_3 = VAR_3 . put ( VAR_2 , value ) ; } else { VAR_3 = VAR_3 . METHOD_4 ( value ) ; <START> VAR_3 = VAR_3 . put ( VAR_2 , value ) ; <END> } }
<|startcomment|> needed change <|endcomment|> <START> public TYPE_4 ( String <END> VAR_2 , TYPE_1 VAR_3 , TYPE_2 VAR_4 , TYPE_3 VAR_5 ) { this . VAR_2 = VAR_2 ; this . VAR_3 = VAR_3 ; this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_3 . METHOD_1 ( ) ? VAR_3 . METHOD_2 ( ) : null ; this . VAR_7 = VAR_3 . METHOD_3 ( ) ? VAR_3 . METHOD_4 ( ) : null ; }
<|startcomment|> please : return ! VAR_2 isEmpty ( ) ; <|endcomment|> public boolean METHOD_1 ( Guid VAR_1 ) { List < TYPE_1 > VAR_2 = VAR_3 . METHOD_2 ( VAR_1 ) ; <START> return VAR_2 . size ( ) > 0 ; <END> }
<|startcomment|> extra space <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <START> <END> try ( TYPE_3 VAR_2 = new TYPE_3 ( VAR_3 . METHOD_2 ( ) ) ) { if ( VAR_4 . containsKey ( VAR_1 ) ) { TYPE_4 VAR_5 = VAR_4 . get ( VAR_1 ) ; return VAR_4 . get ( VAR_1 ) . METHOD_3 ( ) ; } else { throw new TYPE_2 ( String . format ( STRING_1 , VAR_1 . toString ( ) ) ) ; } } }
<|startcomment|> I d return false logic doesn t prevent parse input null empty fixed merge : smiley : <|endcomment|> public static boolean METHOD_1 ( final String version ) { boolean result = true ; if ( version == null || version . trim ( ) . length ( ) < 1 ) { <START> result = false ; <END> } try { TYPE_1 VAR_1 = new TYPE_2 ( version ) . METHOD_2 ( ) ; } catch ( final TYPE_3 e ) { result = false ; } catch ( final TYPE_4 e ) { result = false ; } return result ; }
<|startcomment|> break statement missing <|endcomment|> public void METHOD_1 ( TYPE_1 connection , int VAR_1 , TYPE_2 VAR_2 , TYPE_2 VAR_3 , TYPE_3 VAR_4 ) throws TYPE_4 { switch ( VAR_1 ) { case TYPE_5 . VAR_6 : { METHOD_2 ( VAR_2 , VAR_3 , VAR_4 ) ; } <START> case TYPE_5 . VAR_7 : { <END> METHOD_3 ( VAR_2 , VAR_3 , VAR_4 ) ; } default : throw new TYPE_4 ( STRING_1 ) ; } }
<|startcomment|> Collections addAll saves wrapper object don t need full - picky allocations a library <|endcomment|> public Builder METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> this . VAR_1 . addAll ( Arrays . asList ( VAR_1 ) ) ; <END> return this ; }
<|startcomment|> named resource <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING_1 , 100 ) ; params . put ( STRING_2 , STRING_3 ) ; params . put ( STRING_4 , STRING_5 ) ; <START> TYPE_2 VAR_1 = TYPE_2 . create ( params ) ; <END> assertNotNull ( VAR_1 ) ; METHOD_2 ( TYPE_3 . TYPE_4 . VAR_4 , STRING_6 , params ) ; }
<|startcomment|> static <|endcomment|> <START> private boolean METHOD_1 ( TYPE_1 result ) { <END> TYPE_2 m = result . VAR_1 ( ) ; return m . VAR_2 ( ) || m . VAR_3 ( ) ; }
<|startcomment|> need create a variable TYPE_2 getInstance ( ) isvalid ( ) <|endcomment|> private static void METHOD_1 ( String value ) throws TYPE_1 { <START> final TYPE_2 VAR_1 = TYPE_2 . getInstance ( ) ; <END> if ( ! VAR_1 . METHOD_2 ( value ) ) { throw new TYPE_1 ( TYPE_3 . VAR_3 , STRING_1 ) ; } }
<|startcomment|> change tojavathis VAR_2 METHOD_3 ( VAR_2 size ( ) + length ) ; <|endcomment|> private void addAll ( Object VAR_1 ) throws TYPE_1 { if ( VAR_1 . getClass ( ) . METHOD_1 ( ) ) { int length = TYPE_2 . METHOD_2 ( VAR_1 ) ; <START> this . VAR_2 . METHOD_3 ( length ) ; <END> for ( int i = 0 ; i < length ; i += 1 ) { this . put ( TYPE_3 . METHOD_4 ( TYPE_2 . get ( VAR_1 , i ) ) ) ; } } else { throw new TYPE_1 ( STRING_1 ) ; } }
<|startcomment|> I don t public ( _CODE_ version public legacy reasons ) <|endcomment|> <START> public static <END> synchronized TYPE_1 METHOD_1 ( Context context ) { if ( VAR_1 == null ) { VAR_1 = new TYPE_2 ( context ) ; } return VAR_1 ; }
<|startcomment|> VAR_1 negative <|endcomment|> protected void METHOD_1 ( int VAR_1 , int VAR_2 ) { try { if ( VAR_3 . METHOD_2 ( ) ) { <START> double VAR_4 = VAR_1 + VAR_2 ; <END> if ( VAR_4 > 0 ) { double d = VAR_1 / VAR_4 ; METHOD_3 ( ) . METHOD_4 ( d ) ; METHOD_3 ( ) . METHOD_5 ( d ) ; } } } finally { VAR_3 . METHOD_6 ( ) ; } }
<|startcomment|> a confusion goal client code write implementation _CODE_ METHOD_5 simply empty I <|endcomment|> public void METHOD_1 ( TYPE_1 element ) { <START> if ( element instanceof TYPE_2 && element != METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) ) { <END> ( ( TYPE_2 ) element ) . METHOD_5 ( STRING_1 ) ; } }
<|startcomment|> shouldn t bereturn METHOD_2 ( new * _CODE_ * ( ) ) evenreturn METHOD_2 ( _CODE_ getInstance ( ) ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return METHOD_2 ( new TYPE_2 ( ) ) ; <END> }
<|startcomment|> ANNOTATION_1 return declared throw TYPE_2 <|endcomment|> <START> public < T > TYPE_1 < T > METHOD_1 ( Class < T > type , ANNOTATION_1 Class < ? > VAR_1 , ANNOTATION_2 String VAR_2 ) throws TYPE_2 { <END> TYPE_1 m = VAR_3 . get ( type ) ; if ( m == null && type . VAR_4 ( TYPE_3 . class ) != null ) { m = new TYPE_1 < T > ( this , type , VAR_1 , VAR_2 ) ; } return m ; }
<|startcomment|> great tests for1 multiple methods1 multiple methods1 methods parameters1 methods parameters1 parameterized tests more parameter <|endcomment|> <START> public void METHOD_1 ( ) { <END> VAR_1 = "" ; final TYPE_1 result = TYPE_2 . METHOD_2 ( TYPE_3 . class ) ; assertEquals ( 0 , result . VAR_2 ( ) ) ; assertEquals ( STRING_1 + STRING_2 , VAR_1 ) ; }
<|startcomment|> shell disposed teardown <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 VAR_1 = new TYPE_1 ( new TYPE_2 ( ) , SWT . NONE ) ; <END> event = new TYPE_3 ( VAR_1 , true ) ; VAR_2 = new TYPE_4 ( ) ; }
<|startcomment|> user STRING_5 ? behaviour ? / add else block assertion <|endcomment|> public void METHOD_1 ( ) { String user = System . getProperty ( STRING_1 ) ; String VAR_1 = TYPE_1 . METHOD_2 ( STRING_2 ) ; assertTrue ( VAR_1 . startsWith ( STRING_3 ) ) ; String VAR_2 = TYPE_1 . METHOD_2 ( STRING_4 ) ; <START> if ( ! STRING_5 . equals ( user ) ) <END> assertTrue ( VAR_2 . startsWith ( STRING_6 + user ) ) ; }
<|startcomment|> protected allow easy subclassing <|endcomment|> <START> private void METHOD_1 ( TYPE_1 VAR_1 ) throws TYPE_2 { <END> String VAR_2 = VAR_3 . METHOD_2 ( VAR_4 ) ; String VAR_5 = VAR_3 . METHOD_3 ( VAR_4 ) . METHOD_4 ( ) ; TYPE_3 VAR_6 = VAR_1 . getProperty ( String . format ( STRING_1 , VAR_2 , VAR_5 ) ) ; if ( VAR_6 . METHOD_5 ( ) ) { String VAR_7 = VAR_6 . getValue ( String . VAR_8 ) ; if ( StringUtils . VAR_9 ( VAR_7 ) && ! METHOD_6 ( VAR_7 ) ) { throw new TYPE_2 ( ) ; } } }
<|startcomment|> harm setting _CODE_ null setting need set null <|endcomment|> protected void METHOD_1 ( ) { METHOD_2 ( null ) ; <START> METHOD_3 ( null ) ; <END> }
<|startcomment|> done super <|endcomment|> public TYPE_2 ( T parameters , TYPE_1 VAR_2 ) { super ( parameters , VAR_2 ) ; <START> METHOD_1 ( parameters . VAR_3 ( ) ) ; <END> }
<|startcomment|> VAR_1 METHOD_1 ( ) I guess need convert utf8 String stream skip ( ) <|endcomment|> public String METHOD_1 ( ) throws IOException { <START> return VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> public <|endcomment|> <START> public TYPE_1 ( int size , float VAR_2 ) <END> { this . size = size ; this . VAR_2 = VAR_2 ; }
<|startcomment|> VAR_4 descriptive please _CODE_ ( number configurations executed test ? ) <|endcomment|> <START> public TYPE_1 ( String VAR_2 , String VAR_3 , int VAR_4 , boolean VAR_5 ) { <END> super ( VAR_2 , String . format ( STRING_1 , VAR_3 ) , STRING_2 + VAR_3 ) ; this . VAR_6 = VAR_4 ; this . VAR_3 = VAR_3 ; this . VAR_5 = VAR_5 ; }
<|startcomment|> follow agreed : a fixed static part ( _CODE_ ) - a randomly generated digit number beside Object expression property count meaning ; need account wrong code <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_2 . VAR_3 ) ) { return ; } final String VAR_4 = VAR_1 . METHOD_4 ( ) + TYPE_2 . VAR_5 ; long count = VAR_1 . METHOD_2 ( ) . keySet ( ) . stream ( ) . filter ( key - > key . startsWith ( VAR_4 ) ) . count ( ) ; <START> VAR_1 . METHOD_5 ( count > 0 ? VAR_4 + STRING_1 + count : VAR_4 , TYPE_2 . VAR_3 ) ; <END> }
<|startcomment|> _CODE_ ? _CODE_ command <|endcomment|> public TYPE_1 ( T parameters ) { super ( parameters ) ; METHOD_1 ( parameters . VAR_2 ( ) ) ; <START> METHOD_2 ( parameters . VAR_3 ( ) ) ; <END> }
<|startcomment|> else redundant consider dropping <|endcomment|> public String METHOD_1 ( TYPE_1 VAR_1 ) { logger . trace ( STRING_1 ) ; logger . trace ( STRING_2 ) ; TYPE_2 . Response response = VAR_1 . METHOD_2 ( new TYPE_2 ( ) ) ; if ( ( response == null ) || ( ! response . VAR_2 ( ) ) ) { logger . trace ( STRING_3 ) ; return null ; <START> } else { <END> logger . trace ( STRING_4 , response . VAR_3 ( ) ) ; return response . VAR_3 ( ) ; } }
<|startcomment|> function bereturn math max ( VAR_1 / VAR_3 1 ) ; <|endcomment|> private static int METHOD_1 ( int VAR_1 ) { int VAR_2 = VAR_1 / VAR_3 ; if ( VAR_2 == 0 ) { VAR_2 = 1 ; } <START> return VAR_2 ; <END> }
<|startcomment|> primitive long avoid unnecessary wrapping <|endcomment|> <START> public synchronized Long size ( ) <END> { final File file = path . VAR_1 ( ) ; Long size = ( file . exists ( ) && ! file . VAR_2 ( ) ) ? file . length ( ) : INT_1 ; if ( VAR_3 < INT_1 || VAR_4 > VAR_5 ) { Long VAR_3 = INT_1 ; VAR_5 = VAR_4 ; for ( TYPE_1 child : VAR_6 ) { VAR_3 += child . size ( ) ; } this . VAR_3 = VAR_3 ; } size += VAR_3 ; return size ; }
<|startcomment|> please exceptions constructor <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , boolean vm ) { <START> if ( VAR_2 == null ) { <END> throw new IllegalArgumentException ( STRING_1 ) ; } this . VAR_2 = VAR_2 ; VAR_3 = vm ; }
<|startcomment|> simpler : ( VAR_1 VAR_2 & context ) ! = 0 <|endcomment|> private static boolean METHOD_1 ( Pair < TYPE_1 , Integer > VAR_1 , int context ) { <START> return ( VAR_1 . VAR_2 & context ) == context ; <END> }
<|startcomment|> hard gerrit ( I pull change eclipse ) checks done protected _CODE_ method method called places checks done <|endcomment|> <START> private void METHOD_1 ( TYPE_1 VAR_1 ) { <END> if ( VAR_1 == null ) { return ; } if ( ! VAR_2 . contains ( VAR_1 ) ) { return ; } VAR_2 . remove ( VAR_1 ) ; if ( page != null ) { page . VAR_3 ( this , VAR_1 , TYPE_2 . VAR_5 ) ; } }
<|startcomment|> I invalid order groups implemented test creates relation : _CODE_ calling METHOD_4 ( sess VAR_6 VAR_4 false ) import members VAR_4 VAR_6 a cycle I detect current implementation test passes error I pointed _CODE_ METHOD_4 ( sess VAR_4 VAR_6 false ) ; <|endcomment|> public void METHOD_1 ( ) throws Exception { System . out . println ( VAR_1 + STRING_1 ) ; TYPE_1 VAR_2 = METHOD_2 ( ) ; VAR_3 . METHOD_3 ( sess , VAR_2 , VAR_4 ) ; VAR_3 . METHOD_3 ( sess , VAR_4 , VAR_5 ) ; VAR_3 . METHOD_3 ( sess , VAR_5 , VAR_6 ) ; <START> VAR_3 . METHOD_4 ( sess , VAR_6 , VAR_4 , false ) ; <END> }
<|startcomment|> final missing <|endcomment|> private TYPE_1 METHOD_1 ( ) { final TYPE_1 listener = new TYPE_1 ( ) { @Override public void <START> METHOD_2 ( TYPE_2 e ) { <END> METHOD_3 ( ) ; } @Override public void METHOD_4 ( TYPE_2 e ) { } } ; return listener ; }
<|startcomment|> I flip condition special case protocol : javaif ( VAR_7 startsWith ( STRING_1 ) ) { VAR_7 = VAR_3 } <|endcomment|> public void METHOD_1 ( String VAR_1 , String VAR_2 , String VAR_3 ) { String VAR_4 = VAR_5 . METHOD_2 ( VAR_1 ) ; String VAR_6 = VAR_4 + VAR_2 ; String VAR_7 = VAR_3 ; <START> if ( ! VAR_7 . startsWith ( STRING_1 ) ) { <END> VAR_7 = VAR_4 + VAR_7 ; } VAR_8 . get ( VAR_6 ) ; String VAR_9 = VAR_8 . METHOD_3 ( ) ; TYPE_1 . assertEquals ( VAR_9 , VAR_7 ) ; }
<|startcomment|> exception possibly thrown close ( false ) call <|endcomment|> public void METHOD_1 ( ) { try { close ( false ) ; } catch ( final RuntimeException e ) { <START> log . warn ( String . format ( STRING_1 , id ) , e ) ; <END> } log . info ( STRING_2 ) ; }
<|startcomment|> TYPE_2 ( import ) <|endcomment|> public boolean METHOD_1 ( int VAR_1 , float VAR_2 ) { <START> TYPE_3 . TYPE_4 . client . TYPE_2 VAR_3 = this . client . VAR_4 . VAR_5 . METHOD_2 ( ) ; <END> if ( VAR_3 != null ) { VAR_3 . METHOD_3 ( VAR_2 , this . client . VAR_4 , this . client ) ; return true ; } return VAR_6 . METHOD_3 ( VAR_1 , VAR_2 ) ; }
<|startcomment|> don t need statement <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 ctx ) { TYPE_3 a = ( TYPE_3 ) this . type ; <START> if ( <END> METHOD_2 ( ) && a . VAR_1 ( ) instanceof TYPE_4 && ( ( TYPE_4 ) a . VAR_1 ( ) ) . getName ( ) . equals ( this . VAR_2 ) ) { return new TYPE_5 ( new TYPE_6 ( VAR_3 ) , VAR_4 ) ; } return ( ( TYPE_3 ) type ) . METHOD_3 ( ) . METHOD_4 ( ctx ) ; }
<|startcomment|> a hack shouldn t boolean driver seat driver seat ? doesn t change based presence a actual driver entity I a deeper assumption boolean correctly set reloading entity a save file <|endcomment|> public TYPE_1 METHOD_1 ( ) { List < TYPE_1 > VAR_1 = METHOD_2 ( ) ; if ( VAR_1 . isEmpty ( ) ) { METHOD_3 ( false ) ; return null ; } else { <START> METHOD_3 ( true ) ; <END> return VAR_1 . get ( 0 ) ; } }
<|startcomment|> I don t need new flag immediately return null _CODE_ ( ) child closed test child _CODE_ ( ) child eos ( ) agree <|endcomment|> public TYPE_4 ( ANNOTATION_1 final Long VAR_2 , final TYPE_1 child ) { super ( child ) ; this . VAR_2 = TYPE_2 . METHOD_1 ( VAR_2 , STRING_1 ) ; TYPE_3 . METHOD_2 ( VAR_2 >= INT_1 , STRING_2 ) ; VAR_3 = this . VAR_2 ; <START> VAR_4 = false ; <END> }
<|startcomment|> ( check column qualifier visibility ) key equals ( VAR_1 _CODE_ ROW_COLFAM_COLQUAL_COLVIS ) checks row column fields <|endcomment|> public void add ( TYPE_1 VAR_1 , TYPE_2 v ) { if ( key == null ) { key = VAR_1 ; VAR_2 . add ( VAR_1 . METHOD_1 ( ) ) ; values . add ( v ) ; size ++ ; } else if ( key . VAR_3 ( VAR_1 . METHOD_2 ( ) ) == 0 <START> && key . VAR_4 ( VAR_1 . METHOD_3 ( ) ) == 0 ) { <END> VAR_2 . add ( VAR_1 . METHOD_1 ( ) ) ; values . add ( v ) ; } else { } }
<|startcomment|> version check call METHOD_2 ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_1 = METHOD_2 ( ) ; <START> String version = METHOD_3 ( ) ; <END> if ( version == null || ! version . equals ( TYPE_3 . VAR_3 ) ) { VAR_4 . VAR_5 . VAR_6 . METHOD_4 ( TYPE_2 . VAR_8 , version , TYPE_3 . VAR_3 , VAR_9 ) ; } } return VAR_1 ; }
<|startcomment|> line triggers a java lang _CODE_ code : $a = 012_345 ; <|endcomment|> private boolean METHOD_1 ( String value ) { <START> return value . length ( ) == 4 || Integer . parseInt ( value ) < INT_1 ; <END> }
<|startcomment|> I ve noticed location = = null NPE exceptions thrown check null <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> TYPE_2 VAR_1 = ( TYPE_2 ) METHOD_2 ( ) . get ( STRING_1 ) ; <END> return new TYPE_1 ( VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ; }
<|startcomment|> parent null caller / log indication a problem desired <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; try { TYPE_2 VAR_2 = METHOD_2 ( ) ; if ( VAR_2 != null ) { TYPE_3 VAR_3 = new TYPE_3 ( VAR_2 ) ; VAR_3 . METHOD_3 ( ) ; VAR_1 . add ( VAR_2 ) ; <START> } <END> } catch ( Exception ex ) { TYPE_4 . log ( TYPE_5 . class , TYPE_6 . VAR_5 , STRING_1 , ex ) ; } }
<|startcomment|> usar generics tipo de retorno <|endcomment|> <START> public List METHOD_1 ( ) <END> { return VAR_1 ; }
<|startcomment|> nitjavafor ( long filter : VAR_1 ) { VAR_2 | = filter ; } <|endcomment|> private static long METHOD_1 ( long [ ] VAR_1 ) { if ( VAR_1 == null ) { return 0 ; } int VAR_2 = 0 ; <START> for ( int i = 0 ; i < VAR_1 . length ; i ++ ) { <END> VAR_2 |= VAR_1 [ i ] ; } return VAR_2 ; }
<|startcomment|> extra whitespace forming neat columns code arguably HARDER read inarguably harder write maintain - - turning future single - line changes multi - line whitespace changes PLEASE DESIST <|endcomment|> private boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , <START> TYPE_3 VAR_3 ) { <END> if ( VAR_1 instanceof TYPE_4 ) { TYPE_4 VAR_4 = ( TYPE_4 ) VAR_1 ; if ( VAR_4 . METHOD_2 ( ) . equals ( VAR_3 . METHOD_2 ( ) ) && VAR_4 . METHOD_3 ( ) . equals ( VAR_2 . METHOD_4 ( ) . METHOD_5 ( ) ) ) { return true ; } } return false ; }
<|startcomment|> localized ? don t localize log message a translated IOException log hard understand submit bug <|endcomment|> public static void log ( Throwable e ) { <START> log ( new Status ( TYPE_1 . VAR_2 , VAR_3 , TYPE_1 . VAR_4 , e . VAR_5 ( ) , e ) ) ; <END> }
<|startcomment|> Boolean TRUE equals ( obj ) want s explicit I don t mind : - ) <|endcomment|> private boolean METHOD_1 ( TYPE_1 channel ) { <START> boolean VAR_1 = TYPE_2 . METHOD_2 ( channel . VAR_2 ( ) , false ) ; <END> boolean VAR_3 = TYPE_2 . METHOD_2 ( channel . VAR_4 ( ) , false ) ; return ! ( VAR_1 || VAR_3 ) ; }
<|startcomment|> lose typing TYPE_1 define method a generic _CODE_ <|endcomment|> default TYPE_1 VAR_2 ( ) { <START> throw new TYPE_2 ( ) ; <END> }
<|startcomment|> original query cacheable I param false <|endcomment|> public TYPE_1 METHOD_1 ( Context context , String token ) throws TYPE_2 { TYPE_3 VAR_1 = METHOD_2 ( context ) ; TYPE_4 VAR_2 = METHOD_3 ( VAR_1 , TYPE_1 . class ) ; TYPE_5 < TYPE_1 > VAR_3 = VAR_2 . from ( TYPE_1 . class ) ; VAR_2 . METHOD_4 ( VAR_3 ) ; VAR_2 . METHOD_5 ( VAR_1 . METHOD_6 ( VAR_3 . get ( TYPE_6 . token ) , token ) ) ; <START> return METHOD_7 ( context , VAR_2 , true , TYPE_1 . class , - 1 , - 1 ) ; <END> }
<|startcomment|> saving preferences a setter please follow pattern other preferences <|endcomment|> public static void METHOD_1 ( TYPE_1 project , boolean VAR_1 ) { if ( VAR_1 != METHOD_2 ( project ) ) { METHOD_3 ( project ) . METHOD_4 ( VAR_2 , VAR_1 ) ; <START> TYPE_2 . METHOD_5 ( project , true ) ; <END> } }
<|startcomment|> elena VAR_4 a _CODE_ suggestion : invert meaning Boolean : true problem false problem <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 element ) { T VAR_2 = METHOD_2 ( element ) ; if ( VAR_2 != null ) { boolean VAR_3 = METHOD_3 ( VAR_2 , VAR_1 ) ; if ( ! VAR_3 ) { VAR_4 . put ( VAR_2 , true ) ; <START> } else if ( ! VAR_4 . containsKey ( VAR_2 ) ) { <END> VAR_4 . put ( VAR_2 , false ) ; } } }
<|startcomment|> extra <|endcomment|> public String toString ( ) { return METHOD_1 ( this ) . METHOD_2 ( ) <START> . add ( STRING_1 , this . VAR_1 ) <END> . add ( STRING_2 , VAR_2 ) . add ( STRING_3 , VAR_3 ) . toString ( ) ; }
<|startcomment|> checks unrelated actual check want perform <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 msg = METHOD_2 ( METHOD_3 ( STRING_1 + STRING_2 + STRING_3 + STRING_4 + STRING_5 + STRING_6 + STRING_7 + STRING_8 ) ) ; METHOD_4 ( msg . VAR_1 ( ) , STRING_9 ) ; <START> METHOD_4 ( msg . VAR_2 ( TYPE_3 . VAR_4 ) , STRING_10 ) ; <END> METHOD_5 ( TYPE_2 . METHOD_6 ( msg . VAR_5 ( ) ) ) ; }
<|startcomment|> I d protected <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> return new TYPE_1 ( VAR_1 , config . VAR_2 ( ) + STRING_1 ) ; }
<|startcomment|> method private <|endcomment|> <START> private void METHOD_1 ( TYPE_1 result ) { <END> assertNotNull ( result ) ; assertTrue ( result . VAR_1 ( ) ) ; }
<|startcomment|> define a constant 1 <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_2 stream , TYPE_3 VAR_1 ) throws IOException { TYPE_4 VAR_2 = stream . VAR_3 ( ) ; if ( ! VAR_2 . equals ( VAR_4 ) ) { throw new IllegalStateException ( STRING_1 + VAR_4 ) ; } TYPE_5 VAR_5 = TYPE_5 . values ( ) [ stream . VAR_3 ( ) ] ; <START> boolean VAR_6 = stream . VAR_7 ( ) == 1 ; <END> return new TYPE_1 ( VAR_5 , VAR_6 , VAR_1 ) ; }
<|startcomment|> expecting workflow jobs ? I work <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { if ( ! METHOD_2 ( VAR_1 ) ) return ; for ( TYPE_3 config : VAR_3 ) { <START> List < TYPE_1 > VAR_4 = TYPE_4 . filter ( config . VAR_5 ( VAR_1 . METHOD_3 ( ) , null ) , TYPE_1 . class ) ; <END> for ( TYPE_1 project : VAR_4 ) TYPE_5 . add ( VAR_1 , project , config , VAR_2 ) ; } }
<|startcomment|> method returns option < TYPE_2 > API null check METHOD_2 ( ) some ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 = null ; TYPE_2 VAR_2 = <START> METHOD_2 ( ) . get ( ) ; <END> TYPE_3 VAR_3 = new TYPE_4 ( VAR_2 ) . METHOD_3 ( ) ; TYPE_5 VAR_4 = TYPE_6 . METHOD_4 ( VAR_3 , false ) ; if ( VAR_4 instanceof TYPE_1 ) { VAR_1 = ( TYPE_1 ) VAR_4 ; } return VAR_1 ; }
<|startcomment|> unnecessary ; call ( ) <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 ) { this ( VAR_2 . METHOD_1 ( ) ) ; <START> VAR_3 = new HashSet < > ( ) ; <END> }
<|startcomment|> clear map EMF observable holds _CODE_ disposal prevent GC collect model observable retained similar reasons please set match null <|endcomment|> public synchronized void METHOD_1 ( ) { for ( Entry < String , TYPE_1 > entry : VAR_1 . entrySet ( ) ) { entry . getValue ( ) . METHOD_1 ( ) ; } <START> super . METHOD_1 ( ) ; <END> }
<|startcomment|> discussed main issue check entire method moved METHOD_3 method <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { final TYPE_1 VAR_2 = VAR_1 . METHOD_2 ( ) . METHOD_2 ( ) ; if ( VAR_2 . getType ( ) == TYPE_3 . VAR_4 && METHOD_3 ( VAR_2 ) && METHOD_4 ( VAR_2 ) <START> && ! TYPE_2 . METHOD_5 ( VAR_2 , STRING_1 ) ) { <END> METHOD_6 ( VAR_1 ) ; } }
<|startcomment|> implementation return false <|endcomment|> public static boolean METHOD_1 ( int [ ] version ) { <START> int VAR_1 = METHOD_2 ( version , VAR_2 ) ; <END> if ( VAR_1 < 0 ) return true ; else if ( VAR_1 == 0 ) return false ; if ( METHOD_2 ( version , VAR_3 ) <= 0 ) return true ; return false ; }
<|startcomment|> removing NPE check <|endcomment|> protected void METHOD_1 ( ) { this . VAR_1 = new TYPE_1 ( METHOD_2 ( ) , this ) ; <START> METHOD_3 ( ) . METHOD_4 ( this . VAR_1 ) ; <END> }
<|startcomment|> s multi - catch <|endcomment|> public static TYPE_1 < TYPE_2 > METHOD_1 ( final TYPE_3 VAR_1 ) { return new TYPE_1 < TYPE_2 > ( ) { @Override public TYPE_2 apply ( TYPE_4 VAR_2 ) { try { TYPE_5 element = METHOD_2 ( VAR_1 , VAR_2 ) ; return element . VAR_3 ( ) ? METHOD_3 ( VAR_1 , element , VAR_2 ) : null ; <START> } catch ( TYPE_6 e ) { <END> return null ; } catch ( TYPE_7 e ) { return null ; } } @Override public String toString ( ) { return STRING_1 + VAR_1 ; } } ; }
<|startcomment|> fault PR feels weird environment * * * * zk connection string <|endcomment|> public TYPE_1 < ? > METHOD_1 ( TYPE_2 context ) { TYPE_3 VAR_1 = new TYPE_3 ( true ) ; VAR_1 . METHOD_2 ( context . VAR_2 ( ) ) ; <START> if ( VAR_3 != null ) { <END> VAR_1 . METHOD_3 ( VAR_3 . METHOD_4 ( ) . METHOD_5 ( ) . METHOD_6 ( ) ) ; } return new TYPE_4 ( context , VAR_1 ) ; }
<|startcomment|> array length ( based VAR_1 size ) <|endcomment|> public String [ ] METHOD_1 ( ) { <START> return this . VAR_1 . METHOD_2 ( new String [ ] { } ) ; <END> }
<|startcomment|> minor return VAR_2 parse ( VAR_1 ) METHOD_2 ( ) <|endcomment|> public static Long METHOD_1 ( String VAR_1 ) { try { TYPE_1 VAR_2 = new TYPE_1 ( VAR_3 , TYPE_3 . VAR_5 ) ; Date VAR_6 = VAR_2 . parse ( VAR_1 ) ; <START> return VAR_6 . METHOD_2 ( ) ; <END> } catch ( TYPE_2 e ) { logger . warn ( STRING_1 + VAR_1 + STRING_2 ) ; return null ; } }
<|startcomment|> please remove public modifier <|endcomment|> <START> public TYPE_2 ( TYPE_1 context ) { <END> this . context = context ; }
<|startcomment|> consistency ! TYPE_2 METHOD_3 ( VAR_2 ) && ! TYPE_2 METHOD_3 ( target ) please <|endcomment|> public void METHOD_1 ( final TYPE_1 VAR_1 ) { final Object target = METHOD_2 ( VAR_1 ) ; <START> if ( this . VAR_2 != null && ! TYPE_2 . METHOD_3 ( target ) ) { <END> VAR_2 . METHOD_4 ( VAR_1 ) ; } }
<|startcomment|> new METHOD_1 method implementation existing _CODE_ method case reuse <|endcomment|> <START> public void METHOD_1 ( Class < ? extends TYPE_1 > filter , <END> Class < ? extends TYPE_1 > VAR_1 ) { Integer position = METHOD_2 ( VAR_1 ) ; if ( position == null ) { throw new IllegalArgumentException ( STRING_1 + VAR_1 ) ; } put ( filter , position + 1 ) ; }
<|startcomment|> a otimization : VAR_2 METHOD_1 don t need check others writeif ( VAR_2 matcher ( VAR_1 ) METHOD_1 ( ) ) return true ; <|endcomment|> public boolean METHOD_1 ( String VAR_1 ) { if ( VAR_1 == null || VAR_1 . isEmpty ( ) ) { return false ; } boolean result = false ; for ( TYPE_1 VAR_2 : VAR_3 ) { <START> result |= VAR_2 . matcher ( VAR_1 ) . METHOD_1 ( ) ; <END> } return result ; }
<|startcomment|> pass map TYPE_3 constructor ( copy internally ) <|endcomment|> public TYPE_1 < String , TYPE_2 > build ( ) { <START> return new TYPE_3 < TYPE_2 > ( VAR_1 , new TYPE_4 < String , TYPE_2 > ( map ) ) ; <END> }
<|startcomment|> suggestionprivate static boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ( VAR_1 instanceof TYPE_2 ) ; } <|endcomment|> <START> static boolean METHOD_1 ( TYPE_1 VAR_1 ) { return ( VAR_1 instanceof TYPE_2 ) ; } <END>
<|startcomment|> a TYPE_1 error more proper ? generally error early late <|endcomment|> public static TYPE_1 < byte [ ] > METHOD_1 ( String url , TYPE_2 VAR_1 ) { TYPE_3 VAR_2 = TYPE_4 . create ( TYPE_3 . class , VAR_1 ) ; try { return VAR_2 . METHOD_2 ( METHOD_3 ( url ) , METHOD_4 ( url ) ) . METHOD_5 ( response - > TYPE_5 . METHOD_6 ( response . getValue ( ) ) ) ; } catch ( TYPE_6 ex ) { <START> return TYPE_1 . empty ( ) ; <END> } }
<|startcomment|> add explicit else blockif ( condition ) { } else { } <|endcomment|> public long METHOD_1 ( ) { if ( VAR_1 . size ( ) == 0 ) { return Long . VAR_2 ; } <START> TYPE_1 VAR_3 = VAR_1 . get ( 0 ) ; <END> return VAR_3 . METHOD_2 ( ) ; }
<|startcomment|> asuming allways argument case <|endcomment|> private static String METHOD_1 ( List < String > VAR_1 ) <START> { <END> int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) + 1 ; return VAR_1 . get ( VAR_2 ) ; }
<|startcomment|> changes relevant patch <|endcomment|> private void METHOD_1 ( ) { <START> METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> }
<|startcomment|> I don t understand purpose local variable VAR_1 : IMHO remove variable <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 element ) { <START> TYPE_2 VAR_1 = element ; <END> if ( VAR_1 . METHOD_2 ( VAR_2 ) ) { if ( element . VAR_3 ( VAR_2 ) ) { return TYPE_1 . VAR_4 ; } } if ( element instanceof TYPE_3 ) { VAR_5 ++ ; } return TYPE_1 . VAR_6 ; }
<|startcomment|> correct ? deleting a product I assume reports parent interesting file delta <|endcomment|> protected boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> return ! METHOD_2 ( VAR_1 , false ) . isEmpty ( ) ; <END> }
<|startcomment|> place put else returns - - consistency change else statement <|endcomment|> protected TYPE_1 METHOD_1 ( String VAR_1 ) { if ( TYPE_2 . getInstance ( ) . METHOD_2 ( VAR_1 ) ) { return TYPE_3 . VAR_3 ; <START> } else { <END> return TYPE_3 . VAR_4 ; } }
<|startcomment|> wondering check VAR_1 belonged auto - assigned partitions ? straight throw TYPE_4 ? a behavioral change <|endcomment|> public void METHOD_1 ( final Map < TYPE_1 , TYPE_2 > VAR_1 , TYPE_3 VAR_2 ) { METHOD_2 ( ) ; try { METHOD_3 ( ) ; METHOD_4 ( VAR_1 ) ; log . debug ( STRING_1 , VAR_1 ) ; VAR_1 . forEach ( this : : METHOD_5 ) ; VAR_3 . METHOD_6 ( new HashMap < > ( VAR_1 ) , VAR_2 ) ; } catch ( TYPE_4 e ) { <START> log . error ( STRING_2 ) ; <END> VAR_2 . METHOD_7 ( VAR_1 , e ) ; } finally { METHOD_8 ( ) ; } }
<|startcomment|> trace log doesn t allow easily entries s informative debug log : ) Long lines log a PITA deal I suggest logging number entries debug level a separate line processed / skipped entry <|endcomment|> public void METHOD_1 ( TYPE_1 [ ] VAR_1 ) throws Exception { if ( trace ) { log . VAR_2 ( STRING_1 , METHOD_2 ( VAR_1 ) ) ; } else if ( debug ) { <START> log . VAR_3 ( STRING_2 , VAR_1 . length ) ; <END> } if ( VAR_4 != null ) { METHOD_3 ( VAR_1 ) ; } else { METHOD_4 ( VAR_1 ) ; } }
<|startcomment|> define enums operation type <|endcomment|> protected TYPE_4 ( TYPE_1 VAR_2 , String VAR_3 , TYPE_2 VAR_4 , TYPE_2 VAR_5 ) { this . VAR_2 = VAR_2 ; <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; this . VAR_5 = VAR_5 ; VAR_6 = TYPE_3 . METHOD_1 ( VAR_2 ) ; }
<|startcomment|> move closer method ? VAR_1 remove happen shell disposed s TBR false <|endcomment|> public void METHOD_1 ( ) { <START> VAR_1 . METHOD_2 ( ) . remove ( VAR_2 ) ; <END> VAR_3 . METHOD_1 ( ) ; VAR_4 . METHOD_1 ( ) ; VAR_5 . METHOD_1 ( ) ; VAR_2 . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 . METHOD_3 ( ) . METHOD_1 ( ) ; ( ( TYPE_1 ) VAR_2 . METHOD_5 ( ) ) . METHOD_1 ( ) ; }
<|startcomment|> butreturn metadata getType ( ) METHOD_2 ( ) = = TYPE_1 VAR_2 ||metadata getType ( ) METHOD_2 ( ) = = TYPE_1 VAR_3 ||metadata getType ( ) METHOD_2 ( ) = = TYPE_1 VAR_4 ; <|endcomment|> public boolean METHOD_1 ( ) { if ( metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_2 || metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_3 || metadata . getType ( ) . METHOD_2 ( ) == TYPE_1 . VAR_4 ) { return true ; } <START> return false ; <END> }
<|startcomment|> remove list preferred install part TYPE_6 done <|endcomment|> protected Builder ( ) { super ( TYPE_1 . class ) ; id ( STRING_1 ) . name ( STRING_2 ) . METHOD_1 ( STRING_3 ) . METHOD_2 ( STRING_4 ) . METHOD_3 ( TYPE_2 . create ( STRING_5 ) ) . version ( STRING_6 ) . METHOD_4 ( STRING_7 ) . METHOD_5 ( TYPE_3 . METHOD_5 ( ) ) . METHOD_6 ( TYPE_7 < Class < ? extends TYPE_4 > > of ( <START> TYPE_5 . class , <END> TYPE_6 . class ) ) ; }
<|startcomment|> optional : import VAR_2 static <|endcomment|> TYPE_1 METHOD_1 ( ) { return new TYPE_1 ( new TYPE_2 ( System . err , <START> TYPE_3 . VAR_2 ) ) ; <END> }
<|startcomment|> file a directory check necessary <|endcomment|> public void METHOD_1 ( ) { int VAR_1 = VAR_2 . METHOD_2 ( ) ; for ( int i = 0 ; i < VAR_1 ; i ++ ) { File file = ( File ) VAR_2 . METHOD_3 ( i ) ; if ( file != null ) { <START> if ( file . VAR_3 ( ) ) { <END> } else { METHOD_4 ( ) . METHOD_5 ( i , true ) ; VAR_4 . METHOD_6 ( file ) ; } } } }
<|startcomment|> I tend agree I existing naming pattern I d fix consistent <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) { <END> TYPE_1 VAR_1 = null ; try { VAR_1 = VAR_2 == null ? null : new TYPE_1 ( VAR_2 ) ; } catch ( TYPE_2 VAR_3 ) { METHOD_2 ( STRING_1 , this . name , VAR_2 ) ; } for ( TYPE_3 p : METHOD_3 ( ) ) { TYPE_1 v = p . VAR_4 ( ) ; if ( v == null ) { continue ; } if ( VAR_1 == null || v . VAR_5 ( VAR_1 ) ) { VAR_1 = v ; } } return VAR_1 ; }
<|startcomment|> throw a RuntimeException a simulation <|endcomment|> public void METHOD_1 ( ) { <START> throw new TYPE_1 ( STRING_1 ) ; <END> }
<|startcomment|> remove empty line <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; METHOD_2 ( VAR_2 ) ; METHOD_2 ( VAR_3 ) ; METHOD_2 ( VAR_4 ) ; <START> <END> }
<|startcomment|> replace : ( ( TYPE_2 ) VAR_2 METHOD_1 ( ) ) ; <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 ) { <START> this . VAR_3 = ( TYPE_2 ) VAR_2 . METHOD_1 ( ) ; this . VAR_4 = VAR_3 . METHOD_2 ( ) . METHOD_3 ( ) . METHOD_4 ( ) . METHOD_5 ( ) ; <END> }
<|startcomment|> explicit cast done prevent overflow I safe remove castsame question other occurrences <|endcomment|> public static long METHOD_1 ( byte [ ] VAR_1 ) { int p = 0 ; long VAR_2 = 0 ; int c , VAR_3 = 0 ; do { c = VAR_1 [ p ++ ] & INT_1 ; <START> VAR_2 |= ( ( c & INT_2 ) < < VAR_3 ) ; <END> VAR_3 += INT_3 ; } while ( ( c & INT_4 ) != 0 ) ; return VAR_2 ; }
<|startcomment|> static import TYPE_6 METHOD_2 <|endcomment|> public TYPE_1 apply ( TYPE_2 node , TYPE_3 VAR_1 , Context context ) { Map < TYPE_4 , TYPE_5 > VAR_2 = <START> METHOD_1 ( TYPE_6 . METHOD_2 ( node ) , context , metadata , VAR_3 ) ; <END> if ( VAR_2 . isEmpty ( ) ) { return TYPE_1 . empty ( ) ; } return TYPE_1 . METHOD_3 ( new TYPE_7 ( context . VAR_4 ( ) . METHOD_4 ( ) , METHOD_5 ( context , node , TYPE_8 . create ( VAR_2 ) ) , METHOD_6 ( node . VAR_5 ( ) ) ) ) ; }
<|startcomment|> move call start method s generally s done <|endcomment|> protected void METHOD_1 ( ) { String action = METHOD_2 ( ) . METHOD_3 ( ) ; if ( action == null || ! action . equals ( STRING_1 ) ) { TYPE_1 VAR_1 = new TYPE_1 ( this , TYPE_2 . class ) ; METHOD_4 ( VAR_1 ) ; METHOD_5 ( ) ; } else { METHOD_2 ( ) . METHOD_6 ( null ) ; } <START> super . METHOD_1 ( ) ; <END> }
<|startcomment|> I want string computation lazy lose info overriding toString <|endcomment|> public TYPE_2 ( TYPE_1 VAR_2 , double value , double VAR_3 ) { <START> super ( VAR_2 + STRING_1 ) ; <END> this . VAR_2 = VAR_2 ; this . value = value ; this . VAR_3 = VAR_3 ; }
<|startcomment|> needs cloning <|endcomment|> public TYPE_1 METHOD_1 ( ) { final TYPE_2 properties = TYPE_3 . VAR_2 . METHOD_2 ( ) ; <START> properties . VAR_3 ( ) . addAll ( METHOD_3 ( ) . entrySet ( ) ) ; <END> return properties ; }
<|startcomment|> sync <|endcomment|> <START> public static TYPE_1 getInstance ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; }
<|startcomment|> s a bug VAR_11 compile work ( a warning ) I ll remove extra <|endcomment|> private void METHOD_1 ( Throwable t ) { if ( message . VAR_1 ( ) ) { TYPE_1 response = new TYPE_1 ( TYPE_2 . TYPE_7 . VAR_3 ) . METHOD_2 ( TYPE_5 . VAR_5 , TYPE_2 . VAR_6 ) ; if ( t instanceof TYPE_3 ) { <START> response = response . VAR_7 ( TYPE_5 . VAR_8 . VAR_8 , TYPE_4 . METHOD_3 ( TYPE_6 . VAR_10 . VAR_11 ) ) ; <END> } TYPE_2 . instance ( ) . METHOD_4 ( response , id , message . from ) ; } }
<|startcomment|> I m surprised VAR_2 return Optional : ) <|endcomment|> public Optional < TYPE_1 > METHOD_1 ( TYPE_2 context ) { <START> final String VAR_1 = context . VAR_2 ( this . VAR_3 ) ; <END> final String VAR_4 = context . VAR_2 ( this . VAR_5 ) ; if ( VAR_1 == null || VAR_4 == null ) { return Optional . empty ( ) ; } return Optional . of ( new TYPE_1 ( VAR_1 , VAR_4 ) ) ; }
<|startcomment|> editor open ( ) BP hit debug view hidden - a single window open java perspective start debugging close editor hide view resume times editor opened <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> METHOD_2 ( VAR_1 , <END> false ) ; }
<|startcomment|> I don t modify generated methods need set merge <|endcomment|> public boolean METHOD_1 ( ) { <START> if ( parent != null ) { <END> return parent . VAR_1 ( ) ; } return VAR_2 ; }
<|startcomment|> final <|endcomment|> <START> public TYPE_1 value ( ) { <END> return METHOD_1 ( ) . run ( ) ; }
<|startcomment|> operands initialized : VAR_3 = VAR_3 ; super ( ) constructor required <|endcomment|> private TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 , TYPE_2 VAR_4 ) { <START> super ( VAR_3 , VAR_4 ) ; <END> this . VAR_2 = VAR_2 ; }
<|startcomment|> please 4 loop vars node delta <|endcomment|> private void METHOD_1 ( ) { if ( VAR_1 == null ) { VAR_2 = new HashMap < > ( 1 ) ; return ; } VAR_2 = new HashMap < > ( VAR_1 . size ( ) * 4 / 3 ) ; for ( TYPE_1 <START> element : <END> VAR_1 ) { METHOD_2 ( element ) ; } }
<|startcomment|> please [ - - resources ] ( ) statement instead handling manually <|endcomment|> public File METHOD_1 ( Collection < TYPE_1 > VAR_1 , TYPE_2 VAR_2 ) throws IOException { TYPE_3 VAR_3 = new TYPE_3 ( ) ; File file = new File ( STRING_1 ) ; TYPE_4 VAR_4 = new TYPE_4 ( file ) ; <START> try { <END> VAR_3 . METHOD_2 ( VAR_1 , VAR_4 , new File ( VAR_2 ) ) ; } catch ( IOException e ) { throw new IOException ( e . getMessage ( ) ) ; } finally { VAR_4 . METHOD_3 ( ) ; VAR_4 . close ( ) ; } return file ; }
<|startcomment|> style : missing braces <|endcomment|> private TYPE_1 source ( TYPE_2 iterator ) { <START> if ( iterator instanceof TYPE_3 ) <END> return TYPE_1 . create ( ( TYPE_3 ) iterator ) ; return TYPE_1 . create ( db . VAR_1 ( ) ) ; }
<|startcomment|> submonitor needed method original monitor passed mutually exclusive method calls <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , int options , TYPE_2 monitor ) throws TYPE_3 { TYPE_4 <START> VAR_2 = <END> TYPE_4 . METHOD_2 ( monitor , 1 ) ; final TYPE_5 VAR_3 = METHOD_3 ( VAR_4 . NONE , null ) ; if ( VAR_3 . METHOD_4 ( ) ) { METHOD_5 ( VAR_3 , VAR_1 , options , VAR_2 . split ( 1 ) ) ; } else { METHOD_6 ( VAR_3 , VAR_1 , options , VAR_2 . split ( 1 ) ) ; } }
<|startcomment|> I meant brackets encapsulate entire rest method <|endcomment|> public void METHOD_1 ( ) { if ( VAR_1 != null && VAR_2 == TYPE_2 . VAR_4 ) <START> VAR_1 . METHOD_2 ( ) ; <END> VAR_2 = TYPE_2 . VAR_5 ; try { METHOD_3 ( ) ; } catch ( Exception e ) { throw new TYPE_1 ( e ) ; } }
<|startcomment|> case jadx replace continue else I correct change jadx don t information restore VAR_2 I miss ? P S time complex VAR_2 write check method check method logic changed transformations decompilation ( example [ _CODE_ ] ( ) test ) VAR_2 changed heavily logic preserved hard check case eye <|endcomment|> public void METHOD_1 ( ) throws Exception { TYPE_1 VAR_1 = METHOD_2 ( TYPE_2 . class ) ; String VAR_2 = VAR_1 . METHOD_3 ( ) . toString ( ) ; <START> assertThat ( VAR_2 , METHOD_4 ( STRING_1 ) ) ; <END> }
<|startcomment|> _CODE_ <|endcomment|> public List < TYPE_1 > METHOD_1 ( ) { METHOD_2 ( ) ; <START> return VAR_1 . values ( ) . stream ( ) . collect ( Collectors . VAR_2 ( ) ) ; <END> }
<|startcomment|> worth extending timeout ? AFIACT won t effect correct working latch prevent issues tests running especially slow device / simulator <|endcomment|> public void METHOD_1 ( String VAR_1 , TYPE_1 VAR_2 , Map < String , String > VAR_3 ) throws TYPE_2 , TYPE_3 { try { <START> VAR_4 . METHOD_2 ( INT_1 , TimeUnit . VAR_5 ) ; <END> } catch ( InterruptedException exception ) { exception . VAR_6 ( ) ; } super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; }
<|startcomment|> method - static private - isn t class <|endcomment|> <START> public static String <END> METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { return METHOD_1 ( VAR_1 , VAR_2 , VAR_1 . METHOD_2 ( ) ) ; }
<|startcomment|> remove seq <|endcomment|> private void METHOD_1 ( String VAR_1 , int VAR_2 , String message , Object ... VAR_3 ) { TYPE_1 . METHOD_2 ( VAR_2 , METHOD_3 ( VAR_1 ) , ( TYPE_2 ) METHOD_4 ( VAR_1 , VAR_4 , false ) , ( TYPE_2 ) METHOD_4 ( VAR_1 , VAR_5 , false ) , message , VAR_3 ) ; VAR_6 . remove ( VAR_1 ) ; <START> METHOD_5 ( ) . METHOD_6 ( ) . METHOD_7 ( VAR_1 ) ; <END> }
<|startcomment|> VAR_4 null ( don t null check equals ( ) method ) change <|endcomment|> private int METHOD_1 ( ) { int result = System . VAR_1 ( VAR_2 ) ; result = INT_1 * result + System . VAR_1 ( VAR_3 ) ; <START> result = INT_1 * result + ( VAR_4 != null ? VAR_4 . METHOD_2 ( ) : 0 ) ; <END> result = INT_1 * result + System . VAR_1 ( VAR_5 ) ; return result ; }
<|startcomment|> I suspect code unused ( lightly ) else complained doesn t work processor max ( 1 TYPE_1 METHOD_3 ( ) METHOD_4 ( ) - 1 ) <|endcomment|> public int METHOD_1 ( ) { int VAR_1 = METHOD_2 ( ) ; if ( VAR_1 != VAR_2 ) { return VAR_1 ; } else { <START> return TYPE_1 . METHOD_3 ( ) . METHOD_4 ( ) - 1 ; <END> } }
<|startcomment|> shouldn t store application a slug abstract implementation control rely implementation calling method <|endcomment|> <START> protected String METHOD_1 ( TYPE_1 id ) { <END> return STRING_1 + VAR_1 . METHOD_2 ( id . VAR_2 ( ) ) ; }
<|startcomment|> invoking METHOD_2 ( true ) a fragment UI risky ( / leak views ) need ? _CODE_ currently holds a reference activity leak a configuration change wdyt <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> METHOD_2 ( true ) ; <END> return new TYPE_3 ( METHOD_3 ( ) , METHOD_4 ( ) ) ; }
<|startcomment|> redundant instanceof casts <|endcomment|> public boolean METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 , TYPE_3 VAR_3 ) { <START> if ( ! TYPE_4 . METHOD_2 ( VAR_1 ) && this instanceof TYPE_5 && ( ( TYPE_5 ) this ) . METHOD_3 ( ) ) { <END> for ( TYPE_2 VAR_4 : ( ( TYPE_5 ) this ) . METHOD_4 ( VAR_1 , VAR_3 . VAR_5 , VAR_3 , VAR_2 ) ) { METHOD_5 ( VAR_1 , VAR_3 , VAR_4 , VAR_2 ) ; } } return super . METHOD_1 ( VAR_1 , VAR_2 , VAR_3 ) ; }
<|startcomment|> subclasses allowed override method <|endcomment|> <START> protected void METHOD_1 ( final TYPE_1 VAR_1 ) { <END> if ( VAR_1 != null ) { VAR_2 . METHOD_1 ( VAR_3 . VAR_4 . create ( VAR_1 . METHOD_2 ( ) ) . METHOD_3 ( ) ) ; } }
<|startcomment|> mag 1 weg <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 message , TYPE_3 session ) throws TYPE_4 { <START> try { try ( TYPE_5 target = TYPE_5 . METHOD_2 ( this , session , METHOD_3 ( ) ) ) { try ( TYPE_6 out = target . VAR_1 ( ) ) { <END> VAR_2 . run ( message . VAR_3 ( ) , out ) ; } return target . VAR_4 ( ) ; } } catch ( Exception e ) { throw new TYPE_4 ( this , STRING_1 , e ) ; } }
<|startcomment|> && more line existing coding pattern minor <|endcomment|> public void METHOD_1 ( TYPE_1 session , Object VAR_1 ) { session . VAR_2 ( VAR_3 , VAR_1 ) ; if ( VAR_4 != null ) { <START> if ( VAR_4 . METHOD_2 ( VAR_1 ) . METHOD_3 ( ) < 0 ) { <END> throw new TYPE_2 ( STRING_1 ) ; } } VAR_5 . METHOD_4 ( session , VAR_1 ) ; }
<|startcomment|> false enough constant <|endcomment|> private static boolean METHOD_1 ( TYPE_1 VAR_1 , Map < String , TYPE_2 > VAR_2 ) { String VAR_3 = VAR_1 . getKey ( ) ; TYPE_2 VAR_4 = VAR_2 . get ( VAR_3 ) ; if ( VAR_4 == null ) { if ( TYPE_1 . Type . VAR_5 == VAR_1 . getType ( ) ) { <START> return VAR_6 ; <END> } throw new IllegalStateException ( String . format ( STRING_1 , VAR_3 ) ) ; } return VAR_4 . METHOD_2 ( ) ; }
<|startcomment|> I missing method doesn t throws a TYPE_2 throw e <|endcomment|> <START> public void error ( TYPE_1 e ) throws TYPE_2 { <END> if ( VAR_1 == null ) { VAR_1 = e ; VAR_2 = new StringBuilder ( INT_1 ) ; VAR_2 . append ( CHAR_1 ) . append ( VAR_3 ) . append ( CHAR_1 ) . append ( STRING_1 ) ; } VAR_2 . append ( CHAR_2 ) . append ( e . toString ( ) ) ; }
<|startcomment|> shouldn t METHOD_3 ( true ) ? I flag meant identify - hosted WP logins WP signups count <|endcomment|> public void METHOD_1 ( String name , String VAR_1 , String VAR_2 , String VAR_3 ) { TYPE_1 . METHOD_2 ( TYPE_1 . TYPE_3 . VAR_5 ) ; <START> VAR_6 . METHOD_3 ( false ) ; <END> if ( VAR_7 ) { TYPE_2 . METHOD_4 ( this , name , VAR_1 , VAR_2 , VAR_3 , false ) ; } else { TYPE_2 . METHOD_5 ( this , name , VAR_1 , VAR_2 , VAR_3 ) ; } METHOD_6 ( TYPE_4 . VAR_9 ) ; METHOD_7 ( ) ; }
<|startcomment|> warning : static field _CODE_ logger accessed a static <|endcomment|> protected void log ( final Level VAR_1 , final String msg , final Throwable t ) { <START> this . logger . log ( VAR_1 , this . VAR_2 + STRING_1 + msg , t ) ; <END> }
<|startcomment|> minor : static <|endcomment|> <START> private short [ ] METHOD_1 ( int [ ] VAR_1 ) { <END> if ( VAR_1 == null ) { return null ; } short [ ] VAR_2 = new short [ VAR_1 . length ] ; for ( int i = 0 ; i < VAR_2 . length ; i ++ ) { VAR_2 [ i ] = METHOD_2 ( VAR_1 [ i ] ) ; } return VAR_2 ; }
<|startcomment|> ここは、 VAR_3 addAll ( VAR_1 ) ; と書くとすっきりしますね。 <|endcomment|> protected void METHOD_1 ( List < TYPE_1 > VAR_1 ) { if ( VAR_1 == null ) { METHOD_2 ( STRING_1 , STRING_2 ) ; } else { <START> for ( TYPE_1 VAR_2 : VAR_1 ) { <END> VAR_3 . add ( VAR_2 ) ; } } for ( int i = 0 ; i < INT_1 ; i ++ ) VAR_3 . add ( new TYPE_1 ( STRING_3 + i , STRING_4 + i , STRING_5 + i ) ) ; VAR_4 . METHOD_3 ( ) ; }
<|startcomment|> picking don t need extra brackets s : VAR_5 = STRING_1 equalsIgnoreCase ( VAR_3 ) ? TYPE_1 VAR_7 : TYPE_1 VAR_8 ; <|endcomment|> public TYPE_2 ( String VAR_2 , String VAR_3 ) { VAR_4 = VAR_2 . substring ( 1 , VAR_2 . length ( ) - 1 ) ; <START> VAR_5 = ( STRING_1 . equalsIgnoreCase ( VAR_3 ) ) ? TYPE_1 . VAR_7 : TYPE_1 . VAR_8 ; <END> }
<|startcomment|> nulls allowed filter - deterministic ; consider adding a test array ( real ) test _CODE_ = filter = = null || VAR_6 || filter VAR_9 ( ) ; <|endcomment|> public TYPE_4 ( TYPE_1 VAR_2 , Optional < TYPE_2 > filter , boolean VAR_3 , TYPE_3 VAR_4 ) { this . VAR_2 = METHOD_1 ( VAR_2 , STRING_1 ) ; this . filter = filter . VAR_5 ( null ) ; this . VAR_3 = VAR_3 ; this . VAR_4 = METHOD_1 ( VAR_4 , STRING_2 ) ; this . VAR_6 = this . filter != null && ! this . filter . VAR_7 ( ) ; <START> this . VAR_8 = this . filter == null || this . filter . VAR_9 ( ) ; <END> }
<|startcomment|> need clear collection inbound collection null drop entire single line : VAR_1 = VAR_1 ! = null ? new HashSet < > ( VAR_1 ) : null ; <|endcomment|> public void METHOD_1 ( Collection < TYPE_1 > VAR_1 ) { this . VAR_2 = null ; if ( VAR_1 != null ) { <START> this . VAR_1 = new HashSet < > ( VAR_1 ) ; <END> } }
<|startcomment|> changes line relevant _CODE_ please remove modify : _CODE_ _CODE_ ( ) METHOD_2 ( ) instead a safe a follower patch <|endcomment|> public TYPE_1 ( T parameters ) { super ( parameters ) ; <START> this . METHOD_1 ( METHOD_2 ( ) . METHOD_3 ( ) ) ; <END> }
<|startcomment|> need close directory stream <|endcomment|> private Collection < File > METHOD_1 ( File VAR_1 ) throws IOException { Collection < File > VAR_2 = new ArrayList < > ( ) ; <START> TYPE_1 < Path > VAR_3 = TYPE_2 . METHOD_2 ( VAR_1 . METHOD_3 ( ) , STRING_1 ) ; <END> VAR_3 . forEach ( path - > VAR_2 . add ( path . VAR_4 ( ) ) ) ; return VAR_2 ; }
<|startcomment|> url checked null <|endcomment|> private String METHOD_1 ( ) { TYPE_1 VAR_1 = getClass ( ) . METHOD_2 ( ) ; if ( VAR_1 instanceof TYPE_2 ) { <START> TYPE_3 url = ( ( TYPE_2 ) VAR_1 ) . METHOD_3 ( TYPE_5 . VAR_3 ) ; <END> try { TYPE_4 VAR_4 = new TYPE_4 ( url . VAR_5 ( ) ) ; return VAR_4 . METHOD_4 ( ) . getValue ( STRING_1 ) ; } catch ( IOException e ) { } } return null ; }
<|startcomment|> simpler : javabind ( TYPE_6 class ) ( TYPE_7 class ) ; <|endcomment|> protected void METHOD_1 ( ) { super . METHOD_1 ( ) ; METHOD_2 ( new TYPE_1 ( ) ) ; bind ( new TYPE_2 < TYPE_3 < TYPE_4 > > ( ) { } ) . to ( new TYPE_2 < TYPE_5 > ( ) { } ) ; <START> bind ( TYPE_6 . class ) . to ( new TYPE_2 < TYPE_7 > ( ) { } ) ; <END> }
<|startcomment|> done test case _CODE_ s constructor line 33 <|endcomment|> public void METHOD_1 ( ) { TYPE_1 . METHOD_2 ( ) ; TYPE_2 user = METHOD_3 ( TYPE_2 . class ) ; when ( VAR_1 . remove ( METHOD_4 ( ) ) ) . METHOD_5 ( 1 ) ; <START> VAR_2 . METHOD_6 ( TYPE_3 . TYPE_4 , INT_1 ) ; <END> VAR_5 . METHOD_7 ( session , user ) ; }
<|startcomment|> useless statement <|endcomment|> public void clear ( ) { VAR_1 . clear ( ) ; <START> ; <END> VAR_2 . clear ( ) ; METHOD_1 ( ) . clear ( ) ; }
<|startcomment|> I d write : VAR_2 = _CODE_ I d method a checkstyle warning <|endcomment|> public void METHOD_1 ( float VAR_1 ) { <START> VAR_2 = VAR_1 ; <END> }
<|startcomment|> i ! testing purposes src / test correct stay 👍 <|endcomment|> public void METHOD_1 ( TYPE_1 task ) throws TYPE_2 { boolean contains = false ; <START> for ( String VAR_1 : VAR_2 ) { <END> if ( VAR_1 . equals ( task . getName ( ) ) ) { contains = true ; break ; } } if ( ! contains ) { VAR_2 . add ( task . getName ( ) ) ; } }
<|startcomment|> I VAR_1 setter instead getter time getValue called evaluate template setter underlined version evaluation <|endcomment|> public TYPE_1 getValue ( ) { <START> if ( VAR_1 ) { <END> return VAR_2 . METHOD_1 ( VAR_3 ) ; } return VAR_3 ; }
<|startcomment|> beif ( ! TYPE_2 METHOD_2 ( VAR_1 ) ) { <|endcomment|> private String METHOD_1 ( TYPE_1 uri , String VAR_1 ) { String url = VAR_2 . getString ( STRING_1 , null , STRING_2 ) ; if ( TYPE_2 . METHOD_2 ( url ) ) { url = uri . toString ( ) ; } if ( ! url . VAR_3 ( STRING_3 ) ) { url += STRING_3 ; } <START> if ( TYPE_2 . METHOD_2 ( VAR_1 ) ) { <END> url += STRING_4 + VAR_1 ; } return url ; }
<|startcomment|> isn t correct item case passed JSR - 352 _CODE_ items current chunk spring batch JSR provide facilities identify item a chunk caused error section 9 2 7 spec more detail <|endcomment|> <START> <END> <END> public <END> <END> void <END> <END> METHOD_1 ( <END> TYPE_1 <END> <END> <END> <END> <END> <END> <END> item , <END> Throwable <END> <END> t <END> ) <END> { <END> if <END> ( <END> VAR_1 != null <END> && <END> t instanceof <END> Exception <END> ) <END> <END> { try <END> <END> <END> { <END> VAR_1 . METHOD_2 ( TYPE_3
<|startcomment|> VAR_2 instead VAR_3 [ 0 ] array <|endcomment|> private TYPE_1 [ ] METHOD_1 ( TYPE_2 VAR_1 , Path VAR_2 ) { try { <START> return VAR_1 . METHOD_2 ( new Path ( VAR_3 [ 0 ] . getPath ( ) , TYPE_4 . VAR_5 ) ) ; <END> } catch ( TYPE_3 e ) { return new TYPE_1 [ ] { } ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
<|startcomment|> access private <|endcomment|> <START> public static boolean METHOD_1 ( ) { <END> return VAR_1 . METHOD_2 ( ) . version ( ) . METHOD_3 ( INT_1 , 2 ) ; }
<|startcomment|> interesting times / runs memory spec devices s a good test <|endcomment|> public void <START> METHOD_1 ( ) <END> throws IOException { TYPE_2 . TYPE_5 instance = TYPE_2 . getInstance ( ) ; String [ ] VAR_1 = instance . VAR_2 ( ) ; Arrays . VAR_3 ( VAR_1 ) ; for ( String id : VAR_1 ) { TYPE_3 VAR_4 = instance . VAR_5 ( id ) ; TYPE_4 VAR_6 = TYPE_4 . METHOD_2 ( id , VAR_4 , Long . VAR_7 ) ; assertNotNull ( STRING_1 + id + STRING_2 , VAR_6 ) ; assertEquals ( id , VAR_6 . METHOD_3 ( ) ) ; } }
<|startcomment|> suggestionpublic int METHOD_1 ( ) { <|endcomment|> <START> public Integer METHOD_1 ( ) { <END> return VAR_1 ; }
<|startcomment|> package - private <|endcomment|> <START> public byte METHOD_1 ( ) <END> { return VAR_1 ; }
<|startcomment|> ordering <|endcomment|> public TYPE_3 ( ANNOTATION_1 ( STRING_1 ) final Type type , ANNOTATION_1 ( STRING_2 ) final Boolean VAR_2 , ANNOTATION_1 ( STRING_3 ) final String VAR_3 , ANNOTATION_1 ( STRING_4 ) final String VAR_4 , ANNOTATION_1 ( STRING_5 ) final TYPE_1 VAR_5 , ANNOTATION_1 ( STRING_6 ) final TYPE_2 VAR_6 ) { this . type = type ; this . VAR_2 = VAR_2 ; this . VAR_5 = VAR_5 ; this . VAR_6 = VAR_6 ; <START> this . VAR_3 = VAR_3 ; <END> this . VAR_4 = VAR_4 ; }
<|startcomment|> incompatible change : VAR_1 return null s throwing null pointer <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> return VAR_1 . get ( 0 ) ; <END> }
<|startcomment|> instead don t nest TYPE_1 s <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_2 == null ) { return ; } <START> while ( VAR_2 instanceof TYPE_1 ) { <END> VAR_2 = ( ( TYPE_1 ) VAR_2 ) . METHOD_2 ( ) ; } TYPE_2 VAR_3 = VAR_4 . apply ( VAR_2 ) ; VAR_1 . METHOD_3 ( VAR_3 ) ; VAR_2 = null ; }
<|startcomment|> want cumulate a StringBuilder a plain String <|endcomment|> public final String METHOD_1 ( ) { if ( this . properties . isEmpty ( ) ) return STRING_1 ; ANNOTATION_1 ( STRING_2 ) TYPE_1 e = this . properties . VAR_1 ( ) ; <START> String response = STRING_3 ; <END> response += STRING_4 + this . VAR_2 + STRING_5 ; while ( e . VAR_3 ( ) ) { String key = ( String ) e . VAR_4 ( ) ; response += STRING_6 + key + STRING_7 + this . properties . getProperty ( key ) + STRING_5 ; } return response ; }
<|startcomment|> move debug patch ( remove ) I INFO level <|endcomment|> public void METHOD_1 ( ) { try { <START> log . info ( STRING_1 ) ; <END> TYPE_1 VAR_1 = TYPE_1 . METHOD_2 ( ) . METHOD_3 ( TYPE_3 < Integer > getValue ( TYPE_4 . TYPE_5 ) * - 1 ) ; VAR_5 . METHOD_4 ( VAR_1 ) ; log . info ( STRING_2 ) ; } catch ( Throwable t ) { log . error ( STRING_3 , TYPE_2 . METHOD_5 ( t ) ) ; log . debug ( STRING_4 , t ) ; } }
<|startcomment|> case Optional doesn t give A simple null check exact doesn t allocate a new object heap doesn t require a lambda readable : String node = VAR_2 METHOD_2 ( ) ( id ) ; ( VAR_2 METHOD_2 ( ) ( id ) = = null ) { context VAR_5 ( Collections _CODE_ ( ) ) ; } else { HashMap < String String > map = new HashMap < > ( 2 ) ; map put ( VAR_3 id ) ; map put ( VAR_4 id ) ; context VAR_5 ( map ) ; } more efficient original <|endcomment|> public void METHOD_1 ( String id ) { HashMap < String , String > map = new HashMap < > ( ) ; <START> Optional . VAR_1 ( VAR_2 . METHOD_2 ( ) . get ( id ) ) . METHOD_3 ( node - > { <END> map . put ( VAR_3 , id ) ; map . put ( VAR_4 , id ) ; } ) ; context . VAR_5 ( map ) ; }
<|startcomment|> please extract method : protected _CODE_ _CODE_ ( ) reason able write a test mockito ( pockermock / static mocking ) query <|endcomment|> protected void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( TYPE_1 . getInstance ( ) <END> . METHOD_4 ( ) . METHOD_5 ( getParameters ( ) . METHOD_6 ( ) ) ) ; }
<|startcomment|> I m understanding patch correctly idea ve reached point infinite crash loop - - <|endcomment|> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { super . METHOD_1 ( VAR_1 ) ; <START> TYPE_2 . METHOD_2 ( false ) ; <END> TYPE_3 . METHOD_3 ( this ) ; METHOD_4 ( ) ; METHOD_5 ( ) ; if ( METHOD_6 ( ) != null ) { METHOD_6 ( ) . METHOD_7 ( true ) ; } METHOD_8 ( this ) ; }
<|startcomment|> I implement other VAR_2 ( backing store ) : VAR_2 METHOD_1 ( VAR_1 ) ; mirror intent caller invoking METHOD_1 ( VAR_1 ) a subtle issue discarding a potentially large free list bottom stack pushing empty free list top stack weird I mirror caller s intent <|endcomment|> void METHOD_1 ( final TYPE_1 VAR_1 ) { <START> VAR_1 . METHOD_1 ( VAR_2 ) ; <END> }
<|startcomment|> simplify immediately returning false VAR_1 METHOD_2 ( ) isEmpty ( ) <|endcomment|> public static boolean METHOD_1 ( TYPE_1 VAR_1 ) { <START> boolean VAR_2 = ! VAR_1 . METHOD_2 ( ) . isEmpty ( ) ; <END> if ( VAR_2 ) { if ( TYPE_2 . METHOD_3 ( TYPE_6 . VAR_4 ) ) { VAR_2 = TYPE_3 . exists ( VAR_1 . METHOD_2 ( ) ) ; } else { VAR_2 = VAR_1 . METHOD_4 ( ) . equals ( TYPE_4 . METHOD_5 ( ) ) ; } } return VAR_2 && VAR_5 == TYPE_5 . VAR_7 ; }
<|startcomment|> a _CODE_ channel a bad state manually close <|endcomment|> public static TYPE_1 create ( TYPE_2 context , TYPE_3 VAR_1 , long id , long length , TYPE_4 type , TYPE_5 options ) throws IOException { long VAR_2 = TYPE_6 . METHOD_1 ( TYPE_8 . VAR_4 ) ; TYPE_7 VAR_5 = context . VAR_6 ( VAR_1 ) ; try { return new TYPE_1 ( context , VAR_1 , id , length , VAR_2 , type , options , VAR_5 ) ; } catch ( Exception e ) { <START> VAR_5 . close ( ) ; <END> context . VAR_7 ( VAR_1 , VAR_5 ) ; throw e ; } }
<|startcomment|> t equals ( type ) parameterized types satisfy test <|endcomment|> public static TYPE_1 of ( Type type , TYPE_2 < ? > VAR_1 ) { <START> return ( t , ctx ) - > t == type <END> ? Optional . of ( VAR_1 ) : Optional . empty ( ) ; }
<|startcomment|> I check METHOD_4 ( ) _CODE_ ( ) instead ( ! METHOD_6 ( ) METHOD_7 ( ) || METHOD_6 ( ) METHOD_5 ( ) ) wish <|endcomment|> private void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( METHOD_4 ( ) . METHOD_5 ( ) && ( ! METHOD_6 ( ) . METHOD_7 ( ) || METHOD_6 ( ) . METHOD_5 ( ) ) ) ; <END> }
<|startcomment|> bug : uncompilable extra ) <|endcomment|> public boolean VAR_1 ( ) { <START> if ( ! VAR_2 . VAR_3 ( TYPE_1 . VAR_5 ) ) ) { <END> return false ; } if ( VAR_6 . VAR_7 ( ) ) { return true ; } return VAR_2 . VAR_8 ( ) && ( VAR_2 . VAR_9 ( ) . length > 1 || ! VAR_2 . VAR_10 . isEmpty ( ) || TYPE_2 . VAR_12 ( ) ) ; }
<|startcomment|> avoid time variables <|endcomment|> public final void METHOD_1 ( ) { final TYPE_1 VAR_1 = new TYPE_1 ( ) ; final String user = null ; <START> final String VAR_2 = STRING_1 ; <END> VAR_1 . METHOD_2 ( user , VAR_2 ) ; }
<|startcomment|> IllegalStateException thrown ( _CODE_ ) <|endcomment|> public int METHOD_1 ( ) { if ( VAR_1 == null ) { <START> throw new IllegalStateException ( STRING_1 + VAR_2 + STRING_2 + VAR_3 ) ; <END> } return VAR_1 ; }
<|startcomment|> interesting method handle nulls VAR_1 _CODE_ NPE exposed a change test class <|endcomment|> <START> public Collection < String > METHOD_1 ( ) { <END> if ( VAR_1 != null ) { return TYPE_1 . METHOD_2 ( VAR_1 ) ; } return Collections . VAR_2 ( ) ; }
<|startcomment|> please simplify <|endcomment|> protected boolean METHOD_1 ( ) { <START> if ( VAR_1 >= VAR_2 ) { <END> return false ; } return true ; }
<|startcomment|> check default null <|endcomment|> public void METHOD_1 ( ) { for ( TYPE_1 key : TYPE_1 . METHOD_2 ( ) ) { <START> METHOD_3 ( key . VAR_1 ( ) , "" , String . format ( <END> STRING_1 , key . getName ( ) ) ) ; } }
<|startcomment|> avoid copy pasting code reuse code other topnresultbuilders <|endcomment|> <START> private boolean METHOD_1 ( String VAR_1 ) <END> { final boolean VAR_2 = VAR_3 . size ( ) < this . VAR_4 ; final boolean VAR_5 = VAR_2 || this . VAR_6 . METHOD_2 ( VAR_3 . METHOD_3 ( ) . METHOD_4 ( ) , VAR_1 ) < 0 ; return VAR_5 && VAR_6 . METHOD_2 ( VAR_1 , VAR_7 ) > 0 ; }
<|startcomment|> reason doesn t TYPE_1 METHOD_2 ( ) ? INT_1 instead 37 ? I changing hashcode formula long doesn t violate equals contract <|endcomment|> public int METHOD_1 ( ) { int result = TYPE_1 . METHOD_2 ( entity ) ; <START> result = INT_1 * result + Arrays . VAR_1 ( values ) ; <END> return result ; }
<|startcomment|> don t need throw exceptions - return null <|endcomment|> TYPE_1 METHOD_1 ( TYPE_2 id ) throws TYPE_3 { TYPE_4 VAR_1 = VAR_2 . get ( id ) ; if ( VAR_1 == null ) { <START> throw new TYPE_3 ( STRING_1 + id + STRING_2 + VAR_3 , <END> TYPE_7 . TYPE_5 ) ; } if ( ! VAR_1 . METHOD_2 ( ) ) { throw new TYPE_3 ( STRING_3 + id + STRING_2 + VAR_3 + STRING_4 , TYPE_7 . TYPE_6 ) ; } return VAR_1 ; }
<|startcomment|> apparently date <|endcomment|> public static int getValue ( String text ) { if ( text == null || text . isEmpty ( ) || text . equals ( STRING_1 ) ) { return VAR_1 ; } if ( text . equals ( STRING_2 ) ) { return VAR_2 ; } <START> if ( text . equals ( STRING_3 ) ) { <END> return VAR_3 ; } throw new IllegalArgumentException ( STRING_4 + text ) ; }
<|startcomment|> ! VAR_1 isEmpty ( ) <|endcomment|> public String METHOD_1 ( Object element ) { if ( element instanceof TYPE_1 ) { String VAR_1 = ( ( TYPE_1 ) element ) . METHOD_2 ( ) ; if ( VAR_1 != null && <START> VAR_1 . length ( ) > 0 ) { <END> return VAR_1 ; } } return super . METHOD_1 ( element ) ; }
<|startcomment|> reason catch exceptions <|endcomment|> public String METHOD_1 ( String name ) throws IOException { if ( METHOD_2 ( ) != null ) { try ( TYPE_1 is = METHOD_3 ( name ) ) { if ( is == null ) { return TYPE_2 . METHOD_4 ( new File ( name ) , VAR_1 ) ; } return TYPE_3 . toString ( is , VAR_1 ) ; <START> } catch ( Exception e ) { <END> } } return null ; }
<|startcomment|> dodaj testowanie drugiego levelu moim zdaniem ten test sfailuje dla levelu 1 <|endcomment|> <START> public void METHOD_1 ( ) throws Exception { <END> assertEquals ( VAR_1 . METHOD_2 ( 0 ) , VAR_2 ) ; METHOD_3 ( VAR_1 . METHOD_2 ( 0 ) , VAR_3 ) ; }
<|startcomment|> I test class optinal empty ( ) - avoiding necessity null ; - ) <|endcomment|> public Optional < TYPE_1 > METHOD_1 ( final double x , final double y ) { <START> return null ; <END> }
<|startcomment|> I check TYPE_4 instead include otherkind breakpoints properties page example a watchpoint _CODE_ trigger code <|endcomment|> public void METHOD_1 ( TYPE_1 element ) { <START> if ( element instanceof TYPE_2 ) { <END> VAR_1 = new TYPE_3 ( ( TYPE_4 ) element , null ) ; } else { VAR_1 = element ; } }
<|startcomment|> I don t idea managing transactions table class <|endcomment|> private boolean METHOD_1 ( ) { <START> if ( ! TYPE_1 . METHOD_2 ( ) ) { <END> VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) . type ( TYPE_2 . VAR_3 ) . build ( ) . METHOD_5 ( ) ; return true ; } return false ; }
<|startcomment|> good enough emails failed ? addition sending exception frist error rest <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 < ? extends TYPE_3 > VAR_1 , TYPE_4 session ) throws TYPE_5 { TYPE_6 listener = METHOD_2 ( STRING_1 ) ; TYPE_1 VAR_2 = METHOD_3 ( VAR_1 , session , listener ) ; METHOD_4 ( Long . VAR_3 ) ; Iterator < TYPE_7 > VAR_4 = listener . VAR_5 ( ) ; if ( VAR_4 . hasNext ( ) ) { throw new TYPE_5 ( <START> String . format ( STRING_2 , VAR_4 . next ( ) . METHOD_5 ( ) ) ) ; <END> } return VAR_2 ; }
<|startcomment|> submonitor needed method original monitor passed a single method call <|endcomment|> public TYPE_6 . TYPE_7 . File METHOD_1 ( int options , TYPE_2 monitor ) throws TYPE_3 { TYPE_4 <START> VAR_1 = <END> TYPE_4 . METHOD_2 ( monitor ) ; if ( options != VAR_2 . VAR_3 ) return null ; return TYPE_5 . METHOD_3 ( ) . cache ( this , VAR_1 ) ; }
<|startcomment|> move tasks _CODE_ constructors <|endcomment|> public TYPE_3 ( TYPE_1 VAR_2 , TYPE_2 VAR_3 ) { super ( VAR_2 , VAR_3 ) ; <START> LOG . info ( STRING_1 ) ; <END> METHOD_1 ( ) ; }
<|startcomment|> i reverse - - check access control existing catalogs I access control impl problems - existing catalogs ( & ) <|endcomment|> private boolean METHOD_1 ( String VAR_1 ) { return VAR_2 . METHOD_2 ( session . VAR_3 ( ) , TYPE_1 . of ( VAR_1 ) ) . contains ( VAR_1 ) <START> && metadata . VAR_4 ( session , VAR_1 ) ; <END> }
<|startcomment|> System currentTimeMillis ( ) avoid creating Date objects Date objects ( TYPE_2 ) I guess stuck Long preferable <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 ) { <START> Date d = new Date ( new Date ( ) . METHOD_2 ( ) - INT_1 ) ; <END> if ( TYPE_2 . METHOD_3 ( VAR_1 ) != null && d . VAR_2 ( TYPE_2 . METHOD_3 ( VAR_1 ) ) ) { return ; } TYPE_2 . map ( VAR_1 ) . remove ( TYPE_2 . VAR_3 ) ; }
<|startcomment|> I clear previous VAR_1 s listeners current <|endcomment|> public void METHOD_1 ( ANNOTATION_1 TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; if ( this . VAR_1 != null ) { <START> this . VAR_1 . METHOD_2 ( ) ; <END> this . VAR_1 . METHOD_3 ( this ) ; this . VAR_1 . METHOD_4 ( this ) ; this . VAR_1 . METHOD_5 ( this ) ; } }
<|startcomment|> info log <|endcomment|> private void METHOD_1 ( List < String > VAR_1 , String [ ] VAR_2 ) { StringBuilder VAR_3 = new StringBuilder ( ) ; for ( String log : VAR_1 ) { VAR_3 . append ( log ) ; } String VAR_4 = VAR_3 . toString ( ) ; for ( String VAR_5 : VAR_2 ) { <START> LOG . error ( STRING_1 + VAR_5 ) ; <END> assertTrue ( VAR_4 . contains ( VAR_5 ) ) ; } }
<|startcomment|> t find extension shouldn t return VAR_1 <|endcomment|> private String METHOD_1 ( String VAR_1 ) { int VAR_2 = VAR_1 . METHOD_2 ( STRING_1 ) ; if ( VAR_2 >= 0 ) { return VAR_1 . substring ( 0 , VAR_2 ) ; } <START> return null ; <END> }
<|startcomment|> remove <|endcomment|> private static TYPE_1 METHOD_1 ( ) throws Throwable { <START> System . out . println ( STRING_1 ) ; <END> return new TYPE_1 ( STRING_2 ) ; }
<|startcomment|> I weird dropping view creating goal assert throws exception assert <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 { METHOD_2 ( ) ; try { VAR_1 . METHOD_3 ( STRING_1 ) ; } catch ( final Throwable a ) { <START> } <END> VAR_1 . METHOD_4 ( METHOD_5 ( STRING_1 ) . METHOD_6 ( METHOD_7 ( METHOD_8 ( ) ) . from ( table ( STRING_2 ) ) ) ) ; VAR_1 . METHOD_3 ( STRING_1 ) ; }
<|startcomment|> adjusting private a breaking change - please public replacing sufficient I <|endcomment|> <START> private void METHOD_1 ( ) { <END> VAR_1 . METHOD_1 ( VAR_2 . METHOD_2 ( ) , VAR_2 . METHOD_3 ( ) ) ; }
<|startcomment|> need return TYPE_2 VAR_3 <|endcomment|> public < T > TYPE_1 < T > METHOD_1 ( Class < T > type ) { <START> return ( TYPE_1 < T > ) ( File . VAR_1 . equals ( type ) ? TYPE_2 . VAR_3 : null ) ; <END> }
<|startcomment|> string ? defined messages properties ? won t work translated <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> String item = VAR_1 . METHOD_2 ( VAR_1 . METHOD_3 ( ) ) ; <END> return TYPE_1 . valueOf ( item . VAR_2 ( ) ) ; }
<|startcomment|> unnecessary called _CODE_ ( ) super METHOD_1 ( ) <|endcomment|> public int METHOD_1 ( final TYPE_1 resource , final boolean VAR_1 ) { if ( resource == null ) return 0 ; if ( resource . VAR_2 <= 0 ) return 0 ; <START> if ( ! METHOD_2 ( resource ) ) <END> return 0 ; int VAR_3 = super . METHOD_1 ( resource , VAR_1 ) ; if ( VAR_3 != 0 && VAR_4 != null ) VAR_4 . METHOD_3 ( this ) ; return VAR_3 ; }
<|startcomment|> replaced method reference i e VAR_1 = TYPE_3 : : METHOD_2 <|endcomment|> private TYPE_1 METHOD_1 ( ) { TYPE_1 VAR_1 ; boolean VAR_2 = VAR_3 . equalsIgnoreCase ( STRING_1 ) ; if ( VAR_2 || VAR_4 || VAR_5 ) { VAR_1 = new TYPE_2 ( VAR_2 , VAR_4 , VAR_6 , VAR_7 , VAR_8 , VAR_5 , VAR_9 ) ; } else { <START> VAR_1 = ( ) - > TYPE_3 . METHOD_2 ( ) ; <END> } return VAR_1 ; }
<|startcomment|> return String line <|endcomment|> public String METHOD_1 ( ) { METHOD_2 ( VAR_1 ) ; String VAR_2 = VAR_1 . METHOD_3 ( ) ; <START> return VAR_2 ; <END> }
<|startcomment|> shouldn t modify methods I won t need based merge ( ) <|endcomment|> public TYPE_1 METHOD_1 ( ) { <START> if ( parent != null ) { <END> return parent . VAR_1 ( ) ; } if ( server != null && ( ( TYPE_2 ) server ) . METHOD_2 ( ) ) { TYPE_3 VAR_2 = ( TYPE_3 ) server ; server = ( TYPE_1 ) METHOD_3 ( VAR_2 ) ; if ( server != VAR_2 ) { if ( METHOD_4 ( ) ) { METHOD_5 ( new TYPE_4 ( this , TYPE_6 . VAR_4 , TYPE_5 . VAR_6 , VAR_2 , server ) ) ; } } } return server ; }
<|startcomment|> I don t < T extends Object > needed < T > enough <|endcomment|> <START> public < T extends Object > boolean contains ( TYPE_1 < T > VAR_1 ) { <END> return contains ( VAR_1 . name ( ) ) ; }
<|startcomment|> return m method equals ( method ) ; instead line <|endcomment|> public boolean equals ( Object o ) { if ( ! ( o instanceof TYPE_1 ) ) return false ; TYPE_1 m = ( TYPE_1 ) o ; if ( m . VAR_1 != VAR_1 ) return false ; if ( m . VAR_2 != VAR_2 ) return false ; <START> if ( ! m . method . equals ( method ) ) return false ; <END> return true ; }
<|startcomment|> incrementing count main purpose loop s rewrite loop : ( ; VAR_2 hasNext ( ) ; VAR_2 ( ) ) { + + count ; } <|endcomment|> private static int METHOD_1 ( TYPE_1 VAR_1 ) throws Exception { TYPE_2 < TYPE_3 > VAR_2 = VAR_1 . METHOD_2 ( ) ; assertNotNull ( VAR_2 ) ; int count = 0 ; <START> for ( ; VAR_2 . hasNext ( ) ; ++ count ) <END> VAR_2 . next ( ) ; return count ; }
<|startcomment|> call method METHOD_1 ( String domain ) instead <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_2 . add ( new TYPE_2 ( VAR_1 . METHOD_2 ( ) , VAR_1 . getName ( ) , VAR_1 . getValue ( ) , <END> VAR_1 . getPath ( ) , VAR_1 . METHOD_3 ( ) , VAR_1 . METHOD_4 ( ) ) ) ; }
<|startcomment|> please define row <|endcomment|> public void METHOD_1 ( ) throws IOException { <START> String VAR_1 = null ; <END> VAR_1 = TYPE_1 . METHOD_2 ( STRING_1 , "" ) ; assertTrue ( STRING_2 , VAR_1 . equals ( STRING_3 ) ) ; }
<|startcomment|> remove line <|endcomment|> public void METHOD_1 ( ) { TYPE_1 VAR_1 = new TYPE_1 ( VAR_2 ) ; VAR_1 . METHOD_2 ( VAR_3 ) ; VAR_1 . METHOD_3 ( ) ; <START> System . out . println ( VAR_4 . VAR_5 ) ; <END> TYPE_2 VAR_6 = VAR_1 . METHOD_4 ( VAR_1 . METHOD_5 ( ) , VAR_1 . METHOD_5 ( ) ) ; VAR_6 . METHOD_6 ( ) ; }
<|startcomment|> read ( long VAR_1 ) VAR_4 <|endcomment|> private void METHOD_1 ( long VAR_1 , ANNOTATION_1 TYPE_1 VAR_2 ) { TYPE_1 VAR_3 ; try { <START> VAR_3 = read ( VAR_1 , VAR_4 ) ; <END> } catch ( TYPE_2 VAR_5 ) { throw new TYPE_3 ( STRING_1 ) ; } if ( ! VAR_3 . equals ( VAR_2 ) ) { throw new TYPE_4 ( TYPE_5 . VAR_7 ) ; } }
<|startcomment|> suggestionrm METHOD_2 ( STRING_1 VAR_2 VAR_3 ) ; child unused <|endcomment|> public void METHOD_1 ( ) { <START> TYPE_1 child = VAR_1 . METHOD_2 ( STRING_1 , VAR_2 , VAR_3 ) ; <END> TYPE_1 VAR_4 = VAR_1 . METHOD_2 ( STRING_2 , VAR_3 , VAR_5 ) ; assertEquals ( VAR_3 , VAR_4 . METHOD_3 ( ) ) ; VAR_1 . METHOD_4 ( VAR_3 ) ; assertEquals ( VAR_2 , VAR_4 . METHOD_3 ( ) ) ; }
<|startcomment|> isn t correct : javaif ( VAR_1 = = VAR_1 ) { VAR_1 = null ; } properly handle replacement <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { <START> this . VAR_1 = null ; <END> }
<|startcomment|> t assert request count 2 a base class mock tests more requests <|endcomment|> public void METHOD_1 ( TYPE_1 server ) { <START> assertEquals ( server . VAR_1 ( ) , 2 ) ; <END> try { assertEquals ( server . VAR_2 ( ) . METHOD_2 ( ) , STRING_1 ) ; } catch ( InterruptedException e ) { TYPE_2 . METHOD_3 ( e ) ; } }
<|startcomment|> s remove blank lines <|endcomment|> void METHOD_1 ( ) throws Exception { <START> <END> TYPE_1 VAR_1 = VAR_2 . METHOD_2 ( TYPE_3 . TYPE_2 . VAR_5 , VAR_6 ) ; assertNotNull ( VAR_1 ) ; assertNotNull ( VAR_1 . getId ( ) ) ; log . info ( STRING_1 + VAR_1 . getId ( ) ) ; }
<|startcomment|> HashMap enough <|endcomment|> public String toString ( ) { <START> Map < String , Object > VAR_1 = new TYPE_1 < String , Object > ( this . values ) ; <END> VAR_1 . remove ( VAR_2 ) ; return VAR_1 . toString ( ) ; }
<|startcomment|> instance variable inlined <|endcomment|> public void METHOD_1 ( ) { VAR_1 = TYPE_1 . METHOD_2 ( TYPE_2 . class ) ; writer = new TYPE_3 ( VAR_1 ) ; VAR_2 = TYPE_1 . METHOD_2 ( TYPE_4 . class ) ; result = TYPE_1 . METHOD_2 ( TYPE_5 . class ) ; <START> server = TYPE_6 . METHOD_3 ( ) ; <END> }
<|startcomment|> arguments passed proceeded a space line 173 example <|endcomment|> void METHOD_1 ( TYPE_1 VAR_1 , TYPE_1 VAR_2 , boolean VAR_3 ) { final TYPE_1 VAR_4 = TYPE_2 . METHOD_2 ( VAR_1 , VAR_5 . METHOD_3 ( ) , VAR_5 . METHOD_4 ( ) , true , VAR_3 ) ; VAR_4 . METHOD_5 ( STRING_1 , STRING_2 ) ; METHOD_6 ( VAR_2 ) ; <START> } <END>
<|startcomment|> classy code <|endcomment|> public void METHOD_1 ( TYPE_1 < TYPE_2 > VAR_1 ) { <START> METHOD_2 ( TYPE_3 . VAR_3 ) . forEach ( VAR_1 ) ; <END> }
<|startcomment|> implement _CODE_ methods avoid casts ( ) boxing <|endcomment|> public void METHOD_1 ( int VAR_1 , boolean VAR_2 ) { if ( ! VAR_3 && VAR_2 ) { boolean VAR_4 = false ; synchronized ( VAR_5 ) { <START> if ( VAR_5 . contains ( ( Object ) VAR_1 ) ) { <END> VAR_6 . add ( ( Integer ) VAR_1 ) ; if ( VAR_6 . size ( ) == VAR_5 . size ( ) ) { log . VAR_7 ( STRING_1 , VAR_5 ) ; VAR_4 = true ; } } } if ( VAR_4 ) { METHOD_2 ( true ) ; } } }
<|startcomment|> unnecessary <|endcomment|> public TYPE_1 METHOD_1 ( int j ) { <START> return METHOD_1 ( j , this . factory ) ; <END> }
<|startcomment|> need async async guard don T bad METHOD_3 <|endcomment|> void METHOD_1 ( ) { <START> METHOD_2 ( ) . METHOD_3 ( ( ) - > <END> METHOD_4 ( Messages . TYPE_1 ) ) ; METHOD_5 ( ) . METHOD_6 ( this : : METHOD_7 ) ; }
<|startcomment|> ( 1 ) code won t function executed threads simultaneously ; ( 2 ) commands ( run stateless vm case ) behaves properly thread interrupted ? I METHOD_2 running tasks trigger a new task previous canceled <|endcomment|> public void METHOD_1 ( ) { try { <START> VAR_1 . METHOD_2 ( true ) ; <END> } catch ( Throwable t ) { log . debug ( STRING_1 , TYPE_1 . METHOD_3 ( t ) ) ; } VAR_1 = VAR_2 . METHOD_4 ( this : : METHOD_5 , 0 , VAR_3 , TimeUnit . VAR_4 ) ; }
<|startcomment|> shouldn t receive a RuntimeException anymore <|endcomment|> <START> public TYPE_1 METHOD_1 ( ) throws RuntimeException { <END> for ( TYPE_1 trace : TYPE_2 . getInstance ( ) . METHOD_2 ( ) ) { if ( trace . VAR_1 ( ) . equals ( METHOD_3 ( ) ) ) { return trace ; } } return null ; }
<|startcomment|> minor : I wouldn t static import clarity <|endcomment|> private void METHOD_1 ( TYPE_1 ... VAR_1 ) { <START> METHOD_2 ( METHOD_3 ( VAR_1 ) , asList ( VAR_1 ) ) ; <END> }
<|startcomment|> obscure reason change ? a slower iterator a List <|endcomment|> public void METHOD_1 ( final TYPE_1 column ) throws TYPE_2 { final TYPE_3 VAR_1 = new TYPE_7 . TYPE_8 ( column ) ; for ( int i = 0 ; i < VAR_2 . size ( ) ; i ++ ) { <START> final TYPE_5 VAR_3 = VAR_2 . get ( i ) ; <END> if ( VAR_3 . METHOD_2 ( VAR_1 ) ) { VAR_3 . append ( VAR_1 ) ; break ; } } VAR_4 . METHOD_3 ( new TYPE_6 ( ) ) ; }
<|startcomment|> won t need test nullity VAR_5 METHOD_4 ( ) : javaif ( VAR_2 equals ( VAR_5 METHOD_4 ( ) ) ) { point VAR_2 null <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { Collection < TYPE_4 > VAR_3 = VAR_1 . METHOD_2 ( ) ; if ( VAR_3 != null && VAR_2 != null ) { for ( TYPE_4 VAR_4 : VAR_3 ) { TYPE_1 VAR_5 = VAR_4 . METHOD_3 ( ) ; <START> if ( VAR_5 . METHOD_4 ( ) != null && VAR_5 . METHOD_4 ( ) . equals ( VAR_2 ) ) { <END> return VAR_5 ; } } } return null ; }
<|startcomment|> I don t I understand works clarify ? a unit tests easier understand long string <|endcomment|> public void METHOD_1 ( ) { METHOD_2 ( STRING_1 , STRING_2 ) ; METHOD_2 ( STRING_3 , STRING_2 ) ; METHOD_2 ( STRING_4 , STRING_5 ) ; METHOD_2 ( STRING_6 , STRING_5 ) ; <START> METHOD_2 ( STRING_7 , STRING_8 ) ; <END> METHOD_2 ( STRING_9 , STRING_10 ) ; }
<|startcomment|> return VAR_2 ( VAR_1 ) ; <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { <START> if ( VAR_2 . containsKey ( VAR_1 ) ) { return VAR_2 . get ( VAR_1 ) ; } return null ; <END> }
<|startcomment|> please project formatter { } <|endcomment|> protected boolean METHOD_1 ( ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; if ( Boolean . VAR_3 . equals ( getParameters ( ) . METHOD_3 ( ) ) && ! METHOD_4 ( VAR_1 . METHOD_5 ( METHOD_6 ( ) ) ) ) { return false ; } <START> else return true ; <END> }
<|startcomment|> exception ! = null || response = = null || ! response trim ( ) startsWith ( STRING_1 ) { return ; } catch <|endcomment|> private void METHOD_1 ( ) { <START> try { <END> if ( this . response != null && this . response . trim ( ) . startsWith ( STRING_1 ) ) { METHOD_2 ( ) ; } } catch ( Exception e ) { e . VAR_1 ( ) ; if ( this . exception == null ) { this . exception = e ; } } }
<|startcomment|> don t need = = true s a boolean : - ) <|endcomment|> private boolean METHOD_1 ( List < Pair < Guid , Boolean > > VAR_1 ) { for ( Pair < Guid , Boolean > VAR_2 : VAR_1 ) { <START> if ( VAR_2 . METHOD_2 ( ) == true ) { <END> return true ; } } return false ; }
<|startcomment|> check String empty change default : ( ! VAR_1 isEmpty ( ) ) <|endcomment|> public String METHOD_1 ( ) { TYPE_1 . METHOD_2 ( VAR_1 , STRING_1 ) ; <START> if ( ! VAR_1 . equals ( STRING_2 ) ) { <END> return String . format ( STRING_3 , VAR_1 , VAR_2 ) ; } return VAR_2 ; }
<|startcomment|> VAR_2 parameter Class ( 8 method declaration ) I suppose add parameter future easier clean <|endcomment|> public void METHOD_1 ( final String VAR_1 , <START> final TYPE_1 VAR_2 ) { <END> if ( VAR_1 != null && VAR_1 . trim ( ) . length ( ) > 0 && METHOD_2 ( ) instanceof TYPE_2 ) { final TYPE_2 VAR_3 = ( TYPE_2 ) METHOD_2 ( ) ; VAR_3 . METHOD_3 ( VAR_1 ) ; VAR_3 . METHOD_4 ( ) ; } }
<|startcomment|> point logs ? flag service processing debug : _CODE_ outputted <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 VAR_2 ) { <START> TYPE_3 . METHOD_2 ( this . getClass ( ) ) ; <END> METHOD_3 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 ) ; }
<|startcomment|> supposed throw exception ( i guess ) add afail statement stating exception thrown <|endcomment|> public void METHOD_1 ( ) { exception . VAR_1 ( IllegalStateException . VAR_2 ) ; TYPE_1 message = METHOD_2 ( TYPE_1 . VAR_2 ) ; when ( message . VAR_3 ( ) ) . METHOD_3 ( VAR_4 ) ; try { <START> VAR_5 . METHOD_4 ( message ) ; <END> } finally { METHOD_5 ( VAR_6 , METHOD_6 ( 0 ) ) . METHOD_7 ( ) ; METHOD_5 ( VAR_6 , METHOD_6 ( 0 ) ) . METHOD_8 ( ) ; METHOD_9 ( VAR_6 ) ; } }
<|startcomment|> need explicitly <|endcomment|> public TYPE_1 ( ) { this . VAR_2 = true ; <START> this . VAR_3 = "" ; <END> }
<|startcomment|> needed <|endcomment|> public static void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 instanceof TYPE_2 ) { TYPE_2 VAR_2 = ( TYPE_2 ) VAR_1 ; if ( ! VAR_2 . METHOD_2 ( ) . isEmpty ( ) && VAR_2 . METHOD_3 ( ) . isEmpty ( ) ) { throw new TYPE_3 ( STRING_1 ) ; } } else if ( VAR_1 instanceof TYPE_4 || VAR_1 instanceof TYPE_5 ) { METHOD_1 ( VAR_1 . METHOD_4 ( 0 ) ) ; } else { <START> return ; <END> } }
<|startcomment|> method called _CODE_ ( ) METHOD_3 ( ) null - check CDA result a _CODE_ instead ID parameters <|endcomment|> protected Map < String , Pair < String , String > > METHOD_1 ( ) { if ( METHOD_2 ( ) ) { <START> return Collections . VAR_1 ( METHOD_3 ( ) . getId ( ) . toString ( ) , TYPE_1 . VAR_3 ) ; <END> } return Collections . VAR_4 ; }
<|startcomment|> removing explicit initialization : worse <|endcomment|> public void run ( ) { <START> TYPE_1 VAR_1 ; <END> TYPE_2 outputStream = null ; try { VAR_1 = VAR_2 . METHOD_1 ( ) ; String response = METHOD_2 ( VAR_1 ) ; outputStream = VAR_1 . METHOD_3 ( ) ; METHOD_4 ( outputStream ) ; write ( response . VAR_3 ( ) , outputStream ) ; outputStream . VAR_4 ( ) ; } catch ( IOException e ) { } finally { TYPE_3 . METHOD_5 ( outputStream ) ; } }
<|startcomment|> delete rule ? IIRC reason ensure smudged entries stayed smudged change smudge logic length based longer sense a source bugs selecting modified files potentially racily clean <|endcomment|> public final boolean METHOD_1 ( final int VAR_1 , final int VAR_2 ) { final int VAR_3 = VAR_4 + VAR_5 ; final int VAR_6 = TYPE_1 . METHOD_2 ( info , VAR_3 ) ; <START> if ( VAR_1 < VAR_6 ) <END> return true ; if ( VAR_1 == VAR_6 ) return VAR_2 <= TYPE_1 . METHOD_2 ( info , VAR_3 + 4 ) ; return false ; }
<|startcomment|> METHOD_1 ( ) called move start ( ) start ( ) stop ( ) symmetrical <|endcomment|> <START> private void METHOD_1 ( ) { <END> if ( VAR_1 != null ) { Log . VAR_2 ( TAG , STRING_1 ) ; return ; } VAR_3 = ( TYPE_1 ) METHOD_2 ( Context . VAR_4 ) ; VAR_5 = VAR_3 . METHOD_3 ( TYPE_1 . VAR_6 ) ; VAR_1 = new TYPE_2 ( TYPE_3 . METHOD_4 ( ) , this ) ; VAR_7 = TYPE_4 . METHOD_5 ( ) ; VAR_7 . METHOD_1 ( TYPE_5 . this ) ; }
<|startcomment|> please perform VAR_1 calls a finally block _CODE_ released assert fails <|endcomment|> public void METHOD_1 ( ) { TYPE_1 buf = TYPE_2 . buffer ( ) ; TYPE_3 . METHOD_2 ( new byte [ ] { } , TYPE_4 . METHOD_3 ( buf ) ) ; <START> buf . VAR_1 ( ) ; <END> }
<|startcomment|> please add braces expression reformat <|endcomment|> public String METHOD_1 ( ) { <START> if ( METHOD_2 ( ) == null ) <END> return "" ; return METHOD_2 ( ) . METHOD_3 ( ) ; }
<|startcomment|> calling a method class want drop TYPE_2 prefix <|endcomment|> private static boolean METHOD_1 ( TYPE_1 params ) { Boolean VAR_1 = params . VAR_2 ( ) ; return VAR_1 != null ? VAR_1 : <START> TYPE_2 . METHOD_1 ( params . VAR_3 ( ) . getId ( ) ) ; <END> }
<|startcomment|> 1 Integer VAR_3 a magic number instead ( arguably more logical ) null a lack location fix ? ( need change return type Integer object int primitive ) 2 formatting yuck ! 3 return branch ; else branch return inline instead a VAR_2 variable <|endcomment|> private int METHOD_1 ( ) { final TYPE_1 VAR_1 = METHOD_2 ( ) ; final int VAR_2 ; if ( VAR_1 == null ) { <START> VAR_2 = Integer . VAR_3 ; } <END> else { final TYPE_2 VAR_4 = TYPE_3 . METHOD_3 ( ) . METHOD_4 ( ) ; VAR_2 = VAR_4 . METHOD_5 ( VAR_1 ) ; } return VAR_2 ; }
<|startcomment|> knew <|endcomment|> public void METHOD_1 ( ) { final TYPE_1 VAR_1 = TYPE_2 . create ( 10 , 0 ) ; assertEquals ( VAR_2 , VAR_1 . METHOD_2 ( VAR_3 ) ) ; assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( new TYPE_3 ( 10 ) ) ) ; assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( VAR_1 . METHOD_2 ( VAR_5 ) ) ) ; <START> assertEquals ( VAR_4 , VAR_1 . METHOD_2 ( VAR_1 . METHOD_2 ( VAR_5 ) ) ) ; <END> assertEquals ( VAR_4 , VAR_1 . METHOD_3 ( VAR_1 ) . METHOD_2 ( VAR_5 ) ) ; }
<|startcomment|> worst happen values log message precise <|endcomment|> boolean METHOD_1 ( int VAR_1 ) { synchronized ( VAR_2 ) { boolean VAR_3 = ! VAR_4 . METHOD_2 ( ) && VAR_1 > 0 ; boolean VAR_5 = VAR_4 . METHOD_2 ( ) && VAR_1 > ( int ) ( VAR_4 . METHOD_3 ( ) ) ; <START> return VAR_3 || VAR_5 ; <END> } }
<|startcomment|> preferable create a new method error propagation <|endcomment|> public TYPE_1 get ( ) { if ( VAR_1 == null ) { synchronized ( this ) { if ( VAR_1 == null ) { try { METHOD_1 ( ) ; } catch ( IOException e ) { <START> throw new RuntimeException ( e ) ; <END> } } } } return VAR_1 ; }
<|startcomment|> private ? private method _CODE_ I place new method _CODE_ I don t _CODE_ ( ) method need a recursive search TYPE_1 _CODE_ _CODE_ extended check case <|endcomment|> <START> protected List < TYPE_1 > METHOD_1 ( TYPE_2 VAR_1 ) { <END> List < TYPE_1 > result = new ArrayList < > ( ) ; for ( TYPE_3 e : VAR_1 . METHOD_2 ( ) ) { if ( e instanceof TYPE_1 ) { result . add ( ( TYPE_1 ) e ) ; } else if ( e instanceof TYPE_2 ) { result . addAll ( METHOD_1 ( ( TYPE_2 ) e ) ) ; } } return result ; }
<|startcomment|> simplified TYPE_2 TYPE_3 equals ( METHOD_2 ( ) ) ; <|endcomment|> public boolean METHOD_1 ( ) { <START> return TYPE_2 . TYPE_3 . equals ( METHOD_2 ( ) ) ? true : false ; <END> }
<|startcomment|> I missed a case METHOD_1 null increment VAR_2 <|endcomment|> public Object METHOD_1 ( ) { Object value = VAR_1 . METHOD_1 ( ) ; <START> if ( VAR_2 != null ) { <END> VAR_2 . METHOD_2 ( ) ; } return value ; }
<|startcomment|> unreadable chain logic operations ternary blocks I proper statements preferred more readable <|endcomment|> <START> public String query ( ) { <END> if ( query == null ) { synchronized ( VAR_1 ) { if ( query == null ) { query = path ( ) == uri || VAR_2 == - 1 ? null : VAR_2 > 0 && uri . length ( ) > VAR_2 ? uri . substring ( VAR_2 + 1 ) : TYPE_1 . METHOD_1 ( uri ) ; } } } return query ; }
<|startcomment|> TYPE_1 VAR_8 = super getValue ( VAR_1 VAR_4 ) ; don t miss base class more clear reason overwrite implementation base class want change input raw want add more information returned property <|endcomment|> public TYPE_1 getValue ( TYPE_2 VAR_1 , Object VAR_2 ) throws TYPE_3 { String VAR_3 = "" ; if ( VAR_2 != null ) { VAR_3 = VAR_2 . toString ( ) ; } if ( StringUtils . isEmpty ( VAR_3 ) ) { return null ; } TYPE_4 VAR_4 = VAR_5 . METHOD_1 ( VAR_3 , TYPE_5 . VAR_7 ) ; TYPE_1 VAR_8 = <START> this . METHOD_2 ( VAR_4 , METHOD_3 ( VAR_1 ) ) ; <END> if ( VAR_8 != null ) { VAR_8 . METHOD_4 ( VAR_3 ) ; } return VAR_8 ; }
<|startcomment|> double parantheses obsolete <|endcomment|> public boolean METHOD_1 ( Object target , TYPE_1 VAR_1 ) { if ( target instanceof TYPE_2 && VAR_1 instanceof TYPE_3 ) { TYPE_2 container = ( TYPE_2 ) target ; for ( Object object : <START> ( ( TYPE_3 ) VAR_1 ) ) <END> { TYPE_4 VAR_2 = ( TYPE_4 ) TYPE_5 . METHOD_2 ( object , TYPE_4 . class ) ; if ( VAR_2 != null ) { container . VAR_3 ( ) . METHOD_3 ( VAR_2 , container . VAR_4 ( ) ) ; } } return true ; } return false ; }
<|startcomment|> adding error message <|endcomment|> public static TYPE_1 METHOD_1 ( TYPE_1 node , TYPE_2 type ) { StringBuilder message = new StringBuilder ( STRING_1 + node . getType ( ) + STRING_2 + type ) ; if ( node . VAR_1 ( ) != null && node . VAR_1 ( ) instanceof TYPE_3 ) { <START> message . append ( STRING_3 + ( ( TYPE_3 ) node . VAR_1 ( ) ) . getKey ( ) + STRING_4 ) ; <END> } return new TYPE_4 ( message . toString ( ) ) ; }
<|startcomment|> printing stack trace needed <|endcomment|> public static File METHOD_1 ( TYPE_1 VAR_1 , TYPE_2 props , Logger log ) throws TYPE_3 { File VAR_2 = null ; try { VAR_2 = File . VAR_3 ( STRING_1 , STRING_2 ) ; } catch ( Exception e ) { <START> e . VAR_4 ( ) ; <END> throw new TYPE_3 ( STRING_3 , e ) ; } VAR_1 . METHOD_2 ( VAR_2 , props , log ) ; return VAR_2 ; }
<|startcomment|> reverse order <|endcomment|> public void METHOD_1 ( ) throws Exception { <START> super . METHOD_1 ( ) ; VAR_1 . METHOD_2 ( ) ; <END> }
<|startcomment|> changing contract other compilers match follow existing pattern passnew String [ ] { } <|endcomment|> protected TYPE_1 ( final String [ ] VAR_2 , final String [ ] VAR_3 ) { this . VAR_2 = VAR_2 . METHOD_1 ( ) ; <START> if ( VAR_3 != null ) <END> { this . VAR_3 = ( String [ ] ) VAR_3 . METHOD_1 ( ) ; } else { this . VAR_3 = null ; } }
<|startcomment|> IMO move VAR_1 place i e call view METHOD_1 ( ) add line calls ( METHOD_2 ( ) ) { view _CODE_ ( false ) ; } <|endcomment|> public void METHOD_1 ( TYPE_1 VAR_1 ) { this . VAR_1 = VAR_1 ; <START> if ( ! this . VAR_1 . METHOD_2 ( ) ) { <END> this . VAR_2 . VAR_3 = true ; } }
<|startcomment|> можно просто не указывать настройку sentry dsnлибо явно указать протокол noop : / / ( ) — он используется по умолчаниюдумаю не стоит поверх этого наворачивать ещё какую - то нашу собственную логикудаже без явного вызова TYPE_3 METHOD_4 сентри все равно будет автоматически инициализировать клиент ( и искать dsn в параметрах jvm или энв - переменных ) поэтому доп логика с может привести к странному поведению <|endcomment|> public static void METHOD_1 ( TYPE_1 context ) { TYPE_2 VAR_1 = context . VAR_2 ( TYPE_2 . class ) ; <START> String VAR_3 = METHOD_2 ( VAR_1 . getString ( STRING_1 ) ) . METHOD_3 ( STRING_2 ) ; <END> if ( ! VAR_3 . equals ( STRING_2 ) ) { TYPE_3 . METHOD_4 ( VAR_3 ) ; } }
<|startcomment|> don t methods <|endcomment|> public TYPE_1 value ( String VAR_1 , String ... VAR_2 ) { List < TYPE_2 < ? super String > > VAR_3 = Arrays . stream ( VAR_2 ) . map ( TYPE_3 : : METHOD_1 ) . collect ( Collectors . VAR_4 ( ) ) ; <START> return this . value ( VAR_1 , VAR_3 ) ; <END> }
<|startcomment|> I call TYPE_4 register ( ) method TYPE_4 instance created <|endcomment|> private TYPE_4 ( long VAR_2 , Class < ? extends TYPE_1 > type , String name , boolean VAR_3 ) { super ( VAR_2 , false ) ; this . type = type ; this . name = name ; this . VAR_3 = VAR_3 ; if ( VAR_3 ) { <START> TYPE_1 . TYPE_3 . METHOD_1 ( this ) ; <END> } }
<|startcomment|> flip || <|endcomment|> private static boolean METHOD_1 ( long VAR_1 , long VAR_2 , int VAR_3 ) { <START> return ( VAR_1 > > > VAR_3 ) == ( VAR_2 > > > VAR_3 ) || VAR_3 == VAR_4 ; <END> }
<|startcomment|> VAR_2 _CODE_ names normalize <|endcomment|> <START> private TYPE_1 ( int VAR_2 , int VAR_3 ) { <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_2 - VAR_3 ; }
<|startcomment|> consider TYPE_3 <|endcomment|> protected static void METHOD_1 ( final TYPE_1 VAR_1 ) throws TYPE_2 { if ( TYPE_3 . isEmpty ( VAR_1 . METHOD_2 ( ) ) <START> && ( VAR_1 . METHOD_3 ( ) == null || VAR_1 . METHOD_3 ( ) . isEmpty ( ) ) ) { <END> METHOD_4 ( VAR_1 ) ; } }
<|startcomment|> stuff benefit a Builder defaults ? ; p <|endcomment|> private void METHOD_1 ( int VAR_1 , long VAR_2 , long VAR_3 ) { Optional . VAR_4 ( VAR_5 ) . METHOD_2 ( TYPE_1 : : METHOD_3 ) ; VAR_5 = new TYPE_1 ( VAR_6 , TYPE_3 . VAR_8 , VAR_1 , VAR_2 , <START> VAR_3 , VAR_9 , TYPE_2 . METHOD_4 ( ) ) ; <END> }
<|startcomment|> project VAR_3 ( ) null <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 VAR_1 ) { ANNOTATION_1 ( STRING_1 ) <START> List < TYPE_1 > VAR_2 = ( List < TYPE_1 > ) project . VAR_3 ( ) . METHOD_2 ( ) ; <END> for ( TYPE_1 VAR_4 : VAR_2 ) { if ( VAR_4 . getId ( ) . equals ( VAR_1 . getId ( ) ) ) { return VAR_4 ; } } return null ; }
<|startcomment|> doesn t a getter triggers node visitation ? aren t visiting nodes <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 args ) { if ( args != null ) { <START> super . METHOD_2 ( args , null ) ; <END> return args . VAR_1 ( TYPE_1 . class ) ; } return null ; }
<|startcomment|> return VAR_2 prevent cycling step size zero return VAR_3 <|endcomment|> public Object METHOD_1 ( ) { double value = ( double ) getValue ( ) ; double VAR_1 = VAR_2 ; while ( VAR_1 >= VAR_3 ) { if ( value >= VAR_1 ) { break ; } else { VAR_1 = VAR_1 / 10 ; } } if ( value >= VAR_2 ) { <START> return 0 ; <END> } return value + VAR_1 ; }
<|startcomment|> I don t need drop support expression parameters repository method parameters <|endcomment|> <START> protected Object METHOD_1 ( TYPE_1 VAR_1 , Object value , Object [ ] values ) { <END> return value ; }
<|startcomment|> remove merging <|endcomment|> public TYPE_3 ( TYPE_1 < Object > VAR_2 , TYPE_2 < Object > VAR_3 ) { <START> System . out . println ( STRING_1 + this . getClass ( ) + STRING_2 ) ; <END> this . VAR_2 = VAR_2 ; this . VAR_4 = VAR_3 ; }
<|startcomment|> I thought VAR_1 extensions _CODE_ thought process definition key extensions _CODE_ s yesterday class key ( id ) i missing <|endcomment|> private Optional < Map < String , TYPE_1 > > METHOD_1 ( String VAR_1 ) { TYPE_2 VAR_2 = VAR_1 != null ? VAR_3 . METHOD_2 ( VAR_1 ) : null ; return Optional . VAR_4 ( VAR_2 ) <START> . map ( p - > p . VAR_5 ( VAR_1 ) ) <END> . map ( TYPE_3 : : METHOD_3 ) ; }
<|startcomment|> necessary <|endcomment|> <START> protected void METHOD_1 ( ) throws TYPE_1 { <END> if ( ! VAR_1 ) { throw new TYPE_1 ( STRING_1 , TYPE_3 . TYPE_2 ) ; } }
<|startcomment|> closing connection ? caller attempts execute query closing prepstmt <|endcomment|> public void close ( ) throws TYPE_1 { if ( VAR_1 != null ) { <START> VAR_1 . close ( ) ; <END> VAR_1 = null ; } if ( result != null ) { result . close ( ) ; result = null ; } VAR_2 = "" ; VAR_3 = null ; VAR_4 = true ; parameters = null ; parser = null ; VAR_5 = null ; }
<|startcomment|> METHOD_3 ( ) METHOD_2 String need METHOD_2 <|endcomment|> public String METHOD_1 ( ) { <START> return STRING_1 + TYPE_1 . METHOD_2 ( METHOD_3 ( ) ) + STRING_1 ; <END> }
<|startcomment|> another class named _CODE_ wondering delete class _CODE_ indexing service <|endcomment|> public List < ? extends TYPE_1 > METHOD_1 ( ) { return TYPE_10 < TYPE_1 > asList ( new TYPE_2 ( STRING_1 ) . METHOD_2 ( new TYPE_3 ( TYPE_4 . class , STRING_2 ) , new TYPE_3 ( TYPE_5 . class , STRING_3 ) , new TYPE_3 ( TYPE_6 . class , STRING_4 ) , new TYPE_3 ( TYPE_7 . class , STRING_5 ) , new TYPE_3 ( TYPE_8 . class , STRING_6 ) , <START> new TYPE_3 ( TYPE_9 . class , STRING_7 ) <END> ) ) ; }
<|startcomment|> question <|endcomment|> protected void METHOD_1 ( TYPE_1 resource , IOException exception ) { try { super . METHOD_1 ( resource , exception ) ; <START> } catch ( Exception e ) { <END> } }
<|startcomment|> surprising suggest I guess spent method call call free inlining <|endcomment|> public final Type getType ( ) { if ( VAR_1 == VAR_2 && VAR_3 < VAR_4 ) return Type . VAR_5 ; if ( VAR_1 < VAR_2 && VAR_3 == VAR_4 ) return Type . VAR_6 ; <START> if ( isEmpty ( ) ) <END> return Type . VAR_7 ; return Type . VAR_8 ; }
<|startcomment|> cosmetic : please braces conditions loops thanks ! : ) <|endcomment|> private String METHOD_1 ( long VAR_1 ) { int VAR_2 = INT_1 ; if ( VAR_1 < VAR_2 ) <START> return VAR_1 + STRING_1 ; <END> int VAR_3 = ( int ) ( Math . log ( VAR_1 ) / Math . log ( VAR_2 ) ) ; String VAR_4 = "" + STRING_2 . METHOD_2 ( VAR_3 - 1 ) ; return String . format ( STRING_3 , VAR_1 / Math . VAR_5 ( VAR_2 , VAR_3 ) , VAR_4 ) ; }
<|startcomment|> METHOD_2 return TYPE_1 break future case support more implementations <|endcomment|> private TYPE_1 METHOD_1 ( final TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = null ; if ( this . VAR_2 != null ) { <START> VAR_2 = ( TYPE_1 ) METHOD_2 ( VAR_1 ) ; <END> VAR_2 . METHOD_3 ( ( ( TYPE_1 ) this . VAR_2 ) . METHOD_4 ( ) ) ; VAR_2 . METHOD_5 ( ( ( TYPE_3 ) VAR_1 ) . METHOD_6 ( ) ) ; } return VAR_2 ; }
<|startcomment|> generally s a good idea throws Exception a more specific signature test methods <|endcomment|> <START> public void METHOD_1 ( ) throws TYPE_1 { <END> VAR_1 = new TYPE_2 ( STRING_1 + VAR_2 ) ; }
<|startcomment|> ! [ MINOR ] ( severity : MINOR ) immediately return expression instead assigning temporary variable instance [ ! [ rule ] ( ) ] ( ) <|endcomment|> public TYPE_1 METHOD_1 ( String VAR_1 ) throws TYPE_2 { <START> TYPE_3 instance = VAR_2 . METHOD_2 ( VAR_1 ) ; <END> return instance ; }
<|startcomment|> needs negated <|endcomment|> protected int [ ] METHOD_1 ( TYPE_1 params , int VAR_1 , int VAR_2 ) { final TYPE_2 < int [ ] > VAR_3 = params . VAR_4 ( ) ; <START> if ( query . VAR_5 ( ) . METHOD_2 ( ) ) { <END> return VAR_3 . build ( ) ; } VAR_3 . METHOD_3 ( VAR_1 ) ; VAR_3 . METHOD_4 ( VAR_2 ) ; return query . VAR_6 ( ) . METHOD_5 ( VAR_3 ) . build ( ) ; }
<|startcomment|> don t need a separate function s a oneliner IMO <|endcomment|> protected void METHOD_1 ( TYPE_1 VAR_1 ) { TYPE_2 VAR_2 = VAR_1 . METHOD_2 ( STRING_1 , TYPE_2 . class ) ; assert VAR_2 != null ; METHOD_3 ( VAR_2 ) ; METHOD_4 ( VAR_2 ) ; VAR_2 . METHOD_5 ( new TYPE_3 < TYPE_4 > ( ) { @Override public TYPE_4 get ( ) { return METHOD_6 ( ) . getValue ( ) . METHOD_7 ( ) ; } @Override public void set ( TYPE_4 value ) { <START> METHOD_8 ( value ) ; <END> } } ) ; }
<|startcomment|> spacing ( need new line ) wait s other changes ll need other reviewers <|endcomment|> public static void METHOD_1 ( TYPE_1 channel , TYPE_2 request , String VAR_1 , TYPE_3 status ) { METHOD_1 ( channel , request , VAR_1 , null ) ; <START> } <END>
<|startcomment|> needed cleared init - - force please cleanup <|endcomment|> <START> public void METHOD_1 ( ) throws IOException { <END> if ( ! VAR_1 . isEmpty ( ) ) { throw new IllegalStateException ( STRING_1 + STRING_2 ) ; } try ( TYPE_1 < Path > VAR_2 = TYPE_2 . METHOD_2 ( VAR_3 ) ) { Iterator < Path > it = VAR_2 . iterator ( ) ; while ( it . hasNext ( ) ) { Path path = it . next ( ) ; TYPE_3 . METHOD_3 ( path . VAR_4 ( ) ) ; } } }
<|startcomment|> wrap a <|endcomment|> public void METHOD_1 ( ) throws TYPE_1 , TYPE_2 { when ( VAR_1 . METHOD_2 ( VAR_2 ) ) . METHOD_3 ( TYPE_3 . class ) ; VAR_3 . METHOD_4 ( VAR_1 ) ; VAR_4 . METHOD_5 ( TYPE_3 . class ) ; <START> VAR_3 . METHOD_2 ( VAR_2 ) ; <END> METHOD_6 ( VAR_1 ) . METHOD_2 ( VAR_2 ) ; }
<|startcomment|> return interface ( List ) class <|endcomment|> <START> public ArrayList < TYPE_1 > METHOD_1 ( ) { <END> return this . VAR_1 ; }
<|startcomment|> local variable VAR_4 <|endcomment|> private static ArrayList < TYPE_1 > METHOD_1 ( Collection < TYPE_2 > VAR_1 ) { ArrayList < TYPE_1 > VAR_2 = new ArrayList < > ( ) ; for ( TYPE_2 VAR_3 : VAR_1 ) { TYPE_1 VAR_4 = VAR_3 . METHOD_2 ( ) ; if ( VAR_4 . METHOD_3 ( ) ) { <START> VAR_2 . add ( VAR_3 . METHOD_2 ( ) ) ; <END> } } return VAR_2 ; }
<|startcomment|> index guard ? cleaner standard loopfor ( int i = 0 ; i < mappinsg length ; i + + ) { ( VAR_1 [ i ] VAR_5 ! = TYPE_6 VAR_6 ) return mappinsg [ i ] ; } / / <|endcomment|> private TYPE_1 METHOD_1 ( TYPE_2 project , TYPE_3 file , TYPE_4 configuration ) throws TYPE_5 { TYPE_1 VAR_1 [ ] = TYPE_6 . METHOD_2 ( project , file . VAR_2 ( ) . METHOD_3 ( ) , configuration , VAR_3 . getId ( ) , true ) ; TYPE_1 VAR_4 = VAR_1 [ 0 ] ; int index = 1 ; while ( VAR_4 . VAR_5 == TYPE_6 . VAR_6 ) { <START> VAR_4 = VAR_1 [ index ++ ] ; <END> } return VAR_4 ; }
<|startcomment|> I object I m a fan spring - style magic - - I stuff a JAR classpath ( year java 9 module graph ) JDBI done a great job keeping magic visible I force users a single call TYPE_1 METHOD_1 ( ) _CODE_ stuff opt - <|endcomment|> public static TYPE_1 create ( TYPE_2 VAR_1 ) { TYPE_1 VAR_2 = new TYPE_1 ( VAR_1 ) ; <START> VAR_2 . METHOD_1 ( ) ; <END> return VAR_2 ; }
<|startcomment|> number VAR_1 includes <|endcomment|> public TYPE_1 METHOD_1 ( int VAR_1 ) { if ( VAR_1 < 1 ) { throw new IllegalArgumentException ( STRING_1 ) ; <START> } <END> return new TYPE_1 ( VAR_2 , monitor , VAR_1 , VAR_3 , VAR_4 ) ; }
<|startcomment|> hmm s delegate super method s internal need include original record details suggestionreturn super toString ( ) ; <|endcomment|> public String toString ( ) { <START> return STRING_1 + STRING_2 + VAR_1 . toString ( ) + STRING_3 + super . toString ( ) ; <END> }
<|startcomment|> instead calling METHOD_1 explicitly call ( ) call default constructor TYPE_2 <|endcomment|> public TYPE_2 ( File VAR_2 ) throws TYPE_1 { <START> METHOD_1 ( ) ; <END> METHOD_2 ( VAR_2 ) ; }
<|startcomment|> need declare throws exceptions <|endcomment|> public String METHOD_1 ( ) <START> throws TYPE_1 , TYPE_2 , TYPE_3 { <END> return TYPE_4 . METHOD_2 ( TYPE_5 . class ) . toString ( ) ; }
<|startcomment|> don t forget - add default TTL <|endcomment|> public void METHOD_1 ( String name ) { TYPE_1 VAR_1 = METHOD_2 ( VAR_2 ) ; if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; <START> VAR_1 . options . put ( TYPE_1 . VAR_3 , <END> String . valueOf ( TYPE_1 . VAR_4 ) ) ; METHOD_3 ( VAR_5 , VAR_1 ) ; } TYPE_1 VAR_6 = ( TYPE_1 ) new TYPE_1 ( ) . METHOD_4 ( VAR_1 ) ; VAR_6 . name = name ; METHOD_3 ( VAR_5 , VAR_6 ) ; METHOD_5 ( name ) ; }
<|startcomment|> TYPE_5 METHOD_3 removed avoid calling wrap throw RuntimeException <|endcomment|> private TYPE_1 < TYPE_2 < String > > METHOD_1 ( ) { return result - > { try { String VAR_1 = result . get ( VAR_2 * 100 , TimeUnit . VAR_3 ) ; if ( VAR_1 != null ) { METHOD_2 ( VAR_1 ) ; } } catch ( InterruptedException | TYPE_3 | TYPE_4 e ) { <START> throw TYPE_5 . METHOD_3 ( e ) ; <END> } } ; }
<|startcomment|> style : missing braces <|endcomment|> private void METHOD_1 ( TYPE_1 VAR_1 ) { if ( VAR_1 . METHOD_2 ( ) ) { TYPE_2 uri = VAR_1 . METHOD_3 ( ) . METHOD_4 ( ) ; <START> if ( uri != null ) <END> TYPE_3 . METHOD_1 ( VAR_1 . METHOD_5 ( ) , uri ) ; } }
<|startcomment|> / catch block a constructor e VAR_4 ( ) ? shouldn t TYPE_3 _CODE_ ( config ) ; <|endcomment|> public TYPE_6 ( TYPE_1 config , TYPE_2 VAR_2 ) { this . config = config ; this . VAR_2 = VAR_2 ; this . VAR_3 = new TYPE_3 ( config ) ; try { <START> VAR_3 . METHOD_1 ( ) . METHOD_2 ( true ) ; <END> } catch ( TYPE_4 e ) { e . VAR_4 ( ) ; } this . VAR_5 = TYPE_5 . getInstance ( ) ; }
<|startcomment|> throw IllegalStateException ? bug case <|endcomment|> void METHOD_1 ( int VAR_1 ) { if ( ! VAR_2 . METHOD_2 ( 0 , VAR_1 ) ) { <START> logger . warn ( STRING_1 ) ; <END> } }
<|startcomment|> static <|endcomment|> <START> private void log ( TYPE_1 method , String VAR_1 ) { <END> if ( method . getInstance ( ) != null ) { VAR_2 . add ( VAR_1 + method . getInstance ( ) . getClass ( ) . getName ( ) + STRING_1 + method . VAR_3 ( ) ) ; } else { VAR_2 . add ( VAR_1 + method . VAR_3 ( ) ) ; } }
<|startcomment|> wrong symbols expressions <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 node , ImmutableList . Builder < TYPE_3 > context ) { node . VAR_1 ( ) . values ( ) . forEach ( VAR_2 - > context . add ( VAR_2 . METHOD_2 ( ) ) ) ; node . VAR_3 ( ) . forEach ( VAR_4 - > VAR_4 <START> . forEach ( VAR_5 - > context . add ( VAR_5 . METHOD_3 ( ) ) ) ) ; <END> return super . METHOD_1 ( node , context ) ; }
<|startcomment|> purpose mechanism <|endcomment|> public TYPE_1 METHOD_1 ( TYPE_2 VAR_1 , TYPE_3 VAR_2 ) { TYPE_1 connection = new TYPE_4 ( VAR_1 , VAR_2 , VAR_3 , VAR_4 , VAR_5 ) ; if ( VAR_6 != null ) { VAR_6 . METHOD_2 ( connection , VAR_2 ) ; } <START> return connection ; <END> }
<|startcomment|> s sticking current styleadd finaland return <|endcomment|> private static String METHOD_1 ( final Context context ) { String VAR_1 = context . get ( TYPE_1 . VAR_3 ) ; if ( VAR_1 != null && ! VAR_1 . isEmpty ( ) ) { <START> return context . get ( TYPE_1 . VAR_3 ) ; <END> } else { return VAR_4 ; } }
<|startcomment|> VAR_2 a Path <|endcomment|> private void METHOD_1 ( ) throws IOException { <START> try ( TYPE_1 VAR_1 = new TYPE_1 ( TYPE_2 . get ( VAR_2 ) ) ) { <END> int VAR_3 = 0 ; while ( VAR_1 . METHOD_2 ( ) ) { VAR_4 . add ( VAR_3 ) ; VAR_3 += METHOD_3 ( VAR_1 ) ; } } }
<|startcomment|> simply return TYPE_5 TYPE_6 equals ( event VAR_2 ( ) getType ( ) ) <|endcomment|> public boolean METHOD_1 ( TYPE_1 < TYPE_2 > event ) <START> { <END> TYPE_3 VAR_1 = event . VAR_2 ( ) ; if ( ! TYPE_5 . TYPE_6 . equals ( VAR_1 . getType ( ) ) ) { return false ; } return true ; }
<|startcomment|> mark private <|endcomment|> <START> public Optional < TYPE_1 < String > > METHOD_1 ( String field ) { <END> Optional < String > value = VAR_1 . getValue ( VAR_2 , field ) ; return value . map ( input - > TYPE_2 . METHOD_2 ( STRING_1 ) . split ( input . trim ( ) ) ) ; }
<|startcomment|> typically compare enum values = = instead equals <|endcomment|> private void METHOD_1 ( ) throws TYPE_1 { <START> if ( VAR_1 . equals ( TYPE_3 . VAR_3 ) ) { <END> VAR_4 = new TYPE_2 ( VAR_5 ) . METHOD_2 ( ) ; } else { METHOD_3 ( ) ; } }
<|startcomment|> strings aren t displayed users internationalized <|endcomment|> public Object execute ( TYPE_1 VAR_1 ) throws TYPE_2 { TYPE_3 VAR_2 = TYPE_3 . METHOD_1 ( ) ; <START> TYPE_6 . TYPE_7 . METHOD_2 ( TYPE_5 . bind ( Messages . TYPE_8 , <END> TYPE_9 . VAR_5 ) ) ; VAR_2 . METHOD_3 ( TYPE_9 . VAR_5 ) ; return null ; }
<|startcomment|> I change belong patch <|endcomment|> protected boolean METHOD_1 ( ) { <START> <END> METHOD_2 ( getParameters ( ) . METHOD_3 ( ) == null ? METHOD_4 ( ) . METHOD_5 ( ) : getParameters ( ) . METHOD_3 ( ) ) ; if ( ! super . METHOD_1 ( ) ) { return false ; } if ( METHOD_4 ( ) . getStatus ( ) . equals ( TYPE_1 . VAR_2 ) ) { return METHOD_6 ( TYPE_2 . VAR_4 ) ; } return true ; }
<|startcomment|> interesting s rationale VAR_1 length <|endcomment|> public boolean METHOD_1 ( Object [ ] VAR_1 , TYPE_1 VAR_2 ) { if ( VAR_1 == null ) { return false ; } <START> return TYPE_2 . METHOD_2 ( VAR_1 ) > 0 ; <END> }
<|startcomment|> needs implemented <|endcomment|> public String METHOD_1 ( ) { <START> return null ; <END> }
<|startcomment|> remove ( ) <|endcomment|> private static TYPE_1 METHOD_1 ( TYPE_2 ctx ) { final TYPE_1 VAR_1 = METHOD_2 ( ctx ) . get ( ) ; <START> return ( VAR_1 == null ) ? TYPE_1 . VAR_2 : VAR_1 ; <END> }
<|startcomment|> set feature transient <|endcomment|> public String <START> METHOD_1 ( ) <END> { if ( description == null || description . isEmpty ( ) ) { } return description ; }
<|startcomment|> id - > id <|endcomment|> public String METHOD_1 ( ) { <START> return this . id ; <END> }
<|startcomment|> style : don t braces single line blocks <|endcomment|> private void METHOD_1 ( ) { int i = 0 ; index . clear ( ) ; Entry VAR_1 = VAR_2 ; while ( VAR_1 != null ) { <START> if ( ++ i % 100 == 0 ) { <END> index . add ( VAR_1 ) ; } VAR_1 = VAR_1 . next ; } }
<|startcomment|> remove <|endcomment|> private TYPE_1 METHOD_1 ( ) throws Throwable { <START> System . out . println ( STRING_1 ) ; <END> return new TYPE_1 ( STRING_2 ) ; }
<|startcomment|> return initialized <|endcomment|> public static void METHOD_1 ( TYPE_1 props ) { if ( props == null ) { throw new TYPE_2 ( STRING_1 ) ; } <START> instance = new TYPE_3 ( props ) ; <END> VAR_1 = true ; logger . info ( STRING_2 + TYPE_3 . class . getName ( ) + STRING_3 ) ; }
<|startcomment|> check dropped <|endcomment|> void METHOD_1 ( ) { <START> if ( VAR_1 != null ) { <END> VAR_1 = null ; } TYPE_1 target = this . target . get ( ) ; if ( target == null ) { return ; } TYPE_2 VAR_2 = target . VAR_3 ( ) ; if ( ! VAR_2 . METHOD_2 ( ) ) { return ; } VAR_2 . METHOD_3 ( this ) ; }
<|startcomment|> I rid VAR_2 variable else block <|endcomment|> protected Map < TYPE_1 , TYPE_2 > METHOD_1 ( Map < TYPE_1 , TYPE_2 > source , Map VAR_1 ) { for ( Entry < TYPE_1 , TYPE_2 > entry : source . entrySet ( ) ) { TYPE_1 key = entry . getKey ( ) ; <START> TYPE_1 VAR_2 ; <END> if ( key instanceof String ) { VAR_2 = ( TYPE_1 ) new TYPE_3 ( ( String ) key ) ; } else { VAR_2 = key ; } VAR_1 . put ( VAR_2 , entry . getValue ( ) ) ; } return VAR_1 ; }
<|startcomment|> A graceful shutdown nice _CODE_ _CODE_ ( ) CONNECTION_REJECTED code base alternately reuse _CODE_ exception <|endcomment|> protected void METHOD_1 ( ) throws IOException { if ( VAR_1 <= 0 ) { return ; } int VAR_2 = METHOD_2 ( ) ; if ( VAR_2 >= VAR_1 ) { <START> throw new IOException ( STRING_1 + VAR_2 + STRING_2 + VAR_1 ) ; <END> } }
<|startcomment|> consider a singleton pattern example CONNECT codebase _CODE_ java <|endcomment|> <START> public static TYPE_1 getInstance ( ) { <END> if ( VAR_1 == null ) { VAR_1 = new TYPE_1 ( ) ; } return VAR_1 ; }
<|startcomment|> incorportate debug logging instead ? log fine <|endcomment|> public static TYPE_1 parse ( String VAR_1 , boolean VAR_2 ) throws IOException { TYPE_2 VAR_3 = new TYPE_3 ( ) ; if ( ! VAR_2 ) { VAR_3 . METHOD_1 ( TYPE_4 . VAR_5 ) ; } TYPE_1 VAR_6 = VAR_3 . METHOD_2 ( VAR_1 , TYPE_1 . class ) ; <START> System . out . println ( VAR_6 ) ; <END> return VAR_6 ; }
<|startcomment|> VAR_2 parameter instead true i <|endcomment|> protected TYPE_1 METHOD_1 ( TYPE_1 . TYPE_5 data , TYPE_3 < TYPE_4 > VAR_1 , boolean VAR_2 ) { <START> return new TYPE_1 ( data , VAR_1 , true ) ; <END> }
