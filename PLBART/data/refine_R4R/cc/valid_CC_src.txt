<|startcomment|> style: missing spaces around + <|endcomment|>  private void setupProject() { String packageName = null; String activityName = null; String activityTestName = null; try { /* Grab package and Activity names */ int lastPeriod = mPackageFull.lastIndexOf('.'); packageName = mPackageFull.substring(0, lastPeriod); if (lastPeriod < mPackageFull.length() - 1) { activityName = mPackageFull.substring(lastPeriod+1); <|startfocus|> activityTestName = activityName+"Test"; <|endfocus|> } if (packageName.indexOf('.') == -1) { printHelpAndExit("ERROR: Package name must be composed of at least two java identifiers."); } } catch (RuntimeException e) { printHelpAndExit("ERROR: Invalid package or activity name."); } println("Package: %1$s", packageName); println("Output directory: %1$s", mOutDir); String testsOutDir = mOutDir + File.separator + "tests"; println("Tests directory: %1$s", testsOutDir); if (activityName != null) { println("Activity name: %1$s", activityName); }
<|startcomment|> enable_google_location_features? <|endcomment|>  public static boolean isSupported() { // This class provides a Google-specific location feature, so it's enabled only // when the system property ro.enable_google_location_feat is set. <|startfocus|> if (!SystemProperties.get("ro.enable_google_location_feat").equals("1")) { <|endfocus|> return false; } // Otherwise, assume cell location should work if we are not running in the emulator return !SystemProperties.get("ro.kernel.qemu").equals("1");
<|startcomment|> line length <|endcomment|>  cancelPollState(); return; } if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) { Log.e(LOG_TAG, "RIL implementation has returned an error where it must succeed", ar.exception); } } else try { switch (what) { case EVENT_POLL_STATE_REGISTRATION_CDMA: <|startfocus|> final int offset = 3; //offset, because we don't want the first 3 values in the int-array <|endfocus|> states = (String[])ar.result; int responseValuesRegistrationState[] = { -1, //[0] radioTechnology -1, //[1] baseStationId -1, //[2] baseStationLatitude -1, //[3] baseStationLongitude 0, //[4] cssIndicator; init with 0, because it is treated as a boolean -1, //[5] systemId -1 //[6] networkId }; if (states.length > 0) { try { this.mRegistrationState = Integer.parseInt(states[0]);
<|startcomment|> On 2008/12/03 16:11:16, John Huang wrote: > Is there a particular reason you switched WCDMA and CDMA values? These values > are encoded into a protocol buffer, and may need to match constants defined > elsewhere (eg, on a server). > Done. <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.internal.location.protocol; public interface GCellularPlatformProfile { static final int RADIO_TYPE_GPRS = 3; <|startfocus|> static final int RADIO_TYPE_WCDMA = 4; static final int RADIO_TYPE_CDMA = 5; static final int RADIO_TYPE_EVDO = 6; <|endfocus|> static final int RADIO_TYPE = 1; static final int CARRIER = 2; static final int IP = 3; static final int HOME_MNC = 4; static final int HOME_MCC = 5; } 
<|startcomment|> On 2008/12/05 22:59:40, Wink Saville wrote: > split? Done. <|endcomment|>  switch(this.mRegistrationState) { case ServiceState.REGISTRATION_STATE_HOME_NETWORK: newSS.setExtendedCdmaRoaming(ServiceState.REGISTRATION_STATE_HOME_NETWORK); break; case ServiceState.REGISTRATION_STATE_ROAMING: newSS.setExtendedCdmaRoaming(ServiceState.REGISTRATION_STATE_ROAMING); break; case ServiceState.REGISTRATION_STATE_ROAMING_AFFILIATE: newSS.setExtendedCdmaRoaming(ServiceState.REGISTRATION_STATE_ROAMING_AFFILIATE); break; default: <|startfocus|> Log.w(LOG_TAG, "Received a different registration state, but don't changed the extended cdma roaming mode."); <|endfocus|> } pollStateDone(); } } private void setRssiDefaultValues() { rssi = 99; } /** * A complete "service state" from our perspective is * composed of a handful of separate requests to the radio. * * We make all of these requests at once, but then abandon them * and start over again if the radio notifies us that some * event has changed */ private void pollState() { pollingContext = new int[1]; pollingContext[0] = 0; 
<|startcomment|> CDMA? <|endcomment|> import android.util.Log; import com.android.internal.telephony.CommandsInterface; import com.android.internal.telephony.IccCard; import com.android.internal.telephony.TelephonyProperties; import com.android.internal.telephony.Phone; import com.android.internal.telephony.TelephonyIntents; import android.content.Intent; import android.content.res.Configuration; import android.app.ActivityManagerNative; import static android.Manifest.permission.READ_PHONE_STATE; /** * {@hide} */ // TODO to be implemented public final class RuimCard extends Handler implements IccCard { <|startfocus|> static final String LOG_TAG="RuimCard"; <|endfocus|> //***** Instance Variables private static final boolean DBG = true; private CDMAPhone phone; private CommandsInterface.IccStatus status = null; private boolean mDesiredPinLocked; private boolean mDesiredFdnEnabled; private boolean mRuimPinLocked = true; // default to locked private boolean mRuimFdnEnabled = false; // Default to disabled. // Will be updated when RUIM_READY. // //***** Constants // // FIXME I hope this doesn't conflict with the Dialer's notifications // Nobody is using this at the moment
<|startcomment|> line to long <|endcomment|>  public void getEnhancedVoicePrivacy(Message onComplete) { <|startfocus|> // This function should be overridden by the class CDMAPhone. It is not implemented in the class GSMPhone. Log.e(LOG_TAG, "Error! This function should never be executed, because we have an inactive CDMAPhone then."); <|endfocus|>
<|startcomment|> Yes, you would win. We will go for the old version  <|endcomment|>  private void initManageConferencePanel() { if (DBG) log("initManageConferencePanel()..."); if (mManageConferencePanel == null) { mManageConferencePanel = (ViewGroup) findViewById(R.id.manageConferencePanel); // set up the Conference Call chronometer mConferenceTime = (Chronometer) findViewById(R.id.manageConferencePanelHeader); mConferenceTime.setFormat(getString(R.string.caller_manage_header)); // Create list of conference call widgets <|startfocus|> mConferenceCallList = new ViewGroup[MAX_CALLERS_IN_CONFERENCE]; { <|endfocus|> final int[] viewGroupIdList = {R.id.caller0, R.id.caller1, R.id.caller2, R.id.caller3, R.id.caller4}; for (int i = 0; i < MAX_CALLERS_IN_CONFERENCE; i++) { mConferenceCallList[i] = (ViewGroup) findViewById(viewGroupIdList[i]); } } mButtonManageConferenceDone = (Button) findViewById(R.id.manage_done); mButtonManageConferenceDone.setOnClickListener(this); }
<|startcomment|> It's a bit of an edge case, but this will do the wrong thing when you're paused at the end of a song in "repeat one song" mode, so you need to treat that case separately. <|endcomment|>  public void play() { if (mPlayer.isInitialized()) { // if we are at the end of the song, go to the next song first <|startfocus|> if (mPlayer.position() >= mPlayer.duration() - 1) { <|endfocus|> next(true); } mPlayer.start(); setForeground(true); mWasPlaying = true; NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); RemoteViews views = new RemoteViews(getPackageName(), R.layout.statusbar); views.setImageViewResource(R.id.icon, R.drawable.stat_notify_musicplayer); if (getAudioId() < 0) { // streaming views.setTextViewText(R.id.trackname, getPath()); views.setTextViewText(R.id.artistalbum, null); } else { String artist = getArtistName(); views.setTextViewText(R.id.trackname, getTrackName()); if (artist == null || artist.equals(MediaFile.UNKNOWN_STRING)) { artist = getString(R.string.unknown_artist_name); } String album = getAlbumName(); if (album == null || album.equals(MediaFile.UNKNOWN_STRING)) {
<|startcomment|> > Use h.removeCallbacksAndMessages(null) instead. Done in Patch set 2 <|endcomment|>  public void dispose() { synchronized(PhoneProxy.lockForRadioTechnologyChange) { super.dispose(); //Unregister from all former registered events mCM.unregisterForAvailable(this); //EVENT_RADIO_AVAILABLE mSIMRecords.unregisterForRecordsLoaded(this); //EVENT_SIM_RECORDS_LOADED mCM.unregisterForOffOrNotAvailable(this); //EVENT_RADIO_OFF_OR_NOT_AVAILABLE mCM.unregisterForOn(this); //EVENT_RADIO_ON <|startfocus|> mCM.unregisterForSIMReady(this); //EVENT_SIM_READY <|endfocus|> mSST.unregisterForNetworkAttach(this); //EVENT_REGISTERED_TO_NETWORK mCM.unSetOnUSSD(this); mCM.unSetOnSuppServiceNotification(this); mPendingMMIs.clear(); //Force all referenced classes to unregister their former registered events mStkService.dispose(); mCT.dispose(); mDataConnection.dispose(); mSST.dispose(); mIccFileHandler.dispose(); // instance of SimFileHandler mSIMRecords.dispose(); mSimCard.dispose(); mSimPhoneBookIntManager.dispose(); mSimSmsIntManager.dispose(); mSubInfo.dispose(); }
<|startcomment|> done for patch3. <|endcomment|>  public void dispose() { <|startfocus|> mBaseHandler.removeCallbacksAndMessages(null); if(this.records != null) { this.records.removeAll(this.records); } <|endfocus|> this.records = null; this.mLock = null; this.adnCache = null; this.mBaseHandler = null; this.phone = null;
<|startcomment|> Please add a space after the cast <|endcomment|>  synchronized (Ringer.this) { if (!hasMessages(STOP_RING)) { mRingtone = r; } } } r = mRingtone; if (r != null && !hasMessages(STOP_RING)) { PhoneUtils.setAudioMode(mContext, AudioManager.MODE_RINGTONE); VideoView view = showVideoView(r.isVideo(mContext), true); final PhoneApp app = PhoneApp.getInstance(); final InCallScreen screen = app.getInCallScreenInstance(); <|startfocus|> r.play(screen, (VideoView)view); <|endfocus|> synchronized (Ringer.this) { mRingPending = false; if (mFirstRingStartTime < 0) { mFirstRingStartTime = SystemClock.elapsedRealtime(); } } } break; case STOP_RING: if (DBG) log("mRingHandler: STOP_RING..."); r = (Ringtone) msg.obj; if (r != null) { r.stop(); showVideoView(false, false); } else {
<|startcomment|> minor style issues: remove trailing white space; use spaces instead of tabs. <|endcomment|>  * values:</p> * * <ul> * <li><em>transactionId (Integer)</em> - The WAP transaction * ID</li> * <li><em>pduType (Integer)</em> - The WAP PDU type</li> * <li><em>data</em> - The data payload of the message</li> <|startfocus|> * <li><em>contentTypeParameters (HashMap&lt;String,String&gt;)</em> * - Any parameters associated with the content type * (decoded from the WSP Content-Type header)</li> <|endfocus|> * </ul> * * The contentTypeParameters extra value is map of content parameters * keyed by their names. * * If any unassigned well-known parameters are encountered, the key * of the map will be 'unassigned/0x...', where '...' is the hex value * of the unassigned parameter. */ @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION) public static final String WAP_PUSH_RECEIVED_ACTION =
<|startcomment|> According to Wap-230-Wsp Section 8.4.2.24: Content-general-form = Value-length Media-type Media-type = (Well-known-media | Extension-Media) *(Parameter) So, headersLength - is length of all Media-type, including parameters, not only length of "content type" <|endcomment|>  if (found) { expandWellKnownMimeType(); } return found; } int headersLength = (int)unsigned32bit; mediaPrefixLength = getDecodedDataLength(); if (decodeIntegerValue(startIndex + mediaPrefixLength) == true) { dataLength += mediaPrefixLength; int readLength = dataLength; stringValue = null; expandWellKnownMimeType(); long wellKnownValue = unsigned32bit; String mimeType = stringValue; <|startfocus|> if (readContentParameters(startIndex + dataLength, (headersLength - (dataLength - mediaPrefixLength)), 0)) { <|endfocus|> dataLength += readLength; unsigned32bit = wellKnownValue; stringValue = mimeType; return true; } return false; } if (decodeExtensionMedia(startIndex + mediaPrefixLength) == true) { dataLength += mediaPrefixLength; int readLength = dataLength; expandWellKnownMimeType(); long wellKnownValue = unsigned32bit; String mimeType = stringValue; if (readContentParameters(startIndex + dataLength, (headersLength - (dataLength - mediaPrefixLength)), 0)) { dataLength += readLength; unsigned32bit = wellKnownValue;
<|startcomment|> could you encapsulate this logic into an inner class? new ClearRecentClickListener() for example. this means we dont need to keep around mClearLogConfirmationDialog. <|endcomment|>  protected Dialog onCreateDialog(int id) { Dialog dialog = null; switch (id) { case DIALOG_CONFIRM_CLEAR_LOG: mClearLogConfirmationDialog = new AlertDialog.Builder(this) .setTitle(R.string.clearConfirmation_title) .setIcon(android.R.drawable.ic_dialog_alert) .setMessage(R.string.clearlogConfirmation) .setNegativeButton(android.R.string.cancel, null) <|startfocus|> .setPositiveButton(android.R.string.ok, this) <|endfocus|> .setCancelable(false) .create(); dialog = mClearLogConfirmationDialog; break; } return dialog;
<|startcomment|> what is the point of String.valueOf a string? <|endcomment|>  if (l < 8) { for (int i = 0; i < (8-l); i++) { location = "0" + location; } } try {// set LAC/CID or PSC based on radioType switch (radioType) { case NETWORK_TYPE_GPRS: case NETWORK_TYPE_EDGE: mNetworkType = radioType; mLac = Integer.valueOf(location.substring(0, 4), 16); // check if 0xFFFFFFFF for UNKNOWN_CID <|startfocus|> if (!location.equalsIgnoreCase(String.valueOf("FFFFFFFF"))) { <|endfocus|> mCid = Integer.valueOf(location.substring(4), 16); } break; case NETWORK_TYPE_UMTS: case NETWORK_TYPE_HSDPA: case NETWORK_TYPE_HSUPA: case NETWORK_TYPE_HSPA: mNetworkType = radioType; mPsc = Integer.valueOf(location, 16); break; } } catch (NumberFormatException e) { // parsing location error mPsc = UNKNOWN_CID; mLac = UNKNOWN_CID; mCid = UNKNOWN_CID; mNetworkType = NETWORK_TYPE_UNKNOWN; }
<|startcomment|> you need a 2nd //$NON-NLS-2$ for the 2nd string. (yes, with // too, the 2 means the 2nd string on the line). Becaus the line is >100 col already I'd split it like so: String errMsg = "env var " + SERVER_PORT_ENV_VAR + //$NON-NLS-1$ ": must be >=0, got " //$NON-NLS-1$ <|endcomment|>  } if (adb_env_var != null && adb_env_var.length() > 0) { // C tools (adb, emulator) accept hex and octal port numbers, so need to accept // them too. result = Integer.decode(adb_env_var); if (result <= 0) { <|startfocus|> String errMsg = "env var " + SERVER_PORT_ENV_VAR + ": must be >=0, got " //$NON-NLS-1$ + System.getenv(SERVER_PORT_ENV_VAR); //$NON-NLS-1$ <|endfocus|> throw new IllegalArgumentException(errMsg); } } } catch (NumberFormatException nfEx) { String errMsg = "env var " + SERVER_PORT_ENV_VAR + ": illegal value '" //$NON-NLS-1$ + System.getenv(SERVER_PORT_ENV_VAR) + "'"; //$NON-NLS-1$ throw new IllegalArgumentException(errMsg); } catch (SecurityException secEx) { // A security manager has been installed that doesn't allow access to env vars. // So an environment variable might have been set, but we can't tell.
<|startcomment|> Tabs (same in the changes below) <|endcomment|>  long id = selectedEvent.id; mDeleteEventHelper.delete(begin, end, id, -1); return true; case KeyEvent.KEYCODE_ENTER: switchViews(true /* trackball or keyboard */); return true; case KeyEvent.KEYCODE_BACK: if (event.getRepeatCount() == 0) { event.startTracking(); return true; } return super.onKeyDown(keyCode, event); case KeyEvent.KEYCODE_DPAD_LEFT: if (mSelectedEvent != null) { mSelectedEvent = mSelectedEvent.nextLeft; <|startfocus|> mSelectedLayout = null; <|endfocus|> } if (mSelectedEvent == null) { selectionDay -= 1; } redraw = true; break; case KeyEvent.KEYCODE_DPAD_RIGHT: if (mSelectedEvent != null) { mSelectedEvent = mSelectedEvent.nextRight; mSelectedLayout = null; } if (mSelectedEvent == null) { selectionDay += 1; } redraw = true; break; case KeyEvent.KEYCODE_DPAD_UP: if (mSelectedEvent != null) { mSelectedEvent = mSelectedEvent.nextUp; mSelectedLayout = null; }
<|startcomment|> Spaces around the = sign. <|endcomment|>  for (int i = 0; i < numEvents; i++) { Event event = events.get(i); if (!geometry.computeEventRect(date, left, top, cellWidth, event)) { continue; } if (date == mSelectionDay && !mSelectionAllDay && mComputeSelectedEvents && geometry.eventIntersectsSelection(event, selectionArea)) { mSelectedEvents.add(event); } RectF rf = drawEventRect(event, canvas, p, eventTextPaint); <|startfocus|> StaticLayout layout=getEventLayout(i, event, eventTextPaint, rf); <|endfocus|> drawEventText(layout, rf, canvas, eventTextPaint, NORMAL_TEXT_TOP_MARGIN); } if (date == mSelectionDay && !mSelectionAllDay && isFocused() && mSelectionMode != SELECTION_HIDDEN) { computeNeighbors(); if (mSelectedEvent != null) { RectF rf = drawEventRect(mSelectedEvent, canvas, p, eventTextPaint); StaticLayout layout = getSelectedLayout(eventTextPaint, rf); drawEventText(layout, rf, canvas, eventTextPaint, NORMAL_TEXT_TOP_MARGIN); } }
<|startcomment|> I'm guessing AdtTestData shouldn't be referenced either. Not sure if you want to do this now or not. At some point I'll clean up these tests to not run within Eclipse. Solving bug 2235282 would also help <|endcomment|>  * * http://www.eclipse.org/org/documents/epl-v10.php * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.sdklib.xml; <|startfocus|> import com.android.ide.eclipse.tests.AdtTestData; import com.android.sdklib.io.FileWrapper; <|endfocus|> import junit.framework.TestCase; /** * Tests for {@link AndroidManifestParser} */ public class AndroidManifestParserTest extends TestCase { private ManifestData mManifestTestApp; private ManifestData mManifestInstrumentation; private static final String TESTDATA_PATH = "com/android/ide/eclipse/testdata/"; //$NON-NLS-1$ private static final String INSTRUMENTATION_XML = TESTDATA_PATH + "AndroidManifest-instrumentation.xml"; //$NON-NLS-1$ private static final String TESTAPP_XML = TESTDATA_PATH + "AndroidManifest-testapp.xml"; //$NON-NLS-1$
<|startcomment|> Why are you changing the class used by the Intent? <|endcomment|>  @Override public IBinder onBind(Intent intent) { return null; } /** * Show a notification while this service is running. */ private void showNotification(String text) { // Set the icon, scrolling text and timestamp Notification notification = new Notification(R.drawable.stat_sample, text, System.currentTimeMillis()); // The PendingIntent to launch our activity if the user selects this notification PendingIntent contentIntent = PendingIntent.getActivity(this, 0, <|startfocus|> new Intent(this, ServiceStartArgumentsController.class), 0); <|endfocus|> // Set the info for the views that show in the notification panel. notification.setLatestEventInfo(this, getText(R.string.service_start_arguments_label), text, contentIntent); // We show this for as long as our service is processing a command. notification.flags |= Notification.FLAG_ONGOING_EVENT; // Send the notification. // We use a string id because it is a unique number. We use it later to cancel. mNM.notify(R.string.service_created, notification); } private void hideNotification() {
<|startcomment|> Curious formatting; how about just this: Log.w(TAG, "Unable to create files directory " + mFilesDir.getPath()); [Note the trailing space in "directory "] <|endcomment|>  public File getFilesDir() { synchronized (mSync) { if (mFilesDir == null) { mFilesDir = new File(getDataDirFile(), "files"); } if (!mFilesDir.exists()) { if(!mFilesDir.mkdirs()) { <|startfocus|> Log.w(TAG, "Unable to create files directory(" + mFilesDir.getPath() + ")"); <|endfocus|> return null; } FileUtils.setPermissions( mFilesDir.getPath(), FileUtils.S_IRWXU|FileUtils.S_IRWXG|FileUtils.S_IXOTH, -1, -1); } return mFilesDir; }
<|startcomment|> Perhaps, this code is bit overcomplicated. We want to display phone numbers and corresponding people's names, right? In that case we just need to run one query, against the Phone.CONTENT_URI. It will return phones with the contact names. Contact is always joined with a Data row. The only other precaution would be to make sure we don't return rows with NULL phone numbers, so selection would be Phone.NUMBER + " NOT NULL" <|endcomment|> import com.example.android.apis.R; import android.app.ListActivity; import android.database.Cursor; import android.provider.ContactsContract; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.AdapterView.OnItemSelectedListener; import android.widget.ListAdapter; import android.widget.SimpleCursorAdapter; import android.widget.TextView; /** * A list view example where the data comes from a cursor. */ public class List7 extends ListActivity implements OnItemSelectedListener { <|startfocus|> private static final String[] PEOPLE_PROJECTION = new String[] { ContactsContract.Contacts._ID, ContactsContract.Contacts.DISPLAY_NAME, ContactsContract.Contacts.HAS_PHONE_NUMBER }; <|endfocus|> private static final String[] PHONE_PROJECTION = new String[] { ContactsContract.CommonDataKinds.Phone._ID, ContactsContract.CommonDataKinds.Phone.CONTACT_ID, ContactsContract.CommonDataKinds.Phone.TYPE, ContactsContract.CommonDataKinds.Phone.LABEL, ContactsContract.CommonDataKinds.Phone.NUMBER }; private int mColumnHasPhoneNumber; private int mColumnContactId; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);
<|startcomment|> an orthogonal point (but if this could be addressed here, would be great) is creation of cursor to fetch a single row is less efficient than selecting one column out of the ONLY row this query should have returned. and it is done by SQLiteStatement.simpleQueryForLong(). so, it would be nice to modify this code to simply call that method, like so: String s = (!TextUtils.isEmpty(selection)) ? " where " + selection : ""; return longForQuery(db, "select count(*) from " + table + s, selectionArgs); sorry don't mean to say your code is wrong or anything but this would be a nice optimization to do while you are in this code. <|endcomment|>  public static long queryNumEntries(SQLiteDatabase db, String table, String selection, String[] selectionArgs) { <|startfocus|> Cursor cursor = db.query(table, countProjection, selection, selectionArgs, null, null, null); try { cursor.moveToFirst(); return cursor.getLong(0); } finally { cursor.close(); } <|endfocus|>
<|startcomment|> typo: res_o_lve <|endcomment|>  static String checkSinglePath(String attribute, Path path) { String[] paths = path.list(); if (paths.length != 1) { <|startfocus|> throw new BuildException(String.format("Value for '%1$s' is not valid. It must reslve to a single path", attribute)); <|endfocus|> } return paths[0];
<|startcomment|> missing javadoc for new parameter <|endcomment|>  */ enum TestFailure { /** Test failed due to unanticipated uncaught exception. */ ERROR, /** Test failed due to a false assertion. */ FAILURE } /** * Reports the start of a test run. * * @param testCount total number of tests in test run */ public void testRunStarted(int testCount); /** * Reports end of test run. * <|startfocus|> * @param elapsedTime device reported elapsed time, in milliseconds <|endfocus|> */ public void testRunEnded(long elapsedTime, Map<String, String> resultBundle); /** * Reports test run stopped before completion. * * @param elapsedTime device reported elapsed time, in milliseconds */ public void testRunStopped(long elapsedTime); /** * Reports the start of an individual test case. * * @param test identifies the test */ public void testStarted(TestIdentifier test); /** * Reports the execution end of an individual test case.
<|startcomment|> trailing space <|endcomment|>  Intent in = new Intent(); in.setClassName("com.android.email", "com.android.email.service.MailService"); in.setAction(ACTION_CHECK_MAIL); in.putExtra(EXTRA_CHECK_ACCOUNT, accountId); context.startService(in); } } finally { accountCursor.close(); } } } } } /** * Minimal EMN WAP message decoder application/vnd.wap.emn+wbxml */ private class EmnDecoder { // decode EMN WAP encoded message <|startfocus|> // <|endfocus|> private static final int WBXML_INLINE_STRING = 0x03; private static final int WBXML_TOKEN_MASK = 0x3F; private static final int WBXML_TOKEN_WITH_ATTRS = 0x80; /** * Holds the email address contained in the EMN message after its been * decoded */ public String mEmailAddress; /** * Decodes a wbxml EMN message and stores the email address in it into * mEmailAddress */ public boolean decode(byte[] wbxmlBody) { // the decoded wap in xml looks like
<|startcomment|> no need to initialize these here since you're doing that on 1532-1533 <|endcomment|>  final PackageManager pm = context.getPackageManager(); String lastInputMethodId = Settings.Secure.getString(context .getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD); if (DEBUG) Slog.v(TAG, "Current IME: " + lastInputMethodId); final List<InputMethodInfo> immis = getEnabledInputMethodList(); if (immis == null) { return; } synchronized (mMethodMap) { hideInputMethodMenuLocked(); int N = immis.size(); <|startfocus|> mItems = new CharSequence[N]; mIms = new InputMethodInfo[N]; <|endfocus|> final Map<CharSequence, InputMethodInfo> imMap = new TreeMap<CharSequence, InputMethodInfo>(Collator.getInstance()); for (int i = 0; i < N; ++i) { InputMethodInfo property = immis.get(i); if (property == null) { continue; } imMap.put(property.loadLabel(pm), property); } N = imMap.size(); mItems = imMap.keySet().toArray(new CharSequence[N]); mIms = imMap.values().toArray(new InputMethodInfo[N]); 
<|startcomment|> We don't generally use '@author'. <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.hierarchyviewerlib; import com.android.hierarchyviewerlib.models.DeviceSelectionModel; /** * This is the central point for getting access to the various parts of the * Hierarchy Viewer. Components register themselves with the class using the * setters and can be accessed using the getters. <|startfocus|> * * @author Konstantin Lopyrev <|endfocus|> */ public class ComponentRegistry { private static HierarchyViewerDirector director; private static DeviceSelectionModel deviceSelectionModel; public static HierarchyViewerDirector getDirector() { return director; } public static void setDirector(HierarchyViewerDirector director) { ComponentRegistry.director = director; } public static DeviceSelectionModel getDeviceSelectionModel() { return deviceSelectionModel; } public static void setDeviceSelectionModel(DeviceSelectionModel deviceSelectionModel) { ComponentRegistry.deviceSelectionModel = deviceSelectionModel; } } 
<|startcomment|> For many of these tests, you could simplify this code to simply start and end with an array, e.g. byte[] wsp = new byte[] { 0x03, 0x02, 0x03, 0x14 }; Not critical, but the tests will run a teeny bit faster. <|endcomment|>  out.write(0x3F | 0x80); // Well-known-media, short-integer WspTypeDecoder unit = new WspTypeDecoder(out.toByteArray()); assertTrue(unit.decodeContentType(0)); String mimeType = unit.getValueString(); assertEquals("application/vnd.wap.rollover-certificate", mimeType); assertEquals(0x3F, unit.getValue32()); assertEquals(2, unit.getDecodedDataLength()); } public void testGeneralFormShortLengthWellKnownLongInteger() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); <|startfocus|> out.write(0x03); // Value-length, short-length out.write(0x02); // Well-known-media, long-integer (2 octets) out.write(0x03); // long int byte 1 out.write(0x14); // long int byte 2 <|endfocus|> WspTypeDecoder unit = new WspTypeDecoder(out.toByteArray()); assertTrue(unit.decodeContentType(0)); String mimeType = unit.getValueString(); assertEquals("application/oma-directory+xml", mimeType); assertEquals(0x0314, unit.getValue32()); assertEquals(4, unit.getDecodedDataLength()); 
<|startcomment|> sorry to keep nit-picking but this could now be an if/then as well. I think with the previous change the that change it will be very readable and clear! <|endcomment|>  byte[] header = new byte[headerLength]; System.arraycopy(pdu, headerStartIndex, header, 0, header.length); int dataIndex = headerStartIndex + headerLength; byte[] intentData; String permission; if(binaryContentType == WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO) { intentData = pdu; } else { intentData = new byte[pdu.length - dataIndex]; System.arraycopy(pdu, dataIndex, intentData, 0, intentData.length); } <|startfocus|> switch (binaryContentType) { case WspTypeDecoder.CONTENT_TYPE_B_MMS: permission = "android.permission.RECEIVE_MMS"; break; default: permission = "android.permission.RECEIVE_WAP_PUSH"; break; <|endfocus|> } Intent intent = new Intent(Intents.WAP_PUSH_RECEIVED_ACTION); intent.setType(mimeType); intent.putExtra("transactionId", transactionId); intent.putExtra("pduType", pduType); intent.putExtra("header", header); intent.putExtra("data", intentData); intent.putExtra("contentTypeParameters", pduDecoder.getContentParameters()); mSmsDispatcher.dispatch(intent, permission); return Activity.RESULT_OK;
<|startcomment|> You can just return new String(....) and no blank line needed between that and the following } catch { line <|endcomment|>  return null; } // expect in line string which is the email address if (wbxmlBody[i + 1] != WBXML_INLINE_STRING) { return null; } i += 2; // the string is null terminated so count to the null to // determine it length int j = i; while (wbxmlBody[j] != 0) { j++; } String value = new String(wbxmlBody, i, j-i); return value; <|startfocus|> <|endfocus|> } catch (ArrayIndexOutOfBoundsException e) { if (Email.DEBUG) { Log.d(Email.LOG_TAG, "ArrayIndexOutOfBoundsException while handling " + "CONTENT_MIME_TYPE_B_EMN"); } } catch (Exception e) { if (Email.DEBUG) { Log.d(Email.LOG_TAG, "Exception while handling CONTENT_MIME_TYPE_B_EMN " + e); } } return null;
<|startcomment|> more precision about the coordinate system (same than accelerometer) <|endcomment|>  * * <p> Note that some proximity sensors only support a binary "close" or "far" measurement. * In this case, the sensor should report its maxRange value in the "far" state and a value * less than maxRange in the "near" state. * * <p>{@link android.hardware.Sensor#TYPE_GRAVITY Sensor.TYPE_GRAVITY}:<p> * A three dimensional vector indicating the direction and magnitude of gravity. Units <|startfocus|> * are m/s^2. <|endfocus|> * * <p>{@link android.hardware.Sensor#TYPE_LINEAR_ACCELERATION Sensor.TYPE_LINEAR_ACCELERATION}:<p> * A three dimensional vector indicating acceleration along each device axis, not including * gravity. All values have units of m/s^2. * * <p>{@link android.hardware.Sensor#TYPE_ROTATION_VECTOR Sensor.TYPE_ROTATION_VECTOR}:<p> * The rotation vector represents the orientation of the device as a combination of an angle * and an axis, in which the device has rotated through an angle theta around an axis
<|startcomment|> Will hasWifi get toggled back to false in this for loop if FEATURE_WIFI is not the last available feature? <|endcomment|>  // roll over all known features & check whether device reports them boolean present = false; int statusIcon; for (Feature f : ALL_FEATURES) { HashMap<String, Object> row = new HashMap<String, Object>(); listViewData.add(row); present = actualFeatures.containsKey(f.name); if (present) { // device reports it -- yay! set the happy icon <|startfocus|> hasWifi = PackageManager.FEATURE_WIFI.equals(f.name); hasTelephony = PackageManager.FEATURE_TELEPHONY.equals(f.name); <|endfocus|> statusIcon = R.drawable.fs_good; actualFeatures.remove(f.name); } else if (!present && f.required) { // it's required, but device doesn't report it. Boo, set the bogus icon statusIcon = R.drawable.fs_error; } else { // device doesn't report it, but it's not req'd, so can't tell if there's a problem statusIcon = R.drawable.fs_indeterminate; } row.put("feature", f.name); row.put("icon", statusIcon); } 
<|startcomment|> With the suggested changes above, I don't think you need this method. Essentially, what the API will provide is: - addRoute: adds a generic route. Could be default route, host route, host route via gateway, or anything else. Takes dst, prefixlen, and gw. gw can be null. - addDefaultRoute: adds a default route. Doesn't take dst, because it's either 0.0.0.0 or :: depending on whether gw is IPv4 or IPv6. Doesn't take prefixLen, because it's always 0. gw must not be null. - addHostRoute: adds a route to a host. The route may be directly connected or via a gateway. Takes dst and gw, but gw can be null if it's directly connected. Doesn't take prefixLen because it's either 32 or 128 depending on whether dst is IPv4 or IPv6. <|endcomment|>  public static boolean addHostRoute(String interfaceName, InetAddress hostAddress) { int prefixLength; <|startfocus|> String dst = hostAddress.getHostAddress(); String gw; <|endfocus|> if (hostAddress instanceof Inet4Address) { prefixLength = 32; gw = "0.0.0.0"; } else if (hostAddress instanceof Inet6Address) { prefixLength = 128; gw = "::"; } else { Log.w(TAG, "addHostRoute failure: address is neither IPv4 nor IPv6" + "(" + dst + ")"); return false; } return addRoute(interfaceName, dst, prefixLength, gw) == 0;
<|startcomment|> The comment seems incorrect now. Is this a concern? <|endcomment|>  return ((mBearerData != null) && (mBearerData.numberOfMessages > 0)); } /** * {@inheritDoc} */ public boolean isMwiDontStore() { return ((mBearerData != null) && (mBearerData.numberOfMessages > 0) && (mBearerData.userData == null)); } /** * Returns the status for a previously submitted message. <|startfocus|> * For not interfering with status codes from GSM, this status code is * shifted to the bits 31-16. <|endfocus|> */ public int getStatus() { return status; } /** Return true iff the bearer data message type is DELIVERY_ACK. */ public boolean isStatusReportMessage() { return (mBearerData.messageType == BearerData.MESSAGE_TYPE_DELIVERY_ACK); } /** * Note: This function is a GSM specific functionality which is not supported in CDMA mode. */ public boolean isReplyPathPresent() { Log.w(LOG_TAG, "isReplyPathPresent: is not supported in CDMA mode."); return false; } /**
<|startcomment|> Why would we not pause the current activity when turning off the screen? I think this is fundamentally wrong -- the screen is no longer off, so the activity can't be seen. Further, at this point there are no guarantees about when the device CPU will next wake up, so we really need to tell the activity to pause so it can stop monitoring GPS, sensors, etc. <|endcomment|>  mScreenOnBroadcastDone, mHandler, 0, null, null); } else { synchronized (mLocks) { EventLog.writeEvent(EventLogTags.POWER_SCREEN_BROADCAST_STOP, 2, mBroadcastWakeLock.mCount); mBroadcastWakeLock.release(); } } } else if (value == 0) { mScreenOffStart = SystemClock.uptimeMillis(); policy.screenTurnedOff(why); try { <|startfocus|> if (activityCallState == ACTIVITY_CANCEL_PAUSE) { activityCallState = ACTIVITY_STATE_DEFAULT; } else { ActivityManagerNative.getDefault().goingToSleep(); } <|endfocus|> } catch (RemoteException e) { // ignore it. } if (mContext != null && ActivityManagerNative.isSystemReady()) { mContext.sendOrderedBroadcast(mScreenOffIntent, null, mScreenOffBroadcastDone, mHandler, 0, null, null); } else { synchronized (mLocks) { EventLog.writeEvent(EventLogTags.POWER_SCREEN_BROADCAST_STOP, 3, mBroadcastWakeLock.mCount); mBroadcastWakeLock.release(); } } } else {
<|startcomment|> extra whitespace <|endcomment|> import java.net.URISyntaxException; import java.net.URL; import java.util.ArrayList; import java.util.HashSet; import java.util.regex.Pattern; /** * Classpath container initializer responsible for binding {@link AndroidClasspathContainer} to * {@link IProject}s. This removes the hard-coded path to the android.jar. */ public class AndroidClasspathContainerInitializer extends ClasspathContainerInitializer { public static final String SOURCES_ZIP = "/sources.zip"; //$NON-NLS-1$ <|startfocus|> public static final String COM_ANDROID_IDE_ECLIPSE_ADT_SOURCE = <|endfocus|> "com.android.ide.eclipse.source"; //$NON-NLS-1$ private static final String ANDROID_API_REFERENCE = "http://developer.android.com/reference/"; //$NON-NLS-1$ private final static String PROPERTY_ANDROID_API = "androidApi"; //$NON-NLS-1$ private final static String PROPERTY_ANDROID_SOURCE = "androidSource"; //$NON-NLS-1$ /** The container id for the android framework jar file */ public final static String CONTAINER_ID = "com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"; //$NON-NLS-1$ 
<|startcomment|> Looks like this would be where we set the default to Profile.ALL...? <|endcomment|>  System.setProperty("javax.net.ssl.trustStore", "/etc/security/cacerts.bks"); TimeZone.setDefault(TimeZone.getTimeZone("GMT")); if (arguments != null) { String classArg = arguments.getString(ARGUMENT_TEST_CLASS); mSingleTest = classArg != null && classArg.contains("#"); String profileArg = arguments.getString(ARGUMENT_PROFILE); if (profileArg != null) { mProfile = Profile.valueOf(profileArg.toUpperCase()); } else { <|startfocus|> mProfile = Profile.HANDHELD; <|endfocus|> } } else { mProfile = Profile.HANDHELD; } // attempt to disable keyguard, if current test has permission to do so // TODO: move this to a better place, such as InstrumentationTestRunner ? if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD) == PackageManager.PERMISSION_GRANTED) { Log.i(TAG, "Disabling keyguard"); KeyguardManager keyguardManager = (KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE); keyguardManager.newKeyguardLock("cts").disableKeyguard(); } else {
<|startcomment|> We don't care whether it was empty or not, only whether you want to delete all folders recursively or not. <|endcomment|>  // if it's a folder, delete derived member. if (rootResource.getType() == IResource.FOLDER) { IFolder folder = (IFolder)rootResource; IResource[] members = folder.members(); boolean wasNotEmpty = members.length > 0; for (IResource member : members) { removeDerivedResources(member, true /*deleteRoot*/, monitor); } // if the folder had content that is now all removed, delete the folder. <|startfocus|> if (deleteRoot && wasNotEmpty && folder.members().length > 0) { <|endfocus|> rootResource.getLocation().toFile().delete(); } } // if the root resource is derived, delete it. if (rootResource.isDerived()) { rootResource.getLocation().toFile().delete(); } } } } 
<|startcomment|> remove adb from comment <|endcomment|>  private Package scanTools(File toolFolder, ISdkLog log) { // Can we find some properties? Properties props = parseProperties(new File(toolFolder, SdkConstants.FN_SOURCE_PROP)); // We're not going to check that all tools are present. At the very least <|startfocus|> // we should expect to find adb, android and an emulator adapted to the current OS. <|endfocus|> Set<String> names = new HashSet<String>(); for (File file : toolFolder.listFiles()) { names.add(file.getName()); } if (!names.contains(SdkConstants.androidCmdName()) || !names.contains(SdkConstants.FN_EMULATOR)) { return null; } // Create our package. use the properties if we found any. try { ToolPackage pkg = new ToolPackage( null, //source props, //properties 0, //revision null, //license "Tools", //description null, //descUrl Os.getCurrentOs(), //archiveOs Arch.getCurrentArch(), //archiveArch toolFolder.getPath() //archiveOsPath
<|startcomment|> nitpick: no javadoc for fillAlpha <|endcomment|>  * foreground color should be set * @param fill A color descriptor for the background color, or null if no * foreground color should be set * @param lineWidth The line width, in pixels, or 0 if no line width should * be set * @param lineStyle The SWT line style - such as {@link SWT#LINE_SOLID}. * @param strokeAlpha The alpha value, an integer in the range 0 to 255 <|startfocus|> * where 0 is fully transparent and 255 is fully opaque. <|endfocus|> */ private SwtDrawingStyle(RGB stroke, int strokeAlpha, RGB fill, int fillAlpha, int lineWidth, int lineStyle) { mStroke = stroke; mFill = fill; mLineWidth = lineWidth; mLineStyle = lineStyle; mStrokeAlpha = strokeAlpha; mFillAlpha = fillAlpha; } /** * Convenience constructor for typical drawing styles, which do not specify * a fill and use a standard thickness line *
<|startcomment|> Operate_s_ <|endcomment|>  /** * A node handler is a callback which operates on a Node, such as for example * the implementation of an XML editing operation via * {@link INode#editXml(String, INodeHandler)}. * <p> * <b>NOTE: This is not a public or final API; if you rely on this be prepared * to adjust your code for the next tools release.</b> * </p> */ public interface INodeHandler { /** <|startfocus|> * Operate on the given node. <|endfocus|> * * @param node The node to be operated on */ void handle(INode node); } 
<|startcomment|> This makes TextView behave differently from all other views. I don't think it is an improvement for this one particular class to be inconsistent with others. <|endcomment|>  int attr = a.getIndex(i); switch (attr) { case com.android.internal.R.styleable.View_focusable: focusable = a.getBoolean(attr, focusable); break; case com.android.internal.R.styleable.View_clickable: clickable = a.getBoolean(attr, clickable); break; case com.android.internal.R.styleable.View_longClickable: longClickable = a.getBoolean(attr, longClickable); break; } } a.recycle(); setFocusable(focusable); setClickable(clickable); setLongClickable(longClickable); <|startfocus|> prepareCursorControllers(); <|endfocus|> } private void setTypefaceByIndex(int typefaceIndex, int styleIndex) { Typeface tf = null; switch (typefaceIndex) { case SANS: tf = Typeface.SANS_SERIF; break; case SERIF: tf = Typeface.SERIF; break; case MONOSPACE: tf = Typeface.MONOSPACE; break; } setTypeface(tf, styleIndex); } @Override public void setEnabled(boolean enabled) { if (enabled == isEnabled()) { return; } if (!enabled) {
<|startcomment|> nit: spaces after "//" <|endcomment|>  private void enqueueMessageForSending(SmsTracker tracker) { synchronized (mPendingMessagesList) { mPendingMessagesList.add(tracker); if (LOCAL_LOGD) { Log.d(TAG, "Added message to the pending queue. Queue size is " + mPendingMessagesList.size()); } <|startfocus|> //Trigger sending only if there are no other messages being sent right now //i.e. the queue was empty before we added this message to it <|endfocus|> if (mPendingMessagesList.size() == 1) { sendSms(tracker); } }
<|startcomment|> Good catch. This one should probably be checking for IllegalAccessError. <|endcomment|>  public void testVFE9() { //@uses dot.junit.opcodes.filled_new_array_range.d.T_filled_new_array_range_11 //@uses dot.junit.opcodes.filled_new_array_range.TestStubs T_filled_new_array_range_11 t = new T_filled_new_array_range_11(); try { t.run(); <|startfocus|> fail("expected NoClassDefFoundError exception"); } catch (NoClassDefFoundError e) { <|endfocus|> // expected }
<|startcomment|> Style: I no longer use under_score variable names and I try to keep my style consistent :-) Please change them to camelCase. E.g. xmlNode and sseDoc. <|endcomment|> <|startfocus|> public String getXmlText(Node xml_node) { <|endfocus|> String data = null; IStructuredModel model = getModelForRead(); try { IStructuredDocument sse_doc = getStructuredDocument(); if (xml_node instanceof NodeContainer) { // The easy way to get the source of an SSE XML node. data = ((NodeContainer) xml_node).getSource(); } else if (xml_node instanceof IndexedRegion && sse_doc != null) { // Try harder. IndexedRegion region = (IndexedRegion) xml_node; int start = region.getStartOffset(); int end = region.getEndOffset(); if (end > start) { data = sse_doc.get(start, end - start); } } } catch (BadLocationException e) { // the region offset was invalid. ignore. } finally { model.releaseFromRead(); } return data;
<|startcomment|> Can/should we switch from arrays to List<ILayoutViewInfo> ? <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.layoutlib.api; /** * Layout information for a specific view object */ public interface ILayoutViewInfo { /** * Returns the list of children views. */ <|startfocus|> ILayoutViewInfo[] getChildren(); <|endfocus|> /** * Returns the key associated with the node. * @see IXmlPullParser#getViewKey() */ Object getViewKey(); /** * Returns the actual layout object. This can be used * to query */ Object getLayoutObject(); /** * Returns the name of the view. */ String getName(); /** * Returns the left of the view bounds. */ int getLeft(); /** * Returns the top of the view bounds. */ int getTop(); /**
<|startcomment|> looks like nativeIndexOfString is no longer used after this CL? could you remove it altogether, including in android_util_StringBlock.cpp? <|endcomment|>  } else { mStrings = new CharSequence[num]; } } String str = nativeGetString(mNative, idx); CharSequence res = str; int[] style = nativeGetStyle(mNative, idx); if (localLOGV) Log.v(TAG, "Got string: " + str); if (localLOGV) Log.v(TAG, "Got styles: " + style); if (style != null) { if (mStyleIDs == null) { mStyleIDs = new StyleIDs(); } <|startfocus|> <|endfocus|> for (int styleIndex = 0; styleIndex < style.length; styleIndex += 3) { int styleId = style[styleIndex]; if (styleId == mStyleIDs.boldId || styleId == mStyleIDs.italicId || styleId == mStyleIDs.underlineId || styleId == mStyleIDs.ttId || styleId == mStyleIDs.bigId || styleId == mStyleIDs.smallId || styleId == mStyleIDs.subId || styleId == mStyleIDs.supId || styleId == mStyleIDs.strikeId || styleId == mStyleIDs.listItemId
<|startcomment|> Shouldn't that be %1$s%2$s (e.g. add in 2$ for the second string) ? <|endcomment|>  // Kludge: use targetXml==null as a signal this is a new file being created targetXml = null; } edit = createXmlReplaceEdit(targetXml, xmlStringId, tokenString, status); } catch (IOException e) { error = e.toString(); } catch (CoreException e) { // Failed to read file. Ignore. Will handle error below. error = e.toString(); } if (edit == null) { <|startfocus|> status.addFatalError(String.format("Failed to modify file %1$s%s", <|endfocus|> mTargetXmlFileWsPath, error == null ? "" : ": " + error)); //$NON-NLS-1$ return null; } editGroup = new TextEditGroup(targetXml == null ? "Create <string> in new XML file" : "Insert <string> in XML file", edit); xmlChange.setEdit(edit); // The TextEditChangeGroup let the user toggle this change on and off later. xmlChange.addTextEditChangeGroup(new TextEditChangeGroup(xmlChange, editGroup)); subMonitor.worked(1);
<|startcomment|> 100 columns. <|endcomment|>  File imageFolder = systemImage.getLocation(); userdataSrc = new File(imageFolder, USERDATA_IMG); } } if (userdataSrc == null || !userdataSrc.exists()) { log.error(null, "Unable to find a '%1$s' file for ABI %2$s to copy into the AVD folder.", USERDATA_IMG, abiType); needCleanup = true; return null; } File userdataDest = new File(avdFolder, USERDATA_IMG); <|startfocus|> copyImageFile(userdataSrc, userdataDest); if (userdataDest.exists() == false) { log.error(null, "Unable to create '%1$s' file in the AVD folder.", userdataDest); needCleanup = true; return null; <|endfocus|> } // Config file. HashMap<String, String> values = new HashMap<String, String>(); if (setImagePathProperties(target, abiType, values, log) == false) { log.error(null, "Failed to set image path properties in the AVD folder."); needCleanup = true; return null; } 
<|startcomment|> Just for the record, I'm not a fan of a unit test that relies on scanning stdout/stderr to know if it worked. It's just too fragile. And no I don't have a better suggestion for you. <|endcomment|>  public void testCreateAvdWithoutSnapshot() { mAvdManager.createAvd( mAvdFolder, this.getName(), mTarget, null, null, null, false, false, mLog); assertEquals("[P Created AVD '" + this.getName() + "' based on Android 0.0\n]", <|startfocus|> mLog.messages.toString()); <|endfocus|> assertTrue("Expected config.ini in " + mAvdFolder, new File(mAvdFolder, "config.ini").exists()); Map<String, String> map = ProjectProperties.parsePropertyFile( new FileWrapper(mAvdFolder, "config.ini"), mLog); assertEquals("HVGA", map.get("skin.name")); assertEquals("platforms/v0_0/skins/HVGA", map.get("skin.path")); assertEquals("platforms/v0_0/images/", map.get("image.sysdir.1")); assertEquals(null, map.get("snapshot.present")); assertTrue("Expected userdata.img in " + mAvdFolder, new File(mAvdFolder, "userdata.img").exists()); assertFalse("Expected NO snapshots.img in " + mAvdFolder,
<|startcomment|> Move this line between CommandsInterface and SmsHeader. <|endcomment|> import android.app.PendingIntent.CanceledException; import android.content.ContentValues; import android.content.Intent; import android.content.SharedPreferences; import android.database.Cursor; import android.database.SQLException; import android.os.AsyncResult; import android.os.Message; import android.os.SystemProperties; import android.provider.Telephony; import android.provider.Telephony.Sms.Intents; import android.preference.PreferenceManager; import android.util.Config; import android.util.Log; import android.telephony.SmsManager; import android.telephony.SmsMessage.MessageClass; <|startfocus|> import com.android.internal.telephony.PhoneBase; import com.android.internal.telephony.TelephonyProperties; <|endfocus|> import com.android.internal.telephony.CommandsInterface; import com.android.internal.telephony.SmsHeader; import com.android.internal.telephony.SmsMessageBase; import com.android.internal.telephony.SMSDispatcher; import com.android.internal.telephony.SmsMessageBase.TextEncodingDetails; import com.android.internal.telephony.cdma.SmsMessage; import com.android.internal.telephony.cdma.sms.SmsEnvelope; import com.android.internal.telephony.cdma.sms.UserData; import com.android.internal.util.HexDump; import java.io.ByteArrayOutputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.lang.Boolean; 
<|startcomment|> Another style issue (sorry): please use braces around the conditional block. <|endcomment|>  // Change the system setting Settings.System.putInt(mContext.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, enabling ? 1 : 0); // Post the intent Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED); intent.putExtra("state", enabling); mContext.sendBroadcast(intent); // There is no modem or it is not known so don't rely on the // service state or the intent response. if (mRadioTech == ServiceState.RADIO_TECHNOLOGY_UNKNOWN) <|startfocus|> onAirplaneModeChanged(); <|endfocus|>
<|startcomment|> we don't put author tags. <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.sdkmanager; import com.android.sdklib.ISdkLog; import java.util.ArrayList; import java.util.Formatter; <|startfocus|> /** * @author weasel@google.com (Your Name Here) * */ <|endfocus|> public class MockLog implements ISdkLog { private ArrayList<String> mMessages = new ArrayList<String>(); private void add(String code, String format, Object... args) { mMessages.add(new Formatter().format(code + format, args).toString()); } @Override public void warning(String format, Object... args) { add("W ", format, args); } @Override public void printf(String format, Object... args) { add("P ", format, args); } @Override
<|startcomment|> setRingerMode() has never been used so far in native code. Do you have a special need for it? <|endcomment|>  private void setRingerModeInt(int ringerMode, boolean persist) { mRingerMode = ringerMode; AudioSystem.setRingerMode(ringerMode, 0); // Mute stream if not previously muted by ringer mode and ringer mode <|startfocus|> // is not RINGER_MODE_NORMAL and stream is affected by ringer mode. <|endfocus|> // Unmute stream if previously muted by ringer mode and ringer mode // is RINGER_MODE_NORMAL or stream is not affected by ringer mode. int numStreamTypes = AudioSystem.getNumStreamTypes(); for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) { if (isStreamMutedByRingerMode(streamType)) { if (!isStreamAffectedByRingerMode(streamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL || (streamType == AudioSystem.STREAM_RING && (mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET) || mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE)))) { mStreamStates[streamType].mute(null, false); mRingerModeMutedStreams &= ~(1 << streamType); } } else {
<|startcomment|> Is this meant to be empty? Either don't override it or explain why it's empty <|endcomment|> <|startfocus|> public void setFocus() { <|endfocus|>
<|startcomment|> The app should check that the device supports FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT before allowing simultaneous pan/zoom. Devices that do not report this feature return touch data that results in jumpy, inconsistent, and unexpected motion when using two-finger input for more than simple in-place zoom. Something like mSupportPanAndZoom = context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT); in the constructor and checking it here would be sufficient. <|endcomment|>  public boolean onScale(ScaleGestureDetector detector) { final GridLayer layer = mLayer; float scale = detector.getScaleFactor(); if (Float.isInfinite(scale) || Float.isNaN(scale)) return true; mScale = scale * mScale; boolean performTranslation = true; <|startfocus|> if (layer.getState() == GridLayer.STATE_FULL_SCREEN) { <|endfocus|> float currentScale = layer.getZoomValue(); if (currentScale <= 1.0f) performTranslation = false; final Vector3f retVal = new Vector3f(); final Vector3f retValCenter = new Vector3f(); final Vector3f retValPrev = new Vector3f(); if (performTranslation) { float posX = detector.getFocusX(); float posY = detector.getFocusY(); posX -= (mCamera.mWidth / 2); posY -= (mCamera.mHeight / 2); mCamera.convertToRelativeCameraSpace(posX, posY, 0, retVal); mCamera.convertToRelativeCameraSpace(0, 0, 0, retValCenter); // For support two-finger panning float posPrevX = detector.getPrevFocusX();
<|startcomment|> style: space after if, space around == <|endcomment|>  public String getArchImageTail() { if(CanRunOnMultiArchs().length==0) { // Use legacy directory structure <|startfocus|> return ""; <|endfocus|> } else { return mProcessorType + File.separator; }
<|startcomment|> NON-NLS-1$ <|endcomment|>  sb.append(" name=\""); //$NON-NLS-1$ sb.append(name); sb.append('"'); sb.append('>'); sb.append(value); sb.append('<').append('/'); sb.append(type.getName()); sb.append(">\n"); //$NON-NLS-1$ sb.append('<').append('/').append(root).append('>').append('\n'); String result = sb.toString(); String error = null; try { <|startfocus|> byte[] buf = result.getBytes("UTF8"); <|endfocus|> InputStream stream = new ByteArrayInputStream(buf); IFile file = mProject.getFile(new Path(projectPath)); file.create(stream, true /*force*/, null /*progress*/); return name; } catch (UnsupportedEncodingException e) { error = e.getMessage(); } catch (CoreException e) { error = e.getMessage(); } error = String.format("Failed to generate %1$s: %2$s", name, error); AdtPlugin.displayError("New Android XML File", error); } return null;
<|startcomment|> I'd be okay with just changing MountService#getSecureContainerPath to return null instead of throwing IllegalArgumentException. <|endcomment|>  try { int rc = getMountService().mountSecureContainer(cid, key, ownerUid); if (rc != StorageResultCode.OperationSucceeded) { Log.i(TAG, "Failed to mount container " + cid + " rc : " + rc); return null; } return getMountService().getSecureContainerPath(cid); } catch (RemoteException e) { Log.e(TAG, "MountService running?"); <|startfocus|> } catch (IllegalArgumentException iae) { Log.e(TAG, "mountSdDir failed to mount container " + cid); <|endfocus|> } return null;
<|startcomment|> Looking at the usage of this, I think we should have getImagePath(String abi) replace getPath(IAndroidTarget.IMAGES) + getPathForAbi(String abi) It would return the full path to the image. No need for manual concatenation. It's just a better API. Remove IAndroidTarget.IMAGES so that it's not used anymore. <|endcomment|>  /** * Returns the USB Vendor ID for the vendor of this target. * <p/>If the target defines no USB Vendor ID, then the method return 0. */ int getUsbVendorId(); /** * Returns array of permitted processor architectures * <p/>If a single Processor is permitted, returns empty array */ public String[] getAbiList(); /** <|startfocus|> * Returns string to append to images directory for current ProcessorType */ public String getPathForAbi(String abiType); <|endfocus|> /** * Returns whether the given target is compatible with the receiver. * <p/> * This means that a project using the receiver's target can run on the given target. * <br/> * Example: * <pre> * CupcakeTarget.canRunOn(DonutTarget) == true * </pre>. * * @param target the IAndroidTarget to test. */ boolean canRunOn(IAndroidTarget target); /** * Returns a string able to uniquely identify a target.
<|startcomment|> 2011? <|endcomment|> <|startfocus|> * Copyright (C) 2009 The Android Open Source Project <|endfocus|> * * Licensed under the Eclipse Public License, Version 1.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.eclipse.org/org/documents/epl-v10.php * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.ide.eclipse.adt.internal.editors.layout.refactoring; import com.android.ide.eclipse.adt.internal.editors.layout.LayoutEditor; import org.eclipse.jface.action.IAction; import org.eclipse.ltk.ui.refactoring.RefactoringWizard; import org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation; /** * Action executed when the "Convert Layout" menu item is invoked. */ public class ChangeLayoutAction extends VisualRefactoringAction {
<|startcomment|> hasResourcesOfType might read better -- "if (resources.hasResourcesOfType(DRAWABLE))" -- but perhaps the name gets a bit on the long side <|endcomment|> <|startfocus|> public boolean hasResources(ResourceType type) { <|endfocus|> return mPublicResourceMap.get(type).size() > 0;
<|startcomment|> findCorresponding <|endcomment|> <|startfocus|> private static Element findEquivalent(Element element, String targetId) { <|endfocus|> String id = element.getAttributeNS(ANDROID_URI, ATTR_ID); if (id != null) { // Work around DOM bug if (id.equals(targetId)) { return element; } else if (id.startsWith(ID_PREFIX)) { id = NEW_ID_PREFIX + id.substring(ID_PREFIX.length()); if (id.equals(targetId)) { return element; } } } NodeList children = element.getChildNodes(); for (int i = 0, n = children.getLength(); i < n; i++) { Node node = children.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element child = (Element) node; Element match = findEquivalent(child, targetId); if (match != null) { return match; } } } return null;
<|startcomment|> These could use more descriptive names for those unfamiliar with the quirks of the resource system. t -> type; e -> entry; OT -> tableOffset (?); etc <|endcomment|> public class CacheManager_CacheResultTest extends ActivityInstrumentationTestCase2<WebViewStubActivity> { private static final long NETWORK_OPERATION_DELAY = 10000l; private WebView mWebView; private CtsTestServer mWebServer; public CacheManager_CacheResultTest() { super("com.android.cts.stub", WebViewStubActivity.class); } @Override protected void setUp() throws Exception { super.setUp(); mWebView = getActivity().getWebView(); <|startfocus|> mWebView.setWebChromeClient(new WebChromeClient()); // to be added for waiver <|endfocus|> } @Override protected void tearDown() throws Exception { if (mWebServer != null) { mWebServer.shutdown(); } super.tearDown(); } @TestTargets({ @TestTargetNew( level = TestLevel.COMPLETE, method = "getInputStream", args = {} ), @TestTargetNew( level = TestLevel.COMPLETE, method = "getContentLength", args = {} ), @TestTargetNew( level = TestLevel.COMPLETE, method = "getETag", args = {} ), @TestTargetNew(
<|startcomment|> I'm also curious about what other kinds of selectors you envision. Don't need to put it in the code, just curious. I'm picturing xpath-ish stuff and just want to make sure that the current selector scheme doesn't box us in. Once we make an API we can't really change it. <|endcomment|> import org.python.core.ArgParser; import org.python.core.ClassDictInit; import org.python.core.Py; import org.python.core.PyException; import org.python.core.PyInteger; import org.python.core.PyObject; import java.util.Set; /** * Extends {@link MonkeyDevice} to support looking up views using a 'selector'. * Currently, only identifiers can be used as a selector. All methods on * MonkeyDevice can be used on this class in Python. * <|startfocus|> * TODO: Implement richer set of selectors. <|endfocus|> */ @MonkeyRunnerExported(doc = "MonkeyDevice with easier methods to refer to objects.") public class EasyMonkeyDevice extends PyObject implements ClassDictInit { public static void classDictInit(PyObject dict) { JythonUtils.convertDocAnnotationsForClass(EasyMonkeyDevice.class, dict); } private MonkeyDevice mDevice; private HierarchyViewer mHierarchyViewer; private static final Set<String> EXPORTED_METHODS = ImmutableSet.of( "touch", "type", "exists", "visible", "getFocusedWindowId"); @MonkeyRunnerExported(doc = "Creates EasyMonkeyDevice with an underlying MonkeyDevice.",
<|startcomment|> extra line. <|endcomment|> import java.util.Iterator; import java.util.logging.Level; import javax.imageio.ImageIO; import javax.imageio.ImageWriter; import javax.imageio.stream.ImageOutputStream; /** * MonkeyImage interface. */ public interface IMonkeyImage { BufferedImage createBufferedImage(); BufferedImage getBufferedImage(); IMonkeyImage getSubImage(int x, int y, int w, int h); byte[] convertToBytes(String format); boolean writeToFile(String path, String format); int getPixel(int x, int y); boolean sameAs(IMonkeyImage other, double percent); <|startfocus|> <|endfocus|> } 
<|startcomment|> Change "read/write" to "copy" for clarity. <|endcomment|>  if (length > mLength) { throw new ArrayIndexOutOfBoundsException(); } stream.write(mBuffer, mIndex, length); } /** * Write a new byte. * @param src Byte to write. */ public void write(byte src) { acquire(1); mBuffer[mIndex + mLength] = src; mLength++; } /** * Read bytes from a byte array and add to unconsumed bytes. <|startfocus|> * Will read/write src.length bytes. <|endfocus|> * @param src Array to read from. */ public void write(byte[] src) { write(src, 0, src.length); } /** * Read bytes from a byte array and add to unconsumed bytes. * Will read/write (src.length - srcOffset) bytes. * @param src Array to read from. * @param srcOffset Offset into source array. */ public void write(byte[] src, int srcOffset) { write(src, srcOffset, src.length - srcOffset); } /**
<|startcomment|> Maybe break this out into a separate call, waitForResult(status)? <|endcomment|>  try { mLock.wait(); } catch (InterruptedException e) { logd("interrupted while trying to update by search"); } } return success; } /** * Update an ADN-like EF record by record index * * This is useful for iteration the whole ADN file, such as write the whole <|startfocus|> * phone book or erase/format the whole phonebook. Currently the email field * if set in the ADN record is ignored. <|endfocus|> * throws SecurityException if no WRITE_CONTACTS permission * * @param efid must be one among EF_ADN, EF_FDN, and EF_SDN * @param newTag adn tag to be stored * @param newPhoneNumber adn number to be stored * Set both newTag and newPhoneNubmer to "" means to replace the old * record with empty one, aka, delete old record * @param index is 1-based adn record index to be updated * @param pin2 required to update EF_FDN, otherwise must be null * @return true for success
<|startcomment|> Use a for loop to avoid creation of a temporary iterator. <|endcomment|>  } if (pi.mPid != 0) { mServiceProcessesByPid.remove(pi.mPid); } continue; } Iterator<ServiceItem> sit = pi.mServices.values().iterator(); while (sit.hasNext()) { ServiceItem si = sit.next(); if (si.mCurSeq != mSequence) { changed = true; sit.remove(); } } } } <|startfocus|> for (Iterator<Integer> iterator = uidToDelete.iterator(); iterator.hasNext();) { int uid = iterator.next(); mServiceProcessesByName.remove(uid); } <|endfocus|> if (changed) { // First determine an order for the services. ArrayList<ProcessItem> sortedProcesses = new ArrayList<ProcessItem>(); for (int i=0; i<mServiceProcessesByName.size(); i++) { for (ProcessItem pi : mServiceProcessesByName.valueAt(i).values()) { pi.mIsSystem = false; pi.mIsStarted = true; pi.mActiveSince = Long.MAX_VALUE; for (ServiceItem si : pi.mServices.values()) {
<|startcomment|> nit: all these exceptions text are probably not visible. Since it's done, keep it :-) <|endcomment|>  public abstract void onNextFromStartDocument(); public abstract void onNextFromStartTag(); public abstract void onNextFromEndTag(); // --- basic implementation of IXmlPullParser --- public void setFeature(String name, boolean state) throws XmlPullParserException { if (FEATURE_PROCESS_NAMESPACES.equals(name) && state) { return; } if (FEATURE_REPORT_NAMESPACE_ATTRIBUTES.equals(name) && state) { return; } <|startfocus|> throw new XmlPullParserException(AdtMessages.BasePullParser_Unsupported_Feature + name); <|endfocus|> } public boolean getFeature(String name) { if (FEATURE_PROCESS_NAMESPACES.equals(name)) { return true; } if (FEATURE_REPORT_NAMESPACE_ATTRIBUTES.equals(name)) { return true; } return false; } public void setProperty(String name, Object value) throws XmlPullParserException { throw new XmlPullParserException(AdtMessages.BasePullParser_SetProperty_Not_Supported); } public Object getProperty(String name) { return null; } public void setInput(Reader in) throws XmlPullParserException { throw new XmlPullParserException(AdtMessages.BasePullParser_SetInput_Not_Supported); }
<|startcomment|> this. not needed <|endcomment|>  * @return the resulting rendered image wrapped in an {@link RenderSession} */ /** * Sets the {@link LayoutLog} to be used during rendering. If none is specified, a * silent logger will be used. * * @param log the log to be used * @return this (such that chains of setters can be stringed together) */ <|startfocus|> public RenderService setLog(LayoutLog log) { this.mLogger = log; <|endfocus|> return this; } /** * Sets the model to be rendered, which can be different than the editor's own * {@link GraphicalEditorPart#getModel()}. * * @param model the model to be rendered * @return this (such that chains of setters can be stringed together) */ public RenderService setModel(UiDocumentNode model) { mModel = model; return this; } /** * Sets the width and height to be used during rendering (which might be adjusted if
<|startcomment|> typo (resource>resources) <|endcomment|>  * file is a .class file. Upon visiting all the delta resource, if this * flag is true, then we know we'll have to make the "classes.dex" file. */ private boolean mConvertToDex = false; /** * PNG Cache update flag. This is set to true if one of the changed/added/removed <|startfocus|> * files is a .png file. Upon visiting all the delta resource, if this <|endfocus|> * flag is true, then we know we'll have to update the PNG cache */ private boolean mUpdateCrunchCache = false; /** * Package resources flag. This is set to true if one of the changed/added/removed * file is a resource file. Upon visiting all the delta resource, if * this flag is true, then we know we'll have to repackage the resources. */ private boolean mPackageResources = false; /** * Final package build flag. */ private boolean mBuildFinalPackage = false; private AndroidPrintStream mOutStream = null;
<|startcomment|> oops need to fix this. <|endcomment|> <|startfocus|> * Copyright (C) 2007 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.ide.common.resources.configuration; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * Resource Qualifier for Screen Pixel Density. */ public final class ScreenHeightQualifier extends ResourceQualifier { /** Default screen size value. This means the property is not set */ final static int DEFAULT_SIZE = -1; 
<|startcomment|> I would appreciate if you added a comment here explaining where atexit() is implemented and the reason why. <|endcomment|>  // FIXME: instead of recreating R.java from scratch, maybe copy // the files (R.java and manifest.java)? This would force to replace // the package line on the fly. callAapt(libPkg); } } } } } /** * Calls aapt with the given parameters. * @param resourceFilter the resource configuration filter to pass to aapt (if configName is * non null) * @param customPackage an optional custom package. */ <|startfocus|> private void callAapt(String customPackage) { <|endfocus|> Project taskProject = getProject(); final boolean generateRClass = mRFolder != null && new File(mRFolder).isDirectory(); if (generateRClass) { } else if (mResourceFilter == null) { System.out.println("Creating full resource package..."); } else { System.out.println(String.format( "Creating resource package with filter: (%1$s)...", mResourceFilter)); } // create a task for the default apk. ExecTask task = new ExecTask(); task.setExecutable(mExecutable);
<|startcomment|> You can just put action in the argument of Intent constructor. <|endcomment|>  public void testCamera() { PackageManager packageManager = mContext.getPackageManager(); if (packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA)) { Intent intent = new Intent(); intent.setAction(android.provider.MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA); <|startfocus|> assertCanBeHandled(intent); <|endfocus|> }
<|startcomment|> null is the default value for uninitialized members of Object type <|endcomment|>  * to access DRM agents through the DRM framework. * */ public class DrmManagerClient { /** * Indicates that a request was successful or that no error occurred. */ public static final int ERROR_NONE = 0; /** * Indicates that an error occurred and the reason is not known. */ public static final int ERROR_UNKNOWN = -2000; <|startfocus|> HandlerThread mInfoThread = null; HandlerThread mEventThread = null; <|endfocus|> private static final String TAG = "DrmManagerClient"; static { // Load the respective library System.loadLibrary("drmframework_jni"); } /** * Interface definition for a callback that receives status messages and warnings * during registration and rights acquisition. */ public interface OnInfoListener { /** * Called when the DRM framework sends status or warning information during registration * and rights acquisition. * * @param client The <code>DrmManagerClient</code> instance. * @param event The {@link DrmInfoEvent} instance that wraps the status information or 
<|startcomment|> Yes, this test is very strict. At this point in time, we're not willing to change it from what it is now which allows for some rounding errors. <|endcomment|>  protected void onPreExecute() { mBitmap = getBitmap(); mReferenceBitmap = BitmapAssets.getBitmap(getApplicationContext(), mBitmapName); <|startfocus|> final float tolerance = 0.01f; // 1% mSame = compareTo(mBitmap, mReferenceBitmap, tolerance); <|endfocus|>
<|startcomment|> Maybe add this one to AdtConstants instead where we have all the other file extensions -- and I think the convention we're usually using is "DOT_" as a prefix for an extension when it includes the dot <|endcomment|> import java.io.FileNotFoundException; import java.io.IOException; import java.net.MalformedURLException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Properties; import java.util.Set; public class LibraryClasspathContainerInitializer extends BaseClasspathContainerInitializer { private final static String ATTR_SRC = "src"; //$NON-NLS-1$ private final static String ATTR_DOC = "doc"; //$NON-NLS-1$ <|startfocus|> private final static String EXT_PROPERTIES = ".properties"; //$NON-NLS-1$ <|endfocus|> public LibraryClasspathContainerInitializer() { } /** * Updates the {@link IJavaProject} objects with new library. * @param androidProjects the projects to update. * @return <code>true</code> if success, <code>false</code> otherwise. */ public static boolean updateProjects(IJavaProject[] androidProjects) { try { // Allocate a new AndroidClasspathContainer, and associate it to the library // container id for each projects. int projectCount = androidProjects.length; IClasspathContainer[] containers = new IClasspathContainer[projectCount];
<|startcomment|> Why do we still need status bar height at all? <|endcomment|>  long statusbarHeight = mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height); DisplayMetrics metrics = new DisplayMetrics(); WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); wm.getDefaultDisplay().getMetrics(metrics); //Use middle of the screen or statusbarHeight +1 if not enought final long x = metrics.heightPixels/2; <|startfocus|> final long y = (metrics.heightPixels/2) > statusbarHeight+1 ? (metrics.heightPixels/2):statusbarHeight+1; <|endfocus|> final int metaState = 0; mMotionEvent = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_DOWN, x, y, metaState); mIntent = new Intent(mContext, InstrumentationTestActivity.class); mIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity = (InstrumentationTestActivity) mInstrumentation.startActivitySync(mIntent); } protected void tearDown() throws Exception { mInstrumentation = null; mIntent = null; if (mActivity != null) { mActivity.finish(); } super.tearDown(); } @TestTargetNew( level = TestLevel.COMPLETE,
<|startcomment|> 2012? <|endcomment|> <|startfocus|> * Copyright (C) 2007 The Android Open Source Project <|endfocus|> * * Licensed under the Eclipse Public License, Version 1.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.eclipse.org/org/documents/epl-v10.php * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.ide.eclipse.adt.internal.editors.layout.configuration; import com.android.ide.eclipse.adt.AdtPlugin; import org.eclipse.jface.viewers.LabelProvider; import org.eclipse.jface.window.Window; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.dialogs.AbstractElementListSelectionDialog; /**
<|startcomment|> nit: no space in "( fos" <|endcomment|>  public void saveSettings() { FileOutputStream fos = null; String path = null; try { String folder = AndroidLocation.getFolder(); File f = new File(folder, SETTINGS_FILENAME); path = f.getPath(); fos = new FileOutputStream(f); <|startfocus|> mSettings.mProperties.store( fos, "## Settings for Android Tool"); //$NON-NLS-1$ <|endfocus|> } catch (Exception e) { if (mSdkLog != null) { // This is important enough that we want to really nag the user about it String reason = null; if (e instanceof FileNotFoundException) { reason = "File not found"; } else if (e instanceof AndroidLocationException) { reason = ".android folder not found, please define ANDROID_SDK_HOME"; } else if (e.getMessage() != null) { reason = String.format("%1$s: %2$s", e.getClass().getSimpleName(), e.getMessage()); } else { reason = e.getClass().getName(); } 
<|startcomment|> 100 columns <|endcomment|>  // we found something info = new ContactInfo(); info.lookupUri = UriUtils.parseUriOrNull(c.getString(CallLogQuery.CACHED_LOOKUP_URI)); info.name = c.getString(CallLogQuery.CACHED_NAME); info.type = c.getInt(CallLogQuery.CACHED_NUMBER_TYPE); info.label = c.getString(CallLogQuery.CACHED_NUMBER_LABEL); String matchedNumber = c.getString(CallLogQuery.CACHED_MATCHED_NUMBER); <|startfocus|> info.number = matchedNumber == null ? c.getString(CallLogQuery.NUMBER) : matchedNumber; <|endfocus|> info.normalizedNumber = c.getString(CallLogQuery.CACHED_NORMALIZED_NUMBER); info.photoId = c.getLong(CallLogQuery.CACHED_PHOTO_ID); info.photoUri = null; // We do not cache the photo URI. info.formattedNumber = c.getString(CallLogQuery.CACHED_FORMATTED_NUMBER); } else { //nothing of interest info = ContactInfo.EMPTY; } }finally { c.close(); } } else { //somthing went south with the query info = null; } return info;
<|startcomment|> this makes the name and presentation package-limited. GsmConnection and CdmaConnection are not in the same package and this won't compile. <|endcomment|>  */ package com.android.internal.telephony; import android.util.Log; /** * {@hide} */ public abstract class Connection { // Number presentation type for caller id display public static int PRESENTATION_ALLOWED = 1; // normal public static int PRESENTATION_RESTRICTED = 2; // block by user public static int PRESENTATION_UNKNOWN = 3; // no specified or unknown by network public static int PRESENTATION_PAYPHONE = 4; // show pay phone info //Caller Name Display <|startfocus|> String cnapName; int cnapNamePresentation = PRESENTATION_ALLOWED; <|endfocus|> private static String LOG_TAG = "TelephonyConnection"; public enum DisconnectCause { NOT_DISCONNECTED, /* has not yet disconnected */ INCOMING_MISSED, /* an incoming call that was missed and never answered */ NORMAL, /* normal; remote */ LOCAL, /* normal; local hangup */ BUSY, /* outgoing call to busy line */ CONGESTION, /* outgoing call to congested network */ MMI, /* not presently used; dial() returns null */ INVALID_NUMBER, /* invalid dial string */
<|startcomment|> returnValue doesn't seem to be set anywhere, so it is going to be null? <|endcomment|>  || Flags.isInterface(modifiers) || Flags.isEnum(modifiers)) { return false; } return true; } }; } }); dialogHolder.set(dialog); dialog.setTitle("Choose Activity Class"); dialog.setMessage("Select an Activity class (? = any character, * = any string):"); if (dialog.open() == IDialogConstants.CANCEL_ID) { return null; } <|startfocus|> if (returnValue.get() != null) { return returnValue.get(); } <|endfocus|> Object[] types = dialog.getResult(); if (types != null && types.length > 0) { return ((IType) types[0]).getFullyQualifiedName(); } } catch (JavaModelException e) { AdtPlugin.log(e, null); } catch (CoreException e) { AdtPlugin.log(e, null); } return null;
<|startcomment|> delete this line? <|endcomment|>  template.setBackupMergedFiles(false); // Generate basic output skeleton Map<String, Object> paramMap = new HashMap<String, Object>(); addProjectInfo(paramMap); return template.render(mProject, paramMap); } @Override protected boolean performFinish(final IProgressMonitor monitor) throws InvocationTargetException { try { IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot(); String name = mValues.projectName; mProject = root.getProject(name); <|startfocus|> //return mActivityValues.computeChanges(); <|endfocus|> final TemplateHandler template = mValues.template; // We'll be merging in an activity template, but don't create *~ backup files // of the merged files (such as the manifest file) in that case. template.setBackupMergedFiles(false); ProjectPopulator projectPopulator = new ProjectPopulator() { @Override public void populate(IProject project) throws InvocationTargetException { // Copy in the proguard file; templates don't provide this one. // add the default proguard config File libFolder = new File(AdtPlugin.getOsSdkToolsFolder(), SdkConstants.FD_LIB); try {
<|startcomment|> change hasX to isX <|endcomment|> <|startfocus|> private boolean hasWindowsExecutableExtension(String extension) { <|endfocus|> return extension != null && WINDOWS_NATIVE_EXECUTABLES.contains(extension);
<|startcomment|> nit: document that null is allowed <|endcomment|>  static final String INCOMPLETE_RUN_ERR_MSG_PREFIX = "Test run failed to complete"; /** * Creates the InstrumentationResultParser. * * @param runName the test run name to provide to * {@link ITestRunListener#testRunStarted(String, int)} * @param listeners informed of test results as the tests are executing */ public InstrumentationResultParser(String runName, Collection<ITestRunListener> listeners) { mTestRunName = runName; mTestListeners = new ArrayList<ITestRunListener>(listeners); } /** * Creates the InstrumentationResultParser for a single listener. * <|startfocus|> * @param runName the test run name to provide to * {@link ITestRunListener#testRunStarted(String, int)} <|endfocus|> * @param listener informed of test results as the tests are executing */ public InstrumentationResultParser(String runName, ITestRunListener listener) { mTestRunName = runName; mTestListeners = new ArrayList<ITestRunListener>(1); mTestListeners.add(listener); } /** * Processes the instrumentation test output from shell. *
<|startcomment|> s/secureRandom/cachedSecureRandomService/? <|endcomment|>  public static void flushCachesAndRefreshServicesIfNeeded() { synchronized (providers) { if (needRefresh) { refreshNumber++; synchronized (services) { services.clear(); } secureRandom = null; for (Provider p : providers) { initServiceInfo(p); } needRefresh = false; <|startfocus|> } <|endfocus|> }
<|startcomment|> when operating on _floats_, no? <|endcomment|>  * {@code android.util.FloatMath} methods to avoid casting. */ public class MathDetector extends Detector implements Detector.ClassScanner { /** The main issue discovered by this detector */ public static final Issue ISSUE = Issue.create( "FloatMath", //$NON-NLS-1$ "Suggests replacing android.util.FloatMath calls with java.lang.Math", "In older versions of Android, using android.util.FloatMath was recommended " + <|startfocus|> "for performance reasons when operating on doubles. However, on modern hardware " + <|endfocus|> "doubles are just as fast as float (though they take more memory), and in " + "recent versions of Android, FloatMath is actually slower than using java.lang.Math " + "due to the way the JIT optimizes java.lang.Math. Therefore, you should use " + "Math instead of FloatMath if you are only targeting Froyo and above.", Category.PERFORMANCE, 3, Severity.WARNING, MathDetector.class, Scope.CLASS_FILE_SCOPE).setMoreInfo(
<|startcomment|> not optional <|endcomment|>  if (!msg.endsWith("\n")) { System.out.println(); } } /** * Prints an info message. * <p/> * The output is done on {@link System#out}. * <p/> * This is displayed only if the logging {@link Level} is {@link Level#INFO} or higher. * <|startfocus|> * @param msgFormat is an optional error format. If non-null, it will be printed * using a {@link Formatter} with the provided arguments. <|endfocus|> * @param args provides the arguments for msgFormat. */ @Override public void info(String msgFormat, Object... args) { if (mLevel.mLevel > Level.INFO.mLevel) { return; } String msg = String.format(msgFormat, args); if (SdkConstants.CURRENT_PLATFORM == SdkConstants.PLATFORM_WINDOWS && !msg.endsWith("\r\n") && msg.endsWith("\n")) { // remove last \n so that println can use \r\n as needed.
<|startcomment|> hmm good plan <|endcomment|>  } mCurrentKeyboardLayout = descriptor; } } else if (parser.getName().equals("calibration")) { String format = parser.getAttributeValue(null, "format"); String rotation = parser.getAttributeValue(null, "rotation"); if (format == null) { throw new XmlPullParserException( "Missing format attribute on calibration."); } <|startfocus|> if (rotation == null) { throw new XmlPullParserException( "Missing rotation attribute on calibration."); } <|endfocus|> if (!format.equals("affine")) { throw new XmlPullParserException( "Unsupported format for calibration."); } try { stringToSurfaceRotation(rotation); } catch (Exception e) { throw new XmlPullParserException( "Unsupported rotation for calibration."); } float[] matrix = TouchCalibration.IDENTITY.getAffineTransform(); int depth = parser.getDepth(); while (XmlUtils.nextElementWithin(parser, depth)) { String tag = parser.getName().toLowerCase(); String value = parser.nextText(); 
<|startcomment|> why do you need this loop? The code above (right below "nothing found" comment already knows the pid that needs to be cleared. Add to it with clearDnsIfaceForPid(myPid) and you're done, right? We can leave off removing the use of system properties for now - it makes the change too big. <|endcomment|>  continue; } NetworkStateTracker nt = mNetTrackers[i]; if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) { LinkProperties p = nt.getLinkProperties(); if (p == null) continue; List pids = mNetRequestersPids[i]; for (int j=0; j<pids.size(); j++) { Integer pid = (Integer)pids.get(j); if (pid.intValue() == myPid) { Collection<InetAddress> dnses = p.getDnses(); writePidDns(dnses, myPid); if (doBump) { bumpDns(); <|startfocus|> } <|endfocus|> return; } } } } // nothing found - delete for (int i = 1; ; i++) { String prop = "net.dns" + i + "." + myPid; if (SystemProperties.get(prop).length() == 0) { if (doBump) { bumpDns(); } return; } SystemProperties.set(prop, ""); } } // return true if results in a change
<|startcomment|> No, I meant inside the if (tracker.mRetryCount > 0) below and then you can print it all the time. <|endcomment|>  protected void sendSms(SmsTracker tracker) { HashMap<String, Object> map = tracker.mData; byte smsc[] = (byte[]) map.get("smsc"); byte pdu[] = (byte[]) map.get("pdu"); Message reply = obtainMessage(EVENT_SEND_SMS_COMPLETE, tracker); <|startfocus|> if (com.android.internal.telephony.Phone.DEBUG_PHONE) { <|endfocus|> Log.d(TAG, "sendSms: " +" mRetryCount="+tracker.mRetryCount +" mMessageRef="+tracker.mMessageRef +" SS=" +mPhone.getServiceState().getState()); } if (tracker.mRetryCount > 0) { // per TS 23.040 Section 9.2.3.6: If TP-MTI SMS-SUBMIT (0x01) type // TP-RD (bit 2) is 1 for retry // and TP-MR is set to previously failed sms TP-MR if (((0x01 & pdu[0]) == 0x01)) { pdu[0] |= 0x04; // TP-RD pdu[1] = (byte) tracker.mMessageRef; // TP-MR } }
<|startcomment|> fix comment style here and else where: /** * Notifies ... <|endcomment|>  notifyPinLockedRegistrantsIfNeeded(r); } public void unregisterForLocked(Handler h) { mPinLockedRegistrants.remove(h); } /** * Notifies handler of any transition into State.NETWORK_LOCKED */ public void registerForNetworkLocked(Handler h, int what, Object obj) { Registrant r = new Registrant (h, what, obj); mNetworkLockedRegistrants.add(r); notifyNetworkLockedRegistrantsIfNeeded(r); } public void unregisterForNetworkLocked(Handler h) { mNetworkLockedRegistrants.remove(h); } <|startfocus|> /** Notifies specified registrant. <|endfocus|> * * @param r Registrant to be notified. If null - all registrants will be notified */ private synchronized void notifyReadyRegistrantsIfNeeded(Registrant r) { if (mDestroyed) { return; } if (mAppState == AppState.APPSTATE_READY) { if (mPin1State == PinState.PINSTATE_ENABLED_NOT_VERIFIED || mPin1State == PinState.PINSTATE_ENABLED_BLOCKED || mPin1State == PinState.PINSTATE_ENABLED_PERM_BLOCKED) { loge("Sanity check failed! APPSTATE is ready while PIN1 is not verified!!!");
<|startcomment|> can we say anything more about what it is? perhaps include the getClass().getName()? <|endcomment|>  * inaccessible at any time, since the mapped file region can be modified by * another thread or process at any time. If this happens, the behavior of the * {@code MappedByteBuffer} is undefined. */ public abstract class MappedByteBuffer extends ByteBuffer { final DirectByteBuffer wrapped; private final MapMode mapMode; MappedByteBuffer(ByteBuffer directBuffer) { super(directBuffer.capacity, directBuffer.block); if (!directBuffer.isDirect()) { <|startfocus|> throw new IllegalArgumentException("directBuffer is not a direct buffer!"); <|endfocus|> } this.wrapped = (DirectByteBuffer) directBuffer; this.mapMode = null; } MappedByteBuffer(MemoryBlock block, int capacity, int offset, MapMode mapMode) { super(capacity, block); this.mapMode = mapMode; if (mapMode == MapMode.READ_ONLY) { wrapped = new ReadOnlyDirectByteBuffer(block, capacity, offset); } else { wrapped = new ReadWriteDirectByteBuffer(block, capacity, offset); } } /**
<|startcomment|> Put this in onIccSwap so it can manage the locking if necessary. <|endcomment|>  public void handleMessage(Message msg){ <|startfocus|> synchronized (mLock) { if (mDestroyed) { loge("Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring."); return; } <|endfocus|> switch (msg.what) { case EVENT_CARD_REMOVED: onIccSwap(false); break; case EVENT_CARD_ADDED: onIccSwap(true); break; default: loge("Unknown Event " + msg.what); } }
<|startcomment|> Change to: log("changeIccFdnPassword"); <|endcomment|>  public void changeIccFdnPassword(String oldPassword, String newPassword, Message onComplete) { synchronized (mLock) { <|startfocus|> if (DBG) log("Change Pin2 old: " + oldPassword + " new: " + newPassword); <|endfocus|> mCi.changeIccPin2ForApp(oldPassword, newPassword, mAid, onComplete); }
<|startcomment|> I think it's better to use File instead of Strings when passing paths around. (File is just a poorly named Path class.) <|endcomment|> <|startfocus|> public void exportImageTo(String path) { if (mImage == null || path == null) { <|endfocus|> return; } ImageLoader imageLoader = new ImageLoader(); imageLoader.data = new ImageData[] { mImage.getImageData() }; try { imageLoader.save(path, SWT.IMAGE_PNG); } catch (Exception e) { ErrorDialog.openError(getShell(), "Save Image", "Error saving image", new Status(Status.ERROR, GlTracePlugin.PLUGIN_ID, e.toString())); }
<|startcomment|> you can remove this TODO now <|endcomment|>  assertEquals(algorithm, c2.getAlgorithm()); assertEquals(provider, c2.getProvider()); test_Cipher(c2); // KeyGenerator.getInstance(String, String) Cipher c3 = Cipher.getInstance(algorithm, provider.getName()); assertEquals(algorithm, c3.getAlgorithm()); assertEquals(provider, c3.getProvider()); test_Cipher(c3); } private void test_Cipher(Cipher c) throws Exception { // TODO: test all supported modes and padding for a given algorithm String algorithm = c.getAlgorithm().toUpperCase(Locale.US); <|startfocus|> if (isUnsupported(algorithm) || (algorithm.indexOf('/') != -1)) { <|endfocus|> return; } try { c.getOutputSize(0); } catch (IllegalStateException expected) { } // TODO: test keys from different factories (e.g. OpenSSLRSAPrivateKey vs JCERSAPrivateKey) Key encryptKey = getEncryptKey(algorithm); final AlgorithmParameterSpec spec; if (isPBE(algorithm)) { final byte[] salt = new byte[8]; new SecureRandom().nextBytes(salt); spec = new PBEParameterSpec(salt, 1024); } else {
<|startcomment|> uses <|endcomment|>  import com.android.annotations.Nullable; import com.android.ide.common.api.Rect; import java.awt.Color; import java.awt.Graphics2D; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; import javax.imageio.ImageIO; /** * This class implements 2D bin packing: packing rectangles into a given area as * tightly as "possible" (bin packing in general is NP hard, so this class is * using heuristics). * <p> <|startfocus|> * The algorithm implemented is to keep a set of (possibly overlapping) set of <|endfocus|> * available areas for placement. For each newly inserted rectangle, we first * pick which available space rectangle to occupy, and we then subdivide the * current rectangle into all the possible remaining unoccupied sub-rectangles. * We also remove any other space rectangles which are no longer eligible if * they are intersecting the newly placed rectangle. * <p> * This algorithm is not very fast, so should not be used for a large number of
<|startcomment|> Any line continuations should be double-indented (8 spaces). See development/ide/eclipse/android-formatting.xml <|endcomment|>  } } else { XmlUtils.skipCurrentTag(parser); continue; } } } catch (XmlPullParserException e) { Slog.w(TAG, "Got execption parsing ", e); } catch (IOException e) { Slog.w(TAG, "Got execption parsing ", e); } try { policyFile.close(); } catch (IOException e) { //omit } return true; } private static String readSeinfoTag(XmlPullParser parser) throws <|startfocus|> IOException, XmlPullParserException { <|endfocus|> int type; int outerDepth = parser.getDepth(); String seinfo = null; while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if ("seinfo".equals(tagName)) { String seinfoValue = parser.getAttributeValue(null, "value"); if (seinfoValue != null) { seinfo = seinfoValue;
<|startcomment|> intentional space? I think it would look better if you use a parenthesis instead <|endcomment|>  status = AvdStatus.ERROR_TARGET_HASH; } else if (target == null) { status = AvdStatus.ERROR_TARGET; } else if (properties == null) { status = AvdStatus.ERROR_PROPERTIES; } else if (validImageSysdir == false) { status = AvdStatus.ERROR_IMAGE_DIR; } else { status = AvdStatus.OK; } AvdInfo info = new AvdInfo( name, iniPath, avdPath, targetHash, target, <|startfocus|> abiType, <|endfocus|> properties, status); return info;
<|startcomment|> proposed change here to avoid sending IN_CALL mode twice: replace L382 by: int curAudioMode = audioManager.getMode(); if (curAudioMode != AudioManager.MODE_RINGTONE) { <|endcomment|>  public void setAudioMode() { Context context = getContext(); if (context == null) return; AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE); // change the audio mode and request/abandon audio focus according to phone state, // but only on audio mode transitions switch (getState()) { case RINGING: <|startfocus|> if (audioManager.getMode() != AudioManager.MODE_RINGTONE) { <|endfocus|> // only request audio focus if the ringtone is going to be heard if (audioManager.getStreamVolume(AudioManager.STREAM_RING) > 0) { if (VDBG) Rlog.d(LOG_TAG, "requestAudioFocus on STREAM_RING"); audioManager.requestAudioFocusForCall(AudioManager.STREAM_RING, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); } if(!mSpeedUpAudioForMtCall) { audioManager.setMode(AudioManager.MODE_RINGTONE); } } if (mSpeedUpAudioForMtCall) { audioManager.setMode(AudioManager.MODE_IN_CALL); } break; case OFFHOOK: Phone offhookPhone = getFgPhone();
<|startcomment|> Comment? <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.build.gradle.internal; import com.android.build.gradle.AndroidSourceDirectorySet; import com.google.common.collect.Lists; import org.gradle.api.internal.file.FileResolver; import java.io.File; import java.util.List; import java.util.Set; <|startfocus|> /** <|endfocus|> */ public class DefaultAndroidSourceDirectorySet implements AndroidSourceDirectorySet { private final String name; private final FileResolver fileResolver; private List<Object> source = Lists.newArrayList(); DefaultAndroidSourceDirectorySet(String name, FileResolver fileResolver) { this.name = name; this.fileResolver = fileResolver; } @Override public String getName() { return name; } @Override public AndroidSourceDirectorySet srcDir(Object srcDir) { source.add(srcDir); return this; } @Override public AndroidSourceDirectorySet srcDirs(Object... srcDirs) {
<|startcomment|> Does this need ALL_RESOURCE_FILES? <|endcomment|>  /** Calling the wrong method */ public static final Issue ISSUE = Issue.create( "WrongCall", //$NON-NLS-1$ "Finds cases where the wrong call is made, such as calling onMeasure instead of measure", "Custom views typically need to call `measure()` on their children, not `onMeasure`. " + "Ditto for onDraw, onLayout, etc.", Category.CORRECTNESS, 6, Severity.ERROR, WrongCallDetector.class, <|startfocus|> EnumSet.of(Scope.ALL_RESOURCE_FILES, Scope.CLASS_FILE)); <|endfocus|> /** Constructs a new {@link WrongCallDetector} */ public WrongCallDetector() { } @NonNull @Override public Speed getSpeed() { return Speed.FAST; } // ---- Implements ClassScanner ---- @Override @Nullable public List<String> getApplicableCallNames() { return Arrays.asList( ON_DRAW, ON_MEASURE, ON_LAYOUT ); } @Override public void checkCall(@NonNull ClassContext context, @NonNull ClassNode classNode, @NonNull MethodNode method, @NonNull MethodInsnNode call) {
<|startcomment|> Not used? <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.phone; import com.android.internal.telephony.Phone; import com.android.internal.telephony.PhoneConstants; <|startfocus|> import com.android.internal.telephony.RILConstants; <|endfocus|> import com.android.internal.telephony.TelephonyIntents; import com.android.internal.telephony.TelephonyProperties; import android.app.ActionBar; import android.app.AlertDialog; import android.content.Context; import android.content.DialogInterface; import android.content.Intent; import android.net.ConnectivityManager; import android.net.ThrottleManager; import android.net.Uri; import android.os.AsyncResult; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.os.SystemProperties; import android.preference.CheckBoxPreference; import android.preference.ListPreference; import android.preference.Preference; import android.preference.PreferenceActivity;
<|startcomment|> Can you change this to "ManifestTypo" ? Most ids use the singular form of the problem (there may be unintentional exceptions before I settled on this) <|endcomment|>  private static final Pattern PATTERN_USES_PERMISSION = Pattern.compile("^use.*permission"); /* The match pattern for <uses-feature> */ private static final Pattern PATTERN_USES_FEATURE = Pattern.compile("^use.*feature"); /* The match pattern for <uses-library> */ private static final Pattern PATTERN_USES_LIBRARY = Pattern.compile("^use.*library"); /** The main issue discovered by this detector */ public static final Issue ISSUE = Issue.create( <|startfocus|> "ManifestTypos", //$NON-NLS-1$ <|endfocus|> "Checks for manifest typos", "This check looks through the manifest , and if it finds any tags " + "that look like likely misspellings, they are flagged.", Category.MESSAGES, 5, Severity.WARNING, ManifestTypoDetector.class, Scope.MANIFEST_SCOPE); /** Constructs a new {@link ManifestTypoDetector} check */ public ManifestTypoDetector() { } @NonNull @Override public Speed getSpeed() { return Speed.FAST; } @Override public boolean appliesTo(@NonNull Context context, @NonNull File file) {
<|startcomment|> Now the timeout is hard coded 5000 here but originally the default timeout interval is defined at the next file ddmlib/DdmPreferences.java (int DEFAULT_TIMEOUT) So my question is that should I keep the 5000 or include the ddmlib and use that variable? <|endcomment|> <|startfocus|> public String shell(String cmd) { <|endfocus|> return shell(cmd, 5000);
<|startcomment|> the code would be difficult to maintain due to this implicit assumption. what if someone in the future to add a test case that downloads the same file twice? Is there any reason that you would like to use Vector? <|endcomment|> import android.util.Log; import java.io.IOException; import java.util.Vector; import static android.drm.fl.cts.FLContentUrls.*; import static android.drm.fl.cts.FLUtilityFunctions.*; /** * Use case based Forward Lock tests. The normal use case involves * downloading and playing audio or video content. */ public class FLUseCaseBasedTests extends ActivityInstrumentationTestCase2<FLTestActivity> { private DrmManagerClient mManager; private FLTestActivity mTestActivity; private Vector<String> mFilesToRemove = new Vector<String>(); <|startfocus|> <|endfocus|> public FLUseCaseBasedTests() { super(FLTestActivity.class); } protected void setUp() throws Exception { super.setUp(); mTestActivity = getActivity(); mManager = mTestActivity.getManager(); // Check that the FL plugin was loaded if (!isPluginLoaded("OMA V1 Forward Lock", mManager)) { throw new Exception("No forward lock plugin was loaded."); } } protected void tearDownAfterClass() throws Exception { if (mFilesToRemove != null) {
<|startcomment|> Maybe better as mPlatformRootFolder rather than mSdkLocation <|endcomment|>  * limitations under the License. */ package com.android.builder; import com.android.SdkConstants; import com.android.annotations.NonNull; import com.android.builder.internal.FakeAndroidTarget; import com.android.sdklib.IAndroidTarget; import com.android.sdklib.internal.repository.packages.FullRevision; import com.android.utils.ILogger; import java.io.File; /** * Implementation of {@link SdkParser} for the SDK prebuilds in the Android source tree. */ class PlatformSdkParser implements SdkParser { <|startfocus|> private final String mSdkLocation; <|endfocus|> private File mHostTools; PlatformSdkParser(@NonNull String sdkLocation) { mSdkLocation = sdkLocation; } @Override public IAndroidTarget resolveTarget(String target, ILogger logger) { return new FakeAndroidTarget(mSdkLocation, target); } @Override public String getAnnotationsJar() { String host; if (SdkConstants.CURRENT_PLATFORM == SdkConstants.PLATFORM_DARWIN) { host = "darwin-x86"; } else if (SdkConstants.CURRENT_PLATFORM == SdkConstants.PLATFORM_LINUX) { host = "linux"; } else {
<|startcomment|> this method does not need to be "public"? <|endcomment|>  * include any header data. * * @param outputFilename The name of the IVF file to write encoded bitsream * @param rawInputFd File descriptor for the raw input file (YUV420) * @param frameWidth Frame width of input file * @param frameHeight Frame height of input file * @param frameRate Frame rate of input file in frames per second */ <|startfocus|> public void encode(String outputFilename, int rawInputFd, <|endfocus|> int frameWidth, int frameHeight, int frameRate) throws Exception { int frameSize = frameWidth * frameHeight * 3 / 2; InputStream rawStream = mResources.openRawResource(rawInputFd); IvfWriter ivf = new IvfWriter(outputFilename, frameWidth, frameHeight); // Create a media format signifying desired output MediaFormat format = MediaFormat.createVideoFormat(VP8_MIME, frameWidth, frameHeight); format.setInteger(MediaFormat.KEY_BIT_RATE, 100000); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, CodecCapabilities.COLOR_FormatYUV420Planar); format.setInteger(MediaFormat.KEY_FRAME_RATE, 30); 
<|startcomment|> It might be better to perform a known-answer test instead of checking that the output of each installed providers matches that of the default provider. If so, then expectedPath should be constructed explicitly, instead of being obtained from the default provider. <|endcomment|>  mCount = mMarked; mStream.reset(); } } /* CertPath tests */ public void testGenerateCertPath() throws Exception { KeyHolder ca = generateCertificate(true, null); KeyHolder cert1 = generateCertificate(true, ca); KeyHolder cert2 = generateCertificate(false, cert1); KeyHolder cert3 = generateCertificate(false, cert2); List<X509Certificate> certs = new ArrayList<X509Certificate>(); certs.add(cert3.certificate); certs.add(cert2.certificate); certs.add(cert1.certificate); <|startfocus|> final CertPath expectedPath; { final CertificateFactory cf = CertificateFactory.getInstance("X.509"); expectedPath = cf.generateCertPath(certs); } <|endfocus|> Provider[] providers = Security.getProviders("CertificateFactory.X509"); for (Provider p : providers) { final CertificateFactory cf = CertificateFactory.getInstance("X.509", p); testCertPathEncoding(cf, expectedPath, certs, cf.getCertPathEncodings()); testCertPathEncoding(cf, expectedPath, certs, cf.generateCertPath(certs).getEncodings()); } } private void testCertPathEncoding(CertificateFactory cf, final CertPath expectedPath,
<|startcomment|> Line too long <|endcomment|>  final List<X509Certificate> certificates = new ArrayList<X509Certificate>(size); for (int i = size - 1; i >= 0; i--) { // create the X.509 certificate on the base of its encoded form // and add it to the list. certificates.add(new X509CertImpl((Certificate) Certificate.ASN1 .decode(encodedCerts.get(i)))); } // create and return the resulting object <|startfocus|> return new X509CertPathImpl(sortCertsIfNeeded(certificates), Encoding.PKI_PATH, in.getEncoded()); <|endfocus|> } /** * Returns the Collection of the encoded form of certificates contained * in the X509CertPathImpl object to be encoded. * This method participates in encoding process. */ public Collection<byte[]> getValues(Object object) { // object to be encoded final X509CertPathImpl cp = (X509CertPathImpl) object; // if it has no certificates in it - create the sequence of size 0 if (cp.certificates == null) { return Collections.emptyList(); } 
<|startcomment|> the what? :-) just skip again. <|endcomment|>  /** * Returns the global count of freed bytes from external * allocation requests. The external allocation tracking feature * was removed in Honeycomb. This method exists for compatibility * and always returns 0. * * @deprecated This method is now obsolete. */ @Deprecated public static int getGlobalExternalFreedSize() { return 0; } /** <|startfocus|> * Resets the global count counter of freed bytes from external * allocations. The external allocation tracking feature was * removed in Honeycomb. This method exists for compatibility and * has no effect. * <|endfocus|> * @deprecated This method is now obsolete. */ @Deprecated public static void resetGlobalExternalFreedSize() {} /** * Returns the thread-local count of objects allocated by the runtime between a * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}. * @return The allocated count. */ public static int getThreadAllocCount() { return VMDebug.getAllocCount(VMDebug.KIND_THREAD_ALLOCATED_OBJECTS); } 
<|startcomment|> The import order needs to be fixed. See the section on "Eclipse formatting" at http://s.android.com/source/using-eclipse.html and make sure you have the android import order setup. <|endcomment|> import org.eclipse.swt.widgets.Display; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.IEditorSite; import org.eclipse.ui.PartInitException; import org.eclipse.ui.dialogs.SaveAsDialog; import org.eclipse.ui.ide.FileStoreEditorInput; import org.eclipse.ui.part.EditorPart; import org.eclipse.ui.part.FileEditorInput; <|startfocus|> import com.android.ide.eclipse.adt.internal.editors.draw9patch.graphics.NinePatchedImage; import com.android.ide.eclipse.adt.internal.editors.draw9patch.ui.ImageViewer; import com.android.ide.eclipse.adt.internal.editors.draw9patch.ui.MainFrame; <|endfocus|> /** * Draw9Patch editor part. */ public class Draw9PatchEditor extends EditorPart implements ImageViewer.OnUpdateListener { private IProject mProject = null; private FileEditorInput mFileEditorInput = null; private IPath mRelativePath = null; private String mFileName = null; private NinePatchedImage mNinePatchedImage = null; private MainFrame mMainFrame = null; private boolean mDirtyFlg = false; @Override public void init(IEditorSite site, IEditorInput input) throws PartInitException { setSite(site); setInput(input);
<|startcomment|> Don't shorten FLAG to FLG (many occurrences of this in this file) <|endcomment|>  * limitations under the License. */ package com.android.ide.eclipse.adt.internal.editors.draw9patch.graphics; import com.android.ide.eclipse.adt.AdtPlugin; import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.graphics.ImageData; import org.eclipse.swt.graphics.Rectangle; /** * The model of 9-patched image. */ public class NinePatchedImage { <|startfocus|> private static final boolean DEBUG_FLG = false; <|endfocus|> public static final String PNG_EXTENSION = ".png"; public static final String NINE_PATCH_EXTENSION = ".9.png"; /** * Get 9-patched filename as like image.9.png . */ public static String getNinePatchedFileName(String fileName) { if (fileName.endsWith(NINE_PATCH_EXTENSION)) { return fileName; } return fileName.substring(0, fileName.lastIndexOf(PNG_EXTENSION)) + NINE_PATCH_EXTENSION; } // For stretch regions and padding public static final int BLACK_TICK = 0xFF000000;
<|startcomment|> Nit: Can be final. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.harmony.xnet.provider.jsse; import java.io.ByteArrayOutputStream; import java.math.BigInteger; import java.security.cert.CRLException; import java.security.cert.X509CRLEntry; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.HashSet; import java.util.Set; import java.util.TimeZone; public class OpenSSLX509CRLEntry extends X509CRLEntry { <|startfocus|> private long mContext; <|endfocus|> OpenSSLX509CRLEntry(long ctx) { mContext = ctx; } @Override public Set<String> getCriticalExtensionOIDs() { String[] critOids = NativeCrypto.get_X509_REVOKED_ext_oids(mContext, 1); /* * This API has a special case that if there are no extensions, we * should return null. So if we have no critical extensions, we'll check * non-critical extensions. */ if ((critOids.length == 0) && (NativeCrypto.get_X509_REVOKED_ext_oids(mContext, 0).length == 0)) {
<|startcomment|> Here, lets just update wpsConfigMethodsSupported and return <|endcomment|>  public void updateConfigMethods(String deviceAddress, int config_method) { if (TextUtils.isEmpty(deviceAddress)) return; WifiP2pDevice d = mDevices.get(deviceAddress); if (d != null) { d.wpsConfigMethodsSupported = config_method; <|startfocus|> if(d.wpsPbcSupported()) wpsPbcSupport = true; else if(d.wpsKeypadSupported()) wpsKeypadSupport = true; else if(d.wpsDisplaySupported()) wpsDisplaySupport = true; <|endfocus|> }
<|startcomment|> So, even with the caveats of what I described above, this implementation does *not* match the implementation within NSS and CryptoAPI. That is, NSS/CAPI will reject the following chain: Root: [Any EKU] Intermediate: [Client Auth] Leaf: [Server Auth] In the forward evaluation case (Leaf->Intermediate->Root), Intermediate must contain the set of all encountered EKUs. In the reverse evaluation case (Root->Intermediate->Leaf), the effective EKU set is reduced through each intermediate. Going from Intermediate->Leaf will fail because Leaf's EKU is not within the effective set of Intermediate. Note I picked those examples just to show how each certificate individually would pass the checks, but collectively fail. <|endcomment|>  private final boolean clientAuth; private ExtendedKeyUsagePKIXCertPathChecker(boolean clientAuth) { this.clientAuth = clientAuth; } @Override public void init(boolean forward) throws CertPathValidatorException { } @Override public boolean isForwardCheckingSupported() { return false; } @Override public Set<String> getSupportedExtensions() { return SUPPORTED_EXTENSIONS; } @Override public void check(Certificate c, Collection<String> unresolvedCritExts) throws CertPathValidatorException { <|startfocus|> X509Certificate x = (X509Certificate) c; <|endfocus|> List<String> ekuOids; try { ekuOids = x.getExtendedKeyUsage(); } catch (CertificateParsingException e) { throw new CertPathValidatorException(e); } if (ekuOids == null) { return; } boolean goodExtendedKeyUsage = false; for (String ekuOid : ekuOids) { // anyExtendedKeyUsage for clients and servers if (ekuOid.equals(EKU_anyExtendedKeyUsage)) { goodExtendedKeyUsage = true; break; } // clients if (clientAuth) { if (ekuOid.equals(EKU_clientAuth)) {
<|startcomment|> This can be done in onLayout() instead of using a listener and setting it on children. <|endcomment|>  mTouchSlop = configuration.getScaledTouchSlop(); mMinimumVelocity = configuration.getScaledMinimumFlingVelocity(); mMaximumVelocity = configuration.getScaledMaximumFlingVelocity(); mOverscrollDistance = configuration.getScaledOverscrollDistance(); mOverflingDistance = configuration.getScaledOverflingDistance(); } @Override public void addView(View child) { if (getChildCount() > 0) { throw new IllegalStateException("HorizontalScrollView can host only one direct child"); } super.addView(child); <|startfocus|> child.addOnLayoutChangeListener(mLayoutChangeListener); <|endfocus|> } @Override public void addView(View child, int index) { if (getChildCount() > 0) { throw new IllegalStateException("HorizontalScrollView can host only one direct child"); } super.addView(child, index); child.addOnLayoutChangeListener(mLayoutChangeListener); } @Override public void addView(View child, ViewGroup.LayoutParams params) { if (getChildCount() > 0) { throw new IllegalStateException("HorizontalScrollView can host only one direct child"); } super.addView(child, params); child.addOnLayoutChangeListener(mLayoutChangeListener); }
<|startcomment|> do you need to null check map here? <|endcomment|>  public List<ResourceItem> getResourceItem(@NonNull ResourceType resourceType, @NonNull String resourceName) { ListMultimap<String, ResourceItem> map = mItems.get(resourceType); <|startfocus|> return map.get(resourceName); <|endfocus|>
<|startcomment|> Style comment: You need to indent everything that goes inside your try <|endcomment|>  protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (DBG) Log.d(LOG_TAG, "onActivityResult: done"); if (resultCode != RESULT_OK) { if (DBG) Log.d(LOG_TAG, "onActivityResult: contact picker result not OK."); return; } Cursor cursor = null; try { cursor = getContentResolver().query(data.getData(), NUM_PROJECTION, null, null, null); <|startfocus|> if ((cursor == null) || (!cursor.moveToFirst())) { if (DBG) Log.d(LOG_TAG, "onActivityResult: bad contact data, no results found."); return; } <|endfocus|> switch (requestCode) { case CommandsInterface.CF_REASON_UNCONDITIONAL: mButtonCFU.onPickActivityResult(cursor.getString(0)); break; case CommandsInterface.CF_REASON_BUSY: mButtonCFB.onPickActivityResult(cursor.getString(0)); break; case CommandsInterface.CF_REASON_NO_REPLY: mButtonCFNRy.onPickActivityResult(cursor.getString(0)); break; case CommandsInterface.CF_REASON_NOT_REACHABLE: mButtonCFNRc.onPickActivityResult(cursor.getString(0)); break;
<|startcomment|> and here <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.conscrypt; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.Key; import java.security.KeyFactory; import java.security.PrivateKey; import java.security.PublicKey; import java.security.SecureRandom; import java.security.spec.AlgorithmParameterSpec; <|startfocus|> <|endfocus|> import javax.crypto.KeyAgreementSpi; import javax.crypto.SecretKey; import javax.crypto.ShortBufferException; import javax.crypto.spec.SecretKeySpec; /** * Elliptic Curve Diffie-Hellman key agreement backed by the OpenSSL engine. */ public final class OpenSSLECDHKeyAgreement extends KeyAgreementSpi { /** OpenSSL handle of the private key. Only available after the engine has been initialized. */ private OpenSSLKey mOpenSslPrivateKey; /** * Expected length (in bytes) of the agreed key ({@link #mResult}). Only available after the * engine has been initialized.
<|startcomment|> extra whitespace added? <|endcomment|>  * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.conscrypt; <|startfocus|> <|endfocus|> import java.io.IOException; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; import java.security.KeyManagementException; import javax.net.ssl.SSLSocketFactory; import libcore.util.EmptyArray; /** * Implementation of SSLSocketFactory. */ public class SSLSocketFactoryImpl extends SSLSocketFactory { private final SSLParametersImpl sslParameters; private final IOException instantiationException; /** * Constructor. */ public SSLSocketFactoryImpl() { SSLParametersImpl sslParametersLocal = null; IOException instantiationExceptionLocal = null; try { sslParametersLocal = SSLParametersImpl.getDefault();
<|startcomment|> tab <|endcomment|>  public void testHypotF32_4() { script_f32_4 = new ScriptC_hypot_f32_4(mRS, mRes, R.raw.hypot_f32_4); <|startfocus|> ScriptField_hypot_f32_4_in in = new ScriptField_hypot_f32_4_in(mRS, INPUTSIZE); <|endfocus|> mIn = in.getAllocation(); doF32_4(0x12ce45, 4);
<|startcomment|> "ImageContainers" <|endcomment|>  */ public String getRequestUrl() { return mRequestUrl; } } /** * Wrapper class used to map a Request to the set of active BitmapContainer objects that are * interested in its results. */ private class RequestListenerWrapper { /** The request being tracked */ private final Request<?> mRequest; /** The result of the request being tracked by this item */ private Bitmap mResponseBitmap; <|startfocus|> /** List of all of the active BitmapContainers that are interested in the request */ <|endfocus|> private final LinkedList<ImageContainer> mHandlers = new LinkedList<ImageContainer>(); /** * Constructs a new RequestListenerWrapper object * @param request The request being tracked * @param container The BitmapContainer of the person who initiated the request. */ public RequestListenerWrapper(Request<?> request, ImageContainer container) { mRequest = request; mHandlers.add(container); } /** * Adds another BitmapContainer to the list of those interested in the results of * the request. */
<|startcomment|> Totally nitpicky: This field name might read better without "Is" in it. <|endcomment|>  * the automatic Gradle model synchronization is started.</li> * <li>When creating a new Android-Gradle project.</li> * <li>When importing an existing Android-Gradle project.</li> * </ul> */ public static void attachToManager() { if (isAttachedToManager()) { return; } instance = new GradleImportNotificationListener(); ExternalSystemProgressNotificationManager progressNotificationManager = getExternalSystemProgressNotificationManager(); progressNotificationManager.addNotificationListener(instance); } <|startfocus|> private volatile boolean myIsProjectImportInProgress; <|endfocus|> public static void detachFromManager() { if (!isAttachedToManager()) { return; } ExternalSystemProgressNotificationManager progressNotificationManager = getExternalSystemProgressNotificationManager(); progressNotificationManager.removeNotificationListener(instance); instance = null; } public static boolean isProjectImportInProgress() { return isAttachedToManager() && instance.myIsProjectImportInProgress; } public static boolean isAttachedToManager() { return instance != null; } @NotNull private static ExternalSystemProgressNotificationManager getExternalSystemProgressNotificationManager() { return ServiceManager.getService(ExternalSystemProgressNotificationManager.class); } 
<|startcomment|> I think it would be a slightly prettier to return null from catch and remove it from here <|endcomment|>  private IJavaProject getJavaProject(ProjectState projectState) { try { return BaseProjectHelper.getJavaProject(projectState.getProject()); } catch (CoreException e) { } <|startfocus|> return null; <|endfocus|>
<|startcomment|> "waiting for a special state" <|endcomment|>  public void handleMessage(Message msg) { Log.d(TAG, "handleMessage() - " + msg.what); CountDownLatch latch = mLatches.get(msg.what); if (latch == null) { return; } AsyncResult r = (AsyncResult)msg.obj; boolean isConsumed = false; switch (msg.what) { <|startfocus|> case EVENT_SERVICE_STATE_CHANGED: // waiting a special state <|endfocus|> if (expectState == null || (Integer)expectState == ((ServiceState)r.result).getState()) { isConsumed = true; } break; case EVENT_PHONE_STATE_CHANGED: Log.d(TAG, "EVENT_PHONE_STATE_CHANGED - " + mPhone.getState()); if (expectState == null || (PhoneConstants.State)expectState == mPhone.getState()) { isConsumed = true; } break; default: // waiting the message only isConsumed = true; break; } if (isConsumed) { mLatches.remove(msg.what); latch.countDown(); expectState = null; }
<|startcomment|> my first piece of advice was wrong, remove the EasyMock.eq( here. Not sure why though <|endcomment|>  try { mRunner.run(mMockListener); fail("IOException not thrown"); } catch (IOException e) { // expected } EasyMock.verify(mMockDevice, mMockListener); } /** * Calls {@link RemoteAndroidTestRunner#run(ITestRunListener...)} and verifies the given * <var>expectedCmd</var> pattern was received by the mock device. */ private void runAndVerify(String expectedCmd) throws Exception { <|startfocus|> mMockDevice.executeShellCommand(EasyMock.eq(expectedCmd), (IShellOutputReceiver) <|endfocus|> EasyMock.anyObject(), EasyMock.eq(0L), EasyMock.eq(TimeUnit.MILLISECONDS)); EasyMock.replay(mMockDevice); mRunner.run(mMockListener); EasyMock.verify(mMockDevice); } } 
<|startcomment|> is this { on its own line or just line wrapping in gerrit? <|endcomment|> <|startfocus|> protected LibraryBundle(@NonNull File bundle, @NonNull File bundleFolder, @Nullable String name) { <|endfocus|> mBundle = bundle; mBundleFolder = bundleFolder; mName = name;
<|startcomment|> wrap? <|endcomment|>  public void onBuildCompleted(int resultCode) { if (resultCode != 0) { Messages <|startfocus|> .showErrorDialog(project, "Unable to generate the Android GCM component for the '" + androidModule.getName() + "' module." + "The App Engine module failed to build.", "Generate App Engine Backend"); <|endfocus|> return; } Module appEngineModule = ModuleManager.getInstance(project).findModuleByName(appEngineModuleName); assert (appEngineModule != null); MavenEndpointGeneratorHelper endpointGeneratorHelper = new MavenEndpointGeneratorHelper(project, appEngineModule); for (String apiName : MavenBackendGeneratorHelper.SAMPLE_API_NAMES) { endpointGeneratorHelper.expandSourceDirForApi(apiName); } // Now, perform a refresh so that the generated endpoint libs folder (google_generated) shows up File generatedLibsDir = new File(VfsUtil.virtualToIoFile(appEngineModuleRootDir), MavenEndpointGeneratorHelper.APPENGINE_GENERATED_LIB_FOLDER_NAME); LocalFileSystem.getInstance().refreshIoFiles(Collections.singletonList(generatedLibsDir), true, true, null); addMavenRunConfiguration(project, appEngineModule); GradleGCMGeneratorHelper
<|startcomment|> since this is done in a loop, maybe extract this to a local variable at the beginning of the method? <|endcomment|>  private static Sdk findFirstCompatibleAndroidSdk() { for (Sdk sdk : AndroidSdkUtils.getAllAndroidSdks()) { String sdkPath = sdk.getHomePath(); <|startfocus|> if (getVersionChecker().isCompatibleVersion(sdkPath)) { <|endfocus|> return sdk; } } return null;
<|startcomment|> use mPhoneBase.setSystemProperty instead. Don't import SystemProperties <|endcomment|>  public static final int EVENT_ICC_CHANGED = 42; protected static final int EVENT_GET_CELL_INFO_LIST = 43; protected static final int EVENT_UNSOL_CELL_INFO_LIST = 44; protected static final int EVENT_CHANGE_IMS_STATE = 45; protected static final int EVENT_IMS_STATE_CHANGED = 46; protected static final int EVENT_IMS_STATE_DONE = 47; protected static final int EVENT_IMS_CAPABILITY_CHANGED = 48; protected static final int EVENT_ALL_DATA_DISCONNECTED = 49; <|startfocus|> protected static final int EVENT_PHONE_TYPE_SWITCHED = 50; <|endfocus|> protected static final String TIMEZONE_PROPERTY = "persist.sys.timezone"; /** * List of ISO codes for countries that can have an offset of * GMT+0 when not in daylight savings time. This ignores some * small places such as the Canary Islands (Spain) and * Danmarkshavn (Denmark). The list must be sorted by code. */ protected static final String[] GMT_COUNTRY_CODES = { "bf", // Burkina Faso "ci", // Cote d'Ivoire
<|startcomment|> build.settings file? I think you want settings.gradle file? <|endcomment|>  private static String updateProjectNameInGradlePath(@NotNull AndroidGradleFacet androidGradleFacet, @NotNull VirtualFile moduleDir) { String gradlePath = androidGradleFacet.getConfiguration().GRADLE_PROJECT_PATH; if (gradlePath.equals(SdkConstants.GRADLE_PATH_SEPARATOR)) { // This is root project, renaming folder does not affect it since the path is just ":". return gradlePath; } <|startfocus|> List<String> pathSegments = GradleUtil.getPathSegments(gradlePath); <|endfocus|> pathSegments.remove(pathSegments.size() - 1); pathSegments.add(moduleDir.getName()); String newPath = Joiner.on(SdkConstants.GRADLE_PATH_SEPARATOR).join(pathSegments); androidGradleFacet.getConfiguration().GRADLE_PROJECT_PATH = newPath; return newPath;
<|startcomment|> shouldn't this be int i = percent * QUANTIZED_COLORS.length / 100 ? <|endcomment|>  private Color getFill(int percent) { <|startfocus|> int i = percent / 10; <|endfocus|> if (i >= QUANTIZED_COLORS.length) { i = QUANTIZED_COLORS.length - 1; } return QUANTIZED_COLORS[i];
<|startcomment|> another bad function name. isOperatorConcideredNonRoaming <|endcomment|>  mDetachedRegistrants.notifyRegistrants(); } if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) { notifyDataRegStateRilRadioTechnologyChanged(); if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) { mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE); } else { mPhone.notifyDataConnection(null); } } if (hasVoiceRoamingOn) { mVoiceRoamingOnRegistrants.notifyRegistrants(); } if (hasVoiceRoamingOff) { mVoiceRoamingOffRegistrants.notifyRegistrants(); } <|startfocus|> if (hasDataRoamingOn) { mDataRoamingOnRegistrants.notifyRegistrants(); } if (hasDataRoamingOff) { mDataRoamingOffRegistrants.notifyRegistrants(); } <|endfocus|> if (hasLocationChanged) { mPhone.notifyLocationChanged(); } if (! isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) { if (!mStartedGprsRegCheck && !mReportedGprsNoReg) { mStartedGprsRegCheck = true; int check_period = Settings.Global.getInt( mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
<|startcomment|> s/in ADT/from ADT/ ? (Also -- I'm not sure, but maybe put *'s around export to make it really stand out? e.g. ...need to *export* it as...) <|endcomment|>  @NonNls private static final String LAST_IMPORTED_LOCATION = "last.imported.location"; @NonNls private static final String ANDROID_NATURE_NAME = "com.android.ide.eclipse.adt.AndroidNature"; private static final Logger LOG = Logger.getInstance(AndroidImportProjectAction.class); private static final String ADT_PROJECT_IMPORT_ERROR_MSG_FORMAT = "The project at '%1$s' is an Android ADT project.\n\n" + <|startfocus|> "To import this project into Android Studio you first need to export it as a Gradle project in ADT."; <|endfocus|> private static final String ERROR_MSG_TITLE = "Import Project"; @NonNls static final String ECLIPSE_CLASSPATH_FILE_NAME = ".classpath"; @NonNls static final String ECLIPSE_PROJECT_FILE_NAME = ".project"; private static final String WIZARD_TITLE = "Select Gradle Project Import"; private static final String WIZARD_DESCRIPTION = "Select build.gradle or settings.gradle"; public AndroidImportProjectAction() { super("Import Project..."); } @Override public void actionPerformed(AnActionEvent e) { AddModuleWizard wizard = selectFileAndCreateWizard();
<|startcomment|> Could this be static? <|endcomment|> <|startfocus|> private File findTemplate() { File jarPath = new File(PathUtil.getJarPathForClass(getClass())); <|endfocus|> if (jarPath.isFile()) { jarPath = jarPath.getParentFile(); } File localTemplateDir = new File(jarPath, SDK_TEMPLATES); File blankLibraryTemplateDir = new File(localTemplateDir, GCM_ACTIVITY); if(blankLibraryTemplateDir.exists()) { return blankLibraryTemplateDir; } return null;
<|startcomment|> Use Log.v and add check Log.isLoggable on VERBOSE to the log line. <|endcomment|>  TransactionSettings connectionSettings, String uriString) { super(context, serviceId, connectionSettings); mUri = Uri.parse(uriString); try { mNotificationInd = (NotificationInd) PduPersister.getPduPersister(context).load(mUri); } catch (MmsException e) { Log.e(TAG, "Failed to load NotificationInd from: " + uriString, e); throw new IllegalArgumentException(); } mContentLocation = new String(mNotificationInd.getContentLocation()); mId = mContentLocation; <|startfocus|> Log.d(TAG, "mId=" + mId); <|endfocus|> // Attach the transaction to the instance of RetryScheduler. attach(RetryScheduler.getInstance(context));
<|startcomment|> I personally prefer assertions over Guava's Preconditions since assertions have zero overhead in production (the entire statement is ignored when the class is loaded). Your call whether you want this check done at all times. With enumsets it's slightly less likely that somebody would pass the wrong values into this method :-) <|endcomment|>  * one ABI and this method only returns a single package per filter type. * * @param filter {@link #PKG_PLATFORMS}, {@link #PKG_SAMPLES} or {@link #PKG_SOURCES}. * @param version The {@link AndroidVersion} specific for this package type. * @return An existing package information or null if not found. */ public LocalPkgInfo getPkgInfo(int filter, AndroidVersion version) { <|startfocus|> Preconditions.checkArgument(filter == PKG_PLATFORMS || filter == PKG_SAMPLES || filter == PKG_SOURCES); <|endfocus|> for (LocalPkgInfo pkg : getPkgsInfos(filter)) { if (pkg instanceof LocalAndroidVersionPkgInfo) { LocalAndroidVersionPkgInfo p = (LocalAndroidVersionPkgInfo) pkg; if (p.getAndroidVersion().equals(version)) { return p; } } } return null; } /** * Retrieves information on a package identified by its {@link FullRevision}. * <p/>
<|startcomment|> rewording: Older clients (API level < 10) are not supported yet. <|endcomment|>  public void onSuccess(String remoteFilePath, Client client) { // TODO: Devices older than API 10 don't return profile results via JDWP. Instead they save the results on the sdcard. // We don't support this yet. <|startfocus|> showError("Method profiling: Older client (API level < 10) not supported yet. Please manually retrieve the file " <|endfocus|> + remoteFilePath + " from the device and open the file to view the results.");
<|startcomment|> tweak this to reflect new syntax? <|endcomment|>  * Maven coordinates take the following form: groupId:artifactId:packaging:classifier:version * where * groupId is dot-notated alphanumeric * artifactId is the name of the project * packaging is optional and is jar/war/pom/aar/etc * classifier is optional and provides filtering context * version uniquely identifies a version. * <|startfocus|> * We only care about coordinates of the following form: groupId:artifactId:MajorRevision.MinorRevision.(MicroRevision|+) * or: groupId:artifactId:+ <|endfocus|> */ public static final int PLUS_REV = -1; private final String myGroupId; private final String myArtifactId; private final ArrayList<Integer> myRevisions = new ArrayList<Integer>(3); private final boolean myIsAnyRevision; private static final Pattern MAVEN_PATTERN = Pattern.compile("([\\w\\d\\.-]+):([\\w\\d\\.-]+):([\\d+\\.\\+]+)"); private static final Pattern REVISION_PATTERN = Pattern.compile("(\\d+|\\+)"); /**
<|startcomment|> I still think it's really important to have the code survive broken sources. Maybe make a getStringValue method on the BuildFileKey which looks up the given key and if it's not a String logs a warning and then returns null. (This might not be just for broken sources; e.g. what if there are places where we expect a literal string and the user has placed a method call which returns a literal string; in those cases we shouldn't break out of whatever call was using this method; it's better to return null as if not found, but also useful to have a log which lets us know that we need to support additional node types here.) <|endcomment|>  * and pass in the block that is the root of the key's path. */ public enum BuildFileKey { // Buildscript block PLUGIN_CLASSPATH("buildscript/dependencies/classpath"), PLUGIN_REPOSITORY("buildscript/repositories"), // TODO: Implement properly. This is not a simple literal. PLUGIN_VERSION("buildscript/dependencies/classpath") { @Override public Object getValue(@NotNull GroovyPsiElement[] args) { <|startfocus|> String s = (String)PLUGIN_CLASSPATH.getValue(args); <|endfocus|> if (s != null && s.startsWith(GradleBuildFile.GRADLE_PLUGIN_CLASSPATH)) { return s.substring(GradleBuildFile.GRADLE_PLUGIN_CLASSPATH.length()); } else { return null; } } @Override public void setValue(@NotNull Project project, @NotNull GroovyPsiElement[] args, @NotNull Object value) { PLUGIN_CLASSPATH.setValue(project, args, GradleBuildFile.GRADLE_PLUGIN_CLASSPATH + value); } }, // Repositories block // TODO: Implement // Dependencies block DEPENDENCIES("dependencies", true) { @Override public Object getValue(@NotNull GrStatementOwner closure) {
<|startcomment|> trailing space <|endcomment|>  */ public abstract class AndroidRunConfigurationBase extends ModuleBasedConfiguration<JavaRunConfigurationModule> { private static final Logger LOG = Logger.getInstance("#org.jetbrains.android.run.AndroidRunConfigurationBase"); /** * A map from launch configuration name to set of devices used in that launch configuration. * We want this list of devices persisted across launches, but not across invocations of studio, so we use a static variable. */ <|startfocus|> private static Map<String,Set<String>> ourLastUsedDevices = new ConcurrentHashMap<String, Set<String>>(); <|endfocus|> public String TARGET_SELECTION_MODE = TargetSelectionMode.EMULATOR.name(); public boolean USE_LAST_SELECTED_DEVICE = false; public String PREFERRED_AVD = ""; public boolean USE_COMMAND_LINE = true; public String COMMAND_LINE = ""; public boolean WIPE_USER_DATA = false; public boolean DISABLE_BOOT_ANIMATION = false; public String NETWORK_SPEED = "full"; public String NETWORK_LATENCY = "none"; public boolean CLEAR_LOGCAT = false; public boolean SHOW_LOGCAT_AUTOMATICALLY = true; 
<|startcomment|> IIRC, cut through is trying to optimize for http where you want to piggy back the last handshake packet with the HTTP request application data. however, in non-http cases, you'll want to let people read, such as if they are expecting the server to speak first. <|endcomment|>  * completed yet. */ private static final int STATE_HANDSHAKE_COMPLETED = 2; /** * {@link #startHandshake()} has completed, but the handshake hasn't completed yet. We * can now start writing data to the socket. */ // TODO: Is it safe to unblock SSLInputStream if we're in cut through mode ? should <|startfocus|> // we wait for the handshake to complete ? <|endfocus|> private static final int STATE_READY_HANDSHAKE_CUT_THROUGH = 3; /** * {@link #startHandshake()} has completed and so has the actual handshake. */ private static final int STATE_READY = 4; /** * We've called {@link #close()}. */ private static final int STATE_CLOSED = 5; // @GuardedBy("stateLock"); private int state = STATE_NEW; /** * Protected by synchronizing on stateLock. Starts as 0, set by * startHandshake, reset to 0 on close. */ // @GuardedBy("stateLock"); private long sslNativePointer; 
<|startcomment|> What is the ":pcs" part? Can you make it a constant and add a comment? Is this provider-specific code or general? It looks general except for the + pcs part. <|endcomment|>  // value. Replace the occurrence of the string returned by // MmsConfig.getHttpParamsLine1Key() with the users telephone number inside // the value. String extraHttpParams = MmsConfig.getHttpParams(); if (extraHttpParams != null) { String line1Number = ((TelephonyManager)context .getSystemService(Context.TELEPHONY_SERVICE)) .getLine1Number(); String nai = SystemProperties.get("persist.radio.cdma.nai", null); if (!TextUtils.isEmpty(nai)) { <|startfocus|> nai = nai + ":pcs"; <|endfocus|> byte[] encoded = Base64.encodeBase64(nai.getBytes(StandardCharsets.UTF_8)); nai = new String(encoded, StandardCharsets.UTF_8); } String line1Key = MmsConfig.getHttpParamsLine1Key(); String naiKey = MmsConfig.getHttpParamsNaiKey(); String paramList[] = extraHttpParams.split("\\|"); for (String paramPair : paramList) { String splitPair[] = paramPair.split(":", 2); if (splitPair.length == 2) { String name = splitPair[0].trim();
<|startcomment|> I think it's safer to check if line1Key != null first. I don't know what value.indexOf(null) returns. How about if (line1Key != null && lineNumber != null) { if (value.indexOf(line1Key) >= 0) { ... } } <|endcomment|>  nai = new String(encoded, StandardCharsets.UTF_8); } } for (String paramPair : paramList) { String splitPair[] = paramPair.split(":", 2); if (splitPair.length == 2) { String name = splitPair[0].trim(); String value = splitPair[1].trim(); <|startfocus|> if (value.indexOf(line1Key) >= 0 && line1Number != null) { value = value.replace(line1Key, line1Number); <|endfocus|> } if (value.indexOf(naiKey) >= 0 && nai != null) { value = value.replace(naiKey, nai); } if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(value)) { req.addHeader(name, value); } } } } req.addHeader(HDR_KEY_ACCEPT_LANGUAGE, HDR_VALUE_ACCEPT_LANGUAGE); HttpResponse response = client.execute(target, req); StatusLine status = response.getStatusLine(); if (status.getStatusCode() != 200) { // HTTP 200 is success.
<|startcomment|> maybe make this part optional (e.g. with a boolean parameter) ? It seems like there are cases where we might not want to strip recursively. (I'm not even sure how we end up in a scenario where the value is FooActivityActivity -- that seems like it would be a bug in the code which creates an activity suggestion from a layout name, where it's appending where it shouldn't be? <|endcomment|>  public static String stripSuffix(String name, String suffix) { if (name.isEmpty()) { return name; } int suffixStart = name.lastIndexOf(suffix.charAt(0)); if (suffixStart != -1 && name.regionMatches(suffixStart, suffix, 0, name.length() - suffixStart)) { name = name.substring(0, suffixStart); } // Recursively continue to strip the suffix (catch the FooActivityActivity case) <|startfocus|> if (name.endsWith(suffix)) { return stripSuffix(name, suffix); <|endfocus|> } return name;
<|startcomment|> can we just lose this constructor? <|endcomment|>  * (ByteBuffer, CharBuffer, etc.) is responsible for initializing this * value. The value is used by JNI code in frameworks/base/ to avoid the * need for costly 'instanceof' tests. */ final int _elementSizeShift; /** * For direct buffers, the effective address of the data; zero otherwise. * This is set in the constructor. * TODO: make this final at the cost of loads of extra constructors? [how many?] */ int effectiveDirectAddress; <|startfocus|> /** * For direct buffers, the underlying MemoryBlock; null otherwise. */ final MemoryBlock block; Buffer(int elementSizeShift, int capacity, MemoryBlock block) { <|endfocus|> this._elementSizeShift = elementSizeShift; if (capacity < 0) { throw new IllegalArgumentException("Capacity < 0: " + capacity); } this.capacity = this.limit = capacity; this.block = block; } /** * Returns the array that backs this buffer (optional operation).
<|startcomment|> that's the name of a local :-) <|endcomment|>  // we did decide to verify this file, we'd have created the Manifest and // the associated Verifier in the constructor itself. manifest = new Manifest(manifestBytes, false); manifestBytes = null; return manifest; } /** * Called by the JarFile constructors, this method reads the contents of the * file's META-INF/ directory and picks out the MANIFEST.MF file and <|startfocus|> * verifier signature files if they exist. All matching files are added to * {@code metaEntriesMap}. <|endfocus|> * * @throws IOException * if there is a problem reading the jar file entries. */ static HashMap<String, byte[]> readMetaEntries(ZipFile zipFile, boolean verificationRequired) throws IOException { // Get all meta directory entries List<ZipEntry> metaEntries = getMetaEntries(zipFile); HashMap<String, byte[]> metaEntriesMap = new HashMap<String, byte[]>(); for (ZipEntry entry : metaEntries) { String entryName = entry.getName();
<|startcomment|> "Gradle-aware Make" <|endcomment|>  public MakeBeforeRunTask createTask(RunConfiguration runConfiguration) { <|startfocus|> // "Android Studio Make" is only available in Android Studio. <|endfocus|> return AndroidStudioSpecificInitializer.isAndroidStudio() ? new MakeBeforeRunTask() : null;
<|startcomment|> ... defined in OpenSSL ssl/ssl_locl.h <|endcomment|>  public static String[] checkEnabledProtocols(String[] protocols) { if (protocols == null) { throw new IllegalArgumentException("protocols == null"); } for (int i = 0; i < protocols.length; i++) { String protocol = protocols[i]; if (protocol == null) { throw new IllegalArgumentException("protocols[" + i + "] == null"); } <|startfocus|> if ((!protocol.equals(SUPPORTED_PROTOCOL_TLSV1)) <|endfocus|> && (!protocol.equals(SUPPORTED_PROTOCOL_TLSV1_1)) && (!protocol.equals(SUPPORTED_PROTOCOL_TLSV1_2))) { throw new IllegalArgumentException("protocol " + protocol + " is not supported"); } } return protocols;
<|startcomment|> How long-lived is this class? Do we have to worry about entries in this map going stale? <|endcomment|> import com.intellij.util.messages.MessageBusConnection; import org.jetbrains.android.uipreview.ModuleClassLoader; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import java.io.File; import java.util.Map; import static com.android.SdkConstants.ANDROID_MANIFEST_XML; import static com.android.SdkConstants.DOT_AAR; import static com.android.tools.idea.gradle.compiler.PostProjectBuildTasksExecutor.GRADLE_BUILD_TOPIC; import static org.jetbrains.android.facet.ResourceFolderManager.EXPLODED_AAR; /** * A registry for class lookup of resource classes (R classes) in AAR libraries. */ <|startfocus|> public class AarResourceClassRegistry implements ProjectComponent { <|endfocus|> private final Map<String,AarResourceClassGenerator> myGeneratorMap = Maps.newHashMap(); private final Project myProject; private GradleBuildListener myBuildCompleteListener; @SuppressWarnings("WeakerAccess") // Accessed via reflection. public AarResourceClassRegistry(Project project) { myProject = project; } public void addLibrary(AppResourceRepository appResources, File aarDir) { String path = aarDir.getPath(); if (path.endsWith(DOT_AAR) || path.contains(EXPLODED_AAR)) {
<|startcomment|> I like to write this as {@linkplain AssetSetStep} to make it easier for IDEs to correctly update this if renaming the class. <|endcomment|> import org.jetbrains.annotations.Nullable; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.image.BufferedImage; import java.io.IOException; import java.util.Collection; import java.util.Iterator; import java.util.Map; import java.util.concurrent.Callable; import static com.android.tools.idea.wizard.AssetStudioWizardState.*; /** <|startfocus|> * AssetSetStep is a page in the New Project wizard that lets the user optionally create a customized launcher icon for the project * being created. <|endfocus|> */ public class AssetSetStep extends TemplateWizardStep { private static final Logger LOG = Logger.getInstance("#" + AssetSetStep.class.getName()); private static final int CLIPART_ICON_SIZE = 32; private static final int CLIPART_DIALOG_BORDER = 10; private static final int DIALOG_HEADER = 20; private AssetStudioWizardState myWizardState; private JPanel myPanel; private JRadioButton myImageRadioButton; private JRadioButton myClipartRadioButton; private JRadioButton myTextRadioButton; private JRadioButton myCropRadioButton; private JRadioButton myCenterRadioButton;
<|startcomment|> swap the order? <|endcomment|>  * @hide */ static int scopeForUnicastAddress(InetAddress addr) { if (addr.isAnyLocalAddress()) { return RT_SCOPE_HOST; } if (addr.isLoopbackAddress() || addr.isLinkLocalAddress()) { return RT_SCOPE_LINK; } // isSiteLocalAddress() returns true for private IPv4 addresses, but RFC 6724 section 3.2 // says that they are assigned global scope. <|startfocus|> if (addr.isSiteLocalAddress() && !(addr instanceof Inet4Address)) { <|endfocus|> return RT_SCOPE_SITE; } return RT_SCOPE_UNIVERSE; } /** * Utility function for the constructors. */ private void init(InetAddress address, int prefixLength, int flags, int scope) { if (address == null || address.isMulticastAddress() || prefixLength < 0 || ((address instanceof Inet4Address) && prefixLength > 32) || (prefixLength > 128)) { throw new IllegalArgumentException("Bad LinkAddress params " + address + "/" + prefixLength); } this.address = address; this.prefixLength = prefixLength;
<|startcomment|> if myArtifactType == null && o.myArtifactType != null this should also set isEqual = false right? But at a higher level do we really want to enforce that artifact types match? I'm not sure where we're using this method, but I would think that if this is used to answer queries like "is this coordinate representing the appcompat library", it should only check the group id -- both appcompat.v19 and appcompat.v9@aar should return true etc. Up to you. <|endcomment|>  public void add(RevisionComponent component) { <|startfocus|> myItems.add(component); <|endfocus|>
<|startcomment|> if (a.length<18 || a.length == 19 || a.length>20) I think == 20 is ok, correct? We also need to modify the tests to verify all this.. <|endcomment|>  boolean carrierEnabled; int bearer; String mvnoType, mvnoMatchData; if (version == 1) { typeArray = new String[a.length - 13]; System.arraycopy(a, 13, typeArray, 0, a.length - 13); protocol = RILConstants.SETUP_DATA_PROTOCOL_IP; roamingProtocol = RILConstants.SETUP_DATA_PROTOCOL_IP; carrierEnabled = true; bearer = 0; mvnoType = ""; mvnoMatchData = ""; } else { <|startfocus|> if (a.length < 18 || a.length >= 20) { <|endfocus|> Rlog.e(LOG_TAG, "ApnSetting format mismatch"); return null; } typeArray = a[13].split("\\s*\\|\\s*"); protocol = a[14]; roamingProtocol = a[15]; try { carrierEnabled = Boolean.parseBoolean(a[16]); } catch (Exception e) { carrierEnabled = true; } bearer = Integer.parseInt(a[17]); mvnoType = a[18]; mvnoMatchData = a[19]; } 
<|startcomment|> Generally, you should clean up comments in the CL under review Ideally, once a CL is reviewed and approved, you should submit it in that state and not have to change it post-approval. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.gct.idea.appengine.facet; import com.intellij.facet.Facet; import com.intellij.facet.FacetType; import com.intellij.openapi.module.JavaModuleType; import com.intellij.openapi.module.Module; import com.intellij.openapi.module.ModuleType; import icons.GoogleCloudToolsIcons; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import javax.swing.*; /** <|startfocus|> * @author nik <|endfocus|> */ public class AppEngineGradleFacetType extends FacetType<AppEngineGradleFacet, AppEngineGradleFacetConfiguration> { public AppEngineGradleFacetType() { super(AppEngineGradleFacet.TYPE_ID, AppEngineGradleFacet.ID, AppEngineGradleFacet.NAME); } @Override public AppEngineGradleFacetConfiguration createDefaultConfiguration() { return new AppEngineGradleFacetConfiguration(); } @Override public AppEngineGradleFacet createFacet(@NotNull Module module, String name, @NotNull AppEngineGradleFacetConfiguration configuration, @Nullable Facet underlyingFacet) { return new AppEngineGradleFacet(this, module, name, configuration); } @Override
<|startcomment|> use isEmpty() <|endcomment|>  public void keyReleased(KeyEvent arg0) { if (arg0.keyCode == SWT.CR) { <|startfocus|> String term = searchTextarea.getText().trim(); if (term.length() > 0) { <|endfocus|> if (term.equals(mLastSearchedTerm)) { nextSearchResult(); return; } mSearchResult = mModel.searchNode(term); if (mSearchResult.size() > 0) { mSearchResultIndex = 0; updateSearchResultSelection(); mLastSearchedTerm = term; } } }
<|startcomment|> 2013 <|endcomment|> <|startfocus|> * Copyright (C) 2012 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.uiautomator.actions; import com.android.uiautomator.UiAutomatorViewer; import com.google.common.io.Files; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Status; import org.eclipse.jface.action.Action; import org.eclipse.jface.dialogs.ErrorDialog; import org.eclipse.jface.resource.ImageDescriptor; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.graphics.ImageData;
<|startcomment|> nit - missing space after comma here and two lines down. <|endcomment|>  } if (methodCallName.equalsIgnoreCase(Type.MAVEN_CENTRAL.getCallName())) { return new Repository(Type.MAVEN_CENTRAL, null); } else if (methodCallName.equalsIgnoreCase(Type.MAVEN_LOCAL.getCallName())) { return new Repository(Type.MAVEN_LOCAL, null); } else if (methodCallName.equalsIgnoreCase(Type.URL.getCallName())) { return new Repository(Type.URL,s); } else if (s.startsWith("'") && s.endsWith("'")) { <|startfocus|> return new Repository(Type.URL,s.substring(1, s.length() - 1)); <|endfocus|> } else { return new UnparseableStatement(s, project); }
<|startcomment|> parameter order issue? I'll just post this comment to see what you think of it (in case I'm missing something) before going through the rest of the code. <|endcomment|>  public boolean OFFLINE_MODE; public String COMMAND_LINE_OPTIONS = ""; public static AndroidGradleBuildConfiguration getInstance(Project project) { return ServiceManager.getService(project, AndroidGradleBuildConfiguration.class); } @Nullable @Override public AndroidGradleBuildConfiguration getState() { return this; } @Override public void loadState(AndroidGradleBuildConfiguration state) { XmlSerializerUtil.copyBean(state, this); } @NotNull <|startfocus|> public Collection<String> getCommandLineOptions() { Collection<String> options = Sets.newLinkedHashSet(); <|endfocus|> CommandLineTokenizer tokenizer = new CommandLineTokenizer(COMMAND_LINE_OPTIONS); while(tokenizer.hasMoreTokens()) { options.add(tokenizer.nextToken()); } return options; } } 
<|startcomment|> What's the point of casting this to a long ? AssetInputStream.getAssetInt returns int anyway and It's also a public API so we can't change it. One really has to question why we have a public API that returns a pointer on the native heap. Anyway, I think the best course of action is to strongly deprecate that API and introduce a new API (getAssetLong) that returns a 64 bit value. Funnily enough, there's a CTS "test" for getAssetInt that goes like this : public void testGetAssetInt() { // the return value of getAssetInt is a random number mAssetInputStream.getAssetInt(); } (heh, "random number") <|endcomment|>  public static Movie decodeStream(InputStream is) { if (is == null) { return null; } if (is instanceof AssetManager.AssetInputStream) { <|startfocus|> final long asset = ((AssetManager.AssetInputStream) is).getAssetInt(); <|endfocus|> return nativeDecodeAsset(asset); } return nativeDecodeStream(is);
<|startcomment|> In addition to the module build.gradle files, we should also check the top level one ($project.getBaseDir/build.gradle) because in newer versions of Studio that's where we put the plugin version! <|endcomment|>  protected void execute(@NotNull Project project) { ModuleManager moduleManager = ModuleManager.getInstance(project); for (Module module : moduleManager.getModules()) { <|startfocus|> VirtualFile file; if ((file = module.getModuleFile()) != null && (file = file.getParent()) != null && (file = file.findChild(FN_BUILD_GRADLE)) != null) { <|endfocus|> final GradleBuildFile buildFile = new GradleBuildFile(file, project); Object pluginVersion = buildFile.getValue(PLUGIN_VERSION); if (pluginVersion != null) { ApplicationManager.getApplication().runWriteAction(new Runnable() { @Override public void run() { buildFile.setValue(PLUGIN_VERSION, GRADLE_PLUGIN_LATEST_VERSION); } }); } } } File wrapperPropertiesFile = GradleUtil.findWrapperPropertiesFile(project); if (wrapperPropertiesFile != null && !updateGradleVersion(project, wrapperPropertiesFile, GRADLE_LATEST_VERSION)) { return; } try { GradleProjectImporter.getInstance().reImportProject(project, null); } catch (ConfigurationException e) {
<|startcomment|> This is used only on the platform which doesn't support Windows, so this is really not necessary. We can add an assert at the top it needed to ensure we don't run this on windows. <|endcomment|>  @NonNull ILogger logger) { if (!mInitialized) { mTarget = new FakeAndroidTarget(mPlatformRootFolder, target); mBuildToolInfo = new BuildToolInfo(buildToolRevision, new File(mPlatformRootFolder), new File(getHostToolsFolder(), SdkConstants.FN_AAPT), new File(getHostToolsFolder(), SdkConstants.FN_AIDL), <|startfocus|> new File(mPlatformRootFolder, "prebuilts/sdk/tools/dx".replace('/', separatorChar)), new File(mPlatformRootFolder, "prebuilts/sdk/tools/lib/dx.jar".replace('/', separatorChar)), <|endfocus|> new File(getHostToolsFolder(), SdkConstants.FN_RENDERSCRIPT), new File(mPlatformRootFolder, "prebuilts/sdk/renderscript/include".replace('/', separatorChar)), new File(mPlatformRootFolder, "prebuilts/sdk/renderscript/clang-include" .replace('/',separatorChar)), new File(getHostToolsFolder(), SdkConstants.FN_BCC_COMPAT), new File(getHostToolsFolder(), "arm-linux-androideabi-ld"), new File(getHostToolsFolder(), "i686-linux-android-ld"),
<|startcomment|> Would be useful if parameters referring to native objects were prefixed with native_ <|endcomment|>  * limitations under the License. */ package android.graphics; public class ComposePathEffect extends PathEffect { /** * Construct a PathEffect whose effect is to apply first the inner effect * and the the outer pathEffect (e.g. outer(inner(path))). */ public ComposePathEffect(PathEffect outerpe, PathEffect innerpe) { native_instance = nativeCreate(outerpe.native_instance, innerpe.native_instance); } <|startfocus|> private static native long nativeCreate(long outerpe, long innerpe); <|endfocus|> } 
<|startcomment|> if "parse" throws exception, InputStream does not get closed. <|endcomment|>  */ public static ManifestData parse( IAbstractFile manifestFile, boolean gatherData, ManifestErrorHandler errorHandler) throws SAXException, IOException, StreamException, ParserConfigurationException { if (manifestFile != null) { SAXParser parser = sParserFactory.newSAXParser(); ManifestData data = null; if (gatherData) { data = new ManifestData(); } ManifestHandler manifestHandler = new ManifestHandler(manifestFile, data, errorHandler); InputStream is = manifestFile.getContents(); <|startfocus|> parser.parse(new InputSource(is), manifestHandler); is.close(); <|endfocus|> return data; } return null; } /** * Parses the Android Manifest, and returns an object containing the result of the parsing. * * <p/> * This is the equivalent of calling <pre>parse(manifestFile, true, null)</pre> * * @param manifestFile the manifest file to parse. * * @throws ParserConfigurationException * @throws StreamException * @throws IOException * @throws SAXException */ public static ManifestData parse(IAbstractFile manifestFile)
<|startcomment|> 2014 <|endcomment|> <|startfocus|> * Copyright (C) 2012 The Android Open Source Project <|endfocus|> * * Licensed under the Eclipse Public License, Version 1.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.eclipse.org/org/documents/epl-v10.php * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.ide.eclipse.adt.internal.wizards.exportgradle; import org.eclipse.jface.wizard.WizardPage; import org.eclipse.swt.SWT; import org.eclipse.swt.custom.CLabel; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; class ImportInsteadPage extends WizardPage { public ImportInsteadPage() { super("importInstead"); setTitle("Import Instead?");
<|startcomment|> WS <|endcomment|>  * into quick compiled code or the interpreter. */ private long entryPointFromPortableCompiledCode; /** * Method dispatch from quick compiled code invokes this pointer which may cause bridging * into portable compiled code or the interpreter. */ private long entryPointFromQuickCompiledCode; /** * Pointer to a data structure created by the compiler and used by the garbage collector to <|startfocus|> * determine which registers hold live references to objects within the heap. <|endfocus|> */ private long gcMap; /* Quick compiler meta-data. TODO: merge and place in native heap. */ /** * Pointer to a data structure created by the quick compiler to map between dex PCs and * native PCs, and vice-versa. */ private long quickMappingTable; /** * Pointer to a data structure used by the quick compiler to map between dalvik and machine * registers. */ private long quickVmapTable; /* End of quick compiler meta-data. */ 
<|startcomment|> nit: extra new line (else should go on the same line as the closing brace) <|endcomment|>  if (mKeyboardLayouts.contains(descriptor)) { throw new XmlPullParserException( "Found duplicate keyboard layout."); } mKeyboardLayouts.add(descriptor); if (current != null && current.equals("true")) { if (mCurrentKeyboardLayout != null) { throw new XmlPullParserException( "Found multiple current keyboard layouts."); } mCurrentKeyboardLayout = descriptor; } <|startfocus|> } else if (parser.getName().equals("calibration")) { <|endfocus|> String format = parser.getAttributeValue(null, "format"); if (format == null) { throw new XmlPullParserException( "Missing format attribute on calibration."); } if (format.equals("affine")) { float[] matrix = TouchCalibration.IDENTITY.getAffineTransform(); int depth = parser.getDepth(); while (XmlUtils.nextElementWithin(parser, depth)) { String tag = parser.getName().toLowerCase(); String value = parser.nextText(); for (int i = 0; i < matrix.length && i < CALIBRATION_NAME.length; i++) {
<|startcomment|> !tmpDirName.endsWith(File.separator) <|endcomment|>  File f = new File(dir, files[i]); if (f.isDirectory()) deleteTempFolder(f); else { f.delete(); } } dir.delete(); } public void test_ConstructorLjava_io_FileLjava_lang_String() throws Exception { String tmpDirName = System.getProperty("java.io.tmpdir"); File d = new File(tmpDirName); File f = new File(d, "input.tst"); <|startfocus|> if (tmpDirName.charAt(tmpDirName.length() - 1) != File.separatorChar) { <|endfocus|> tmpDirName += File.separator; } tmpDirName += "input.tst"; assertEquals(tmpDirName, f.getPath()); String fileName = null; try { f = new File(d, fileName); fail(); } catch (NullPointerException expected) { } f = new File(d, "input.tst"); assertEquals(tmpDirName, f.getAbsolutePath()); // Regression test for Harmony-382 File s = null; f = new File("/abc"); d = new File(s, "/abc");
<|startcomment|> Change the parameter type to ResourceType and pass in ResourceType.LAYOUT here (and ResourceType.DRAWABLE in the next call) <|endcomment|>  if (message != null) { violations.add(Constraint.APP_PACKAGE); } if (project != null) { exists = JavaPsiFacade.getInstance(project).findPackage(value) != null; } } if (constraints.contains(Constraint.LAYOUT)) { String resourceNameError = ResourceNameValidator.create(false, ResourceFolderType.LAYOUT).getErrorText(value); if (resourceNameError != null) { violations.add(Constraint.LAYOUT); } <|startfocus|> exists = existsResourceFile(module, SdkConstants.FD_RES_LAYOUT, value); <|endfocus|> } if (constraints.contains(Constraint.DRAWABLE)) { String resourceNameError = ResourceNameValidator.create(false, ResourceFolderType.DRAWABLE).getErrorText(value); if (resourceNameError != null) { violations.add(Constraint.DRAWABLE); } exists = existsResourceFile(module, "drawable", value); } if (constraints.contains(Constraint.ID)) { // TODO: validity and existence check } if (constraints.contains(Constraint.STRING)) { String resourceNameError = ResourceNameValidator.create(false, ResourceFolderType.VALUES).getErrorText(value); if (resourceNameError != null) {
<|startcomment|> I'm wondering if there's value in adding if ((mHandle & 0xffffffffL) != mHandle) { throw ... } to prevent mixing & matching 64-bit pointers with getHandle(). <|endcomment|> <|startfocus|> public int getHandle() { <|endfocus|> return (int)mHandle;
<|startcomment|> nit: s/getResolvedDependencies/resolveDependencies since it also modifies state related to the unresolved dependencies <|endcomment|>  * will be reported later on to the user. * * @param gradleModule the owner of the dependencies. * @param ideModule the module {@code DataNode} (it will ultimately converted into a real IDEA module. * @return the resolved dependencies in the given module. */ @NotNull <|startfocus|> private List<? extends IdeaDependency> getResolvedDependencies(@NotNull IdeaModule gradleModule, @NotNull DataNode<ModuleData> ideModule) { <|endfocus|> ProjectDependenciesModel model = resolverCtx.getExtraProject(gradleModule, ProjectDependenciesModel.class); List<? extends IdeaDependency> dependencies = model != null ? model.getDependencies() : gradleModule.getDependencies().getAll(); if (dependencies == null) { return Collections.emptyList(); } List<IdeaDependency> resolved = Lists.newArrayList(); Set<String> unresolved = Sets.newHashSet(); for (IdeaDependency dependency : dependencies) { if (dependency == null) { continue; } if (dependency instanceof IdeaSingleEntryLibraryDependency) { IdeaSingleEntryLibraryDependency library = (IdeaSingleEntryLibraryDependency)dependency; if (checkIfResolved(library)) {
<|startcomment|> I'd drop this comment as well -- no need to un-hide the API if we don't have a use for it yet. <|endcomment|>  // C function EGLDisplay eglGetDisplay ( EGLNativeDisplayType display_id ) public static native EGLDisplay eglGetDisplay( int display_id ); <|startfocus|> // TODO Unhide the eglGetDisplay(long) API method <|endfocus|> /** * {@hide} */ public static native EGLDisplay eglGetDisplay( long display_id ); 
<|startcomment|> closeQuietly or whatever its called? <|endcomment|>  * This of course implies that the {@code currentEntryNeedsZip64} and * {@code archiveNeedsZip64EocdRecord} are always {@code true}. */ private final boolean forceZip64; /** * Constructs a new {@code ZipOutputStream} that writes a zip file to the given * {@code OutputStream}. * * <p>UTF-8 will be used to encode the file comment, entry names and comments. */ public ZipOutputStream(OutputStream os) { <|startfocus|> this(os, false /* forceZip64 */); <|endfocus|> } public ZipOutputStream(OutputStream os, boolean forceZip64) { super(new CountingOutputStream(os), new Deflater(Deflater.DEFAULT_COMPRESSION, true)); this.forceZip64 = forceZip64; } /** * Closes the current {@code ZipEntry}, if any, and the underlying output * stream. If the stream is already closed this method does nothing. * * @throws IOException * If an error occurs closing the stream. */ @Override public void close() throws IOException {
<|startcomment|> We have a logger interface that ties into the Gradle logger API. we should use that one instead. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.manifmerger; import com.google.common.base.Optional; import com.google.common.collect.ImmutableList; import java.io.ByteArrayOutputStream; import java.io.File; import java.util.logging.Logger; /** * merges android manifest files, idempotent. */ public class ManifestMerger2 { <|startfocus|> private static final Logger logger = Logger.getLogger(ManifestMerger2.class.getName()); private final File mainManifestFile; private final ImmutableList<File> libraryFiles; private final ImmutableList<File> flavorsAndBuildTypeFiles; <|endfocus|> private final ImmutableList<Invoker.Features> mOptionalFeatures; private ManifestMerger2(File mainManifestFile, ImmutableList<File> libraryFiles, ImmutableList<File> flavorsAndBuildTypeFiles, ImmutableList<Invoker.Features> optionalFeatures) { this.mainManifestFile = mainManifestFile; this.libraryFiles = libraryFiles; this.flavorsAndBuildTypeFiles = flavorsAndBuildTypeFiles; this.mOptionalFeatures = optionalFeatures; } /** * Perform high level ordering of files merging and delegates actual merging to
<|startcomment|> Remove blank line. <|endcomment|>  public void run() { <|startfocus|> <|endfocus|> // Create a weak reference to an object so that we can detect when it is garbage collected. WeakReference<Object> reference = new WeakReference<Object>(new Object()); try { // 'Force' a GC and finalize to cause CloseGuards to report warnings. Doesn't loop forever // as there are no guarantees that the following code does anything at all so don't want // a potential infinite loop. Runtime runtime = Runtime.getRuntime(); for (int i = 0; i < 20; ++i) { runtime.gc(); System.runFinalization(); try { Thread.sleep(1); } catch (InterruptedException e) { throw new AssertionError(e); } // Check to see if the weak reference has been garbage collected. if (reference.get() == null) { System.logI("Sentry object has been freed so assuming CloseGuards have reported" + " any resource leakages"); break; } } } finally { // Restore the reporter. CloseGuard.setReporter(closeGuardReporter);
<|startcomment|> nullness annotations here? (I noticed you added them on the parent class) <|endcomment|> <|startfocus|> private NodeRecord(ActionType actionType, <|endfocus|> ActionLocation actionLocation, NodeOperationType nodeOperationType) { super(actionType, actionLocation); this.mNodeOperationType = nodeOperationType;
<|startcomment|> mOverallResult. (Is "overall" redundant here and mResult adequate?) <|endcomment|>  * * This is implemented as a separate class so it can be invoked by tools independently from the * merging process. * * This validator will check the state of the loaded xml document before any merging activity is * attempted. It verifies things like a "tools:replace="foo" attribute has a "android:foo" * attribute also declared on the same element (since we want to replace its value). */ public class PreValidator { <|startfocus|> private MergingReport.Result overallResult = MergingReport.Result.SUCCESS; <|endfocus|> private PreValidator() {} /** * Validates a loaded {@link com.android.manifmerger.XmlDocument} and return a status of the * merging model. * * Will return one the following status : * <ul> * <li>{@link com.android.manifmerger.MergingReport.Result#SUCCESS} : the merging model is * correct, merging should be attempted</li> * <li>{@link com.android.manifmerger.MergingReport.Result#WARNING} : the merging model
<|startcomment|> The line should be split before the "||" statement. See http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-136091.html#248 for the rules for line splitting. <|endcomment|>  String target_context = createAvcContext(t, true, c, p); if (!contextsCache.containsKey(target_context)) { contextsCache.put(target_context, checkSELinuxContext(target_context)); } if (!contextsCache.get(target_context)) { continue; } boolean canAccess = checkSELinuxAccess(source_context, target_context, c, p, ""); result.numTotalChecks++; <|startfocus|> if ((r.type.equals("allow") && !canAccess) || (r.type.equals("neverallow") && canAccess)) { <|endfocus|> String failureNotice = s + ", " + t + ", " + c + ", " + p; result.numFailedChecks++; result.failedChecks.add(failureNotice); } } } } } return result;
<|startcomment|> Yuck, this looks much worse and is harder to understand than channel().isOpen(). Do we understand why this new API was added ? (Also, why is it not final like channel() is ?) <|endcomment|>  public boolean isValid() { <|startfocus|> return !isReleased && acquiredBy().isOpen(); <|endfocus|>
<|startcomment|> "@" is an unfortunate prefix to use for placeholders in Android resource files, since it is an extremely common valid prefix (@string/app_name etc). What about ${} instead? <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.manifmerger; import com.android.annotations.NonNull; import com.android.annotations.Nullable; import java.util.logging.Logger; import java.util.regex.Matcher; import java.util.regex.Pattern; /** <|startfocus|> * Replaces all placeholders of the form @{name} with an tool invocation provided value <|endfocus|> */ public class PlaceholderHandler { // regular expression to recognize placeholders like @{name}, potentially surrounded by a // prefix and suffix string. this will split in 3 groups, the prefix, the placeholder name, and // the suffix. private final Pattern mPattern = Pattern.compile("([^@]*)@\\{([^\\}]*)\\}(.*)"); /** * Interface to provide a value for a placeholder key. */ public interface KeyBasedValueResolver { /** * Returns a placeholder value for the placeholder key or null if none exists. */ @Nullable
<|startcomment|> Charsets.UTF_8 <|endcomment|>  list.add(lval); } break; case EVENT_TYPE_STRING: { /* UTF-8 chars, not NULL-terminated */ int strLen; if (eventData.length - offset < 4) return -1; strLen = ArrayHelper.swap32bitFromArray(eventData, offset); offset += 4; if (eventData.length - offset < strLen) return -1; // get the string <|startfocus|> try { String str = new String(eventData, offset, strLen, SdkConstants.UTF_8); list.add(str); } catch (UnsupportedEncodingException e) { } <|endfocus|> offset += strLen; break; } case EVENT_TYPE_LIST: { /* N items, all different types */ if (eventData.length - offset < 1) return -1; int count = eventData[offset++]; // make a new temp list ArrayList<Object> subList = new ArrayList<Object>(); for (int i = 0; i < count; i++) { int result = parseBinaryEvent(eventData, offset, subList); if (result == -1) {
<|startcomment|> if the name parameter is just a prefix, maybe rename it to namePrefix. If this code is ever used to check resources in the values folder you may want to make the check case insensitive (we have SdkUtils.startsWithIgnoreCase) <|endcomment|>  File[] resTypes = resDir.listFiles(); if (resTypes == null) { continue; } for (File resTypeDir : resTypes) { if (resTypeDir.exists() && resTypeDir.isDirectory() && resTypeDir.getName().startsWith(resourceType.getName())) { File[] files = resTypeDir.listFiles(); if (files == null) { continue; } for (File f : files) { <|startfocus|> if (f.getName().startsWith(name)) { <|endfocus|> return true; } } } } } return false;
<|startcomment|> Let's move this under current too and make it part of the policy update bundle. <|endcomment|>  // Default seinfo read from policy. private static String sDefaultSeinfo = null; // Data policy override version file. private static final String DATA_VERSION_FILE = Environment.getDataDirectory() + "/security/current/selinux_version"; // Base policy version file. private static final String BASE_VERSION_FILE = "/selinux_version"; // Data override mac_permissions.xml policy file. private static final String DATA_MAC_PERMISSIONS = <|startfocus|> Environment.getDataDirectory() + "/security/mac_permissions.xml"; <|endfocus|> // Base mac_permissions.xml policy file. private static final String BASE_MAC_PERMISSIONS = Environment.getRootDirectory() + "/etc/security/mac_permissions.xml"; // Location of seapp_contexts policy file. private static final String SEAPP_CONTEXTS_FILE = "/seapp_contexts"; // Stores the hash of the last used seapp_contexts file. private static final String SEAPP_HASH_FILE = Environment.getDataDirectory().toString() + "/system/seapp_hash"; // Signature policy stanzas static class Policy { private String seinfo;
<|startcomment|> looks like indentation is off? <|endcomment|>  private void displayProjectSetupMessages() { final ProjectSyncMessages messages = ProjectSyncMessages.getInstance(myProject); <|startfocus|> int sdkErrorCount = messages.getMessageCount(FAILED_TO_SET_UP_SDK); <|endfocus|> if (sdkErrorCount > 0) { // If we have errors due to platforms not being installed, we add an extra message that prompts user to open Android SDK manager and // install any missing platforms. Navigatable quickFix = new OpenAndroidSdkNavigatable(myProject); String text = "Double-click here to open Android SDK Manager and install all missing platforms."; Message quickFixMsg = new Message(FAILED_TO_SET_UP_SDK, Message.Type.INFO, quickFix, text); messages.add(quickFixMsg); } // Now we only show one balloon, telling user that errors can be found in the "Messages" window. String title = String.format("Failed to set up project '%1$s':\n", myProject.getName()); NotificationHyperlink hyperlink = new NotificationHyperlink("open.messages.view", "Open Messages Window") { @Override
<|startcomment|> @TargetApi(17) is safer <|endcomment|>  } TrustManagerFactory tmfactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); tmfactory.init(keystore); return tmfactory.getTrustManagers(); } // non-javadoc, see interface org.apache.http.conn.SocketFactory @Override public Socket createSocket() throws IOException { // the cast makes sure that the factory is working as expected return socketfactory.createSocket(); } // non-javadoc, see interface org.apache.http.conn.SocketFactory @Override <|startfocus|> @SuppressLint("NewApi") <|endfocus|> public Socket connectSocket( final Socket sock, final String host, final int port, final InetAddress localAddress, int localPort, final HttpParams params ) throws IOException { if (host == null) { throw new IllegalArgumentException("Target host may not be null."); } if (params == null) { throw new IllegalArgumentException("Parameters may not be null."); } SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket()); if ((localAddress != null) || (localPort > 0)) { 
<|startcomment|> %1$s <|endcomment|>  if (mapping.getValue() == null) { projects.add(mapping.getKey()); } } if (projects.isEmpty()) { return null; } else if (projects.size() == 1) { return String.format("Sources for module '%s' were not found", Iterables.getFirst(projects, null)); } else { String projectsList = Joiner.on("', '").join(projects); <|startfocus|> return String.format("Sources were not found for modules '%s'", projectsList); <|endfocus|> }
<|startcomment|> mMap is used in synchronized context in "getItem", but not here. My understanding is that synchronized variables need to be, well, synchronized, on every read/write access. Also by adding "Guardedby(this)" we are implying that. <|endcomment|> <|startfocus|> public void clear() { <|endfocus|> if (!mMap.isEmpty()) { System.out.println("PREDEX CACHE HITS: " + mHits); System.out.println("PREDEX CACHE MISSES: " + mMisses); } mMap.clear();
<|startcomment|> Can you use EGLExt.EGL_OPENGL_ES3_BIT_KHR <|endcomment|>  * And we know the configSpec is well formed. */ int len = configSpec.length; int[] newConfigSpec = new int[len + 2]; System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1); newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE; if (mEGLContextClientVersion == 2) { newConfigSpec[len] = 0x4; /* EGL_OPENGL_ES2_BIT */ } else { <|startfocus|> newConfigSpec[len] = 0x40; /* EGL_OPENGL_ES3_BIT_KHR */ <|endfocus|> } newConfigSpec[len+1] = EGL10.EGL_NONE; return newConfigSpec;
<|startcomment|> maybe myEnabled instead? (e.g. leave the "is" for the getter prefix) <|endcomment|>  } private void toggleSelection(@Nullable Module module) { if (module != null) { Map<String, VirtualFile> old = getModel().getSelectedModules(); module.setEnabled(!module.isEnabled()); Map<String, VirtualFile> current = getModel().getSelectedModules(); firePropertyChange(PROPERTY_SELECTED_MODULES, old, current); } } private static class Module implements Comparable<Module> { @NotNull public final String name; @Nullable public final VirtualFile location; <|startfocus|> private boolean myIsEnabled = true; <|endfocus|> private Module(@NotNull String name, @Nullable VirtualFile location) { this.name = name; this.location = location; } public boolean isEnabled() { return myIsEnabled && location != null; } public void setEnabled(boolean enabled) { this.myIsEnabled = enabled; } @Override public int compareTo(@NotNull Module o) { if (location == null && o.location != null) { return 1; } else if (location != null && o.location == null) { return -1;
<|startcomment|> myResolved <|endcomment|> import com.intellij.openapi.module.Module; import org.jetbrains.annotations.NotNull; import java.util.Collection; import java.util.List; public class SelectionConflict { @NotNull private final Module mySource; @NotNull private final String mySelectedVariant; // Key: variant expected by module, Value: all modules expecting the variant used as key. @NotNull private final Multimap<String, AffectedModule> myAffectedModulesByExpectedVariant = ArrayListMultimap.create(); @NotNull private final List<AffectedModule> myAffectedModules = Lists.newArrayList(); <|startfocus|> private boolean resolved; <|endfocus|> public SelectionConflict(@NotNull Module source, @NotNull String selectedVariant) { mySource = source; mySelectedVariant = selectedVariant; } public void addAffectedModule(@NotNull Module target, @NotNull String expectedVariant) { AffectedModule affected = new AffectedModule(this, target, expectedVariant); myAffectedModules.add(affected); myAffectedModulesByExpectedVariant.put(expectedVariant, affected); } @NotNull public Collection<String> getExpectedVariants() { return myAffectedModulesByExpectedVariant.keySet(); } @NotNull
<|startcomment|> I suggest you remove this line too, as Elliott said. <|endcomment|>  assertGetCollationElementIteratorString(new Locale("de", "DE", ""), "\u00e6b", 0, 1, 1, 2); } public void testGetCollationElementIteratorCharacterIterator_es() throws Exception { assertGetCollationElementIteratorCharacterIterator(new Locale("es", "", ""), "cha", 0, 1, 2, 3); } public void testGetCollationElementIteratorCharacterIterator_de_DE() throws Exception { <|startfocus|> // Same change as in the ...String_de_DE() test. <|endfocus|> assertGetCollationElementIteratorCharacterIterator(new Locale("de", "DE", ""), "\u00e6b", 0, 1, 1, 2); } } 
<|startcomment|> Do we really need to put this in the log? <|endcomment|>  long now = System.currentTimeMillis(); long start; synchronized (myTimestampMap) { start = myTimestampMap.remove(key); } if (start > 0 && start < now) { StudioBuildStatsPersistenceComponent stats = StudioBuildStatsPersistenceComponent.getInstance(); if (stats != null) { BuildRecord record = new BuildRecord(key, Long.toString(now - start)); stats.addBuildRecord(record); } } } catch (Throwable ignore) { <|startfocus|> LOG.info("Unable to add build record", ignore); <|endfocus|> }
<|startcomment|> this has now moved to android.system. <|endcomment|>  import android.content.res.Resources; import android.content.res.TypedArray; import android.icu.impl.CacheValue; import android.icu.text.DecimalFormatSymbols; import android.icu.util.ULocale; import android.net.LocalServerSocket; import android.opengl.EGL14; import android.os.Process; import android.os.SystemClock; import android.os.SystemProperties; import android.os.Trace; import android.os.ZygoteProcess; import android.os.storage.StorageManager; import android.security.keystore.AndroidKeyStoreProvider; import android.system.ErrnoException; import android.system.Os; <|startfocus|> import android.system.OsConstants; <|endfocus|> import android.text.Hyphenator; import android.util.EventLog; import android.util.Log; import android.webkit.WebViewFactory; import android.widget.TextView; import com.android.internal.os.InstallerConnection.InstallerException; import dalvik.system.DexFile; import dalvik.system.PathClassLoader; import dalvik.system.VMRuntime; import dalvik.system.ZygoteHooks; import libcore.io.IoUtils; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.security.Security; import java.security.Provider; /**
<|startcomment|> Style "if(" vs "if (" [there are some other places in this file] <|endcomment|>  if(classType.isEmpty()) { LOG.error("Invalid class \"" + classType + "\" to create Endpoint for"); } // Check if there is a file with the same name as the file that will contain the endpoint class String endpointFileName = directory +"/" + classType + ENDPOINT_CLASS_SUFFIX; File temp = new File(endpointFileName); if(temp.exists()) { <|startfocus|> Messages.showErrorDialog(project, "\'" + temp.getName() + "\" already exist", ERROR_MESSAGE_TITLE); <|endfocus|> return; } final Template template = Template.createFromPath(getTemplate().getFile()); if(template == null) { return; } final File projectRoot = new File(project.getBasePath()); final File moduleRoot = new File(projectRoot, module.getName()); // Create the replacement map final Map<String, Object> replacementMap = new HashMap<String, Object>(); try { replacementMap.put(TemplateMetadata.ATTR_PROJECT_OUT, moduleRoot.getCanonicalPath()); } catch (Exception e) {
<|startcomment|> fstrim? <|endcomment|>  public void onReceive(Context context, Intent intent) { String action = intent.getAction(); <|startfocus|> // Since fstrim will be run on a daily basis we do not expect // fstrim to be too long, so it is not interruptible. We will // implement interruption only in case we see issues. <|endfocus|> if (Intent.ACTION_IDLE_MAINTENANCE_START.equals(action)) { onIdleStart(); } else if (Intent.ACTION_IDLE_MAINTENANCE_END.equals(action)) { onIdleStop(); }
<|startcomment|> in the tools/base project the field prefix is just "m" (and for statics, "s") instead of my and our. <|endcomment|>  return type; } } } return null; } @Override public String toString() { return myId; } } /** * A single component of a revision number: either a number, a string or a list of * components separated by dashes. */ public abstract static class RevisionComponent implements Comparable<RevisionComponent> { public abstract int asInteger(); } public static class NumberComponent extends RevisionComponent { <|startfocus|> private final int myNumber; <|endfocus|> public NumberComponent(int number) { myNumber = number; } @Override public String toString() { return Integer.toString(myNumber); } @Override public int asInteger() { return myNumber; } @Override public boolean equals(Object o) { return o instanceof NumberComponent && ((NumberComponent) o).myNumber == myNumber; } @Override public int hashCode() { return myNumber; } @Override public int compareTo(RevisionComponent o) { if (o instanceof NumberComponent) {
<|startcomment|> This looks wrong <|endcomment|> import com.google.common.base.Charsets; import com.google.common.collect.*; import com.google.common.io.Files; import com.intellij.ide.actions.NonEmptyActionGroup; import com.intellij.openapi.actionSystem.*; import com.intellij.openapi.application.PathManager; import com.intellij.openapi.diagnostic.Logger; import com.intellij.openapi.module.Module; import com.intellij.openapi.util.io.FileUtil; import com.intellij.openapi.vfs.LocalFileSystem; import com.intellij.openapi.vfs.VfsUtilCore; import com.intellij.openapi.vfs.VirtualFile; <|startfocus|> import com.sun.org.apache.regexp.internal.recompile; <|endfocus|> import icons.AndroidIcons; import org.jetbrains.android.facet.AndroidFacet; import org.jetbrains.android.sdk.AndroidSdkData; import org.jetbrains.android.sdk.AndroidSdkUtils; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import org.w3c.dom.Document; import java.io.File; import java.io.FileFilter; import java.io.IOException; import java.util.*; import static com.android.SdkConstants.*; import static com.android.tools.idea.templates.Template.TEMPLATE_XML_NAME; /** * Handles locating templates and providing template metadata */ public class TemplateManager {
<|startcomment|> This one's just unnecessary though :) <|endcomment|>  public void test_toString_nonUs() { // The string for the timezone depends on what the default locale is. Not every locale // has a short-name for America/Chicago -> PST. Locale.setDefault(Locale.UK); TimeZone.setDefault(TimeZone.getTimeZone("America/Chicago")); assertEquals("Wed Dec 31 18:00:00 GMT-06:00 1969", new Date(0).toString()); <|startfocus|> <|endfocus|>
<|startcomment|> ditto <|endcomment|>  * Written by Doug Lea with assistance from members of JCP JSR-166 * Expert Group and released to the public domain, as explained at * http://creativecommons.org/publicdomain/zero/1.0/ */ package jsr166; <|startfocus|> import junit.framework.*; import java.util.Arrays; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; import java.util.concurrent.BlockingDeque; <|endfocus|> import java.util.concurrent.BlockingQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; import java.util.concurrent.LinkedBlockingDeque; import static java.util.concurrent.TimeUnit.MILLISECONDS; public class LinkedBlockingDequeBoundedTest extends JSR166TestCase { protected BlockingQueue emptyCollection() { return new LinkedBlockingDeque(SIZE); } } 
<|startcomment|> nit: double space. <|endcomment|>  List<Item> items = classMap.get(cls); Collections.sort(items); for (Item item : items) { item.write(writer); } } writer.println("</root>\n"); writer.close(); String xml = stringWriter.toString(); // Validate if (assertionsEnabled()) { Document document = checkDocument(xml, false); if (document == null) { <|startfocus|> error("Could not parse XML document back in for entry " + name <|endfocus|> + ": invalid XML?\n\"\"\"\n" + xml + "\n\"\"\"\n"); return false; } } byte[] bytes = xml.getBytes(Charsets.UTF_8); zos.write(bytes); zos.closeEntry(); } finally { writer.close(); } } } finally { zos.flush(); zos.close(); } } catch (IOException ioe) { error(ioe.toString()); return false; } return true; } /**
<|startcomment|> This interferes with anti-aliasing and may make the text unreadable. I would suggest to subtract 1 or 2 from the font size but provide lover bound for the smallest font size. Or just use regular font size... <|endcomment|>  public void setFont(Font font) { if (font == null || myContentLabel == null) { return; } super.setFont(font); myContentLabel.setFont(font); <|startfocus|> Font smallerFont = font.deriveFont((float)(font.getSize() * 0.8)); <|endfocus|> myEditLabel.setFont(smallerFont);
<|startcomment|> This method now always returns true, please change its return type to void. <|endcomment|>  * Returns true if there is an active user and false otherwise. * @return True if there is an active user and false otherwise. */ public boolean isActiveUserAvailable() { synchronized (this) { return activeUser != null; } } /** * Adds a user to the list of current users. If the user already exists, * the user will be updated. * The <code>user</code> becomes the active user. * @param user * @return */ <|startfocus|> public boolean addUser(User user) { <|endfocus|> synchronized (this) { if(allUsers.containsKey(user.getEmail())) { allUsers.remove(user.getEmail()); } allUsers.put(user.getEmail(), user); setActiveUser(user.getEmail()); return true; } } /** * Remove <code>userEmail</code> from the list of logged in users if <code>userEmail</code> is
<|startcomment|> same here: createMergeManifest <|endcomment|>  public void createTasks( @NonNull BaseVariantData variantData, @Nullable Task assembleTask) { assert variantData instanceof ApplicationVariantData; ApplicationVariantData appVariantData = (ApplicationVariantData) variantData; basePlugin.createAnchorTasks(variantData); basePlugin.createCheckManifestTask(variantData); handleMicroApp(variantData); // Add a task to process the manifest(s) <|startfocus|> basePlugin.mergeManifests(variantData, "manifests"); <|endfocus|> // Add a task to create the res values basePlugin.createGenerateResValuesTask(variantData); // Add a task to compile renderscript files. basePlugin.createRenderscriptTask(variantData); // Add a task to merge the resource folders basePlugin.createMergeResourcesTask(variantData, true /*process9Patch*/); // Add a task to merge the asset folders basePlugin.createMergeAssetsTask(variantData, null /*default location*/, true /*includeDependencies*/); // Add a task to create the BuildConfig class basePlugin.createBuildConfigTask(variantData); // Add a task to generate resource source files basePlugin.createProcessResTask(variantData, true /*generateResourcePackage*/); // Add a task to process the java resources
<|startcomment|> misleading: the file is missing or unreadable, not that you weren't able to +x it. <|endcomment|>  String msg = errors.size() == 1 ? errors.get(0) : Joiner.on('\n').join(errors); Messages.showErrorDialog(msg, ERROR_MSG_TITLE); LOG.error(msg); } } public static void setGradleWrapperExecutable(File projectRoot) throws IOException { if (SystemInfo.isUnix) { File gradlewFile = new File(projectRoot, "gradlew"); if (!gradlewFile.isFile()) { <|startfocus|> LOG.error("Unable to set executable bit on gradle wrapper. Command line builds may not work properly."); <|endfocus|> } else { FileUtil.setExecutableAttribute(gradlewFile.getPath(), true); } } } } 
<|startcomment|> Please don't hardcode any colors. It's very likely that this color will look wrong under the Darcula L&F. At least you need to use JBColor that can automatically choose one of two colors depending on whether you use Darcula. <|endcomment|> import javax.swing.JPanel; import javax.swing.ListCellRenderer; import java.awt.Color; import java.awt.Component; import java.awt.Dimension; import java.awt.Font; import java.awt.Graphics; import java.awt.GridLayout; import java.awt.Image; /** * A custom cell render for {@link GoogleLoginUsersPanel#list} that manages * how each user item in the Google Login panel would be displayed. */ public class UsersListCellRenderer extends JComponent implements ListCellRenderer { <|startfocus|> private final Color ACTIVE_COLOR = Color.LIGHT_GRAY; <|endfocus|> private final Font PLAIN_NAME_FONT; private final Font PLAIN_EMAIL_FONT; private final Dimension MAIN_PANEL_DIMENSION; public UsersListCellRenderer() { PLAIN_NAME_FONT = new Font("Helvetica", Font.BOLD, 13); PLAIN_EMAIL_FONT = new Font("Helvetica", Font.PLAIN, 13);; MAIN_PANEL_DIMENSION = new Dimension(250, 68); } @Override public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) { if(!(value instanceof UsersListItem)) { return null; } 
<|startcomment|> wrong indent <|endcomment|>  + "use / instead"; report(context, cookie, PATH, message); } else if (new File(path.replace('/', File.separatorChar)).isAbsolute()) { String message = "Avoid using absolute paths in .gradle files"; report(context, cookie, PATH, message); } } else { String dependency = getStringLiteralValue(value); if (dependency != null) { GradleCoordinate gc = GradleCoordinate.parseCoordinateString(dependency); if (gc != null) { <|startfocus|> boolean gotError = false; <|endfocus|> if (dependency.startsWith(SdkConstants.GRADLE_PLUGIN_NAME)) { gotError = checkGradlePluginDependency(context, gc, cookie); } else { if (gc.acceptsGreaterRevisions()) { String message = "Avoid using + in version numbers; can lead " + "to unpredictable and unrepeatable builds"; report(context, cookie, PLUS, message); } } if (!gotError) { checkDependency(context, gc, cookie); } } } } } else if (property.equals("packageNameSuffix")) {
<|startcomment|> Should probably extract getProjectStatePath(project) into a local variable here, and return false if (!file.exists()). (Instead of relying on IOEceptions to fail if file doesn't exist) -- since it seems normal for this file to not exist (e.g. for every new project). <|endcomment|>  catch (IOException e) { LOG.info("Error accessing project cache, sync will be needed."); } catch (ClassNotFoundException e) { LOG.info("Cannot recover cache, sync will be needed."); } return false; } @Nullable static private boolean doLoadFromDisk(Project project) throws IOException, ClassNotFoundException { FileInputStream fin = null; try { File rootDirPath = new File(FileUtil.toSystemDependentName(project.getBasePath())); <|startfocus|> fin = new FileInputStream(getProjectStatePath(project)); <|endfocus|> ObjectInputStream ois = new ObjectInputStream(fin); try { AndroidGradleProjectData data = (AndroidGradleProjectData)ois.readObject(); if (data.validate(rootDirPath)) { data.applyTo(project); return true; } } finally { Closeables.close(ois, false); } } finally { Closeables.close(fin, false); } return false; } @NotNull private static String getProjectStatePath(@NotNull Project project) throws IOException {
<|startcomment|> I know this CL doesn't introduce this method, but this method name looks like it's going to delete everything in my Gradle project :P It's private, so not a big deal at all. <|endcomment|>  } else { // Since we have nothing else to show, just print the stack trace of the caught exception. ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE); try { //noinspection IOResourceOpenedButNotSafelyClosed e.printStackTrace(new PrintStream(out)); String message = "Internal error:" + SystemProperties.getLineSeparator() + out.toString(); GradleMessage msg = new GradleMessage(GradleMessage.Kind.ERROR, message); buildMessages.add(msg); addMessage(msg, null); } finally { <|startfocus|> try { Closeables.close(out, true /* swallowIOException */); } catch (IOException ex) { // Cannot happen } <|endfocus|> } }
<|startcomment|> I don't you need a static instance of this; it's very lightweight to construct (statics incur overhead for gc) <|endcomment|>  public static String getMergedFlavorName(Variant variant) { <|startfocus|> return JOINER.join(variant.getProductFlavors()); <|endfocus|>
<|startcomment|> move up one line <|endcomment|>  static void fixBuildToolsVersionAndSync(@NotNull Project project, @NotNull VirtualFile buildFile, @NotNull final String version) { final GradleBuildFile gradleBuildFile = new GradleBuildFile(buildFile, project); Object pluginVersion = gradleBuildFile.getValue(BUILD_TOOLS_VERSION); if (pluginVersion != null) { WriteCommandAction.runWriteCommandAction(project, new Runnable() { @Override public void run() { gradleBuildFile.setValue(BUILD_TOOLS_VERSION, version); } }); } <|startfocus|> GradleProjectImporter.getInstance().requestProjectSync(project, null); <|endfocus|>
<|startcomment|> no more need of the original "first this then that" comments (you removed the "then" one already) so remove this part too. <|endcomment|>  protected void writeRepeatedData(Object array, CodedOutputByteBufferNano output) { if (tag == nonPackedTag) { // Use base implementation for non-packed data super.writeRepeatedData(array, output); } else if (tag == packedTag) { // Packed. Note that the array element type is guaranteed to be primitive, so there <|startfocus|> // won't be any null elements, so no null check in this block. First get data size. <|endfocus|> int arrayLength = Array.getLength(array); int dataSize = computePackedDataSize(array); try { output.writeRawVarint32(tag); output.writeRawVarint32(dataSize); switch (type) { case TYPE_BOOL: for (int i = 0; i < arrayLength; i++) { output.writeBoolNoTag(Array.getBoolean(array, i)); } break; case TYPE_FIXED32: for (int i = 0; i < arrayLength; i++) { output.writeFixed32NoTag(Array.getInt(array, i)); } break; case TYPE_SFIXED32:
<|startcomment|> our <|endcomment|> import com.intellij.openapi.roots.libraries.ui.OrderRoot; import com.intellij.openapi.roots.ui.configuration.ProjectSettingsService; import com.intellij.openapi.util.io.FileUtil; import com.intellij.openapi.vfs.StandardFileSystems; import com.intellij.openapi.vfs.VfsUtil; import com.intellij.openapi.vfs.VirtualFile; import com.intellij.pom.java.LanguageLevel; import com.intellij.util.ArrayUtil; import com.intellij.util.SystemProperties; import com.intellij.util.io.URLUtil; <|startfocus|> import org.jetbrains.android.facet.AndroidFacet; <|endfocus|> import org.jetbrains.android.sdk.AndroidSdkAdditionalData; import org.jetbrains.android.sdk.AndroidSdkData; import org.jetbrains.android.sdk.AndroidSdkUtils; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import org.jetbrains.plugins.gradle.util.GradleConstants; import java.io.File; import java.util.Collection; import java.util.EnumSet; import java.util.List; import java.util.Set; import static com.android.SdkConstants.FN_FRAMEWORK_LIBRARY; import static com.android.tools.idea.gradle.messages.CommonMessageGroupNames.FAILED_TO_SET_UP_SDK; import static com.android.tools.idea.gradle.service.notification.errors.AbstractSyncErrorHandler.FAILED_TO_SYNC_GRADLE_PROJECT_ERROR_GROUP_FORMAT;
<|startcomment|> Do not hard-code these values; these will be different on different operating systems. Use FontMetrics.stringWidth() to calculate the width of the string dynamically. <|endcomment|>  public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) { if(!(value instanceof UsersListItem)) { return null; } JPanel mainPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); mainPanel.setMinimumSize(MAIN_PANEL_DIMENSION); mainPanel.setAlignmentX(LEFT_ALIGNMENT); // Update colors <|startfocus|> final Color bg = isSelected ? ACTIVE_COLOR : UIUtil.getListBackground(); final Color fg = isSelected ? UIUtil.getListSelectionForeground() : UIUtil.getListForeground(); <|endfocus|> mainPanel.setBackground(bg); mainPanel.setForeground(fg); Image image = ((UsersListItem)value).getUserPicture(); Image scaledImage = image.getScaledInstance(PLAIN_IMAGE_WIDTH, PLAIN_IMAGE_HEIGHT, java.awt.Image.SCALE_SMOOTH); mainPanel.add(new JLabel(new ImageIcon(scaledImage))); mainPanel.add(createTextDisplay(isSelected, (UsersListItem)value)); // TODO: add Separator to bottom of panel return mainPanel;
<|startcomment|> Doesn't look like this variable is getting used. Is it meant for the TODO below? <|endcomment|>  // That's because on Windows trying to update some of the packages in-place // *will* fail (e.g. typically the android platform or the tools) as the // folder is most likely locked. // As mentioned in InstallTask below, the shortcut we're taking here will // install all the requested packages, even if already installed, which is // useless so that's another incentive to remove already installed packages // from the requested list. <|startfocus|> LocalSdk localSdk = sdkData.getLocalSdk(); <|endfocus|> final ArrayList<String> requestedPackages = Lists.newArrayList(); List requestedChanges = myState.get(INSTALL_REQUESTS_KEY); if (requestedChanges == null) { // This should never occur myInstallFinished = true; invokeUpdate(null); return; } for (Object object : requestedChanges) { try { IPkgDesc packageDesc = (IPkgDesc)object; if (packageDesc != null) { // TODO use localSdk to filter list and remove already installed items requestedPackages.add(packageDesc.getInstallId()); }
<|startcomment|> + Why not use the frame rate set to configure the encoder? + Why 132? <|endcomment|> <|startfocus|> private static long computePresentationTime(int frameIndex) { return 132 + frameIndex * 1000000 / FRAME_RATE; <|endfocus|>
<|startcomment|> Can REMOVE_PREVIEWS and GRADLE_COORDINATE_ORDERING be private? <|endcomment|>  } } /** * Get a helpful comment about how to install the parent repository for the given coordinate */ public static String getHelpComment(@NotNull GradleCoordinate coordinate) { String repositoryName = coordinate.getArtifactId().equals(PLAY_SERVICES_ID) ? "Google" : "Support"; return String.format(HELP_COMMENT, repositoryName); } /** * Evaluates to true iff the given FullRevision is not a preview version */ <|startfocus|> public static final Predicate<GradleCoordinate> REMOVE_PREVIEWS = new Predicate<GradleCoordinate>() { <|endfocus|> @Override public boolean apply(GradleCoordinate input) { return !input.isPreview(); } }; public static final Ordering<GradleCoordinate> GRADLE_COORDINATE_ORDERING = new Ordering<GradleCoordinate>() { @Override public int compare(GradleCoordinate left, GradleCoordinate right) { return GradleCoordinate.COMPARE_PLUS_LOWER.compare(left, right); } }; @Nullable protected AndroidSdkData tryToChooseAndroidSdk() { return AndroidSdkUtils.tryToChooseAndroidSdk(); } @Nullable protected String readTextFile(File file) { return TemplateUtils.readTextFile(file);
<|startcomment|> Just curious, why do we use getSize().width here but getWidth() in other places? <|endcomment|>  Dimension preferredSize = super.getPreferredSize(); int itemCount = myModel == null ? 0 : myModel.getSize(); if (isPreferredSizeSet() || itemCount == 0) { return preferredSize; } Insets insets = getInsets(); int insetsWidth = insets.left + insets.right; int insetsHeight = insets.top + insets.bottom; Dimension cellSize = computeCellSize(); <|startfocus|> final int width = getSize().width; if (width == 0) { // Initial computation, try to make component as square as possible <|endfocus|> return new Dimension(cellSize.width + insetsWidth, cellSize.height + insetsHeight); } else { // Avoid horizontal scroll int rows = intDivideRoundUp(itemCount, getColumnCount()); int height = rows * cellSize.height + insetsHeight; return new Dimension(Math.max(width, cellSize.width + insetsWidth), height); }
<|startcomment|> Unless 'idom' is something from the paper referenced above, I'd just have it as mDom or mDominatorMap <|endcomment|> import com.google.common.collect.Sets; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; /** * Initial implementation of dominator computation. * * The full algorithm is described in {@see http://www.cs.rice.edu/~keith/EMBED/dom.pdf}. It's a * simple iterative algorithm with worst-case complexity of O(N^2). */ public class Dominators { private final Heap mHeap; private final HashMap<Instance, Instance> idom = Maps.newHashMap(); <|startfocus|> public Dominators(Heap heap) { mHeap = heap; } <|endfocus|> public Map<Instance, Instance> getDominatorMap() { if (idom.isEmpty()) { calculate(); } return ImmutableMap.copyOf(idom); } private void calculate() { // Only instances reachable from the roots will participate in dominator computation. // Start with a topological sort because we want to process a node after all its parents Map<Instance, Integer> topSort = getTopologicalSort(mHeap.getRoots()); Set<Instance> roots = Sets.newHashSet();
<|startcomment|> unused? <|endcomment|>  public enum ContrastResult { PASS, FAIL, INDETERMINATE } public static final String CONTRAST_RATIO_FORMAT = "%.2f:1"; public static final double CONTRAST_RATIO_NORMAL_TEXT = 4.5; public static final double CONTRAST_RATIO_LARGE_TEXT = 3.0; public static final int NORMAL_TEXT_SZ_PTS = 18; public static final int NORMAL_TEXT_BOLD_SZ_PTS = 14; public static final String NOT_APPLICABLE = "N/A"; <|startfocus|> private static final String TYPEFACE_BOLD = "BOLD"; <|endfocus|> private static final double MAX_RGB_VALUE = 255.0; private ImageData mImageData; /** The bounds of the view within the image */ private Rectangle mViewBounds; /** Maps an int representation of a {@link Color} to its luminance value. */ private HashMap<Integer, Double> mLuminanceMap; /** Keeps track of how many times a luminance value occurs in this view. */ private HashMap<Double, Integer> mLuminanceHistogram; private final List<Integer> mBackgroundColors; private final List<Integer> mForegroundColors;
<|startcomment|> While you are editing this file, can you please add @SuppressWarnings("UnusedParameters") to this param? <|endcomment|> <|startfocus|> public static boolean isShowingMenu(@Nullable RenderContext context) { <|endfocus|> return ourShowMenu;
<|startcomment|> style <|endcomment|>  public void stop() { CancellableServerReceiver localreceiver = receiver; <|startfocus|> if (localreceiver != null) { <|endfocus|> try { localreceiver.stop(); } catch(IOException e) { logErrorAndDisplayDialog("Google Login", e); } }
<|startcomment|> document what am I and where are one input functions <|endcomment|>  import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Collections; import java.util.HashSet; import java.util.Set; /** * Standard single-input test framework for csv math tests */ public abstract class CSVTest extends junit.framework.TestCase { /* * csv file should have the following format: * function,expected_output,input,extra_info * for two input: function,expected_output,input1,input2,extra * vogar classpath: obj/JAVA_LIBRARIES/core-tests-support_intermediates */ <|startfocus|> <|endfocus|> protected static final Set<String> twoInputFunctions; static { Set<String> twoInFunc = new HashSet<String>(); twoInFunc.add("atan2"); twoInFunc.add("copySign"); twoInFunc.add("hypot"); twoInFunc.add("IEEEremainder"); twoInFunc.add("max"); twoInFunc.add("min"); twoInFunc.add("nextAfter"); twoInFunc.add("pow"); twoInFunc.add("scalb"); twoInputFunctions = Collections.unmodifiableSet(twoInFunc); } void TestCSVInputs(String[] csvFileNames) throws Exception { int totalTests = 0;
<|startcomment|> same comment about the name. <|endcomment|>  * @return true if the resulting time value is in UTC time * @throws android.util.TimeFormatException if s cannot be parsed. */ public boolean parse3339(String s) { if (s == null) { throw new NullPointerException("time string is null"); } if (parse3339_2(s)) { timezone = TIMEZONE_UTC; return true; } return false; } <|startfocus|> private boolean parse3339_2(String s) { <|endfocus|> int len = s.length(); if (len < 10) { throw new TimeFormatException("String too short --- expected at least 10 characters."); } boolean inUtc = false; // year int n = getChar(s, 0, 1000); n += getChar(s, 1, 100); n += getChar(s, 2, 10); n += getChar(s, 3, 1); year = n; checkChar(s, 4, '-'); // month n = getChar(s, 5, 10);
<|startcomment|> umm, no better way? <|endcomment|>  expected.put("icecreamSandwich-universal", 2000123); expected.put("icecreamSandwich-armeabi-v7a", 2100123); expected.put("icecreamSandwich-mips", 2200123); expected.put("icecreamSandwich-x86", 2300123); checkVersionCode(project, "app/", expected, "app"); } private void checkVersionCode( File project, String outRoot, Map<String, Integer> expected, String baseName) throws IOException, InterruptedException, LoggedErrorException { File aapt = new File(sdkDir, "build-tools/20.0.0/aapt"); <|startfocus|> <|endfocus|> String[] command = new String[4]; command[0] = aapt.getPath(); command[1] = "dump"; command[2] = "badging"; CommandLineRunner commandLineRunner = new CommandLineRunner(new StdLogger(StdLogger.Level.ERROR)); for (Map.Entry<String, Integer> entry : expected.entrySet()) { String path = "build/" + FD_OUTPUTS + "/apk/" + baseName + "-" + entry.getKey() + "-debug.apk"; if (outRoot != null) { path = outRoot + path; } 
<|startcomment|> Can you confirm that syncEnded will be called precisely when sync finished AND didn't fail? In fact if that's the semantics, you may want to rename syncEnded to syncSucceeded (to match the corresponding syncFailed method) <|endcomment|> <|startfocus|> public void syncEnded(@NotNull Project project) { <|endfocus|> repository.updateRoots();
<|startcomment|> am I reading this right that both conditions do the same thing? <|endcomment|>  //2. They show up in a popup under a cogwheel button (layoutSecondaries = true, getRightAlignSecondaries = false) // This happens if the layout supports the cogwheel (horizontal, auto layout) //3. They show up as regular left-aligned toolbar buttons (layoutSecondaries = false, getRightAlignSecondaries = false) if (!myActionGroup.isPrimary(action) && getRightAlignSecondaries()) { mySecondaryActions.add(action); //the secondary will be in the main toolbar, but right aligned. continue; } <|startfocus|> else if (!myActionGroup.isPrimary(action) && layoutSecondaries) { mySecondaryActions.add(action); //the secondary will be in a popup continue; } //falling thru with a secondary, it will be treated as a regular left aligned button. <|endfocus|> addComponent(action, i == 0 || i == actions.size() - 1); } if ((ActionPlaces.MAIN_TOOLBAR.equals(myPlace) || ActionPlaces.NAVIGATION_BAR.equals(myPlace))) { final AnAction searchEverywhereAction = ActionManager.getInstance().getAction("SearchEverywhere");
<|startcomment|> we use this in several places, can we extract it into a helper method? <|endcomment|>  break; } } if (off == len) return true; return false; } private void readReply() throws IllegalArgumentException, IOException{ int len; mBufLen = 0; if (!readBytes(mBuf, 2)) throw new IllegalArgumentException("Unable to read response code from reply"); len = ((mBuf[0]) & 0xff) | (((mBuf[1]) & 0xff) << 8); if ((len < 1) || (len > 1024)) { <|startfocus|> throw new IllegalArgumentException("Invalid replay length"); <|endfocus|> } if (!readBytes(mBuf, len)) throw new IOException("Unable to read full response"); mBufLen = len; } private void writeCommand(String _cmd) throws IOException { byte[] cmd = _cmd.getBytes(); int len = cmd.length; if ((len < 1) || (len > 1024)) throw new IllegalArgumentException("Inavlid length of command"); mBuf[0] = (byte) (len & 0xff);
<|startcomment|> I'm pretty sure that the users will not appreciate seeing the Google login widget as the first action in their toolbar. I think that it should be added to the end of the toolbar if we don't have the ability to right-align it. <|endcomment|>  public void initComponent() { ActionManager am = ActionManager.getInstance(); GoogleLoginAction action = new GoogleLoginAction(); action.getTemplatePresentation().setText("Google Login"); am.registerAction("GoogleLogin.LoginService", action); //If secondaries are being right aligned, it will use that to put login on the right side. //Otherwise, it will leave Login on the left. DefaultActionGroup mainToolBar = (DefaultActionGroup) am.getAction("MainToolBar"); <|startfocus|> mainToolBar.addAction(action, new Constraints(Anchor.FIRST, null)). <|endfocus|> setAsSecondary(Registry.get("actionSystem.rightAlignSecondaries").asBoolean()); DefaultActionGroup navToolBar = (DefaultActionGroup) am.getAction("NavBarToolBar"); navToolBar.addAction(action, new Constraints(Anchor.FIRST, null)). setAsSecondary(Registry.get("actionSystem.rightAlignSecondaries").asBoolean());
<|startcomment|> we should use android.util.Log.e(tag, message, exception) here <|endcomment|>  private void testSensorInBatchingMode(int sensorType, String sensorName, boolean checkTimestamp) { if (!mCompletedTests.contains(sensorType)) { startBatching(sensorType, sensorName); try { Thread.sleep(DATA_COLLECTION_TIME_IN_MS); } catch (InterruptedException e) { appendText("Data collection for " + sensorName + "was interrupted"); e.printStackTrace(); } <|startfocus|> stopDataCollection(); analyzeData(sensorType, sensorName, checkTimestamp); mCompletedTests.add(sensorType); <|endfocus|> }
<|startcomment|> do we expect a wide range of exceptions being thrown? if there are only a couple, we should catch them individually <|endcomment|>  if (clientRequest.length() > 0) { Log.d(TAG, "Client requested: " + clientRequest); try { String response = processClientRequest(clientRequest); if (response != null) { Log.d(TAG, "Sending response " + response); streamOut.write(response.getBytes(), 0, response.length()); } // null response means response is defered awaiting user // response } catch (Exception e) { Log.e(TAG, "Error executing " + clientRequest, e); <|startfocus|> <|endfocus|> streamOut.write(RESPONSE_ERR.getBytes(), 0, RESPONSE_ERR.length()); } } receiverSocket.close(); } catch (IOException e) { Log.e(TAG, "There is an exception when reading from or writing tosocket", e); break; } } Log.d(TAG, "The LocalSocketServer thread is going to stop !!!"); if (mServerSocket != null) { try { mServerSocket.close(); } catch (IOException e) { e.printStackTrace(); } } mConnected = false;
<|startcomment|> camel case here too <|endcomment|>  private final Module myModule; private final String myExplodedWarPath; private final String mySdkPath; private final String myClient_secret; private final String myClient_id; private final String myRefresh_token; private final String myVersion; private final String myAppEngineProject; AppEngineUpdater(Project project, Module module, String sdkPath, String explodedWarPath, String appEngineProject, String version, <|startfocus|> String client_secret, String client_id, String refresh_token) { <|endfocus|> myProject = project; myModule = module; mySdkPath = sdkPath; myExplodedWarPath = explodedWarPath; myClient_secret = client_secret; myClient_id = client_id; myRefresh_token = refresh_token; myVersion = version; myAppEngineProject = appEngineProject; } /** * Starts the compile and upload async process. */ void startUploading() { FileDocumentManager.getInstance().saveAllDocuments(); ProgressManager.getInstance().run(new Task.Backgroundable(myModule.getProject(), "Deploying application", true, null) { @Override
<|startcomment|> Unless you are guaranteed that the resource items will *always* come from different files, use Sets.newHashSetWithExpectedSize() instead <|endcomment|>  public boolean setAttributeForItems(@NotNull final String attribute, @Nullable final String value, @NotNull ResourceItem... items) { if (items.length <= 0) { return false; } final List<XmlTag> tags = Lists.newArrayListWithExpectedSize(items.length); <|startfocus|> final List<PsiFile> files = Lists.newArrayListWithExpectedSize(items.length); <|endfocus|> for (ResourceItem item : items) { XmlTag tag = StringResourceData.resourceToXmlTag(item); if (tag == null) { return false; } tags.add(tag); files.add(tag.getContainingFile()); } final boolean deleteTag = attribute.equals(SdkConstants.ATTR_NAME) && (value == null || value.isEmpty()); new WriteCommandAction.Simple(myProject, "Setting attribute " + attribute, files.toArray(new PsiFile[files.size()])) { @Override public void run() { for (XmlTag tag : tags) { if (deleteTag) { tag.delete(); } else { // XmlTagImpl handles a null value by deleting the attribute, which is our desired behavior
<|startcomment|> Can you please remove this unused import? <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.volley.toolbox; import com.android.volley.Cache; import com.android.volley.VolleyLog; <|startfocus|> import android.os.SystemClock; <|endfocus|> import java.io.BufferedInputStream; import java.io.EOFException; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Collections; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.Map; /** * Cache implementation that caches files directly onto the hard disk in the specified * directory. The default disk usage size is 5MB, but is configurable.
<|startcomment|> not needed, please remove <|endcomment|>  format.setInteger(MediaFormat.KEY_WIDTH, w); format.setInteger(MediaFormat.KEY_HEIGHT, h); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, infoEnc.mSupportSemiPlanar ? CodecCapabilities.COLOR_FormatYUV420SemiPlanar : CodecCapabilities.COLOR_FormatYUV420Planar); format.setInteger(MediaFormat.KEY_FRAME_RATE, infoEnc.mFps); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, KEY_I_FRAME_INTERVAL); <|startfocus|> // if infoEnc is not null, set fps to adjust timestamp if(infoEnc!=null) mFrameRate = infoEnc.mFps; <|endfocus|> double encodingTime = runEncoder(VIDEO_AVC, format, TOTAL_FRAMES); // re-initialize format for decoder format = new MediaFormat(); format.setString(MediaFormat.KEY_MIME, mimeType); format.setInteger(MediaFormat.KEY_WIDTH, w); format.setInteger(MediaFormat.KEY_HEIGHT, h); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, infoDec.mSupportSemiPlanar ? CodecCapabilities.COLOR_FormatYUV420SemiPlanar : CodecCapabilities.COLOR_FormatYUV420Planar); double[] decoderResult = runDecoder(VIDEO_AVC, format); if (decoderResult == null) { success = false; } else {
<|startcomment|> use UnsignedBytes.toInt <|endcomment|>  case 2: return mInput.readShort(); case 4: return mInput.readInt(); case 8: return mInput.readLong(); } throw new IllegalArgumentException("ID Length must be 1, 2, 4, or 8"); } private String readUTF8(int length) throws IOException { byte[] b = new byte[length]; mInput.read(b); return new String(b, "utf-8"); } private int readUnsignedByte() throws IOException { <|startfocus|> return mInput.readByte() & 0xff; <|endfocus|> } private int readUnsignedShort() throws IOException { return mInput.readShort() & 0xffff; } private long readUnsignedInt() throws IOException { return mInput.readInt() & 0xffffffffL; } private void loadString(int length) throws IOException { long id = readId(); String string = readUTF8(length); mStrings.put(id, string); } private void loadClass() throws IOException { mInput.readInt(); // Ignored: Class serial number. long id = readId();
<|startcomment|> where is this defined? <|endcomment|>  public boolean setDeviceType(int deviceType) { if (deviceType >= WFD_SOURCE && deviceType <= SOURCE_OR_PRIMARY_SINK) { <|startfocus|> mDeviceInfo &= ~DEVICE_INFO; <|endfocus|> mDeviceInfo |= deviceType; return true; } return false;
<|startcomment|> Nit: ArrayList is more efficient than LinkedList even when it has to resize, and we can put in some good guesses for initial size here. <|endcomment|>  public void init() { super.init(); <|startfocus|> List<ModuleTemplate> galleryTemplates = Lists.newLinkedList(); List<ModuleTemplate> extrasTemplates = Lists.newLinkedList(); <|endfocus|> Set<FormFactorUtils.FormFactor> formFactorSet = Sets.newHashSet(); for (ModuleTemplateProvider provider : myModuleTypesProviders) { for (ModuleTemplate moduleTemplate : provider.getModuleTemplates()) { if (moduleTemplate.isGalleryModuleType()) { galleryTemplates.add(moduleTemplate); } else { extrasTemplates.add(moduleTemplate); } FormFactorUtils.FormFactor formFactor = moduleTemplate.getFormFactor(); if (formFactor != null) { formFactorSet.add(formFactor); } } } for (final FormFactorUtils.FormFactor formFactor : formFactorSet) { registerValueDeriver(FormFactorUtils.getInclusionKey(formFactor), new ValueDeriver<Boolean>() { @Nullable @Override public Boolean deriveValue(@NotNull ScopedStateStore state, @Nullable ScopedStateStore.Key changedKey, @Nullable Boolean currentValue) { ModuleTemplate moduleTemplate = myState.get(SELECTED_MODULE_TYPE_KEY);
<|startcomment|> Remove this println or move it to log <|endcomment|>  public Void fun(AndroidDebugBridge bridge) { <|startfocus|> System.out.println("Bridge: " + bridge); <|endfocus|> populateView(project, bridge); return null;
<|startcomment|> ? <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.compile.androidtree.frameworks; import com.android.jack.Options; import com.android.jack.TestTools; import com.android.jack.category.RedundantTests; import com.android.jack.category.SlowTests; import org.junit.BeforeClass; import org.junit.Test; import org.junit.experimental.categories.Category; import java.io.File; <|startfocus|> //@Ignore("Tree") <|endfocus|> public class FrameworksBaseCompilationTest { private static File[] BOOTCLASSPATH; private static File[] CLASSPATH; private static File SOURCELIST; @BeforeClass public static void setUpClass() { FrameworksBaseCompilationTest.class.getClassLoader().setDefaultAssertionStatus(true); BOOTCLASSPATH = new File[] { TestTools.getFromAndroidTree( "out/target/common/obj/JAVA_LIBRARIES/core_intermediates/classes.jar") }; CLASSPATH = new File[] { TestTools.getFromAndroidTree( "out/target/common/obj/JAVA_LIBRARIES/bouncycastle_intermediates/classes.jar"), TestTools.getFromAndroidTree(
<|startcomment|> I know this code already existed, but if you interested, you could add a small test with a few patterns for this GetPropReceiver. If not, I'll add it in a subsequent CL. <|endcomment|> import java.util.regex.Matcher; import java.util.regex.Pattern; /** * Fetches and caches 'getprop' values from device. */ class PropertyFetcher { private static final long FETCH_FREQ_MS = 10000; // 10 seconds private static final String GETPROP_COMMAND = "getprop"; //$NON-NLS-1$ private static final Pattern GETPROP_PATTERN = Pattern.compile("^\\[([^]]+)\\]\\:\\s*\\[(.*)\\]$"); //$NON-NLS-1$ private static final int GETPROP_TIMEOUT_SEC = 2; <|startfocus|> private Map<String, String> mProperties = new HashMap<String, String>(); private final Device mDevice; private long mLastFetchTime = 0; <|endfocus|> class GetPropReceiver extends MultiLineReceiver { private Map<String, String> mCollectedProperties = new HashMap<String, String>(); @Override public void processNewLines(String[] lines) { // We receive an array of lines. We're expecting // to have the build info in the first line, and the build
<|startcomment|> Treat isSameType as final ? <|endcomment|> <|startfocus|> public boolean isSameType(@Nonnull JType type) { <|endfocus|> return this == type;
<|startcomment|> how about getEmergencyStatus() <|endcomment|>  public boolean needVerify; public boolean privacyOverride; public int timeout; public int defaultResponse; public String requestorId; public String text; public int requestorIdEncoding; public int textEncoding; public Bundle extras; }; public static class GpsNiResponse { /* User reponse, one of the values in GpsUserResponseType */ int userResponse; /* Optional extra data to pass with the user response */ Bundle extras; }; // for reading the value of mIsInEmergency <|startfocus|> public boolean readEmergencySUPLStatus() <|endfocus|> { synchronized (this) { if (DEBUG) Log.d(TAG, "public boolean readEmergencySUPLStatus():" + "mIsInEmergency is " + mIsInEmergency); return mIsInEmergency; } } // for writing the value of mIsInEmergency public void updateEmergencySUPLStatus(boolean status) { synchronized (this) { if (DEBUG) Log.d(TAG, "public boolean updateEmergencySUPLStatus():" + "mIsInEmergency is " + status); mIsInEmergency = status; } } /**
<|startcomment|> assert vs require <|endcomment|> <|startfocus|> public void assertHaveRenderError(@NotNull String error) { <|endfocus|> RenderResult lastResult = myRenderContext.getLastResult(); assertNotNull("No render result available", lastResult); RenderErrorPanel panel = new RenderErrorPanel(); String html = panel.showErrors(lastResult); assertNotNull(html); assertTrue("Did not find " + error + " in " + html, html.contains(error));
<|startcomment|> this is implicitly taken care of <|endcomment|>  public static final int GPS_ENC_UNKNOWN = -1; private final Context mContext; // parent gps location provider private final LocationManager mLocationManager; // configuration of notificaiton behavior private boolean mPlaySounds = false; private boolean mPopupImmediately = true; // read the SUPL_ES form gps.conf private int mIsSuplEsEnabled; /* will be changed form GpsLocationProvider if the device enter or leave emergency mode.*/ static public boolean mIsInEmergency = false; <|startfocus|> public static GpsNetInitiatedHandler obj; <|endfocus|> private final INetInitiatedListener mNetInitiatedListener; // Set to true if string from HAL is encoded as Hex, e.g., "3F0039" static private boolean mIsHexInput = true; public static class GpsNiNotification { public int notificationId; public int niType; public boolean needNotify; public boolean needVerify; public boolean privacyOverride; public int timeout; public int defaultResponse; public String requestorId; public String text; public int requestorIdEncoding; public int textEncoding; public Bundle extras; }; 
<|startcomment|> (ditto) <|endcomment|>  else if (size <= max) { <|startfocus|> return String .format("%1$s and %2$s", getLabels(Iterables.limit(locales, size - 1)), getLabel(Iterables.get(locales, size - 1))); <|endfocus|>
<|startcomment|> Add a method "findChooseDeviceDialog" that returns a ChooseDeviceDialogFixture <|endcomment|>  * @return ActionButtonFixture for the run button. */ @NotNull public ActionButtonFixture findRunApplicationButton() { return findActionButtonByActionId("Run"); } @NotNull public ChooseDeviceDialogFixture debugApp(@NotNull String appName) throws ClassNotFoundException { runApplication("Debug", appName); return ChooseDeviceDialogFixture.find(this, robot, AndroidBundle.message("choose.device.dialog.title")); } @NotNull public ChooseDeviceDialogFixture runApp(@NotNull String appName) throws ClassNotFoundException { <|startfocus|> runApplication("Run", appName); <|endfocus|> return ChooseDeviceDialogFixture.find(this, robot, AndroidBundle.message("choose.device.dialog.title")); } @NotNull public RunToolWindowFixture getRunToolWindowFixture() { return new RunToolWindowFixture("Run", getProject(), robot); } @NotNull public RunToolWindowFixture getDebugToolWindowFixture() { return new RunToolWindowFixture("Debug", getProject(), robot); } @NotNull public String scanLogCatOutputForProcessName(@NotNull final RunToolWindowFixture baseToolWindowFixture, @NotNull final String appName) {
<|startcomment|> A similar comparator is used in the DevicePanel. See DevicePanel:58. Could we move this comparator to a common place and reuse it from both places? (This version takes pid's into account while the other one doesn't, so I think this one is better). <|endcomment|>  Client toSelect = selected; boolean update = true; myClientCombo.removeAllItems(); if (device != null) { // Change the currently selected client if the user has a preference. String preferred = getPreferredClientForDevice(device.getName()); if (preferred != null) { Client preferredClient = device.getClient(preferred); if (preferredClient != null) { toSelect = preferredClient; } } Client[] clients = device.getClients(); <|startfocus|> Arrays.sort(clients, new Comparator<Client>() { @Override public int compare(Client a, Client b) { ClientData ad = a.getClientData(); ClientData bd = b.getClientData(); <|endfocus|> String as = ad.getClientDescription() != null ? ad.getClientDescription() : String.valueOf(ad.getPid()); String bs = bd.getClientDescription() != null ? bd.getClientDescription() : String.valueOf(bd.getPid()); return as.compareTo(bs); } }); for (Client client : clients) { myClientCombo.addItem(client);
<|startcomment|> stale? <|endcomment|>  import java.lang.reflect.Modifier; import java.util.Collections; import java.util.List; import lombok.ast.AstVisitor; import lombok.ast.ClassDeclaration; import lombok.ast.ForwardingAstVisitor; import lombok.ast.Node; /** * Checks that subclasses of certain APIs are overriding all methods that were abstract * in one or more earlier API levels that are still targeted by the minSdkVersion * of this project. */ public class OverrideConcreteDetector extends Detector implements JavaScanner { <|startfocus|> /** Are fragment subclasses instantiatable? */ <|endfocus|> public static final Issue ISSUE = Issue.create( "OverrideAbstract", //$NON-NLS-1$ "Not overriding abstract methods on older platforms", "Ensures that all methods that used to be abstract in older versions are overridden", "To improve the usability of some APIs, some methods that used to be `abstract` have " + "been made concrete by adding default implementations. This means that when compiling " + "with new versions of the SDK, your code does not have to override these methods.\n" + "\n" +
<|startcomment|> since you have it in manual testing, you should remove it from here, unless you think it's important that you need to also install it on a device? <|endcomment|>  "api", "assets", "applibtest", "attrOrder", "basic", "dependencies", "flavored", "flavorlib", "flavoredlib", "flavors", "libProguardJarDep", "libProguardLibDep", "libTestDep", "libsTest", "migrated", "multires", "ndkJniLib", "ndkJniLib2", "ndkPrebuilts", "ndkLibPrebuilts", "overlay1", "overlay2", "packagingOptions", "pkgOverride", "proguard", <|startfocus|> "pseudolocalized", <|endfocus|> "proguardLib", "sameNamedLibs" }; private static final List<String> ndkPluginTests = ImmutableList.of( "ndkJniLib2" ); public static Test suite() { TestSuite suite = new TestSuite(); suite.setName("DeviceTest"); for (String gradleVersion : BasePlugin.GRADLE_SUPPORTED_VERSIONS) { if (isIgnoredGradleVersion(gradleVersion)) { continue; } // first the project we build on all available versions of Gradle for (String projectName : sBuiltProjects) { // Disable NDK plugin tests on non-Linux platforms due to Gradle incorrectly
<|startcomment|> FYI there's is also a LinkLabel class in IntelliJ which implements link-like labels (with the right colors etc) <|endcomment|>  public ProjectSelectorItem(Color backgroundNonSelectionColor, Color textSelectionColor, Color textNonSelectionColor) { setBorder(BorderFactory.createEmptyBorder(2, 15, 2, 0)); setOpaque(false); setHorizontalAlignment(SwingConstants.LEFT); setVerticalAlignment(SwingConstants.CENTER); Color backgroundNonSelectionColor1 = backgroundNonSelectionColor; myTextSelectionColor = textSelectionColor; myTextNonSelectionColor = textNonSelectionColor; myHoverColor = UI.getColor("link.foreground"); <|startfocus|> setBackground(backgroundNonSelectionColor1); <|endfocus|>
<|startcomment|> maybe add "Actual" or "Specific" or "Resolved" in the name here to make it clear that it returns the version without dynamic dependencies. <|endcomment|> <|startfocus|> public static FullRevision getAndroidGradleModelVersion(@NotNull Project project) { <|endfocus|> VirtualFile baseDir = project.getBaseDir(); if (baseDir == null) { // This is default project. return null; } final Ref<FullRevision> modelVersionRef = new Ref<FullRevision>(); VfsUtil.processFileRecursivelyWithoutIgnored(baseDir, new Processor<VirtualFile>() { @Override public boolean process(VirtualFile virtualFile) { if (SdkConstants.FN_BUILD_GRADLE.equals(virtualFile.getName())) { File fileToCheck = VfsUtilCore.virtualToIoFile(virtualFile); try { String contents = FileUtil.loadFile(fileToCheck); FullRevision version = getAndroidGradleModelVersion(contents); if (version != null) { modelVersionRef.set(version); return false; // we found the model version. Stop. } } catch (IOException e) { LOG.warn("Failed to read contents of " + fileToCheck.getPath()); } } return true; } }); return modelVersionRef.get();
<|startcomment|> nit - isEmpty() <|endcomment|>  public void requirePreviewTitles(@NotNull List<String> titles) { RenderPreviewManager previewManager = getContent().getPreviewManager(false); <|startfocus|> if (titles.size() == 0) { <|endfocus|> if (previewManager == null) { return; } assert(!previewManager.hasPreviews()); } assertNotNull(previewManager); List<RenderPreview> previews = previewManager.getPreviews(); assertNotNull(previews); assertEquals(previews.size(), titles.size()); //noinspection SpellCheckingInspection Iterator<String> titlesIter = titles.iterator(); for (RenderPreview preview : previews) { assertEquals(titlesIter.next(), preview.getDisplayName()); }
<|startcomment|> Then maybe we should rename Structure to hierarchy? <|endcomment|>  JClass superClass = ((JDefinedClass) currentType).getSuperClass(); if (superClass != null) { String usedTypeFileName = getFileName(superClass); if (usedTypeFileName != null) { compilerState.addStructUsage(currentFileName, usedTypeFileName); } } } for (JInterface interf : ((JDefinedClassOrInterface) currentType).getImplements()) { String usedTypeFileName = getFileName(interf); if (usedTypeFileName != null) { <|startfocus|> compilerState.addStructUsage(currentFileName, usedTypeFileName); <|endfocus|> } } }
<|startcomment|> the break in the nested for loop had me confused there for a sec. Maybe this would be better structured as an if/elseif/else. <|endcomment|>  for (Sample s : mySamples.getItems()) { if (StringUtil.containsIgnoreCase(s.getTitle(), keyword)) { filteredSamples.add(s); continue; } if (s.getDescription() != null && StringUtil.containsIgnoreCase(s.getDescription(), keyword)) { filteredSamples.add(s); continue; } <|startfocus|> for (String category : s.getCategories()) { if (StringUtil.containsIgnoreCase(category, keyword)) { filteredSamples.add(s); break; <|endfocus|> } } } return filteredSamples;
<|startcomment|> %1$s <|endcomment|>  public static Icon getIcon(@Nullable String codename) { if (codename == null) { return null; } try { <|startfocus|> return IconLoader.getIcon(String.format("/icons/versions/%s.png", codename), AndroidIcons.class); <|endfocus|> } catch (RuntimeException e) { int size = 128; Image image = UIUtil.createImage(size, size, BufferedImage.TYPE_INT_ARGB); Graphics g = image.getGraphics(); GraphicsUtil.setupAntialiasing(g); GraphicsUtil.setupAAPainting(g); Font f = UIUtil.getLabelFont(); Font font = new Font(f.getName(), f.getStyle() | Font.BOLD, 100); g.setColor(JBColor.background()); g.fillRect(0, 0, size, size); g.setColor(JBColor.foreground()); g.setFont(font); int height = g.getFontMetrics().getHeight(); int width = g.getFontMetrics().stringWidth("?"); g.drawString("?", (size - width) / 2, height + (size - height) / 2); return new ImageIcon(image); }
<|startcomment|> AndroidLanguageSourceSet? <|endcomment|> import org.gradle.api.tasks.util.PatternFilterable; import org.gradle.api.tasks.util.PatternSet; import org.gradle.language.base.FunctionalSourceSet; import org.gradle.language.base.LanguageSourceSet; import org.gradle.api.internal.AbstractBuildableModelElement; import org.gradle.language.base.internal.AbstractLanguageSourceSet; import java.io.File; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Set; import javax.inject.Inject; import groovy.lang.Closure; /** <|startfocus|> * Default implementation of the AndroidSourceDirectorySet. <|endfocus|> */ public class AndroidLanguageSourceSet extends AbstractLanguageSourceSet implements LanguageSourceSet { @Inject public AndroidLanguageSourceSet(String name, FunctionalSourceSet parent, FileResolver fileResolver) { super(name, parent, "Android source", new DefaultSourceDirectorySet("source", fileResolver)); } } 
<|startcomment|> Better inline this method. <|endcomment|>  CompileContext context = contextRef.get(); assertNotNull(context); return context; } finally { Disposer.dispose(disposable); } } /** * Finds the Run button in the IDE interface. * * @return ActionButtonFixture for the run button. */ @NotNull public ActionButtonFixture findRunApplicationButton() { return findActionButtonByActionId("Run"); } public void debugApp(@NotNull String appName) throws ClassNotFoundException { <|startfocus|> runApplication("Debug", appName); <|endfocus|> } public void runApp(@NotNull String appName) throws ClassNotFoundException { runApplication("Run", appName); } @NotNull public ChooseDeviceDialogFixture findChooseDeviceDialog() { return ChooseDeviceDialogFixture.find(this, robot); } @NotNull public RunToolWindowFixture getRunToolWindowFixture() { return new RunToolWindowFixture(this); } @NotNull public DebugToolWindowFixture getDebugToolWindowFixture() { return new DebugToolWindowFixture(this); } public void toFront() { GuiActionRunner.execute(new GuiTask() { @Override
<|startcomment|> MB (megabyte), not Mb (megabit). (Also, use %1$d) <|endcomment|>  public String valueOf(AvdInfo avdInfo) { Storage size = getSize(avdInfo); <|startfocus|> return String.format(Locale.getDefault(), "%d Mb", size.getSizeAsUnit(Storage.Unit.MiB)); <|endfocus|>
<|startcomment|> change <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.builder.tasks; <|startfocus|> /** * Created by jedo on 9/15/14. */ <|endfocus|> import com.android.annotations.NonNull; import com.android.utils.ILogger; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.atomic.AtomicInteger; import java.util.logging.Level; import java.util.logging.Logger; /** * A work queue that accepts jobs and treat them in order. * * @author jedo@google.com (Jerome Dochez) */ public class WorkQueue<T> implements Runnable { private final ILogger mLogger; // queue name as human would understand. private final String mName; 
<|startcomment|> I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that. <|endcomment|>  } } while (s != 1); // Busy loop. synchronized (lock) { values = null; state = 2; } } void thread2() { int[] vs1; synchronized (lock) { vs1 = values; state = 1; } int s; do { synchronized (lock) { s = state; } } while (s != 2); // Busy loop. <|startfocus|> int[] vs2; synchronized (lock) { vs2 = values; } <|endfocus|> int v1 = vs1[0]; int v2 = vs2[0]; System.out.println("b17689750TestMonitor failed: " + v1 + ", " + v2); } } 
<|startcomment|> nit: This statement seems to miss the actual test. What we're really doing is making sure that if it does exist, it is only for pre-cleared executables. Asserting that a domain has either 0 or >= 1 instances should always be true. <|endcomment|>  for (ProcessDetails p : procs) { msg = "Expected one of \"" + execList + "\" in SELinux domain \"" + domain + "\"" + " Found: \"" + p + "\""; assertTrue(msg, execList.contains(p.procTitle)); } } /** <|startfocus|> * Asserts that either a domain doesn't exist, or if it does exist, it's * cardinality is greater than or equal to 1. <|endfocus|> * * @param domain * The domain or SELinux context to check. * @param executables * The path of the allowed executables or application package names. */ private void assertDomainZeroOrN(String domain, String... executables) throws FileNotFoundException { List<ProcessDetails> procs = ProcessDetails.getProcessMap().get(domain); if (procs == null) { return; // domain doesn't exist } Set<String> execList = new HashSet<String>(Arrays.asList(executables)); for (ProcessDetails p : procs) {
<|startcomment|> nit: cannot <|endcomment|>  + Synchronized.class.getSimpleName() + " must have no parameter"); } if (isSynchronized) { throw new SchedulableNotConformException("Schedulable '" + name + "' cannot have both a static and a dynamic @" + Synchronized.class.getName() + " (on class '" + cls.getCanonicalName() + "')"); } if (dynamicIsSynchronized != null) { <|startfocus|> throw new MarkerNotConformException("Schedulable '" + name + "' could not have two @" <|endfocus|> + Synchronized.class.getName() + " ('" + method + "' and '" + dynamicIsSynchronized + "')"); } dynamicIsSynchronized = method; } }
<|startcomment|> Nit: this fields are automatically initialized with null. Any reason for explicitly doing that? I've seen other classes in this CL not doing it. <|endcomment|>  import java.util.Arrays; import java.util.Collection; import java.util.Set; /** * The configuration of a product flavor. * * This is also used to describe the default configuration of all builds, even those that * do not contain any flavors. */ public class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor { private static final long serialVersionUID = 1L; private final String mName; <|startfocus|> private ApiVersion mMinSdkVersion = null; private ApiVersion mTargetSdkVersion = null; private Integer mMaxSdkVersion = null; private Integer mRenderscriptTargetApi = null; <|endfocus|> private Boolean mRenderscriptSupportMode; private Boolean mRenderscriptNdkMode; private Integer mVersionCode = null; private String mVersionName = null; private String mApplicationId = null; private String mTestApplicationId = null; private String mTestInstrumentationRunner = null; private Boolean mTestHandleProfiling = null; private Boolean mTestFunctionalTest = null; private SigningConfig mSigningConfig = null; private Set<String> mResourceConfiguration = null; /**
<|startcomment|> Should this really be nullable? or should it be @NotNull <|endcomment|> <|startfocus|> private XmlFile getAppEngineXmlFile(@Nullable String fileName) { <|endfocus|> AppEngineConfigurationProperties model = getConfiguration().getState(); if (model == null || Strings.isNullOrEmpty(model.WEB_APP_DIR)) { return null; } String path = model.WEB_APP_DIR + "/WEB-INF/" + fileName; VirtualFile appEngineFile = LocalFileSystem.getInstance().findFileByPath(path.replace(File.separatorChar, '/')); if (appEngineFile == null) { return null; } PsiFile psiFile = PsiManager.getInstance(getModule().getProject()).findFile(appEngineFile); if (psiFile == null || !(psiFile instanceof XmlFile)) { return null; } return (XmlFile) psiFile;
<|startcomment|> Wouldn't it be better to add this Runner.zipAsBinary check in the two places where it's called instead (Digester.digestFile, and Patch.calculateActions) ? I agree that this is a smaller diff, but I think this is a change that IntelliJ would really want to upstream anyway, so it seems more correct to preserve the semantics of what it means for a filename to represent a zipfile, and instead have the clients which act on that method look up whether they should be special casing zip files. <|endcomment|>  public static boolean isZipFile(String fileName) { <|startfocus|> return !Runner.zipAsBinary && (fileName.endsWith(".zip") || fileName.endsWith(".jar")); <|endfocus|>
<|startcomment|> Can delete this. <|endcomment|>  } if (WizardConstants.INVALID_WINDOWS_FILENAMES.contains(filename.toLowerCase())) { return ValidationResult.error("Illegal filename in project location path: " + filename); } if (CharMatcher.WHITESPACE.matchesAnyOf(filename)) { warningResult = ValidationResult .warn("Your project location contains whitespace. This can cause " + "problems on some platforms and is not recommended."); } if (!CharMatcher.ASCII.matchesAllOf(filename)) { <|startfocus|> warningResult = ValidationResult .warn("Your project location contains non-ASCII characters. " + "This can cause problems on Windows. Proceed with caution."); <|endfocus|> } // Check that we can write to that location: make sure we can write into the first extant directory in the path. if (!testFile.exists() && testFile.getParentFile() != null && testFile.getParentFile().exists()) { if (!testFile.getParentFile().canWrite()) { return ValidationResult
<|startcomment|> for (BinaryKind kind : ...) { if (kind.isBinaryFile(v)) { return kind; } } <|endcomment|>  return DEX_FILE_EXTENSION; } }; @Nonnull private static final String DEX_FILE_EXTENSION = ".dex"; @Nonnull public abstract String getFileExtension(); public static boolean isBinaryFile(@Nonnull InputVFile v) { return (v.getName().endsWith(DEX.getFileExtension())); } @Nonnull public static BinaryKind getBinaryKind(@Nonnull InputVFile v) { assert isBinaryFile(v); if (v.getName().endsWith(DEX.getFileExtension())) { return DEX; } <|startfocus|> throw new AssertionError("Unsupported binary file"); <|endfocus|> } } 
<|startcomment|> @Nullable <|endcomment|>  */ public class RestSignatureInspection extends EndpointInspectionBase { public enum RestMethod { LIST("list", "GET") { /** * If the return type of {@code method} is a parameterized collection, * this function constructs the resource name from the parameterized parameters * of the return type else it returns {@code null}. * * @param method The method in which the resource name will be generated from * @return the guessed resource name */ <|startfocus|> @Override <|endfocus|> public String guessResourceName(PsiMethod method) { Project project; try { project = method.getContainingFile().getProject(); } catch (PsiInvalidElementAccessException e) { LOG.error("Error getting project with parameter " + method.getText(), e); return null; } PsiType returnType = method.getReturnType(); if(isValidCollectionType(project, returnType)) { assert(returnType instanceof PsiClassType); PsiClassType classType = (PsiClassType) returnType; PsiType[] typeParams = classType.getParameters(); 
<|startcomment|> Just a minor concern: Encoding it inside the patch file probably implies that this patch file cannot be decoded by anything other than the jar file embedded with the patch. As a minor change, maybe we can switch the order around: the first two strings can describe the old and new builds, followed by the list of options. That way, all versions only need to know that they ought to parse the first two strings and then parse the options appropriately.. <|endcomment|>  } else { throw new RuntimeException("Unknown action " + each); } dataOut.writeInt(key); each.write(dataOut); } } finally { dataOut.flush(); } } private void read(InputStream patchIn) throws IOException { List<PatchAction> newActions = new ArrayList<PatchAction>(); @SuppressWarnings("IOResourceOpenedButNotSafelyClosed") DataInputStream in = new DataInputStream(patchIn); isBinary = in.readBoolean(); isStrict = in.readBoolean(); myOldBuild = in.readUTF(); <|startfocus|> myNewBuild = in.readUTF(); <|endfocus|> int size = in.readInt(); while (size-- > 0) { int key = in.readInt(); PatchAction a; switch (key) { case CREATE_ACTION_KEY: a = new CreateAction(this, in); break; case UPDATE_ACTION_KEY: a = new UpdateAction(this, in); break; case UPDATE_ZIP_ACTION_KEY: a = new UpdateZipAction(this, in); break; case DELETE_ACTION_KEY:
<|startcomment|> I think the emulator capitalizes its error tags so you may need ERROR or case insensitive check <|endcomment|>  myProject = project; myTitle = title; myExecutor = executor; myProcessHandler = processHandler; } @Override public void processWillTerminate(ProcessEvent event, boolean willBeDestroyed) { myProcessHandler.removeProcessListener(this); } @Override public void onTextAvailable(ProcessEvent event, Key outputType) { if (event.getText().contains("error") || ProcessOutputTypes.STDERR.equals(outputType)) { ExecutionManager.getInstance(myProject).getContentManager().toFrontRunContent(myExecutor, myProcessHandler); <|startfocus|> Logger.getInstance(ExternalToolRunner.class).error(myTitle + ": " + event.getText()); <|endfocus|> } } } public static class ProcessOutputCollector extends ProcessAdapter { private final StringBuilder sb = new StringBuilder(); @Override public void onTextAvailable(ProcessEvent event, Key outputType) { sb.append(event.getText()); } public String getText() { return sb.toString(); } } } 
<|startcomment|> What about using constants somewhere for version numbers? <|endcomment|>  private void dumpLibraryProperties(@CheckForNull ZipOutputStream zos) { Properties libraryProperties = new Properties(); libraryProperties.put(KEY_LIB_EMITTER, "jill " + version); libraryProperties.put(KEY_LIB_MAJOR_VERSION, "0"); libraryProperties.put(KEY_LIB_MINOR_VERSION, "0"); libraryProperties.put(KEY_JAYCE, String.valueOf(true)); <|startfocus|> libraryProperties.put(KEY_JAYCE_MAJOR_VERSION, "2"); libraryProperties.put(KEY_JAYCE_MINOR_VERSION, "14"); <|endfocus|> if (zos != null) { dumpPropertiesToZip(zos, libraryProperties); } else { dumpPropertiesToFile(new File(options.getOutputDir(), LIBRARY_PROPERTIES), libraryProperties); }
<|startcomment|> Missing space <|endcomment|>  public Object getValue(String key) { <|startfocus|> return Action.NAME.equals(key)? myText : null; <|endfocus|>
<|startcomment|> This name appears incorrect and is a duplicate of the method two above this. <|endcomment|>  } catch (Exception ignored) {} } } finally { super.tearDown(); } } public void testDuckTypingFailsWhenOneMethodMissing() throws Exception { try { DuckTypedPSKKeyManager.getInstance(new AlmostPSKKeyManager()); fail(); } catch (NoSuchMethodException expected) {} } public void testDuckSucceedsWhenAllMethodsPresent() throws Exception { assertNotNull(DuckTypedPSKKeyManager.getInstance( new KeyManagerOfferingAllPSKKeyManagerMethods())); } <|startfocus|> public void testDuckTypingSucceedsWhenAllMethodsPresent() throws Exception { try { DuckTypedPSKKeyManager.getInstance(new AlmostPSKKeyManager()); fail(); } catch (NoSuchMethodException expected) {} <|endfocus|> } public void testMethodInvocationDelegation() throws Exception { // IMPLEMENTATION NOTE: We create a DuckTypedPSKKeyManager wrapping a Reflection Proxy, // invoke each method of the PSKKeyManager interface on the DuckTypedPSKKeyManager instance, // and assert that invocations on the Proxy are as expected and that values returned by the // Proxy are returned to us. MockInvocationHandler mockInvocationHandler = new MockInvocationHandler();
<|startcomment|> space <|endcomment|>  public String getMessage() { <|startfocus|> return location.getDescription() + " is invalid library:" + super.getMessage(); <|endfocus|>
<|startcomment|> nit: Failed <|endcomment|>  sysLog.log(Level.SEVERE, "Fails to parse the property " + JayceProperties.KEY_JAYCE_MAJOR_VERSION + " from " + inputLibrary.getLocation(), e); throw new LibraryFormatException(inputLibrary.getLocation()); } try { minorVersion = Integer.parseInt(minorVersionStr); } catch (NumberFormatException e) { <|startfocus|> sysLog.log(Level.SEVERE, "Fails to parse the property " + JayceProperties.KEY_JAYCE_MINOR_VERSION + " from " + inputLibrary.getLocation(), e); <|endfocus|> throw new LibraryFormatException(inputLibrary.getLocation()); } String className = "com.android.jack.jayce.v" + LibraryFactory.getVersionString(majorVersion) + ".io.JayceInternalReaderImpl"; JayceInternalReader jayceReader = (JayceInternalReader) instantiateConstructorWithParameters( className, new Class[] {InputStream.class}, new Object[] {in}, majorVersionStr); int minorMin = jayceReader.getMinorMin(); int currentMinor = jayceReader.getCurrentMinor(); if (minorVersion < minorMin) { throw new JayceVersionException("The version of the jayce file is not supported anymore."
<|startcomment|> Can you leave this unselected too? So both buttons are unselected initially? <|endcomment|>  super("License Agreement", "Read and agree to the licenses for the components which will be installed", null, disposable); Splitter splitter = new Splitter(false, .30f); splitter.setHonorComponentsMinimumSize(true); myChangeTree = new Tree(); splitter.setFirstComponent(ScrollPaneFactory.createScrollPane(myChangeTree)); myLicenseTextField = new JTextPane(); splitter.setSecondComponent(ScrollPaneFactory.createScrollPane(myLicenseTextField)); myDeclineRadioButton = new JBRadioButton("Decline"); <|startfocus|> myDeclineRadioButton.setSelected(true); <|endfocus|> myAcceptRadioButton = new JBRadioButton("Accept"); ButtonGroup optionsGroup = new ButtonGroup(); optionsGroup.add(myDeclineRadioButton); optionsGroup.add(myAcceptRadioButton); JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.TRAILING)); optionsPanel.add(myDeclineRadioButton); optionsPanel.add(myAcceptRadioButton); JPanel mainPanel = new JPanel(new BorderLayout()); mainPanel.add(splitter, BorderLayout.CENTER); mainPanel.add(optionsPanel, BorderLayout.SOUTH); setBodyComponent(mainPanel);
<|startcomment|> move this to a static final field. <|endcomment|>  static ApkInfo getApkInfo(@NonNull List<String> aaptOutput) { <|startfocus|> Pattern p = Pattern.compile( "^package: name='([^']+)' versionCode='([0-9]*)' versionName='([^']*)'.*$"); <|endfocus|> String pkgName = null, versionCode = null, versionName = null; for (String line : aaptOutput) { Matcher m = p.matcher(line); if (m.matches()) { pkgName = m.group(1); versionCode = m.group(2); versionName = m.group(3); break; } } if (pkgName == null) { throw new RuntimeException("Failed to find apk information with aapt"); } return new ApkInfo(pkgName, Integer.parseInt(versionCode), versionName);
<|startcomment|> AttributeSet wraps a mutable XmlPullParser and is not safe to cache. <|endcomment|>  this(context, attrs, com.android.internal.R.attr.toolbarStyle); } public Toolbar(Context context, AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, 0); } public Toolbar(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Toolbar, defStyleAttr, defStyleRes); <|startfocus|> mAttrs = attrs; mDefStyleAttr = defStyleAttr; mDefStyleRes = defStyleRes; <|endfocus|> mTitleTextAppearance = a.getResourceId(R.styleable.Toolbar_titleTextAppearance, 0); mSubtitleTextAppearance = a.getResourceId(R.styleable.Toolbar_subtitleTextAppearance, 0); mNavButtonStyle = a.getResourceId(R.styleable.Toolbar_navigationButtonStyle, 0); mGravity = a.getInteger(R.styleable.Toolbar_gravity, mGravity); mButtonGravity = a.getInteger(R.styleable.Toolbar_buttonGravity, Gravity.TOP); mTitleMarginStart = mTitleMarginEnd = mTitleMarginTop = mTitleMarginBottom = a.getDimensionPixelOffset(R.styleable.Toolbar_titleMargins, 0); 
<|startcomment|> Unused import. <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.calculator2; import android.content.Context; import android.content.res.Resources; import android.content.res.TypedArray; import android.util.AttributeSet; <|startfocus|> import android.util.Log; <|endfocus|> import android.widget.Button; import android.view.View; import android.view.ViewGroup; import java.text.DecimalFormat; import java.text.NumberFormat; /** * A layout that places children in an evenly distributed grid based on the specified * {@link android.R.attr#columnCount} and {@link android.R.attr#rowCount} attributes. */ public class CalculatorPadLayout extends ViewGroup { private int mRowCount; private int mColumnCount; public CalculatorPadLayout(Context context) { this(context, null); } public CalculatorPadLayout(Context context, AttributeSet attrs) {
<|startcomment|> where's the recursion ? (here and below). Even if it were recursive, the description "recursive" pretty useless in the context of its callers. I'd suggest naming it "assertSSLContextDefaultConfiguration" <|endcomment|>  public static void assertSSLContextDefaultConfigurationRecursive( SSLContext sslContext) throws IOException { assertSSLContextDefaultConfiguration(sslContext); <|startfocus|> assertSSLSocketFactoryConfigSameAsSSLContextRecursive( sslContext.getSocketFactory(), sslContext); assertSSLServerSocketFactoryConfigSameAsSSLContextRecursive( sslContext.getServerSocketFactory(), sslContext); <|endfocus|> SSLEngine sslEngine = sslContext.createSSLEngine(); assertFalse(sslEngine.getUseClientMode()); assertSSLEngineConfigSameAsSSLContext(sslEngine, sslContext);
<|startcomment|> forwards <|endcomment|> import java.util.Set; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; /** * Tool to find direct class references to other classes. */ public class ClassReferenceListBuilder { private static final String CLASS_EXTENSION = ".class"; private Path path; private Set<String> classNames = new HashSet<String>(); public ClassReferenceListBuilder(Path path) { this.path = path; } /** <|startfocus|> * Kept for compatibility with the gradle integration, this method just forward to <|endfocus|> * {@link MainDexListBuilder#main(String[])}. * @deprecated use {@link MainDexListBuilder#main(String[])} instead. */ @Deprecated public static void main(String[] args) { MainDexListBuilder.main(args); } /** * @param jarOfRoots Archive containing the class files resulting of the tracing, typically * this is the result of running ProGuard. */ public void addRoots(ZipFile jarOfRoots) throws IOException { // keep roots
<|startcomment|> Remove this? (At least that's what my intern host told me to do in my CLs last year...) <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.gct.idea.git; import com.google.gct.idea.elysium.ProjectSelector; import com.google.gct.login.CredentialedUser; import com.intellij.openapi.project.Project; import com.intellij.openapi.ui.DialogWrapper; import com.intellij.ui.DocumentAdapter; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import javax.swing.*; import javax.swing.event.DocumentEvent; import java.awt.*; /** <|startfocus|> * @author benwu <|endfocus|> */ public class ChooseProjectDialog extends DialogWrapper { private JPanel myRootPanel; private ProjectSelector myRepositoryURL; private String myProjectId; private CredentialedUser myCredentialedUser; public ChooseProjectDialog(@NotNull Project project, @NotNull String title, @NotNull String okText) { super(project, true); init(); setTitle(title); setOKButtonText(okText); setOKActionEnabled(false); } @NotNull public String getProjectId() { return myProjectId; } @Nullable public CredentialedUser getCredentialedUser() { return myCredentialedUser; } @Override
<|startcomment|> Lists.newArrayList() (or newArrayListWithCapacity()) <|endcomment|>  private static InstallableComponent[] createComponents(@NotNull FirstRunWizardMode reason, boolean createAvd) { AndroidSdk androidSdk = new AndroidSdk(); <|startfocus|> ArrayList<InstallableComponent> components = new ArrayList<InstallableComponent>(); <|endfocus|> components.add(androidSdk); if (Haxm.canRun() && reason == FirstRunWizardMode.NEW_INSTALL) { components.add(new Haxm(KEY_CUSTOM_INSTALL)); } if (createAvd) { components.add(new AndroidVirtualDevice()); } return components.toArray(new InstallableComponent[components.size()]);
<|startcomment|> missing class docs. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.gct.idea.git; import com.google.gct.idea.elysium.ProjectSelector; import com.google.gct.login.CredentialedUser; import com.intellij.openapi.project.Project; import com.intellij.openapi.ui.DialogWrapper; import com.intellij.ui.DocumentAdapter; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import javax.swing.*; import javax.swing.event.DocumentEvent; import java.awt.*; /** <|startfocus|> * @author benwu <|endfocus|> */ public class ChooseProjectDialog extends DialogWrapper { private JPanel myRootPanel; private ProjectSelector myRepositoryURL; private String myProjectId; private CredentialedUser myCredentialedUser; public ChooseProjectDialog(@NotNull Project project, @NotNull String title, @NotNull String okText) { super(project, true); init(); setTitle(title); setOKButtonText(okText); setOKActionEnabled(false); } @NotNull public String getProjectId() { return myProjectId; } @Nullable public CredentialedUser getCredentialedUser() { return myCredentialedUser; } @Override
<|startcomment|> ? <|endcomment|>  } if (zipFiles) { args.add("--output-jack"); } else { args.add("--output-jack-dir"); } args.add(out.getAbsolutePath()); args.addAll(extraJackArgs); if (jarjarRules != null) { args.add("--config-jarjar"); args.add(jarjarRules.getAbsolutePath()); } for (File flags : proguardFlags) { args.add("--config-proguard"); args.add(flags.getAbsolutePath()); } <|startfocus|> // args.add("--ecj"); <|endfocus|> if (withDebugInfos) { args.add("-g"); } if (annotationProcessorClass != null) { args.add("-processor"); args.add(annotationProcessorClass.getName()); } if (annotationProcessorOutDir != null) { args.add("-d"); args.add(annotationProcessorOutDir.getAbsolutePath()); } for (String ecjArg : extraEcjArgs) { args.add(ecjArg); } AbstractTestTools.addFile(args, /* mustExist = */ false, sources); 
<|startcomment|> Why not use parameter, with a good formatting, can be good. <|endcomment|>  import com.android.jack.analysis.dependency.Dependency; import com.android.jack.backend.dex.DexProperties; import com.android.jack.jayce.JayceProperties; import com.android.jack.preprocessor.PreprocessorProperties; import com.android.jack.resource.ResourceProperties; import com.android.sched.vfs.InputVFile; import com.android.sched.vfs.VPath; import javax.annotation.Nonnull; /** * File types supported by jack library. */ public enum FileType { DEX("dex", DexProperties.KEY_DEX, ".dex") { @Override <|startfocus|> public String toString() { return "dex"; <|endfocus|> } @Override public void check() throws LibraryFormatException { } }, JAYCE("jayce", JayceProperties.KEY_JAYCE, ".jayce") { @Override public String toString() { return "jayce"; } @Override public void check() throws LibraryFormatException { } }, JPP("jpp", PreprocessorProperties.KEY_JPP, ".jpp") { @Override public String toString() { return "java pre-processor"; } @Override public void check() throws LibraryFormatException { } },
<|startcomment|> toUpperCase() is either needed or not (for ModeId and Variant) <|endcomment|>  Map<ModeId, Set<Variant>> result = new LinkedHashMap<ModeId, Set<Variant>>(); reader.beginArray(); while (reader.hasNext()) { reader.beginArray(); ModeId mode = ModeId.valueOf(reader.nextString().toUpperCase()); Set<Variant> set = result.get(mode); if (set == null) { set = new LinkedHashSet<Variant>(); result.put(mode, set); } <|startfocus|> set.add(Variant.valueOf(reader.nextString())); <|endfocus|> reader.endArray(); } reader.endArray(); return result; } /** * Sets the bugIsOpen status on all expectations by querying an external bug * tracker. */ public void loadBugStatuses(BugDatabase bugDatabase) { Iterable<Expectation> allExpectations = Iterables.concat(outcomes.values(), failures.values()); // figure out what bug IDs we're interested in Set<Long> bugs = new LinkedHashSet<Long>(); for (Expectation expectation : allExpectations) { if (expectation.getBug() != -1) { bugs.add(expectation.getBug()); } }
<|startcomment|> this should definitely not be public <|endcomment|>  */ public enum Priority { LOW (Process.THREAD_PRIORITY_BACKGROUND + (5 * Process.THREAD_PRIORITY_LESS_FAVORABLE)), NORMAL (Process.THREAD_PRIORITY_DISPLAY); int mID; Priority(int id) { mID = id; } } void validate() { if (mContext == 0) { throw new RSInvalidStateException("Calling RS with no Context active."); } } /** * check if IO support lib is available. */ <|startfocus|> public boolean usingIO() { <|endfocus|> return useIOlib; } /** * Change the priority of the worker threads for this context. * * @param p New priority to be set. */ public void setPriority(Priority p) { validate(); nContextSetPriority(p.mID); } static class MessageThread extends Thread { RenderScript mRS; boolean mRun = true; int[] mAuxData = new int[2]; static final int RS_MESSAGE_TO_CLIENT_NONE = 0; static final int RS_MESSAGE_TO_CLIENT_EXCEPTION = 1;
<|startcomment|> This can happen at a random time after the page was shown for the first time (e.g. in case of NFC mounts, especially if the network connection just went away lost). I suggest we take care and only override missing value to avoid clobbering user input. <|endcomment|>  public void run() { <|startfocus|> myState.put(myPathKey, path); <|endfocus|>
<|startcomment|> nit: you can just use Files.toString(file, Charsets.UTF_8) <|endcomment|>  public boolean isRunning() { // this is a file on Unix, and a directory on Windows. File f = new File(mFolderPath, "userdata-qemu.img.lock"); //$NON-NLS-1$ String command = null; if (SdkConstants.currentPlatform() == SdkConstants.PLATFORM_WINDOWS) { f = new File(f, "pid"); } if (f.exists()) { BufferedReader reader = null; try { <|startfocus|> reader = new BufferedReader(new FileReader(f)); String pid = reader.readLine(); <|endfocus|> if (SdkConstants.currentPlatform() == SdkConstants.PLATFORM_WINDOWS) { command = "cmd /c \"tasklist /FI \"PID eq " + pid + "\" | findstr " + pid + "\""; } else { command = "kill -0 " + pid; } } catch (IOException e) { // Shouldn't happen, but if it does be safe and return true; return true; } finally { try { if (reader != null) { reader.close(); } }
<|startcomment|> What if it is null? Is there some default value or we consider this an "undetermined" state? <|endcomment|>  state.put(NETWORK_LATENCY_KEY, properties.get(NETWORK_LATENCY_KEY.name)); state.put(NETWORK_SPEED_KEY, properties.get(NETWORK_SPEED_KEY.name)); state.put(HAS_HARDWARE_KEYBOARD_KEY, fromIniString(properties.get(HAS_HARDWARE_KEYBOARD_KEY.name))); state.put(DISPLAY_NAME_KEY, AvdManagerConnection.getAvdDisplayName(avdInfo)); String orientation = properties.get(HardwareProperties.HW_INITIAL_ORIENTATION); <|startfocus|> if (orientation != null && orientation.equalsIgnoreCase(ScreenOrientation.PORTRAIT.getShortDisplayValue())) { state.put(DEFAULT_ORIENTATION_KEY, ScreenOrientation.PORTRAIT); <|endfocus|> } if (orientation != null && orientation.equalsIgnoreCase(ScreenOrientation.LANDSCAPE.getShortDisplayValue())) { state.put(DEFAULT_ORIENTATION_KEY, ScreenOrientation.LANDSCAPE); } String skinPath = properties.get(CUSTOM_SKIN_FILE_KEY.name); if (skinPath != null) { File skinFile = new File(skinPath); if (skinFile.isDirectory()) { state.put(CUSTOM_SKIN_FILE_KEY, skinFile); } } state.put(IS_IN_EDIT_MODE_KEY, true);
<|startcomment|> Convention is to always use braces. Also please update the comment. <|endcomment|>  mNavigationBarWidthForRotation[mUpsideDownRotation] = mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] = res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width); // SystemUI (status bar) layout policy int shortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density; int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density; <|startfocus|> // Allow the navigation bar to move on small devices (phones). if (width != height) mNavigationBarCanMove = shortSizeDp < 600; <|endfocus|> mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar); // Allow a system property to override this. Used by the emulator. // See also hasNavigationBar(). String navBarOverride = SystemProperties.get("qemu.hw.mainkeys"); if ("1".equals(navBarOverride)) { mHasNavigationBar = false; } else if ("0".equals(navBarOverride)) { mHasNavigationBar = true; } // For demo purposes, allow the rotation of the HDMI display to be controlled.
<|startcomment|> Unnecessary "this" reference. <|endcomment|>  } if (myHoverIndex >= 0) { if (myJList.getSelectedIndex() >= 0) { myJList.clearSelection(); } myJList.repaint(myJList.getUI().getCellBounds(myJList, myHoverIndex, myHoverIndex)); } } } }); myJList.requestFocusInWindow(); int preferredWidth = UserSelector.this.getWidth(); <|startfocus|> this.setPreferredSize(new Dimension(Math.max(MIN_WIDTH, preferredWidth), getPreferredPopupHeight())); <|endfocus|>
<|startcomment|> Both .fixedLength and .on are static methods of Splitter class, something is clearly should be fixed there <|endcomment|>  public static String getAttrPropertyName(@NotNull ItemResourceValueWrapper item) { if (!item.isAttr()) { return ""; } <|startfocus|> String propertyName = Splitter.fixedLength(2).on('/').splitToList(item.getValue()).get(1); <|endfocus|> return (item.getValue().startsWith(SdkConstants.ANDROID_THEME_PREFIX) ? SdkConstants.PREFIX_ANDROID : "") + propertyName;
<|startcomment|> s/an/a/ <|endcomment|>  protected ValidationInfo doValidate() { String newStyleName = myStyleNameTextField.getText(); if (Strings.isNullOrEmpty(newStyleName)) { <|startfocus|> return new ValidationInfo("You must specify an style name", myStyleNameTextField); <|endfocus|> } if (!myResourceNameValidator.checkInput(newStyleName)) { return new ValidationInfo(myResourceNameValidator.getErrorText(newStyleName), myStyleNameTextField); } return super.doValidate();
<|startcomment|> Wrong comment? (Doesn't look like a utility class; lots of instance state and instance methods) <|endcomment|> import com.android.tools.idea.rendering.ProjectResourceRepository; import com.google.common.collect.ForwardingQueue; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.intellij.openapi.diagnostic.Logger; import com.intellij.openapi.project.Project; import org.jetbrains.android.sdk.AndroidTargetData; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import java.util.*; import static com.android.ide.common.resources.ResourceResolver.THEME_NAME; import static com.android.ide.common.resources.ResourceResolver.THEME_NAME_DOT; /** <|startfocus|> * Utility methods for theme resolution. <|endfocus|> */ public class ThemeResolver { private static final Logger LOG = Logger.getInstance(ThemeResolver.class.getName()); // Order is important, we want project themes first. private final HashSet<String> myThemeNames = new HashSet<String>(); private final List<StyleWrapper> myAllThemes; private final List<StyleWrapper> myFrameworkThemes; private final List<StyleWrapper> myProjectThemes; private final List<StyleWrapper> myProjectLocalThemes; private final StyleResolver myStyleResolver; public ThemeResolver(@NotNull Configuration configuration) {
<|startcomment|> This method is still used in projectClosed() are you sure you don't need to change it to isBuildWithGradle there? <|endcomment|> import com.intellij.openapi.util.Disposer; import com.intellij.openapi.util.text.StringUtil; import com.intellij.openapi.vfs.VirtualFileManager; import com.intellij.util.Function; import com.intellij.util.messages.MessageBusConnection; import org.jetbrains.annotations.NonNls; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; import org.jetbrains.plugins.gradle.util.GradleConstants; import java.util.ArrayList; import java.util.List; import static com.android.tools.idea.gradle.util.Projects.isBuildWithGradle; <|startfocus|> import static com.android.tools.idea.gradle.util.Projects.isGradleProject; <|endfocus|> import static com.android.tools.idea.gradle.util.Projects.lastGradleSyncFailed; public class AndroidGradleProjectComponent extends AbstractProjectComponent { @NonNls private static final String SHOW_MIGRATE_TO_GRADLE_POPUP = "show.migrate.to.gradle.popup"; @Nullable private Disposable myDisposable; @NotNull public static AndroidGradleProjectComponent getInstance(@NotNull Project project) { return ServiceManager.getService(project, AndroidGradleProjectComponent.class); } public AndroidGradleProjectComponent(@NotNull final Project project) { super(project);
<|startcomment|> List <|endcomment|> <|startfocus|> public ArrayList<CategorizedProblem> getExtraProblems() { <|endfocus|> return extraProblems;
<|startcomment|> Strange name? <|endcomment|>  * limitations under the License. */ package com.android.jack.shrob; import com.android.jack.Main; import com.android.jack.test.toolchain.AbstractTestTools; import com.android.jack.test.toolchain.JackBasedToolchain; import org.junit.BeforeClass; import org.junit.Test; import java.io.File; public class ObfuscationTest { @BeforeClass public static void setUpClass() { Main.class.getClassLoader().setDefaultAssertionStatus(true); } @Test <|startfocus|> public void testparameternpe() throws Exception { <|endfocus|> File lib = AbstractTestTools.createTempFile("lib", ".jack"); { JackBasedToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); toolchain.srcToLib(AbstractTestTools.getClasspathAsString(toolchain.getDefaultBootClasspath()), lib, /* zipFiles = */ true, AbstractTestTools.getTestRootDir("com.android.jack.shrob.testparameternpe.lib")); } { JackBasedToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); toolchain.addProguardFlags( new File(AbstractTestTools.getTestRootDir("com.android.jack.shrob.testparameternpe"), "proguard.flags001"));
<|startcomment|> remove the @NotNull annotation on myServerSocket <|endcomment|>  public void dispose() { myIsConnectedToServer = false; clearUi(); clearCaptureState(); if (myServerSocket != null) { try { myServerSocket.close(); } catch (IOException e) { LOG.error(e); } myServerSocket = null; } <|startfocus|> <|endfocus|>
<|startcomment|> space before throws. <|endcomment|>  try { aaptProcessEntry.getValue().shutdown(); } catch (Exception e) { mLogger.error(e, "while shutting down" + aaptProcessEntry.getKey()); } } } mAaptProcesses.clear(); } }; mCrunchingRequests = new WorkQueue<AaptProcess>(mLogger, queueThreadContext, "png-cruncher", 5, 2); } @Override <|startfocus|> public void crunchPng(@NonNull final File from, @NonNull final File to)throws PngException { <|endfocus|> try { final Job<AaptProcess> aaptProcessJob = new Job<AaptProcess>( "Cruncher " + from.getName(), new Task<AaptProcess>() { @Override public void run(Job<AaptProcess> job, JobContext<AaptProcess> context) throws IOException { mLogger.verbose("Thread(%1$s): begin executing job %2$s", Thread.currentThread().getName(), job.getJobTitle()); context.getPayload().crunch(from, to, job); mLogger.verbose("Thread(%1$s): done executing job %2$s",
<|startcomment|> nit: weird white space <|endcomment|>  throw new IOException("\"" + rootJar + "\" can not be read as a zip archive. (" + e.getMessage() + ")", e); } path = new Path(pathString); ClassReferenceListBuilder mainListBuilder = new ClassReferenceListBuilder(path); mainListBuilder.addRoots(jarOfRoots); for (String className : mainListBuilder.getClassNames()) { filesToKeep.add(className + CLASS_EXTENSION); } <|startfocus|> keepAnnotated(path); <|endfocus|> } finally { try { jarOfRoots.close(); } catch (IOException e) { // ignore } if (path != null) { for (ClassPathElement element : path.elements) { try { element.close(); } catch (IOException e) { // keep going, lets do our best. } } } } } /** * Returns a list of classes to keep. This can be passed to dx as a file with --main-dex-list. */ public Set<String> getMainDexList() { return filesToKeep; } 
<|startcomment|> Nit: sourceXml + " failed to parse", for consistency? <|endcomment|>  private String mergeXml(String sourceXml, String targetXml, File targetFile, Map<String, Object> paramMap) { boolean ok; String fileName = targetFile.getName(); String contents = null; if (fileName.equals(SdkConstants.FN_ANDROID_MANIFEST_XML)) { Document currentDocument = XmlUtils.parseDocumentSilently(targetXml, true); assert currentDocument != null : targetXml + "failed to parse"; Document fragment = XmlUtils.parseDocumentSilently(sourceXml, true); <|startfocus|> assert fragment != null : sourceXml; <|endfocus|> contents = mergeManifest(targetFile, sourceXml); ok = contents != null; } else { // Merge plain XML files String parentFolderName = targetFile.getParentFile().getName(); ResourceFolderType folderType = ResourceFolderType.getFolderType(parentFolderName); // mergeResourceFile handles the file updates itself, so no content is returned in this case. ok = mergeResourceFile(targetFile, sourceXml, folderType); } // Finally write out the merged file (formatting etc) if (!ok) {
<|startcomment|> probably want to use named(path) or maybe named(new File(path).getName()). This is useful for tests that can throw multiple asserts to not have to revert to searching for a matching line number to understand which test fail. BTW, in this case, the content will also show up in the error message, so maybe doing a manual comparison and manually building an erorr message might be better (using failWithBadResult) <|endcomment|>  public void containsFileWithContent(String path, byte[] content) { <|startfocus|> assertThat(extractContentAsByte(path)).isEqualTo(content); <|endfocus|>
<|startcomment|> InputOutputVDir <|endcomment|>  * limitations under the License. */ package com.android.sched.vfs; import com.android.sched.util.file.CannotCreateFileException; import com.android.sched.util.file.CannotDeleteFileException; import com.android.sched.util.file.NoSuchFileException; import com.android.sched.util.file.NotDirectoryException; import com.android.sched.util.file.NotFileException; import com.android.sched.util.location.Location; import java.util.Collection; import javax.annotation.Nonnull; /** <|startfocus|> * An {@link VDir} implementation for a {@link GenericInputOutputVFS}. <|endfocus|> */ public class GenericInputOutputVDir implements InputOutputVDir { @Nonnull private final VDir dir; GenericInputOutputVDir(@Nonnull VDir dir) { this.dir = dir; } @Override public boolean isVDir() { return true; } @Override @Nonnull public String getName() { return dir.getName(); } @Override @Nonnull public Location getLocation() { return dir.getLocation(); } @SuppressWarnings("unchecked") @Override @Nonnull public Collection<? extends InputVElement> list() {
<|startcomment|> So this will be changing this variable in a different thread but this class is not thread safe. pupulateUi uses this variable and it's guarded from the caller (which is btw not ideal as it is not possible for the caller to know which methods it should guard. selectFrame for example uses myAtomTreeRoot twice, and it might change in between the two usages. It would not be the right solution to wrap the call to selectFrame in a sync block, as it should not be the caller the one that knows when a lock is needed on this side and it would be too easy to introduce mistakes if we do that. <|endcomment|>  public void initializeData(@NotNull EnumInfoCache enumInfoCache, @NotNull Hierarchy hierarchy) { assert (!ApplicationManager.getApplication().isDispatchThread()); // This shouldn't be called from EDT. myEnumInfoCache = enumInfoCache; <|startfocus|> myAtomTreeRoot = generateAtomTree(hierarchy.getRoot()); <|endfocus|>
<|startcomment|> changeVFS can be done one time in the ctor. Modify also DeflateFS in the same way. <|endcomment|>  public BaseVDir getRootDir() { <|startfocus|> return changeVFS(vfs.getRootDir()); <|endfocus|>
<|startcomment|> I see that we're adding contexts to the configurationsFromContext list above too (on line 103). Does that part need to go through the filter too? <|endcomment|>  final boolean strict) { if (location == null) { return null; } final ArrayList<ConfigurationFromContext> configurationsFromContext = new ArrayList<ConfigurationFromContext>(); for (RuntimeConfigurationProducer producer : findAllProducers(location, context)) { configurationsFromContext.add(new ConfigurationFromContextWrapper(producer)); } for (RunConfigurationProducer producer : Extensions.getExtensions(RunConfigurationProducer.EP_NAME)) { ConfigurationFromContext fromContext = producer.findOrCreateConfigurationFromContext(context); <|startfocus|> if (fromContext != null && ConfigurationFilter.allowConfiguration(fromContext)) { <|endfocus|> configurationsFromContext.add(fromContext); } } if (configurationsFromContext.isEmpty()) return null; Collections.sort(configurationsFromContext, ConfigurationFromContext.COMPARATOR); if(strict) { final ConfigurationFromContext first = configurationsFromContext.get(0); for (Iterator<ConfigurationFromContext> it = configurationsFromContext.iterator(); it.hasNext();) { ConfigurationFromContext producer = it.next(); if (producer != first && ConfigurationFromContext.COMPARATOR.compare(producer, first) > 0) { it.remove(); } } } return configurationsFromContext;
<|startcomment|> explain why? <|endcomment|>  private void setGfxContext(@NotNull final Long contextId) { ApplicationManager.getApplication().assertIsDispatchThread(); // Must be in EDT to call this, since we're synchronized on it. <|startfocus|> // Reference comparison is actually desired here. //noinspection NumberEquality if (!myShouldStopContextSwitch.get() && contextId == myCurrentContext) { <|endfocus|> return; } myShouldStopContextSwitch.set(true); myShouldStopContextSwitch = new AtomicBoolean(false); myCurrentContext = contextId; myEditor.resolveGfxContextChange(myShouldStopContextSwitch);
<|startcomment|> I'm not following why this class would be needed? Why can't the callees simply use the Future<Image> as returned by the RPC APIs? <|endcomment|>  handle.setBinary(binary); } handle.setBinary(binary); return new FetchedImage(handle.getImageInfo(), binary); } catch (InterruptedException e) { LOG.error(e); } catch (ExecutionException e) { LOG.error(e); } catch (RpcException e) { LOG.error(e); } catch (IOException e) { LOG.error(e); } return null; } public static class ImageFetchHandle { <|startfocus|> @NotNull protected ImageInfoId myImageInfoId; protected ImageInfo myImageInfo; protected Binary myBinary; <|endfocus|> protected ImageFetchHandle(@NotNull ImageInfoId imageInfoId) { myImageInfoId = imageInfoId; } public ImageInfo getImageInfo() { return myImageInfo; } public void setImageInfo(@NotNull ImageInfo imageInfo) { myImageInfo = imageInfo; } public Binary getBinary() { return myBinary; } public void setBinary(@NotNull Binary binary) { myBinary = binary; } @NotNull protected ImageInfoId getImageInfoId() {
<|startcomment|> typo. <|endcomment|>  * limitations under the License. */ package com.android.tools.idea.gradle.output.parser.androidPlugin; import com.android.ide.common.blame.output.GradleMessage; import com.android.ide.common.blame.parser.ParsingFailedException; import com.android.ide.common.blame.parser.PatternAwareOutputParser; import com.android.ide.common.blame.parser.util.OutputLineReader; import com.android.ide.common.blame.parser.util.ParserUtil; import com.android.utils.ILogger; import org.jetbrains.annotations.NotNull; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; <|startfocus|> ; <|endfocus|> /** * A parser for exceptions thrown by dex. They are of the form: * <p/> * <pre> * UNEXPECTED TOP-LEVEL EXCEPTION: * [Stack trace] * </pre> */ public class DexExceptionParser implements PatternAwareOutputParser { private static final Pattern ERROR = Pattern.compile("UNEXPECTED TOP-LEVEL EXCEPTION:"); private static final Pattern ALREADY_ADDED_EXCEPTION = Pattern.compile("already added: L(.+);"); @Override
<|startcomment|> Why not use (!closed) here? <|endcomment|>  @Nonnull BaseVFS<? extends BaseVDir, ? extends BaseVFile> finalVFS) { this.workVFS = (BaseVFS<BaseVDir, BaseVFile>) workVFS; this.finalVFS = (BaseVFS<BaseVDir, BaseVFile>) finalVFS; } @Override @Nonnull public Location getLocation() { return finalVFS.getLocation(); } @Override public void close() throws CannotCreateFileException, WrongPermissionException, IOException { <|startfocus|> if (!workVFS.isClosed()) { assert !finalVFS.isClosed(); <|endfocus|> dumpToDir(getRootDir(), finalVFS.getRootDir()); finalVFS.close(); workVFS.close(); } else { assert finalVFS.isClosed(); } } private void dumpToDir(VDir srcRootDir, VDir destRootDir) throws CannotCreateFileException, WrongPermissionException, IOException { for (VElement element : srcRootDir.list()) { String elementName = element.getName(); if (element.isVDir()) { VDir dir = destRootDir.createVDir(elementName); dumpToDir((VDir) element, dir); } else {
<|startcomment|> return Collections.singletonList(new TextPiece... <|endcomment|>  public List<TextPiece> getTextPieces(@NotNull JTree tree, @NotNull TreeNode node, @NotNull EnumInfoCache enumInfoCache, @NotNull AtomReader atomReader) { <|startfocus|> List<TextPiece> textPieces = new ArrayList<TextPiece>(1); textPieces.add(new TextPiece(myAtomGroup.getName(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES)); return textPieces; <|endfocus|>
<|startcomment|> This last part is covered by the code above, isn't it? <|endcomment|>  if (record.commentLength > 0) { byte[] commentBytes = new byte[record.commentLength]; raf.readFully(commentBytes); comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8); } // We have a zip64 eocd record : use that for getting the information we need. <|startfocus|> // Note that zip64 eocd records don't contain comment lengths so we'll need to parse // the regular record just for the comment length (sigh). <|endfocus|> if (zip64EocdRecordOffset != -1) { record = Zip64.parseZip64EocdRecord(raf, zip64EocdRecordOffset, record.commentLength); } // Seek to the first CDE and read all entries. // We have to do this now (from the constructor) rather than lazily because the // public API doesn't allow us to throw IOException except from the constructor // or from getInputStream. RAFStream rafStream = new RAFStream(raf, record.centralDirOffset); BufferedInputStream bufferedStream = new BufferedInputStream(rafStream, 4096);
<|startcomment|> Specify where to put ... <|endcomment|>  @Nonnull public File outProcessorSources = new File("."); @Nonnull public static final PropertyId<Directory> ANNOTATION_PROCESSOR_SOURCE_OUTPUT_DIR = PropertyId.create( "jack.annotation-processor.src.output", "Output folder for sources generated by annotation processors", new DirectoryCodec(Existence.MUST_EXIST, Permission.WRITE | Permission.READ)) .addDefaultValue("."); @Option(name = "--output-processor-class", usage = "output classes generated by annotation processors to this folder", metaVar = "DIRECTORY") @Nonnull <|startfocus|> public File outProcessorClasses = new File("."); @Nonnull <|endfocus|> public static final PropertyId<Directory> ANNOTATION_PROCESSOR_CLASS_OUTPUT_DIR = PropertyId.create( "jack.annotation-processor.class.output", "Output folder for classes generated by annotation processors", new DirectoryCodec(Existence.MUST_EXIST, Permission.WRITE | Permission.READ)) .addDefaultValue("."); @Option(name = "--processorpath", usage = "annotation processor classpath", metaVar = "PATH") @CheckForNull public String processorPath; @Nonnull
<|startcomment|> Prefer to use STOPSHIP as tag <|endcomment|>  return getVFile(name); } catch (NoSuchFileException e) { BaseVFile file = vfs.createVFile(this, name); map.put(name, file); return file; } catch (NotFileException e) { throw new CannotCreateFileException(vfs.getVFileLocation(this, name)); } } @Override @Nonnull public synchronized Collection<? extends BaseVElement> list() { // assert !vfs.isClosed(); <|startfocus|> // XXX: There is a problem with this assertion, likely due to PrefixedFS that has a close() <|endfocus|> // method that is not related to the the close() method of the underlying VFS. return Collections.unmodifiableCollection(map.values()); } @Override public boolean isEmpty() { return map.isEmpty(); } synchronized void internalDelete(@Nonnull String name) { map.remove(name); } } 
<|startcomment|> createNewThemeWithtAttributeValue <|endcomment|>  LOG.error("No style/theme selected"); return; } final ThemeEditorStyle parentStyle = selectedStyle.getParent(); if (myCurrentSubStyle != null) { mySubStyleLabel.setText("\u27A5 " + myCurrentSubStyle.getSimpleName()); mySubStyleLabel.setVisible(true); } else { <|startfocus|> mySubStyleLabel.setVisible(false); <|endfocus|> } // Setting advanced to true here is a required workaround until we fix the hack to set the cell height below. myPropertiesFilter.setAdvancedMode(true); myParentThemeButton.setVisible(parentStyle != null); myParentThemeButton.setToolTipText(parentStyle != null ? parentStyle.getName() : ""); myBackButton.setVisible(myCurrentSubStyle != null); myConfiguration.setTheme(selectedTheme.getName()); final List<EditedStyleItem> rawAttributes = ThemeEditorUtils.resolveAllAttributes(selectedStyle); final List<EditedStyleItem> attributes = new ArrayList<EditedStyleItem>(); final List<TableLabel> labels = AttributesSorter.generateLabels(rawAttributes, attributes); AttributesTableModel rawModel = new AttributesTableModel(selectedStyle, attributes) { @Override
<|startcomment|> Internal to whom? Consider adding more to aid clarity. Full stop, etc. Document null behaviors and interesting edge cases when time == now. Document minResolution with an example. Generally documenting the intended behavior would be useful. There's quite a lot of logic in here. Same comments apply to other public methods below. <|endcomment|> <|startfocus|> public static String getRelativeTimeSpanString(Locale locale, TimeZone tz, long time, long now, long minResolution, int flags) { <|endfocus|> if (locale == null) { locale = Locale.getDefault(); } if (tz == null) { tz = TimeZone.getDefault(); } long duration = Math.abs(now - time); boolean past = (now >= time); // Use UDAT_STYLE_SHORT or UDAT_STYLE_LONG. int style; if ((flags & (FORMAT_ABBREV_RELATIVE | FORMAT_ABBREV_ALL)) != 0) { style = UDAT_STYLE_SHORT; } else { style = UDAT_STYLE_LONG; } // Use UDAT_DIRECTION_LAST or UDAT_DIRECTION_NEXT. int direction; if (past) { direction = UDAT_DIRECTION_LAST; } else { direction = UDAT_DIRECTION_NEXT; } long address = 0; // 'relative' defaults to true as we are generating relative time span string. It will be set // to false when we try to display strings without a quantity, such as 'yesterday', etc.
<|startcomment|> nit: extra 'e' <|endcomment|>  public void createToolWindowContent(@NotNull final Project project, @NotNull final ToolWindow toolWindow) { <|startfocus|> // In order to use the runner layout ui, the runner infraestructure needs to be initialized. <|endfocus|> // Otherwise it is not possible to for example drag one of the tabs out of the tool window. // The object that needs to be created is the content manager of the execution manager for this project. ExecutionManager.getInstance(project).getContentManager(); RunnerLayoutUi layoutUi = RunnerLayoutUi.Factory.getInstance(project).create( "ddms", "ddms", "ddms", project); toolWindow.setIcon(AndroidIcons.AndroidToolWindow); toolWindow.setAvailable(true, null); toolWindow.setToHideOnEmptyContent(true); toolWindow.setTitle(TOOL_WINDOW_ID); DeviceContext deviceContext = new DeviceContext(); Content devicesContent = createDeviceContent(layoutUi, project, deviceContext); Content logcatContent = createLogcatContent(layoutUi, project, deviceContext); Content adbLogsContent = createAdbLogsContent(layoutUi, project); final AndroidLogcatView logcatView = logcatContent.getUserData(AndroidLogcatView.ANDROID_LOGCAT_VIEW_KEY);
<|startcomment|> enableDdms would be less vague than "enableDebuggingFeatures". <|endcomment|>  } if (!sharedLibraries.isEmpty()) { sharedLibraries += ":"; } sharedLibraries += classPathElement; } } finally { installer.disconnect(); } } /** * Prepare the arguments and fork for the system server process. */ private static boolean startSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) throws Zygote.MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( <|startfocus|> OsConstants.CAP_IPC_LOCK, <|endfocus|> OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG, OsConstants.CAP_WAKE_ALARM ); /* Containers run without this capability, so avoid setting it in that case */ if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) { capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND); }
<|startcomment|> Try to always use braces, even for one line statements. <|endcomment|>  private String getCommentBeforeEatComment(XmlTag tag) { PsiElement comment = XmlDocumentationProvider.findPreviousComment(tag); for (int i = 0; i < 5; ++i) { if (comment == null) break; String value = StringUtil.trim(XmlUtil.getCommentText((XmlComment)comment)); <|startfocus|> if (!StringUtil.isEmpty(value)) { if (Character.isLetter(value.charAt(0))) return value; <|endfocus|> } comment = XmlDocumentationProvider.findPreviousComment(comment.getPrevSibling()); } return null;
<|startcomment|> I think this should be part of the configure call since it could be reused in different places with different maximum heights. <|endcomment|>  // Size of a square in checkered board background private static final int CELL_SIZE = 10; // Distance between border of a cell and image private static final int IMAGE_PADDING = 5; // Amount of space between border of box with text and text itself private static final int TEXT_PADDING = 1; // Amount of space between border of a cell and rectangle with solid background for showing text private static final int TEXT_MARGIN = 3; <|startfocus|> private static final int MAX_HEIGHT = 60; <|endfocus|> private final List<BufferedImage> myImages = new ArrayList<BufferedImage>(); private String myName; private String myValue; public static Border getBorder(final Color borderColor) { return BorderFactory.createMatteBorder(PADDING, PADDING, PADDING, PADDING, borderColor); } /** * Populate text fields shown in a cell from EditedStyleItem value */ public void configure(final @NotNull EditedStyleItem item, final @Nullable RenderResources renderResources) { myName = item.getName(); myValue = item.getValue(); myImages.clear();
<|startcomment|> please assert is not null before calling "toSystemDependentName" to get rid of IDE warning <|endcomment|>  File projectSdkPath = localProperties.getAndroidSdkPath(); return projectSdkPath == null || !FileUtil.filesEqual(ideSdkPath, projectSdkPath); } catch (IOException ignored) { } } return true; } return false; } @Nullable private static GradleProjectSyncData doLoadFromDisk(@NotNull Project project) throws IOException, ClassNotFoundException { FileInputStream fin = null; try { <|startfocus|> File rootDirPath = new File(FileUtil.toSystemDependentName(project.getBasePath())); <|endfocus|> File dataFile = getProjectStateFile(project); if (!dataFile.exists()) { return null; } fin = new FileInputStream(dataFile); ObjectInputStream ois = new ObjectInputStream(fin); try { GradleProjectSyncData data = (GradleProjectSyncData)ois.readObject(); data.myRootDirPath = rootDirPath; return data; } finally { Closeables.close(ois, false); } } finally { Closeables.close(fin, false); } } /** * Persists the gradle sync data of this project to disk. *
<|startcomment|> s/, i.e.// <|endcomment|>  final long totalBytesWritten = getBytesWritten(); final long entriesWritten = entries.size(); currentEntryNeedsZip64 = false; if (forceZip64) { currentEntryNeedsZip64 = true; archiveNeedsZip64EocdRecord = true; return; } // In this particular case, we'll write a zip64 eocd record locator and a zip64 eocd // record but we won't actually need zip64 extended info records for any of the individual <|startfocus|> // entries (unless they trigger the checks below, i.e). <|endfocus|> if (entriesWritten == 64*1024-1) { archiveNeedsZip64EocdRecord = true; } // Check whether we'll need to write out a zip64 extended info record in both the local file header // and the central directory. In addition, we will need a zip64 eocd record locator // and record to mark this archive as zip64. // // TODO: This is an imprecise check. When method != STORED it's possible that the compressed
<|startcomment|> JSR305 for these two fields <|endcomment|> import com.android.sched.util.config.ThreadConfig; import com.android.sched.util.file.Directory; import com.android.sched.util.file.FileOrDirectory.ChangePermission; import com.android.sched.util.file.FileOrDirectory.Existence; import com.android.sched.util.file.FileOrDirectory.Permission; import com.android.sched.vfs.DirectFS; import com.android.sched.vfs.VPath; import junit.framework.Assert; import org.junit.BeforeClass; import org.junit.Test; import java.io.File; import java.util.Collections; import javax.annotation.CheckForNull; public class AnnotationProcessorTests { <|startfocus|> <|endfocus|> private static final File ANNOTATED_DIR = AbstractTestTools.getTestRootDir( "com.android.jack.annotation.processor.sample.annotated"); private static final File ANNOTATIONS_DIR = AbstractTestTools.getTestRootDir( "com.android.jack.annotation.processor.sample.annotations"); @CheckForNull private static File noConfigProcessors; @CheckForNull private static File autoProcessors; @BeforeClass public static void setupClass() throws ConfigurationException { // required for creating InputJackLibrary when running tests on cli ThreadConfig.setConfig(new GatherConfigBuilder().build()); noConfigProcessors = null;
<|startcomment|> Why not an accessor? (And below) <|endcomment|>  */ package android.system; import libcore.util.Objects; import java.net.SocketAddress; /** * Netlink socket address. * * Corresponds to Linux's {@code struct sockaddr_nl} from * <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/netlink.h">&lt;linux/netlink.h&gt;</a>. * * @hide */ public final class NetlinkSocketAddress extends SocketAddress { public final int nl_family = OsConstants.AF_NETLINK; /** port ID */ <|startfocus|> public final int nl_pid; <|endfocus|> /** multicast groups mask */ public final int nl_groups; public NetlinkSocketAddress() { this(0, 0); } public NetlinkSocketAddress(int nl_pid) { this(nl_pid, 0); } public NetlinkSocketAddress(int nl_pid, int nl_groups) { this.nl_pid = nl_pid; this.nl_groups = nl_groups; } @Override public String toString() { return Objects.toString(this); } } 
<|startcomment|> nit: s/semaph*/acquired/ <|endcomment|>  public void run() { long timeToWait = mySampleFrequencyMs; while (myRunning) { try { long start = System.currentTimeMillis(); boolean semaphoreAcquiredInTime = myDataSemaphore.tryAcquire(timeToWait, TimeUnit.MILLISECONDS); if (myRunning) { <|startfocus|> sample(semaphoreAcquiredInTime); <|endfocus|> } timeToWait -= System.currentTimeMillis() - start; if (timeToWait <= 0) { timeToWait = mySampleFrequencyMs; } } catch (InterruptedException e) { myRunning = false; } }
<|startcomment|> the code is actually more general than just for exploded-aar, the comment might want to mention that. <|endcomment|>  if (hasLibraryBackup) { updateDependency(model, backup, androidProject); } } private void updateDependency(@NotNull ModifiableRootModel moduleModel, @NotNull LibraryDependency dependency, @NotNull AndroidProject androidProject) { Collection<String> binaryPaths = dependency.getPaths(LibraryDependency.PathType.BINARY); setUpLibraryDependency(moduleModel, dependency.getName(), dependency.getScope(), binaryPaths); File buildFolder = androidProject.getBuildFolder(); <|startfocus|> // Exclude jar files that are in "exploded-aar" folder in "build" folder. <|endfocus|> // see https://code.google.com/p/android/issues/detail?id=123788 ContentEntry[] contentEntries = moduleModel.getContentEntries(); for (String binaryPath : binaryPaths) { File parent = new File(binaryPath).getParentFile(); if (parent != null && FD_JARS.equals(parent.getName()) && isAncestor(buildFolder, parent, true)) { ContentEntry parentContentEntry = findParentContentEntry(parent, contentEntries); if (parentContentEntry != null) { parentContentEntry.addExcludeFolder(pathToIdeaUrl(parent)); } } } } @Override @NotNull
<|startcomment|> List<> <|endcomment|>  @Nonnull Api01Config setResourceDirs(@Nonnull List<File> resourceDirs) throws ConfigurationException; @Nonnull Api01Config setIncrementalDir(@Nonnull File directory) throws ConfigurationException; @Nonnull Api01Config setOutputDexDir(@Nonnull File directory) throws ConfigurationException; @Nonnull Api01Config setOutputJackFile(@Nonnull File file) throws ConfigurationException; @Nonnull Api01Config setConfigJarjarFile(@Nonnull File file) throws ConfigurationException; @Nonnull <|startfocus|> Api01Config setConfigProguardFile(@Nonnull File file) throws ConfigurationException; <|endfocus|> @Nonnull Api01Config setEmitDebug(boolean emitDebug) throws ConfigurationException; @Nonnull Api01Config setMultiDex(@Nonnull MultiDexKind multiDexKind) throws ConfigurationException; @Nonnull Api01Config setVerbosity(@Nonnull VerbosityLevel verbosityLevel) throws ConfigurationException; @Nonnull Api01Config setProperty(@Nonnull String key, @Nonnull String value) throws ConfigurationException; @Nonnull Api01Compiler build() throws ConfigurationException; } 
<|startcomment|> Enum? <|endcomment|>  import com.android.jack.api.JackConfig; import java.io.File; import java.io.OutputStream; import java.util.List; import java.util.Map; import javax.annotation.Nonnull; /** * STOPSHIP */ public interface Api01Config extends JackConfig { @Nonnull Api01Config setReporter(@Nonnull ReporterKind reporterKind, @Nonnull OutputStream reporterStream) throws ConfigurationException; @Nonnull Api01Config setImportTypePolicy(@Nonnull String importTypePolicy) throws ConfigurationException; @Nonnull <|startfocus|> Api01Config setImportResourcePolicy(@Nonnull String importResourcePolicy) throws ConfigurationException; <|endfocus|> @Nonnull Api01Config setJavaSourceVersion(@Nonnull String javaSourceVersion) throws ConfigurationException; @Nonnull Api01Config setObfuscationMappingDumpFile(@Nonnull File obfuscationMappingDumpFile) throws ConfigurationException; @Nonnull Api01Config setClasspath(@Nonnull List<File> classpath) throws ConfigurationException; @Nonnull Api01Config setImport(@Nonnull List<File> libraryFiles) throws ConfigurationException; @Nonnull Api01Config setMetaDirs(@Nonnull List<File> metaDirs) throws ConfigurationException; @Nonnull Api01Config setResourceDirs(@Nonnull List<File> resourceDirs) throws ConfigurationException; @Nonnull
<|startcomment|> Try something <|endcomment|>  public int getMinorVersion() { <|startfocus|> throw new UnsupportedOperationException(); <|endfocus|>
<|startcomment|> setDebugInfoEmission? Maybe not in this CL. <|endcomment|>  ProcessException pe = null; boolean processedWithoutError = false; try { try { Jack.run(api, options, runSessionHooks); } catch (ProcessException e) { // Handle the cause, but keep the ProcessException in case of Internal Compiler Error only pe = e; throw e.getCause(); } <|startfocus|> runSessionHooks.runHooks(); processedWithoutError = true; <|endfocus|> } catch (FrontendCompilationException e) { throw new CompilationException(e.getMessage(), e); } catch (JackUserException e) { throw new CompilationException(e.getMessage(), e); } catch (JackAbortException e) { throw new CompilationException(e.getMessage(), e); } catch (com.android.sched.util.UnrecoverableException e) { throw new UnrecoverableException(e.getMessage(), e); } catch (Throwable e) { // Internal Compiler Error here // If the exception comes from a ProcessException, we want // to report the ProcessException instead of the cause if (pe != null) { e = pe; }
<|startcomment|> needed? <|endcomment|>  public StringValueCodec(@Nonnull String usage) { this.usage = usage; } @Override @Nonnull public String parseString(@Nonnull CodecContext context, @Nonnull String string) { return string; } @Override @CheckForNull public String checkString(@Nonnull CodecContext context, @Nonnull String string) { return string; } @Override @Nonnull public String getUsage() { return usage; } @Override @Nonnull <|startfocus|> public List<com.android.sched.util.codec.Parser.ValueDescription> getValueDescriptions() { <|endfocus|> return Collections.<ValueDescription> emptyList(); } @Override @Nonnull public String formatValue(@Nonnull String data) { return data; } @Override public void checkValue(@Nonnull CodecContext context, @Nonnull String data) { } } 
<|startcomment|> ditto <|endcomment|>  assertTrue("Returned exception ThreadID is null,", returnedThread != 0); // assert that exception catch location is not null Location catchLocation = exceptionEvent.getCatchLocation(); printTestLog("returnedExceptionLoc = " + catchLocation); assertNotNull("Returned exception catch location is null,", catchLocation); // check catch location's method if (!isNullLocation(catchLocation)) { <|startfocus|> StringBuilder builder = new StringBuilder("Invalid catch location: expected null but got "); builder.append(dumpLocation(catchLocation)); fail(builder.toString()); <|endfocus|> } // resume debuggee printTestLog("resume debuggee..."); debuggeeWrapper.vmMirror.resume();
<|startcomment|> and rename it run? <|endcomment|> <|startfocus|> public int runAndGetExitCode() { <|endfocus|> int ret; Process proc = null; Thread suckOut = null; Thread suckErr = null; Thread suckIn = null; try { StringBuilder cmdLineBuilder = new StringBuilder(); for (String arg : cmdLine) { cmdLineBuilder.append(arg).append(' '); } if (verbose) { PrintStream printStream; if (outStream instanceof PrintStream) { printStream = (PrintStream) outStream; } else { printStream = System.out; } if (printStream != null) { printStream.println(cmdLineBuilder); } } else { logger.log(Level.INFO, "Execute: {0}", cmdLineBuilder); } proc = Runtime.getRuntime().exec(cmdLine, null, workDir); InputStream localInStream = inStream; if (localInStream != null) { suckIn = new Thread( new ThreadByteStreamSucker(localInStream, proc.getOutputStream(), inToBeClose)); } else { proc.getOutputStream().close(); } 
<|startcomment|> Remove ? <|endcomment|>  } } jackApiToolchain.setErrorStream(errOut); jackApiToolchain.addToClasspath(jackApiToolchain.getDefaultBootClasspath()) .addToClasspath(te.getJackFolder()) .srcToExe(AbstractTestTools.createTempDir(), false, te.getSourceFolder()); Assert.fail(); } catch (JackAbortException e) { e.printStackTrace(); Assert.assertTrue(e.getCause() instanceof LibraryReadingException); Assert.assertTrue(e.getCause().getCause() instanceof LibraryIOException); <|startfocus|> } catch (Throwable t) { t.printStackTrace(); <|endfocus|> } finally { String errOutput = errOut.toString(); Assert.assertTrue(errOutput.contains("is an invalid library")); Assert.assertTrue(errOutput.contains("is not readable")); for (File jackFile : AbstractTestTools.getFiles(te.getJackFolder(), JayceFileImporter.JAYCE_FILE_EXTENSION)) { if (!jackFile.setReadable(true)) { Assert.fail("Fails to change file permissions of " + jackFile.getAbsolutePath()); } } } } /**
<|startcomment|> You misspelled must-revalidate <|endcomment|>  long now = System.currentTimeMillis(); headers.put("Date", rfc1123Date(now)); headers.put("Expires", rfc1123Date(now + ONE_HOUR_MILLIS)); // - max-age (entry.softTtl) indicates that the asset is fresh for 1 day // - stale-while-revalidate (entry.ttl) indicates that the asset may // continue to be served stale for up to additional 7 days headers.put("Cache-Control", <|startfocus|> "must_revalidate, max-age=86400, stale-while-revalidate=604800"); <|endfocus|> Cache.Entry entry = HttpHeaderParser.parseCacheHeaders(response); assertNotNull(entry); assertNull(entry.etag); assertEqualsWithin(now + ONE_DAY_MILLIS, entry.softTtl, ONE_MINUTE_MILLIS); assertEqualsWithin(now + ONE_DAY_MILLIS + ONE_WEEK_MILLIS, entry.ttl, ONE_MINUTE_MILLIS);
<|startcomment|> Would equals() be meaningful? Worth doing? <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package android.system; import libcore.util.Objects; import java.net.SocketAddress; /** * Packet socket address. * * Corresponds to Linux's {@code struct sockaddr_ll}. * * @hide */ public final class PacketSocketAddress extends SocketAddress { /** Protocol. An Ethernet protocol type, e.g., {@code ETH_P_IPV6}. */ <|startfocus|> private final short protocol; <|endfocus|> /** Interface index. */ private final int ifindex; /** ARP hardware type. One of the {@code ARPHRD_*} constants. */ private final short hatype; /** Packet type. One of the {@code PACKET_*} constants, such as {@code PACKET_OTHERHOST}. */ private final byte pkttype; /** Hardware address. */ private final byte[] addr; /** Constructs a new PacketSocketAddress. */ public PacketSocketAddress(short protocol, int interfaceIndex, short hardwareType, byte packetType, byte[] address) { this.protocol = protocol;
<|startcomment|> How about boolean hasWarning = !warningText.isEmpty(); if (hasWarning) { warningText.insert(0, "<html>"); warningText.append("</html>"); ... } and then we don't have to remember to set the boolean everywhere? <|endcomment|>  hasLink = true; } } else if (haxmState == HaxmState.NOT_LATEST) { warningText.append("Newer HAXM Version Available<br>"); setupDownloadLink(); hasWarning = true; hasLink = true; } } } if (myImageDescription.getVersion().getApiLevel() < SdkVersionInfo.LOWEST_ACTIVE_API) { warningText.append("This API Level is Deprecated<br>"); hasWarning = true; } <|startfocus|> if (hasWarning) { warningText.append("</html>"); myWarningMessage.setText(warningText.toString()); <|endfocus|> setVisible(true); if (hasLink) { myErrorInstructionsLink.setVisible(true); } else { myErrorInstructionsLink.setVisible(false); } } else { setVisible(false); } Window window = SwingUtilities.getWindowAncestor(this); if (window != null) { window.pack(); }
<|startcomment|> Add comment for input <|endcomment|>  */ package com.android.jill.api.v01; import com.android.jill.api.JillConfig; import java.io.File; import javax.annotation.Nonnull; /** * A configuration implementation for API level 01 of the Jill compiler. */ public interface Api01Config extends JillConfig { /** * Toggle verbosity mode. * @param isVerbose the desired verbosity mode */ void setVerbose(boolean isVerbose) throws ConfigurationException; /** <|startfocus|> * Sets jar file to apply the Jill transformation onto. * @param input <|endfocus|> */ void setInputJavaBinaryFile(@Nonnull File input) throws ConfigurationException; /** * Sets file to output jill transformation result into. * @param output */ void setOutputJackFile(@Nonnull File output) throws ConfigurationException; /** * Set how much debug info should be emitted. * @param debugInfoLevel The level of debug info to emit */ void setDebugInfoLevel(@Nonnull DebugInfoLevel debugInfoLevel) throws ConfigurationException; /**
<|startcomment|> Should this be ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED or keyguard orientation? <|endcomment|>  if (appShowWhenLocked != null) { int req = appShowWhenLocked.requestedOrientation; if (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND) { req = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED; } if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + appShowWhenLocked + " -- show when locked, return " + req); return req; } if (DEBUG_ORIENTATION) Slog.v(TAG, "No one is requesting an orientation when screen locked"); return ActivityInfo.SCREEN_ORIENTATION_NOSENSOR; } <|startfocus|> } <|endfocus|> // Top system windows are not requesting an orientation. Start searching from apps. int lastOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED; boolean findingBehind = false; boolean lastFullscreen = false; // TODO: Multi window. DisplayContent displayContent = getDefaultDisplayContentLocked(); final ArrayList<Task> tasks = displayContent.getTasks(); for (int taskNdx = tasks.size() - 1; taskNdx >= 0; --taskNdx) { AppTokenList tokens = tasks.get(taskNdx).mAppTokens; final int firstToken = tokens.size() - 1;
<|startcomment|> Change the declaration on line 31 to read: public void testARTASLR() throws Exception { and drop this catch clause. It's not needed, as an exception is considered a test failure. It also suppresses important debugging information in the stack trace <|endcomment|>  while ((line = bufReader.readLine()) != null) { // Check that we don't have /system/.*boot.art if (line.matches("/system/.*boot\\.art")) { fail("found boot.art from system partition"); } else if (line.matches(".*boot\\.art")) { foundBootART = true; } } if (!foundBootART) { fail("expected to find boot.art"); } } catch (Exception e) { fail("unexpected exception " + e); <|startfocus|> } <|endfocus|>
<|startcomment|> @Nonnull <|endcomment|> <|startfocus|> protected WithLocationException(@CheckForNull Location location, @CheckForNull Throwable cause) { <|endfocus|> super("", cause); assert location != null; this.location = location; this.locationProvider = null;
<|startcomment|> after? <|endcomment|>  /// CHECK-NOT: Mul public static int MulN1(int arg) { return arg * -1; } /// CHECK-START: long Main.MulPowerOfTwo128(long) instruction_simplifier (before) /// CHECK-DAG: <<Arg:j\d+>> ParameterValue /// CHECK-DAG: <<Const128:j\d+>> LongConstant 128 <|startfocus|> /// CHECK-DAG: <<Mul:j\d+>> Mul [<<Const128>>,<<Arg>>] <|endfocus|> /// CHECK-DAG: Return [<<Mul>>] /// CHECK-START: long Main.MulPowerOfTwo128(long) instruction_simplifier (after) /// CHECK-DAG: <<Arg:j\d+>> ParameterValue /// CHECK-DAG: <<Const7:i\d+>> IntConstant 7 /// CHECK-DAG: <<Shl:j\d+>> Shl [<<Arg>>,<<Const7>>] /// CHECK-DAG: Return [<<Shl>>] /// CHECK-START: long Main.MulPowerOfTwo128(long) instruction_simplifier (after) /// CHECK-NOT: Mul public static long MulPowerOfTwo128(long arg) { return arg * 128; } 
<|startcomment|> Same as above. If this can be replaced by javax.swing.Box, one line can be removed. <|endcomment|>  protected JComponent createCenterPanel() { JPanel box = new JPanel(); box.setLayout(new BoxLayout(box, BoxLayout.PAGE_AXIS)); AttributeDefinition attrDefinition = myAttributeDefinitions.getAttrDefByName(myItem.getName()); <|startfocus|> CheckBoxListener listener = new CheckBoxListener(); <|endfocus|> if (attrDefinition != null) { String[] flagNames = attrDefinition.getValues(); JCheckBox[] flags = new JCheckBox[flagNames.length]; for (int index = 0; index < flags.length; index++) { String name = flagNames[index]; JCheckBox flag = new JCheckBox(name); if (mySelectedFlags.contains(name)) { flag.setSelected(true); } flag.addActionListener(listener); flags[index] = flag; box.add(flag); } } return box;
<|startcomment|> It is not a dependency <|endcomment|> import com.android.sched.util.location.FileLocation; import com.android.sched.vfs.OutputVFile; import com.android.sched.vfs.VPath; import java.io.BufferedOutputStream; import java.io.IOException; import java.io.OutputStream; import java.util.ArrayList; import java.util.List; import javax.annotation.Nonnull; /** * This {@code RunnableSchedulable} write index in a library. */ @Description("Write library index in a library") @Constraint(need = {JackFormatIr.class}, no = {NonJackFormatIr.class}) <|startfocus|> @Produce(DependencyInLibraryProduct.class) <|endfocus|> public class LibraryIndexWriter implements RunnableSchedulable<JSession> { @Override public void run(@Nonnull JSession session) throws JackUserException, LibraryIOException { OutputJackLibrary outputJackLibrary = Jack.getSession().getJackOutputLibrary(); boolean generatingLibrary = !ThreadConfig.getConfig().get(Options.GENERATE_DEX_FILE).booleanValue(); List<JDefinedClassOrInterface> types = new ArrayList<JDefinedClassOrInterface>(); for(JType type : session.getTypesToEmit()) { if(type instanceof JDefinedClassOrInterface) { JDefinedClassOrInterface node = (JDefinedClassOrInterface) type;
<|startcomment|> Line past 100 columns? Not sure how long the limit is usually. <|endcomment|>  ParcelFileDescriptor fd = data.readFileDescriptor(); Debug.MemoryInfo mi = Debug.MemoryInfo.CREATOR.createFromParcel(data); boolean checkin = data.readInt() != 0; boolean dumpInfo = data.readInt() != 0; boolean dumpDalvik = data.readInt() != 0; boolean dumpSummaryOnly = data.readInt() != 0; String[] args = data.readStringArray(); if (fd != null) { try { <|startfocus|> dumpMemInfo(fd.getFileDescriptor(), mi, checkin, dumpInfo, dumpDalvik, dumpSummaryOnly, args); <|endfocus|> } finally { try { fd.close(); } catch (IOException e) { // swallowed, not propagated back to the caller } } } reply.writeNoException(); return true; } case DUMP_GFX_INFO_TRANSACTION: { data.enforceInterface(IApplicationThread.descriptor); ParcelFileDescriptor fd = data.readFileDescriptor(); String[] args = data.readStringArray(); if (fd != null) { try { dumpGfxInfo(fd.getFileDescriptor(), args); } finally { try { fd.close();
<|startcomment|> Non-... clone. <|endcomment|>  * limitations under the License. */ package java.text; import libcore.icu.NativeBreakIterator; /* * Default implementation of BreakIterator. Wraps libcore.icu.NativeBreakIterator. * We need this because BreakIterator.isBoundary and BreakIterator.preceding are non-abstract, * and we don't have Java implementations of those methods (other than the current ones, which * forward to the wrapped NativeBreakIterator). */ class IcuIteratorWrapper extends BreakIterator { <|startfocus|> /* The wrapped ICU implementation. non-final for clone */ <|endfocus|> private com.android.ibm.icu.text.BreakIterator wrapped; /* * wrapping constructor */ IcuIteratorWrapper(com.android.ibm.icu.text.BreakIterator iterator) { wrapped = iterator; } @Override public int current() { return wrapped.current(); } @Override public int first() { return wrapped.first(); } @Override public int following(int offset) { if (offset < 0) { throw new IllegalArgumentException("offset < 0"); } return wrapped.following(offset); } @Override public CharacterIterator getText() {
<|startcomment|> ditto <|endcomment|>  protected FrameInfo findFrameInfo(long threadID) { // get number of frames int frameCount = jdwpGetFrameCount(threadID); logWriter.println("=> frames count = " + frameCount); // get frames info FrameInfo[] frameIDs = jdwpGetFrames(threadID, 0, frameCount); if (frameIDs.length != frameCount) { printErrorAndFail("Received number of frames = " + frameIDs.length + " differ from expected number = " + frameCount); } <|startfocus|> //check and print methods info <|endfocus|> FrameInfo frameInfo = null; for (int i = 0; i < frameCount; i++) { logWriter.println("\n"); String methodName = getMethodName(frameIDs[i].location.classID, frameIDs[i].location.methodID); logWriter.println("=> method name = " + methodName); logWriter.println("=> methodID = " + frameIDs[i].location.methodID); logWriter.println("=> frameID = " + frameIDs[i].frameID); logWriter.println("\n"); if (methodName.equals(testedMethodName)) {
<|startcomment|> if Daemons.stop doesn't return until all other threads have stopped, why do you ever find yourself in this loop? <|endcomment|>  private static void waitUntilAllThreadsStopped() { File tasks = new File("/proc/self/task"); while (tasks.list().length > 1) { <|startfocus|> try { Thread.sleep(1); } catch (InterruptedException ignored) { } <|endfocus|> }
<|startcomment|> nit: defaultAnnotationType? <|endcomment|>  * public @interface Annotation1 { * int v1; * int v2; * } * </pre> */ @Description("Add annotation methods default values as system annotation.") @Synchronized @Transform(remove = AnnotationMethodDefaultValue.class, add = {JAnnotationLiteral.class, JNameValuePair.class}) public class DefaultValueAnnotationAdder implements RunnableSchedulable<JMethod> { @Nonnull private final Filter<JMethod> filter = ThreadConfig.get(Options.METHOD_FILTER); @CheckForNull <|startfocus|> private JAnnotationType defaultAnnotation; <|endfocus|> @Override public synchronized void run(@Nonnull JMethod method) throws Exception { final JDefinedClassOrInterface enclosingType = method.getEnclosingType(); if (enclosingType.isExternal() || !filter.accept(this.getClass(), method)) { return; } if (method instanceof JAnnotationMethod) { JAnnotationMethod annotationMethod = (JAnnotationMethod) method; JLiteral defaultValue = annotationMethod.getDefaultValue(); if (defaultValue != null) { TransformationRequest tr = new TransformationRequest(enclosingType); tr.append(new Remove(defaultValue)); SourceInfo sourceInfo = defaultValue.getSourceInfo(); JAnnotationLiteral defaultAnnotation =
<|startcomment|> http://developer.android.com/reference/java/lang/VirtualMachineError.html ? <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package dalvik.system; import java.lang.Error; import java.lang.String; import java.lang.Throwable; /** * An exception only used by the compiler to abort a transaction. * * @hide */ <|startfocus|> public class TransactionAbortError extends Error { <|endfocus|> /** * Constructs a new {@code TransactionAbortError} with its stack trace filled in. */ public TransactionAbortError() { } /** * Constructs a new {@code TransactionAbortError} with its stack trace and detail * message filled in. * * @param detailMessage * The detail message for the exception. */ public TransactionAbortError(String detailMessage) { super(detailMessage); } /** * Constructs a new {@code TransactionAbortError} with detail message and cause * filled in. *
<|startcomment|> It's fine to use null when decrypting, say, in ECB mode. How about "If the specified parameters are inappropriate or insufficient for initializing this cipher"? Same comment for the description paragraph above. <|endcomment|>  * (one of: {@code ENCRYPT_MODE}, {@code DECRYPT_MODE}, {@code * WRAP_MODE} or {@code UNWRAP_MODE}). * @param key * the input key for the operation. * @param params * the algorithm parameters. * @throws InvalidKeyException * if the specified key can not be used to initialize this * cipher instance. * @throws InvalidAlgorithmParameterException <|startfocus|> * if the specified parameters are inappropriate for encrypting * or wrapping using this cipher or if the parameters are * {@code null} and the mode is decrypting or unwrapping. <|endfocus|> */ public final void init(int opmode, Key key, AlgorithmParameterSpec params) throws InvalidKeyException, InvalidAlgorithmParameterException { if (secureRandom == null) { secureRandom = new SecureRandom(); } init(opmode, key, params, secureRandom); } /** * Initializes this cipher instance with the specified key, algorithm * parameters and a source of randomness. * <p>
<|startcomment|> Just return fmtter.format()? <|endcomment|>  endCalendar.roll(Calendar.DAY_OF_MONTH, false); endMs -= DAY_IN_MS; } String skeleton = toSkeleton(startCalendar, endCalendar, flags); synchronized (CACHED_FORMATTERS) { com.ibm.icu.text.DateIntervalFormat fmtter = getFormatter(skeleton, locale, tz); com.ibm.icu.util.Calendar scal = icuCalendar(startCalendar); com.ibm.icu.util.Calendar ecal = icuCalendar(endCalendar); <|startfocus|> String result = fmtter.format(scal, ecal, new StringBuffer(), new FieldPosition(0)).toString(); return result; <|endfocus|> }
<|startcomment|> so you dont forget when you get back, this Canvas is not needed <|endcomment|>  public void setUI(PanelUI ui) { super.setUI(ui); Font regularFont = UIUtil.getLabelFont(); <|startfocus|> Canvas dummyCanvas = new Canvas(); int regularFontSize = dummyCanvas.getFontMetrics(regularFont).getHeight(); myHeaderFont = regularFont.deriveFont(regularFontSize * 1.3f); int labelFontSize = dummyCanvas.getFontMetrics(myHeaderFont).getHeight(); <|endfocus|> if (myRowHeights == null) { myRowHeights = new HashMap<Class<?>, Integer>(); } else { myRowHeights.clear(); } myRowHeights.put(Object.class, regularFontSize + 4); int bigCellSize = 3 * regularFontSize + 10; myRowHeights.put(Color.class, bigCellSize); myRowHeights.put(DrawableDomElement.class, bigCellSize); myRowHeights.put(TableLabel.class, labelFontSize + 10);
<|startcomment|> or maybe myMinimumPluginVersion ? (And maybe just inline 1.2.0 here in the parseRevision call as you did for Gradle on line 245?) <|endcomment|>  AndroidModelVersionCompatibilityCheck(@Nullable FullRevision gradleVersion) { // If Gradle version is 2.4.x, we need to check that the Android plugin version is not older than 1.2. if (gradleVersion != null) { myCheckGradleVersion = gradleVersion.compareTo(PreciseRevision.parseRevision("2.4.0"), FullRevision.PreviewComparison.IGNORE) >= 0; } else { myCheckGradleVersion = false; } <|startfocus|> myAndroidPluginOneDotTwoVersion = myCheckGradleVersion ? PreciseRevision.parseRevision(MODEL_VERSION_ONE_DOT_TWO) : null; <|endfocus|> } boolean isAndroidModelVersionCompatible(@NotNull AndroidProject model) { if (myCheckGradleVersion) { // The project is using Gradle 2.4.x. The model version should be 1.2 or newer. FullRevision pluginVersion = PreciseRevision.parseRevision(model.getModelVersion()); return pluginVersion.compareTo(myAndroidPluginOneDotTwoVersion, FullRevision.PreviewComparison.IGNORE) >= 0; } return true; } } } 
<|startcomment|> remove this. <|endcomment|>  public void configure(final EditedStyleItem resValue, final List<Color> color) { <|startfocus|> this.myValue = resValue.getValue(); <|endfocus|> myIsPublic = resValue.isPublicAttribute(); setColors(color);
<|startcomment|> this is very dangerous as it does not set the font sometimes, meaning the font is whatever the font was last time this component was used, so unpredictable we should prob do something like the renderer here too: returnedComponent.setFont((item != null && item.getSourceStyle().equals(((AttributesTableModel) table.getModel()).getSelectedStyle())) ? table.getFont().deriveFont(Font.BOLD) : table.getFont()); <|endcomment|>  font = (item.getSourceStyle().equals(((AttributesTableModel)table.getModel()).getSelectedStyle())) ? table.getFont() .deriveFont(Font.BOLD) : table.getFont(); } else { stringValue = value; tooltipText = null; } final Component returnedComponent = myDelegate.getTableCellEditorComponent(table, myConvertValueToString ? stringValue : value, isSelected, row, column); <|startfocus|> if (font != null) { returnedComponent.setFont(font); } <|endfocus|> if (returnedComponent instanceof JComponent) { ((JComponent) returnedComponent).setToolTipText(tooltipText); } return returnedComponent;
<|startcomment|> move into if statement <|endcomment|>  public byte[] findClassDefinition(@NotNull String name) { int index = name.lastIndexOf('.'); if (index != -1 && name.charAt(index + 1) == 'R' && (index == name.length() - 2 || name.charAt(index + 2) == '$') && index > 1) { String pkg = name.substring(0, index); AarResourceClassGenerator generator = myGeneratorMap.get(pkg); registerSyncListenerIfNecessary(); <|startfocus|> if (generator != null) { <|endfocus|> return generator.generate(name); } } return null;
<|startcomment|> Nit: put a "" at the end of line 38 such that this can begin with "+"; that way the lines will align. (Take a look at the PrivateResourceDetectorTest for examples of what I mean). <|endcomment|>  @SuppressWarnings("javadoc") public class AppIndexingApiDetectorTest extends AbstractCheckTest { @Override protected Detector getDetector() { return new AppIndexingApiDetector(); } public void testOk() throws Exception { assertEquals( "No warnings.", lintProject( "appindexing_ok.xml=>AndroidManifest.xml")); } public void testCheckDataNode() throws Exception { <|startfocus|> assertEquals( "AndroidManifest.xml:28: Warning: At least one android:scheme attribute should be set for the intent filter [AppIndexing]\n" <|endfocus|> + " <data android:pathPrefix=\"gizmos\" />\n" + " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" + "AndroidManifest.xml:28: Warning: android:host attribute must be set for the intent filter [AppIndexing]\n" + " <data android:pathPrefix=\"gizmos\" />\n" + " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" + "AndroidManifest.xml:28: Warning: android:pathPrefix attribute should start with / [AppIndexing]\n" + " <data android:pathPrefix=\"gizmos\" />\n" + " ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
<|startcomment|> instances (sorry, didn't notice last time.) <|endcomment|>  * classes this will be zero. See also {@link Class#classSize}. */ private transient int objectSize; /** * The lower 16 bits is the primitive type value, or 0 if not a primitive type; set for * generated primitive classes. */ private transient int primitiveType; /** Bitmap of offsets of iFields. */ private transient int referenceInstanceOffsets; /** State of class initialization */ private transient int status; <|startfocus|> /** Offset of the first virtual method copied from an interface in the methods array. */ private transient short copiedMethodsOffset; /** Offset of the first virtual method defined in this class in the methods array. */ private transient short virtualMethodsOffset; <|endfocus|> private Class() { // Prevent this class from being instantiated, // instances should be created by the runtime only. } /** * Returns a {@code Class} object which represents the class with * the given name. The name should be the name of a non-primitive
<|startcomment|> lllocalization <|endcomment|>  if(facet != null) { AppEngineConfigurationProperties state = facet.getConfiguration().getState(); if (state != null && !(new File(state.APPENGINE_SDKROOT).exists())) { System.out.println("hello"); return new DownloadSdkNotification(module); } } return null; } public class DownloadSdkNotification extends EditorNotificationPanel { DownloadSdkNotification(@NotNull Module module) { setText("A valid App Engine SDK was not found for module :" + module.getName() + "."); <|startfocus|> createActionLabel("Install using Gradle", new Runnable() { <|endfocus|> @Override public void run() { GradleInvoker.getInstance(myProject).executeTasks(Collections.singletonList("appengineDownloadSdk")); } }); final VirtualFile buildFile = GradleUtil.getGradleBuildFile(module); if (buildFile != null && buildFile.exists()) { createActionLabel("Open build.gradle", new Runnable() { @Override public void run() { FileEditorManager.getInstance(myProject).openFile(buildFile, true); } }); } } } } 
<|startcomment|> You could also make TreeTable.isTreeColumn public <|endcomment|>  public int getTreeColumnOffset() { int dx = 0; boolean found = false; for (int i = 0; i < myTreeTable.getColumnCount(); i++) { <|startfocus|> if (TreeTableModel.class.isAssignableFrom(myTreeTable.getColumnClass(i))) { found = true; <|endfocus|> break; } dx += myTreeTable.getColumnModel().getColumn(i).getWidth(); } return found ? dx : -1;
<|startcomment|> optional: StringUtil.compareIgnoreCase already does null checks. <|endcomment|>  protected void run(@NotNull Result<Void> result) { for (Resources resources : resourcesElements) { for (ScalarResourceElement colorElement : resources.getColors()) { String colorValue = colorElement.getName().getStringValue(); <|startfocus|> if (colorValue == null || !colorValue.equalsIgnoreCase(colorName)) { continue; <|endfocus|> } colorElement.setStringValue(newValue); } }
<|startcomment|> is this value used? <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.tools.idea.updater.configure; import com.android.tools.idea.sdk.remote.UpdatablePkgInfo; /** * State of a row in {@link SdkUpdaterConfigurable}. */ class NodeStateHolder { enum SelectedState { NOT_INSTALLED, MIXED, INSTALLED } public NodeStateHolder(UpdatablePkgInfo pkg) { ourPkg = pkg; } <|startfocus|> public SelectedState ourState; public UpdatablePkgInfo ourPkg; <|endfocus|> } 
<|startcomment|> localization? <|endcomment|>  public XExecutionStack getActiveExecutionStack() { return myStack; } @NotNull public XExecutionStack getSourceStack() { return myStack; } @Override public XExecutionStack[] getExecutionStacks() { return new XExecutionStack[]{ getActiveExecutionStack(), getSourceStack() }; } } private class SaveAndExitAction extends AnAction { public SaveAndExitAction() { <|startfocus|> super("Stop and Continue Later", "Exit debug mode and continue the debug session later.", GoogleCloudToolsIcons.CLOUD_DEBUGSAVEEXIT); <|endfocus|> } @Override public void update(AnActionEvent e) { e.getPresentation().setEnabled(myListBreakpointsJob != null); } @Override public void actionPerformed(AnActionEvent e) { ActionManager.getInstance().getAction(IdeActions.ACTION_STOP_PROGRAM).actionPerformed(e); } } } 
<|startcomment|> moved them.. <|endcomment|>  * Right now we only support Git. If we added citc or other clients, this would need to be factored out. * @return */ @Transient @Nullable public GitRepository getSourceRepository() { return mySourceRepository; } @Transient public void setSourceRepository(@Nullable GitRepository sourceRepository) { mySourceRepository = sourceRepository; } /** <|startfocus|> * This is the branch the user was on before he started a debug session and we moved him to the target SHA. * @return <|endfocus|> */ @Transient @Nullable public String getOriginalBranchName() { return myOriginalBranchName; } @Transient public void setOriginalBranchName(@Nullable String originalBranchName) { myOriginalBranchName = originalBranchName; } /** * The email user is stored in workspace.xml and is used during deserialization to recreated the debugger client. * @return */ @Nullable public String getEmailUser() { return myEmailUser; } public void setEmailUser(@Nullable String emailUser) { myEmailUser = emailUser; } 
<|startcomment|> This (and the to-list-to-join part below) seems a lot less efficient -- can you explain what this change is for? <|endcomment|>  public String getFolderName(@NonNull ResourceFolderType folder) { <|startfocus|> String qualifierString = getQualifierString(); if (qualifierString.isEmpty()) { return folder.getName(); } else { return folder.getName() + SdkConstants.RES_QUALIFIER_SEP + qualifierString; } <|endfocus|>
<|startcomment|> Nit: SvgGroupNode? https://google-styleguide.googlecode.com/svn/trunk/javaguide.html#s5.3-camel-case <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.assetstudiolib.vectordrawable; <|startfocus|> import com.android.assetstudiolib.vectordrawable.vg.SVGGroupNode; import com.android.assetstudiolib.vectordrawable.vg.SVGLeaveNode; import com.android.assetstudiolib.vectordrawable.vg.SVGTree; <|endfocus|> import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException; import java.io.File; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.util.HashMap; import java.util.logging.Level; import java.util.logging.Logger; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; 
<|startcomment|> There's public constant MAX_RESOURCE_INDIRECTION in ResourceResolver, maybe we should use it here? <|endcomment|>  static boolean isAppCompatTheme(Configuration configuration) { ResourceResolver resources = configuration.getResourceResolver(); if (resources == null) { LOG.error("null ResourceResolver"); return false; } StyleResourceValue defaultTheme = resources.getDefaultTheme(); <|startfocus|> for (int i = 0; i < 50; i++) { <|endfocus|> // for loop ensures that we don't run into cyclic theme inheritance. if (defaultTheme.getName().startsWith("Theme.AppCompat")) { return true; } defaultTheme = resources.getParent(defaultTheme); if (defaultTheme == null) { break; } } return false;
<|startcomment|> private? <|endcomment|>  * limitations under the License. */ package com.android.assetstudiolib.vectordrawable; import java.io.IOException; import java.io.OutputStreamWriter; import java.util.ArrayList; import java.util.logging.Level; import java.util.logging.Logger; /** * Represent a SVG file's group element. */ class SvgGroupNode extends SvgNode { private static Logger logger = Logger.getLogger(SvgGroupNode.class.getSimpleName()); private final static String INDENT_LEVEL = " "; <|startfocus|> ArrayList<SvgNode> mChildren = new ArrayList<SvgNode>(); <|endfocus|> public SvgGroupNode(String name) { super(name); } public void addChild(SvgNode child) { mChildren.add(child); } @Override public void dumpNode(String indent) { // Print the current group. logger.log(Level.FINE, indent + "current group is :" + getName()); // Then print all the children. for (SvgNode node : mChildren) { node.dumpNode(indent + INDENT_LEVEL); } } @Override public boolean isGroupNode() { return true; } @Override
<|startcomment|> Rename method to "findAndroidSdkEntry", because the method only cares about Android SDKs. <|endcomment|> <|startfocus|> public JdkOrderEntry findSdkEntriesForFile(@NotNull VirtualFile file) { <|endfocus|> ProjectFileIndex index = ProjectFileIndex.SERVICE.getInstance(myProject); for (OrderEntry entry : index.getOrderEntriesForFile(file)) { if (entry instanceof JdkOrderEntry) { JdkOrderEntry jdkOrderEntry = (JdkOrderEntry) entry; if (jdkOrderEntry.getJdk().getSdkType() != AndroidSdkType.getInstance()) { continue; } return jdkOrderEntry; } } return null;
<|startcomment|> Replace "app indexing api" with "App Indexing". API is more narrow (the java API in https://developers.google.com/app-indexing/webmasters/appindexingapi), so let's just say App Indexing (https://developers.google.com/app-indexing/). <|endcomment|> import com.android.tools.lint.detector.api.Scope; import com.android.tools.lint.detector.api.Severity; import com.android.tools.lint.detector.api.XmlContext; import com.google.common.collect.Sets; import org.w3c.dom.Attr; import org.w3c.dom.Element; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import java.util.Collection; import java.util.Collections; import java.util.Set; /** <|startfocus|> * Check if the usage of app indexing api is correct. <|endfocus|> */ public class AppIndexingApiDetector extends Detector implements Detector.XmlScanner { private static final Implementation IMPLEMENTATION = new Implementation( AppIndexingApiDetector.class, Scope.MANIFEST_SCOPE); public static final Issue ISSUE_ERROR = Issue.create("AppIndexingError", //$NON-NLS-1$ "Wrong Usage of AppIndexing", "Ensure the app can correctly handle deep links and integrate with " + "the Google AppIndexing API.", Category.USABILITY, 5, Severity.ERROR, IMPLEMENTATION) .addMoreInfo("http://g.co/AppIndexing"); 
<|startcomment|> Since you're saying "*may* be a mistake, is this always a mistake, or is it sometimes correct? If it's sometimes correct, it's probably better to change this to a warning and maybe add a "?" at the end of Missing Data Node. <|endcomment|>  if (actionView && isHttp && !browsable) { context.report(ISSUE_WARNING, intent, context.getLocation(intent), "Activity supporting ACTION_VIEW is not set as BROWSABLE"); } // If this activity is an ACTION_VIEW action with category BROWSABLE, but doesn't // have data node, it may be a mistake and we will report error. if (actionView && browsable && !hasData) { context.report(ISSUE_ERROR, intent, context.getLocation(intent), <|startfocus|> "Missing data node"); <|endfocus|> } } }
<|startcomment|> Continue to support that. If possible, emit a warning about deprecated, and go to info. <|endcomment|>  protected File libraryOutZip = null; @Option(name = "--config-jarjar", usage = "use this jarjar rules file (default: none)", metaVar = "FILE") protected File jarjarRulesFile = null; @Option(name = "--import", usage = "import the given file into the output (repeatable)", <|startfocus|> metaVar = "FILE") <|endfocus|> protected List<File> importedLibraries = new ArrayList<File>(); @Option(name = "--import-resource", usage = "import the given directory into the output as resource files (repeatable)", metaVar = "DIRECTORY") protected List<File> resImport = new ArrayList<File>(); @Option(name = "--import-meta", usage = "import the given directory into the output as meta-files (repeatable)", metaVar = "DIRECTORY") protected List<File> metaImport = new ArrayList<File>(); @Option(name = "--dx-legacy", usage = "keep generation close to dx (default: on)",
<|startcomment|> Do we make this clear to the user? Seems like a strange requirement. <|endcomment|>  // return new BreakpointConfigurationPanel(this); //} @Nullable @Override public final XDebuggerEditorsProvider getEditorsProvider(@NotNull XLineBreakpoint<CloudLineBreakpointProperties> breakpoint, @NotNull Project project) { return new JavaDebuggerEditorsProvider(); } /** * We can only place a cloud breakpoint on a line if: * 1) Its normally ok to do so with a java breakpoint. <|startfocus|> * 2) The selected run config is a cloud debugger runconfig. <|endfocus|> * @param file * @param line * @param project * @return */ @Override public final boolean canPutAt(@NotNull final VirtualFile file, final int line, @NotNull Project project) { RunManagerImpl runManager = RunManagerImpl.getInstanceImpl(project); if (runManager.getSelectedConfiguration() == null || !(runManager.getSelectedConfiguration().getConfiguration() instanceof CloudDebugRunConfiguration)) { return false; } // Most of this code is reused from java linebreakpoint. final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);
<|startcomment|> '...' <|endcomment|>  public String getMessage() { <|startfocus|> return "Verbosity level " + verbosity.name().toLowerCase() + " is deprecated"; <|endfocus|>
<|startcomment|> we're moving away from interfaces starting with I. I would rename this. <|endcomment|>  * @param archivePath the archive file path of the entry * @return <code>true</code> if the file should be included. * @throws ZipAbortException if writing the file should be aborted. */ boolean checkEntry(String archivePath) throws ZipAbortException; } /** * Classes which implement this interface provides a method to check whether a file should * be merged and extracted from the zip. */ <|startfocus|> public interface IZipEntryExtractor { <|endfocus|> boolean checkEntry(String archivePath); void extract(String archivePath, InputStream zis) throws IOException; } /** * Creates a {@link SignedJarBuilder} with a given output stream, and signing information. * <p/>If either <code>key</code> or <code>certificate</code> is <code>null</code> then * the archive will not be signed. * @param out the {@link OutputStream} where to write the Jar archive. * @param key the {@link PrivateKey} used to sign the archive, or <code>null</code>.
<|startcomment|> Here too (@Nullable or @NotNull) <|endcomment|> <|startfocus|> public boolean setAccepted(File sdkRoot) { <|endfocus|> if (checkAccepted(sdkRoot)) { return true; } File licenseDir = new File(sdkRoot, LICENSE_DIR); if (licenseDir.exists() && !licenseDir.isDirectory()) { return false; } if (!licenseDir.exists()) { licenseDir.mkdir(); } File licenseFile = new File(licenseDir, mLicenseRef == null ? mLicenseHash : mLicenseRef); try { Files.write(mLicenseHash, licenseFile, Charsets.UTF_8); } catch (IOException e) { return false; } return true;
<|startcomment|> nit: same with this, although this extends AbstractJComponentFixture. <|endcomment|>  return button.getClass().getSimpleName().equals("ComboBoxButton"); } }); return new RunConfigurationComboBoxFixture(parent.robot(), button); } private RunConfigurationComboBoxFixture(@NotNull Robot robot, @NotNull JButton target) { super(RunConfigurationComboBoxFixture.class, robot, target); } @Nullable public String getText() { return execute(new GuiQuery<String>() { @Override protected String executeInEDT() throws Throwable { return target().getText(); } }); } <|startfocus|> @Override @NotNull protected JComponentDriver createDriver(@NotNull Robot robot) { return new JComponentDriver(robot); } <|endfocus|> } 
<|startcomment|> does ImmutableList.of() work? <|endcomment|>  private String myDebuggeeId; private String myProjectName; private String myProjectNumber; // A WaitToken is defined by the cloud debugger service to represent the entirety of the service state. // The state is defined by any combination of snapshots and their values. private String myWaitToken; <|startfocus|> private volatile List<Breakpoint> myCurrentServerBreakpointList = ContainerUtil.immutableList(new ArrayList<Breakpoint>()); private Debugger myCloudDebuggerClient, myBlockingDebuggerClient; <|endfocus|> private Project myProject; /** * This constructor is used by deserialization of the stateserializer. * We use a separate serializer so we can ensure that the config is written to workspace.xml which is not shared * between users and is never checked in. */ public CloudDebugProcessState() { } @TestOnly CloudDebugProcessState(Debugger client, @Nullable String userEmail, @Nullable String debuggeeId, @Nullable String projectName, @Nullable String projectNumber) { setUserEmail(userEmail); setDebuggeeId(debuggeeId); setProjectName(projectName); setProjectNumber(projectNumber); myCloudDebuggerClient = client;
<|startcomment|> WIP I suppose? <|endcomment|>  if (dirOrZip.isDirectory()) { DirectFS directFS = new DirectFS(new Directory(workingDirectory, string, context.getRunnableHooks(), Existence.MUST_EXIST, Permission.READ | Permission.WRITE, ChangePermission.NOCHANGE), Permission.READ | Permission.WRITE); try { Service service = messageDigestCodec.checkString(context, "SHA"); vfs = new CaseInsensitiveFS(directFS, 2, 2, new MessageDigestFactory(service)); <|startfocus|> System.out.println("CIFS for " + string); <|endfocus|> } catch (WrongVFSFormatException e) { vfs = directFS; System.out.println("CIFS failed for " + string); } } else { RunnableHooks hooks = context.getRunnableHooks(); assert hooks != null; vfs = new ReadZipFS(new InputZipFile(workingDirectory, string, hooks, Existence.MUST_EXIST, ChangePermission.NOCHANGE)); } return JackLibraryFactory.getInputLibrary(vfs); } catch (LibraryException e) { throw new ParsingException(e.getMessage(), e); } catch (NotFileOrDirectoryException e) { // we already checked it this was a dir or a file
<|startcomment|> /*isVirtualDispatch =*/ <|endcomment|>  id.getMarker(NeedsDispatchAdjustment.class); if (needsDispatchAdjustmentMarker != null) { JMethodId idReplacement = needsDispatchAdjustmentMarker.getReplacementId(); JMethodCall replacement; if (methodCall instanceof JNewInstance) { JNewInstance newCall = (JNewInstance) methodCall; replacement = new JNewInstance(newCall.getSourceInfo(), newCall.getReceiverType(), idReplacement); } else { replacement = new JMethodCall(methodCall.getSourceInfo(), <|startfocus|> null, methodCall.getReceiverType(), idReplacement, methodCall.getType(), false); <|endfocus|> } replacement.addAllMarker(methodCall.getAllMarkers()); replacement.addArgs(methodCall.getArgs()); if (needsDispatchAdjustmentMarker.needsThis()) { JExpression instance = methodCall.getInstance(); assert instance != null; replacement.addArg(instance); } replacement.updateParents(methodCall.getParent()); tr.append(new Replace(methodCall, replacement)); } return super.visit(methodCall);
<|startcomment|> Same here. <|endcomment|>  final int h = min.y * 2; assertDesiredMinimum(new Point(min.x / 2, min.y / 2), min, screenSize); assertDesiredMinimum(new Point(w, h), new Point(w, h), screenSize); assertDesiredMinimum(new Point(min.x / 2, h), new Point(min.x, h), screenSize); <|startfocus|> assertDesiredMinimum(new Point(w, min.y / 2), new Point(w, min.y), screenSize); <|endfocus|>
<|startcomment|> Annotate as @Nullable? <|endcomment|>  public static void drawCenterInside(Graphics2D g, BufferedImage source, Rectangle dstRect) { <|startfocus|> if (source == null) { return; } <|endfocus|> final int srcWidth = source.getWidth(); final int srcHeight = source.getHeight(); if (srcWidth * 1.0 / srcHeight > dstRect.width * 1.0 / dstRect.height) { final int scaledWidth = Math.max(1, dstRect.width); final int scaledHeight = Math.max(1, dstRect.width * srcHeight / srcWidth); Image scaledImage = scaledImage(source, scaledWidth, scaledHeight); g.drawImage(scaledImage, dstRect.x, dstRect.y + (dstRect.height - scaledHeight) / 2, dstRect.x + dstRect.width, dstRect.y + (dstRect.height - scaledHeight) / 2 + scaledHeight, 0, 0, 0 + scaledWidth, 0 + scaledHeight, null); } else { final int scaledWidth = Math.max(1, dstRect.height * srcWidth / srcHeight); final int scaledHeight = Math.max(1, dstRect.height);
<|startcomment|> I think this should be done as part of addInstance. This is the only call to addInstance, and it should be at that time we add the size. And when you move it in, it will be clear the dependency the class set the size of itself to the instance to then add it back to itself. :-/ <|endcomment|>  int classSize = javaLangClassSize; for (Field f : classObj.mStaticFields) { classSize += getTypeSize(f.getType()); } classObj.setSize(classSize); } for (Instance instance : heap.getInstances()) { ClassObj classObj = instance.getClassObj(); if (classObj != null) { <|startfocus|> // Now is a good time to set the size of this instance if (instance instanceof ClassInstance) { instance.setSize(classObj.getInstanceSize()); } <|endfocus|> classObj.addInstance(heap.getId(), instance); } } }
<|startcomment|> I see the test verifies that Unit test run, but it doesn't verify what the CL is about, which is ensuring that irrelevant run configurations are hidden. Please add a test that verifies that irrelevant run configurations are hidden. This can be though to do in UI tests. Let's get this checked in (I tested that manually) and add the missing test in a separate CL. <|endcomment|> import com.android.tools.idea.tests.gui.framework.fixture.IdeFrameFixture; import org.jetbrains.annotations.NotNull; import org.junit.Test; import java.io.IOException; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; @BelongsToTestGroups({TestGroup.UNIT_TESTING}) public class UnitTestingSupportTest extends GuiTestCase { private IdeFrameFixture myProjectFrame; private EditorFixture myEditor; @Test @IdeGuiTest <|startfocus|> public void unitTestingUi() throws IOException { <|endfocus|> myProjectFrame = importProjectAndWaitForProjectSyncToFinish("SimpleApplicationWithUnitTests"); BuildVariantsToolWindowFixture buildVariants = myProjectFrame.getBuildVariantsWindow(); buildVariants.activate(); buildVariants.selectUnitTests(); // Open the test file: myEditor = myProjectFrame.getEditor(); myEditor.open("app/src/test/java/google/simpleapplication/UnitTest.java"); // Run the test case that is supposed to pass: myEditor.moveTo(myEditor.findOffset("passing", "Test", true)); runTestUnderCursor(); UnitTestTreeFixture unitTestTree = getTestTree("UnitTest.passingTest"); assertTrue(unitTestTree.isAllTestsPassed()); 
<|startcomment|> "Wait 5s" in line with the sleep below, or non-specific "Wait a bit". <|endcomment|>  String[] secCmdLine = new String[cmdline.length + 1]; System.arraycopy(cmdline, 0, secCmdLine, 0, cmdline.length); secCmdLine[secCmdLine.length - 1] = "--secondary"; Process p = exec(secCmdLine); int pid = getPid(p); if (pid <= 0) { p.destroy(); throw new RuntimeException("Couldn't parse process"); } // Wait 1s, so the forked process has time to run until its sleep phase. try { <|startfocus|> Thread.sleep(5000); } catch (Exception e) { throw new RuntimeException(e); } <|endfocus|> if (!unwindOtherProcess(pid)) { System.out.println("Unwinding other process failed."); }
<|startcomment|> What about checking keycode or coordinate as well? And could you add a test for OnUnhandledInputEventListener as well? <|endcomment|>  @Override protected boolean check() { CountingSession session = CountingTvInputService.sSession; return session != null && session.mKeyMultipleCount> 0; } }.run(); } public void verifyCommandDispatchKeyUp() { resetCounts(); mTvView.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_K)); mInstrumentation.waitForIdleSync(); new PollingCheck(TIME_OUT) { @Override protected boolean check() { CountingSession session = CountingTvInputService.sSession; <|startfocus|> return session != null && session.mKeyUpCount> 0; <|endfocus|> } }.run(); } public void verifyCommandDispatchTouchEvent() { resetCounts(); long now = SystemClock.uptimeMillis(); MotionEvent event = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, 1.0f, 1.0f, 1.0f, 1.0f, 0, 1.0f, 1.0f, 0, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); mTvView.dispatchTouchEvent(event); mInstrumentation.waitForIdleSync(); new PollingCheck(TIME_OUT) { @Override protected boolean check() {
<|startcomment|> Is it the normal way of getting JSession? <|endcomment|>  @Override protected boolean mustBeRemoved(@Nonnull JDefinedClassOrInterface type) { if (type == stringDef || type == intDef) { return true; } if (type instanceof JDefinedAnnotationType) { if ((!type.getAnnotations(stringDef).isEmpty()) || !type.getAnnotations(intDef).isEmpty()) { JDefinedAnnotationType typeDef = (JDefinedAnnotationType) type; if (typeDef.getRetentionPolicy() != JRetentionPolicy.SOURCE) { <|startfocus|> JSession session = type.getParent(JSession.class); session.getReporter().report(Severity.NON_FATAL, <|endfocus|> new InvalidRetentionForTypeDef(typeDef)); } return true; } } return false; } @Override protected boolean isPlannedForRemoval(@Nonnull JMethod method) { return mustBeRemoved(method.getEnclosingType()); } } 
<|startcomment|> these cursors look immutable. You should constant case them. <|endcomment|> import java.text.SimpleDateFormat; import java.util.*; import java.util.List; /** * This panel shows a list of historical and pending snapshots. * The user can navigate to them by double clicking on them, which synchronizes the debugger state to that snapshot. */ public class CloudDebugHistoricalSnapshots extends AdditionalTabComponent implements XDebugSessionListener, CloudDebugStateController.CloudBreakpointListener { <|startfocus|> private static final Cursor ourHandCursor = Cursor.getPredefinedCursor(Cursor.HAND_CURSOR); private static final Cursor ourDefaultCursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR); <|endfocus|> private static final int COLUMN_MARGIN_PX = 1; private static final int WINDOW_WIDTH = 200; private static final int WINDOW_HEIGHT = 8 * JBTable.PREFERRED_SCROLLABLE_VIEWPORT_HEIGHT_IN_ROWS; private final JBTable myTable; private CloudDebugProcess myProcess; public CloudDebugHistoricalSnapshots(@NotNull CloudDebugProcessHandler processHandler) { super(new BorderLayout()); myTable = new JBTable() { // Returning the Class of each column will allow different // renderers to be used based on Class @Override
<|startcomment|> nit: I'd still use StringBuilder to avoid creating this string for no reason. <|endcomment|>  if ("value".equals(entry.getKey().getName())) { charBufferArray = (ArrayInstance)entry.getValue(); } } assert (charBufferArray != null); final int MAX_SIZE = 1024; char[] stringChars = charBufferArray.asCharArray(MAX_SIZE); int charLength = stringChars.length; if (charLength == MAX_SIZE) { myTruncatedValueText = " \"" + new String(stringChars, 0, charLength - 1) + "...\""; } else { <|startfocus|> myTruncatedValueText = " \"" + new String(stringChars) + "\""; <|endfocus|> }
<|startcomment|> should this always be immutable? should clients of this be able to mofify this list? <|endcomment|>  @Nullable @Override public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException { // There is nothing to execute. We set up all of our state in CloudDebugRunner. return null; } /** * Returns a cached set of {@link Breakpoint} objects. The list is periodically updated from a * background timer. * * @return the current list of breakpoints and their state. */ @NotNull @Transient <|startfocus|> public List<Breakpoint> getCurrentServerBreakpointList() { <|endfocus|> return myCurrentServerBreakpointList; } /** * Updates the state (breakpoint list). */ public void setCurrentServerBreakpointList(List<Breakpoint> newBreakpointList) { myCurrentServerBreakpointList = newBreakpointList; } /** * Called during serialization to store the id in workspace.xml. * * @return The target debuggee Id the state is attached to. */ @Nullable public String getDebuggeeId() { return myDebuggeeId; } /** * Called during deserialization from {@link CloudDebugProcessStateSerializer}
<|startcomment|> project.file doesn't do anything if the path is an absolute path. You can remove the ConventionHelper and just set it since buildDir is always aboslute <|endcomment|>  FD_REPORTS + "/" + FD_ANDROID_TESTS; } return scope.getGlobalScope().getProject().file(rootLocation + subFolder); } }); ConventionMappingHelper.map(task, "coverageDir", new Callable<File>() { @Override public File call() { String rootLocation = scope.getGlobalScope().getBuildDir() + "/" + FD_OUTPUTS + "/code-coverage"; <|startfocus|> return scope.getGlobalScope().getProject().file(rootLocation + subFolder); } }); <|endfocus|> if (scope.getVariantData() instanceof TestVariantData) { TestVariantData testVariantData = (TestVariantData) scope.getVariantData(); if (connected) { testVariantData.connectedTestTask = task; } else { testVariantData.providerTestTaskList.add(task); } } task.setEnabled(deviceProvider.isConfigured());
<|startcomment|> nit: move declaration of comparisonToken above and use it here? <|endcomment|>  sourceInfoWriter.writeDebugBegin(currentClass, currentLine); writer.writeCatchBlockIds(currentCatchList); writer.writeKeyword(Token.EXPRESSION_STATEMENT); writer.writeOpen(); sourceInfoWriter.writeDebugBegin(currentClass, currentLine); writer.writeKeyword(Token.ASG_OPERATION); writer.writeOpen(); writeStackAccess(nextFrame, TOP_OF_STACK); writeValue((long) (insn.getOpcode() - LCONST_0), currentClass, currentLine); sourceInfoWriter.writeDebugEnd(currentClass, currentLine + 1); writer.writeClose(); <|startfocus|> sourceInfoWriter.writeDebugEnd(currentClass, currentLine + 1); <|endfocus|> writer.writeClose(); break; } case FCONST_0: case FCONST_1: case FCONST_2: { assert nextFrame != null; sourceInfoWriter.writeDebugBegin(currentClass, currentLine); writer.writeCatchBlockIds(currentCatchList); writer.writeKeyword(Token.EXPRESSION_STATEMENT); writer.writeOpen(); sourceInfoWriter.writeDebugBegin(currentClass, currentLine); writer.writeKeyword(Token.ASG_OPERATION); writer.writeOpen(); writeStackAccess(nextFrame, TOP_OF_STACK); writeValue((float) (insn.getOpcode() - FCONST_0), currentClass, currentLine);
<|startcomment|> s/public/protected Sorry to be this nitpicky. <|endcomment|>  private static byte[] getFirstOnMeasureClass() { // Use asmifier to convert the compiled version of following class to generation code: // public class FirstClass { // int a; <|startfocus|> // public void onMeasure(int x, int y) {a = 1;} <|endfocus|> // public int test() { onMeasure(0,0); return a;}} ClassWriter cw = new ClassWriter(0); FieldVisitor fv; MethodVisitor mv; cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, "FirstClass", null, "java/lang/Object", null); { fv = cw.visitField(0, "a", "I", null, null); fv.visitEnd(); } { mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null); mv.visitCode(); mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false); mv.visitInsn(RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); } {
<|startcomment|> NFCID2 <|endcomment|>  } catch (RemoteException e) { // Try one more time recoverService(); if (sService == null) { Log.e(TAG, "Failed to recover CardEmulationService."); return false; } try { return sService.removeSystemCodeForService(UserHandle.myUserId(), service); } catch (RemoteException ee) { Log.e(TAG, "Failed to reach CardEmulationService."); return false; } } } /** <|startfocus|> * Retrieves the current NFCUD2 for the specified service. <|endfocus|> * * <p>Before calling {@link #setNfcid2ForService(ComponentName, String)}, * the NFCID2 contained in the Manifest file is returned. If "random" is specified * in the Manifest file, a random number assigned by the system at installation time * is returned. After setting an NFCID2 * with {@link #setNfcid2ForService(ComponentName, String)}, this NFCID2 is returned. * * @param service The component name of the service * @return the current NFCID2 */
<|startcomment|> dito. <|endcomment|>  // to turn the screen back on within a certain window without // having to unlock the screen) final ContentResolver cr = mContext.getContentResolver(); // From DisplaySettings long displayTimeout = Settings.System.getIntForUser(cr, SCREEN_OFF_TIMEOUT, KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT, UserHandle.USER_CURRENT); // From SecuritySettings final long lockAfterTimeout = Settings.Secure.getIntForUser(cr, Settings.Secure.LOCK_SCREEN_LOCK_AFTER_TIMEOUT, <|startfocus|> KEYGUARD_LOCK_AFTER_DELAY_DEFAULT, UserHandle.USER_CURRENT); <|endfocus|> // From DevicePolicyAdmin final long policyTimeout = mLockPatternUtils.getDevicePolicyManager() .getMaximumTimeToLock(null, mLockPatternUtils.getCurrentUser()); long timeout; if (policyTimeout > 0) { // policy in effect. Make sure we don't go beyond policy limit. displayTimeout = Math.max(displayTimeout, 0); // ignore negative values timeout = Math.min(policyTimeout - displayTimeout, lockAfterTimeout); } else { timeout = lockAfterTimeout; } if (timeout <= 0) { // Lock now mSuppressNextLockSound = true; doKeyguardLocked(null);
<|startcomment|> to be used used to use <|endcomment|> import android.net.Uri; import android.os.RemoteException; import android.text.TextUtils; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; /** * A utility class for verifying channel/program results on global search requests. */ public class SearchUtil { private SearchUtil() {} /** * Returns {@code true} if the search results include the given expected result. * <|startfocus|> * @param context The context object to used for getting content resolver <|endfocus|> * @param searchable The {@link android.app.SearchableInfo} the TV app implements * @param query A query string to search for * @param expectedResult The expected search result */ public static boolean verifySearchResult(Context context, SearchableInfo searchable, String query, String expectedResult) { Uri.Builder uriBuilder = getSearchUri(searchable).buildUpon(); String selection = searchable.getSuggestSelection(); String[] selectionArg = null; if (selection != null) { selectionArg = new String[] { query }; } else {
<|startcomment|> not necessary. setUp() will be called for each tests. <|endcomment|>  private Handler mHandler = new Handler(Looper.getMainLooper()); private MediaSession mSession; private MediaSessionCallback mCallback; private MediaController mController; @Override protected void setUp() throws Exception { super.setUp(); mSession = new MediaSession(getContext(), SESSION_TAG); mCallback = new MediaSessionCallback(); mSession.setCallback(mCallback, mHandler); mController = mSession.getController(); } public void testSendCommand() throws Exception { mCallback.reset(); <|startfocus|> synchronized (mWaitLock) { <|endfocus|> final String command = "test-command"; final Bundle extras = new Bundle(); extras.putString(EXTRAS_KEY, EXTRAS_VALUE); mController.sendCommand(command, extras, new ResultReceiver(null)); mWaitLock.wait(TIME_OUT_MS); assertTrue(mCallback.mOnCommandCalled); assertNotNull(mCallback.mCommandCallback); assertEquals(EXTRAS_VALUE, mCallback.mExtras.getString(EXTRAS_KEY)); } } public void testVolumeControl() throws Exception { VolumeProvider vp = new VolumeProvider(VolumeProvider.VOLUME_CONTROL_ABSOLUTE, 11, 5) { @Override
<|startcomment|> If you're going with this, put it close to the use... <|endcomment|>  public static double ceil(double d) { final long bits = Double.doubleToRawLongBits(d); int highBits = (int) (bits >>> 32); // high word of d int lowBits = (int) bits; // low word of d <|startfocus|> long unsignedL = lowBits & 0xFFFFFFFFL; // unsigned low word of d <|endfocus|> int exp = ((highBits >> 20) & 0x7ff) - 0x3ff; // value of exponent /* negative exponent */ if (exp < 0) { if (HUGE + d > 0.0) { if (highBits < 0) { // if |d| < 1 return -0 highBits = 0x80000000; } else if ((highBits | lowBits) != 0) { // raise inexact if d != 0, this is ignored by Java highBits = 0x3ff00000; // return 1 } lowBits = 0; } } /* exponent in range [0, 20) */ else if (exp < 0x014) {
<|startcomment|> constant? <|endcomment|>  private ModelBuilder createModelBuilder() { AndroidBuilder androidBuilder = registry.realize( new ModelPath(ANDROID_BUILDER), ModelType.of(AndroidBuilder.class)); DefaultAndroidComponentSpec componentSpec = (DefaultAndroidComponentSpec) registry.realize( <|startfocus|> new ModelPath("components"), <|endfocus|> ModelType.of(ComponentSpecContainer.class)) .get(AndroidComponentModelPlugin.COMPONENT_NAME); VariantManager variantManager = componentSpec.getVariantManager(); TaskManager taskManager = registry.realize( new ModelPath(TASK_MANAGER), ModelType.of(TaskManager.class)); AndroidConfig extension = registry.realize( new ModelPath("createModelAdaptor"), ModelType.of(AndroidConfig.class)); ExtraModelInfo extraModelInfo = registry.realize( new ModelPath(EXTRA_MODEL_INFO), ModelType.of(ExtraModelInfo.class)); Boolean isApplication = registry.realize( new ModelPath(IS_APPLICATION), ModelType.of(Boolean.class)); NdkHandler ndkHandler = registry.realize( new ModelPath(NDK_HANDLER), ModelType.of(NdkHandler.class)); // Forces rules for binaries to run so that the variants are created. registry.realizeNode(new ModelPath("binaries")); return new ModelBuilder(
<|startcomment|> can be "private static final double[] CEIL_DOUBLES" but there's not much difference in this context (and you're following the rest of this class). <|endcomment|>  /** * Many of these tests are bogus in that the cost will vary wildly depending on inputs. * For _my_ current purposes, that's okay. But beware! */ public class StrictMathBenchmark extends SimpleBenchmark { private final double d = 1.2; private final float f = 1.2f; private final int i = 1; private final long l = 1L; /* Values for full line coverage of ceiling function */ <|startfocus|> private final double[] ceilDoubles = new double[] { <|endfocus|> 3245817.2018463886, 1418139.083668501, 3.572936802189103E15, -4.7828929737254625E249, 213596.58636369856, 6.891928421440976E-96, -7.9318566885477E-36, -1.9610339084804148E15, -4.696725715628246E10, 3742491.296880909, 7.140274745333553E11 }; /* Values for full line coverage of floor function */ private final double[] floorDoubles = new double[] { 7.140274745333553E11, 3742491.296880909, -4.696725715628246E10, -1.9610339084804148E15, 7.049948629370372E-56, -7.702933170334643E-16, -1.99657681810579, -1.1659287182288336E236,
<|startcomment|> private? <|endcomment|> <|startfocus|> protected PsiFileAndLineNavigation[] getTargetFiles() { <|endfocus|> TreePath path = myTree.getSelectionPath(); if (path.getPathCount() < 2) { return null; } DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent(); if (node.getUserObject() instanceof HeapClassObj) { ClassObj classObj = ((HeapClassObj)node.getUserObject()).getClassObj(); return PsiFileAndLineNavigation.wrappersForClassName(myProject, classObj.getClassName(), 1); } return null;
<|startcomment|> I usually write != 0 instead of > 0, but that may just be experience from writing assembly. <|endcomment|>  public PKCS5Padding() { super(Padding.PKCS5PADDING); } } } public static class OFB extends AES { public OFB() { super(Mode.OFB, Padding.NOPADDING); } } @Override protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException { switch (keyLength) { case 16: // AES 128 case 24: // AES 192 case 32: // AES 256 return; default: throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes"); <|startfocus|> } <|endfocus|> } @Override protected void checkSupportedMode(Mode mode) throws NoSuchAlgorithmException { switch (mode) { case CBC: case CFB: case CFB1: case CFB8: case CFB128: case CTR: case ECB: case OFB: return; default: throw new NoSuchAlgorithmException("Unsupported mode " + mode.toString()); } } @Override protected void checkSupportedPadding(Padding padding) throws NoSuchPaddingException { switch (padding) { case NOPADDING: case PKCS5PADDING: return; default:
<|startcomment|> This would be unnecessary when we'll get rid of that property, so maybe it would be a good idea to mark it with corresponding TODO comment (or maybe leave that comment near the place this flag is used in the main code) <|endcomment|>  public static void runBeforeClass() { <|startfocus|> System.setProperty("enable.theme.editor", "true"); <|endfocus|>
<|startcomment|> nit: year <|endcomment|> <|startfocus|> * Copyright (C) 2012 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.switchstatement.test013.jack; import java.lang.Thread.State; /** * Tests about customized enum switches when framework enum * is used. */ public class Switch1 { @SuppressWarnings("incomplete-switch") public static int switch1(State state) { switch (state) { case NEW: return -1; case RUNNABLE: return -2; case BLOCKED:
<|startcomment|> weird <|endcomment|>  */ package com.android.sched.util; import com.android.sched.util.findbugs.SuppressFBWarnings; import java.io.File; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Properties; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import javax.annotation.CheckForNull; import javax.annotation.Nonnegative; import javax.annotation.Nonnull; /** * A class describing version, release, build & code. */ <|startfocus|> public class Version { @Nonnegative private static final int VERSION_CODE = 2; <|endfocus|> @Nonnull private static final String VERSION_CODE_KEY = "version-file.version.code"; @Nonnull private static final String VERSION_KEY = "version"; @Nonnull private static final String RELEASE_NAME_KEY = "version.release.name"; @Nonnull private static final String RELEASE_CODE_KEY = "version.release.code"; @Nonnull private static final String SUB_RELEASE_CODE_KEY = "version.sub-release.code"; @Nonnull private static final String SUB_RELEASE_KIND_KEY = "version.sub-release.kind"; @Nonnull
<|startcomment|> final <|endcomment|>  height = w.mCompatFrame.height(); } // Something is wrong and SurfaceFlinger will not like this, // try to revert to sane values if (width < 1) { width = 1; } if (height < 1) { height = 1; } float left = w.mShownFrame.left; float top = w.mShownFrame.top; // Adjust for surface insets. final LayoutParams attrs = w.getAttrs(); <|startfocus|> int displayId = w.getDisplayId(); boolean surfaceScaled = false; <|endfocus|> float scale = 1.0f; // Magnification is supported only for the default display. if (mService.mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) { MagnificationSpec spec = mService.mAccessibilityController.getMagnificationSpecForWindowLocked(w); if (spec != null && !spec.isNop()) { scale = spec.scale; surfaceScaled = true; } } if (surfaceScaled) { width += scale * (attrs.surfaceInsets.left + attrs.surfaceInsets.right);
<|startcomment|> A Pair with a null first here will cause an assertion error from the @NotNull on getActivityName. Let's used the declared exceptions for error messages rather than returning a Pair. <|endcomment|>  public MavenDefaultActivityLocator(@NotNull AndroidFacet facet) { myFacet = facet; } @Override public void validate(@NotNull AndroidFacet facet) throws ActivityLocatorException { // We can't validate anything before having the artifacts from the build, // so nothing much to do here.. } @NotNull @Override protected String getActivityName() throws ActivityLocatorException { <|startfocus|> return computeActivityName().getFirst(); } @NotNull private Pair<String, String> computeActivityName() throws ActivityLocatorException { <|endfocus|> File manifestCopy = null; try { Pair<File, String> pair; try { pair = AndroidRunConfigurationBase.getCopyOfCompilerManifestFile(myFacet); } catch (IOException e) { throw new ActivityLocatorException("Error while obtaining compiler manifest file", e); } manifestCopy = pair != null ? pair.getFirst() : null; VirtualFile manifestVFile = manifestCopy != null ? LocalFileSystem.getInstance().findFileByIoFile(manifestCopy) : null; final Manifest manifest =
<|startcomment|> StringUtil.isEmpty? <|endcomment|>  public CreateXmlResourcePanel(@NotNull Module module, @NotNull ResourceType resourceType, @Nullable String predefinedName, @Nullable String predefinedValue, boolean chooseName, @Nullable VirtualFile defaultFile) { this(module, resourceType, defaultFile); if (chooseName) { predefinedName = ResourceHelper.prependResourcePrefix(module, predefinedName); } <|startfocus|> if (predefinedName != null && predefinedName.length() > 0) { <|endfocus|> if (chooseName) { myNameLabel.setVisible(true); myNameField.setVisible(true); } myNameField.setText(predefinedName); } else { myNameLabel.setVisible(true); myNameField.setVisible(true); } if (predefinedValue != null && predefinedValue.length() > 0) { myValueField.setText(predefinedValue); } else { myValueLabel.setVisible(true); myValueField.setVisible(true); }
<|startcomment|> Fits on the previous line <|endcomment|>  Collections.<String>emptySet(); } /** * Implementation of the {@link SignedJarBuilder.IZipEntryFilter} contract which only * cares about copying or ignoring files since merging is handled differently. * @param archivePath the archive file path of the entry * @return true if the archive entry satisfies the filter, false otherwise. * @throws ZipAbortException */ @Override <|startfocus|> public boolean checkEntry(String archivePath) throws ZipAbortException { <|endfocus|> return apply(archivePath) != Action.IGNORE; } /** * apply the filtering logic on an abstract archive entry denoted by its path and provide * an action to be implemented for the entry. * @param archivePath the archive entry path in the archive. * @return the action to implement. */ @NonNull public Action apply(@NonNull String archivePath) { //noinspection VariableNotUsedInsideIf if (packagingOptions != null) { if (excludes.contains(archivePath)) { return Action.IGNORE; } if (pickFirsts.contains(archivePath)) {
<|startcomment|> Remove. <|endcomment|>  public void invoke(@NotNull final Project project, @Nullable final Editor editor, @Nullable PsiFile file) { if (editor != null) { if (!CodeInsightUtilBase.prepareEditorForWrite(editor)) return; } if (myModules.size() == 1) { addDependencyOnModule(project, editor, ContainerUtil.getFirstItem(myModules)); } else { final JBList list = new JBList(myModules); list.setCellRenderer(new ModuleListCellRenderer()); <|startfocus|> final JBPopup popup = JBPopupFactory.getInstance().createListPopupBuilder(list) <|endfocus|> .setTitle("Choose Module to Add Dependency on") .setMovable(false) .setResizable(false) .setRequestFocus(true) .setItemChoosenCallback(new Runnable() { @Override public void run() { final Object value = list.getSelectedValue(); if (value instanceof Module) { addDependencyOnModule(project, editor, (Module)value); } } }).createPopup(); if (editor != null) { popup.showInBestPositionFor(editor); } else { popup.showCenteredInCurrentWindow(project); } }
<|startcomment|> Any reason for extracting these names into constants (in this file and others)? I can't find any usages. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.tools.idea.editors.systeminfo; import com.android.SdkConstants; import com.android.tools.idea.profiling.capture.FileCaptureType; import com.intellij.openapi.fileEditor.FileEditor; import com.intellij.openapi.project.Project; import com.intellij.openapi.vfs.VirtualFile; import icons.AndroidIcons; import org.jetbrains.annotations.NotNull; <|startfocus|> import sun.plugin.dom.exception.InvalidStateException; <|endfocus|> public class SystemInfoCaptureType extends FileCaptureType { protected SystemInfoCaptureType() { super("System Information", AndroidIcons.Ddms.SysInfo, "SystemInfo_", SdkConstants.DOT_TXT); } @NotNull @Override public FileEditor createEditor(@NotNull Project project, @NotNull VirtualFile file) { throw new InvalidStateException("Should not ask to create an editor"); } @Override public boolean accept(VirtualFile file) { return false; } } 
<|startcomment|> Same here <|endcomment|>  public CreateXmlResourceDialog(@NotNull Module module, <|startfocus|> @NotNull ResourceType resourceType, @Nullable String predefinedName, @Nullable String predefinedValue, boolean chooseName, @Nullable VirtualFile defaultFile) { <|endfocus|> super(module.getProject()); myPanel = new CreateXmlResourcePanel(module, resourceType, predefinedName, predefinedValue, chooseName, defaultFile); init();
<|startcomment|> @NotNull <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.jetbrains.android.run; import com.android.ddmlib.Client; /** * @author coyote */ public interface DebugLauncher { <|startfocus|> void launchDebug(Client client); <|endfocus|> } 
<|startcomment|> Add another line with spacing here (and the *). This makes it such that they are on completely separate lines. <|endcomment|>  * * @param ain The source buffer * @param aout The destination buffer */ public void forEachXor(Allocation ain, Allocation aout) { forEachXor(ain, aout, null); } /** * Sets dst = {src.r ^ dst.r, src.g ^ dst.g, src.b ^ dst.b, src.a ^ dst.a} <|startfocus|> * <b>Note:</b> this is NOT the Porter/Duff XOR mode this is a bitwise xor <|endfocus|> * * @param ain The source buffer * @param aout The destination buffer * @param opt LaunchOptions for clipping */ public void forEachXor(Allocation ain, Allocation aout, Script.LaunchOptions opt) { blend(11, ain, aout, opt); } /** * Get a KernelID for the Xor kernel. * * @return Script.KernelID The KernelID object. */ public Script.KernelID getKernelIDXor() { return createKernelID(11, 3, null, null); } //////// /* public void forEachNormal(Allocation ain, Allocation aout) {
<|startcomment|> nit: it would actually be nicer to see the constant name. <|endcomment|>  Object allowed = annotation.getValue(); if (allowed instanceof Object[]) { Object[] allowedValues = (Object[]) allowed; for (Object o : allowedValues) { if (o instanceof Integer) { Integer integer = (Integer)o; if (values.contains(integer)) { String message = String.format( "More than one constant specifies the same exact value (%1$d) " + "and this is not marked as a flag", (int)integer); Node scope = getAnnotationScope(node); <|startfocus|> mContext.report(UNIQUE, scope, mContext.getLocation(node), message); <|endfocus|> break; } values.add(integer); } } }
<|startcomment|> 3.0 espresso is already at 2.2 and we plan at least 2 more releases in the 2.x branch <|endcomment|>  * be removed in the next release. */ @Deprecated public static void openDrawer(int drawerLayoutId, int gravity) { onView(withId(drawerLayoutId)).perform(open(gravity)); } /** * Creates an action which opens the {@link DrawerLayout} drawer with gravity START. This method * blocks until the drawer is fully open. No operation if the drawer is already open. */ <|startfocus|> // TODO alias to openDrawer before 1.0 and deprecate this method. <|endfocus|> public static ViewAction open() { return open(GravityCompat.START); } /** * Creates an action which opens the {@link DrawerLayout} drawer with the gravity. This method * blocks until the drawer is fully open. No operation if the drawer is already open. */ // TODO alias to openDrawer before 1.0 and deprecate this method. public static ViewAction open(final int gravity) { return new DrawerAction() { @Override public String getDescription() { return "open drawer with gravity " + gravity; } 
<|startcomment|> should this be true (assuming this is also an ideFatalError)? <|endcomment|>  Class<?> guiTestCaseType = Class.forName(GuiTestCase.class.getCanonicalName(), true, classLoader); if (guiTestCaseType.isInstance(myTest)) { if (!canRunGuiTests()) { // We don't run tests in headless environment. return; } field("myTestName").ofType(String.class).in(myTest).set(myTestMethod.getName()); } try { myTestMethod.invokeExplosively(myTest); } catch (Throwable e) { <|startfocus|> takeScreenshot(executionIndex); throw e; } } <|endfocus|> @NotNull private String getTestFqn() { return myTestMethod.getMethod().getDeclaringClass() + "#" + myTestMethod.getName(); } private void takeScreenshot(int executionIndex) { if (myTestConfigurator.shouldTakeScreenshotOnFailure()) { Method method = myTestMethod.getMethod(); String testFqn = method.getDeclaringClass().getSimpleName() + "." + (executionIndex + 1) + "." + method.getName(); String extension = ".png"; try {
<|startcomment|> We should also probably check that there was no error before we typed something. <|endcomment|>  ThemeEditorFixture themeEditor = ThemeEditorTestUtils.openThemeEditor(projectFrame); JTableFixture themeEditorTable = themeEditor.getPropertiesTable(); assertNotNull(themeEditorTable); // Cell (1,0) should be some color JTableCellFixture colorCell = themeEditorTable.cell(row(1).column(0)); // click on a color colorCell.click(); ChooseResourceDialogFixture dialog = ChooseResourceDialogFixture.find(myRobot); JTextComponentFixture name = dialog.getNameTextField(); // add mistake into name field <|startfocus|> name.enterText("("); <|endfocus|> assertNotNull(dialog.getError()); } } 
<|startcomment|> This seems an odd place to put this logic, particularly given that as an enum it's effectively static. If you had prerequisites that required context (e.g. like a CWD) then you'd have to pass it in. Wouldn't HostRuntime and/or Mode be a better place for this? <|endcomment|>  private static final String[] COMMON_DEVICE_JARS = new String[] { "conscrypt", "okhttp", "core-junit", "bouncycastle", "ext", "framework", "telephony-common", "mms-common", "framework", "android.policy", "services", "apache-xml"}; <|startfocus|> private static final String[] ART_HOST_JARS = new String[] {"core-libart-hostdex"}; private static final String[] COMMON_HOST_JARS = new String[] { <|endfocus|> "conscrypt-hostdex", "okhttp-hostdex", "bouncycastle-hostdex", }; public boolean acceptsVmArgs() { return this != ACTIVITY; } /** * Returns {@code true} if execution happens on the local machine. e.g. host-mode android or a * JVM. */ public boolean isLocal() { return isHost() || this == ModeId.JVM; } /** Returns {@code true} if execution takes place with a host-mode Android runtime */ public boolean isHost() { return this == HOST; } 
<|startcomment|> remove the else <|endcomment|>  final AttributesTableModel.ParentAttribute parent = (AttributesTableModel.ParentAttribute)contents; final ThemeEditorStyle parentStyle = model.getSelectedStyle().getParent(); if (parentStyle == null) { return null; } final JBPopupMenu menu = new JBPopupMenu(); menu.add(new AbstractAction("Edit parent") { @Override public void actionPerformed(ActionEvent e) { myGoToListener.goToParent(); } }); return menu; } <|startfocus|> else { return null; } <|endfocus|>
<|startcomment|> This line can be extracted outside the three ifs <|endcomment|>  .create(true, AppResourceRepository.getAppResources(myLocationSettings.getModule(), true), resType, true); } }); } myContentPanel.setSelectedIndex(numberOfTabs - 1); myValidator = ResourceNameValidator.create(true, AppResourceRepository.getAppResources(myModule, true), resType, true); } if (attributeName != null) { ColorSuggestor colorSuggestor; if (PRIMARY_MATERIAL.equals(attributeName)) { colorSuggestor = new PrimaryColorSuggestor(); myColorPicker.setRecentColors(colorSuggestor.suggestColor()); } <|startfocus|> else if (PRIMARY_DARK_MATERIAL.equals(attributeName)) { <|endfocus|> colorSuggestor = new PrimaryDarkColorSuggestor(primaryColor); myColorPicker.setRecentColors(colorSuggestor.suggestColor()); } else if (ACCENT_MATERIAL.equals(attributeName)) { colorSuggestor = new AccentColorSuggestor(primaryColor); myColorPicker.setRecentColors(colorSuggestor.suggestColor()); } } if (doSelection && value.startsWith("@")) { value = StringUtil.replace(value, "+", ""); int index = value.indexOf('/'); if (index != -1) {
<|startcomment|> This sounds like you're sharing actual path instances. I assume that can't actually be done.... or can it? Actually now I think probably it would be fine, if everyone stores their state in the right ScopedStateStore. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ /** * Support for wizards that allow dynamically adding multiple paths and steps (unlike the wizards * offered by IntelliJ, which require a fixed list of steps up front). * <p/> <|startfocus|> * A path is a collection collection of one or more steps, and wizards contain one or more paths. * It is possible to share paths across different wizards. <|endfocus|> * <p/> * Data is passed along the wizard from step to step via a * {@link com.android.tools.idea.wizard.dynamic.ScopedStateStore}, which is a hashtable of data, * essentially. */ package com.android.tools.idea.wizard.dynamic; 
<|startcomment|> Fits on the previous line. <|endcomment|>  */ public static <T> T record(@NonNull Project project, @NonNull ExecutionType executionType, @NonNull Recorder.Block<T> block, Recorder.Property... properties) { Recorder.Property[] mergedProperties = new Recorder.Property[properties.length + 1]; mergedProperties[0] = new Recorder.Property(PROJECT, project.getName()); System.arraycopy(properties, 0, mergedProperties, 1, properties.length); <|startfocus|> return (T) ThreadRecorder.get().record( executionType, block, mergedProperties); <|endfocus|> } } 
<|startcomment|> No need. CameraTestUtils is static imported in this file <|endcomment|>  public MaxOutputSizes(CameraCharacteristics cc, String cameraId, Context context) { StreamConfigurationMap configs = cc.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP); Size[] privSizes = configs.getOutputSizes(SurfaceTexture.class); Size[] yuvSizes = configs.getOutputSizes(ImageFormat.YUV_420_888); Size[] jpegSizes = configs.getOutputSizes(ImageFormat.JPEG); Size[] rawSizes = configs.getOutputSizes(ImageFormat.RAW_SENSOR); <|startfocus|> Size maxPreviewSize = CameraTestUtils.getPreviewSizeBound( (WindowManager) context.getSystemService(Context.WINDOW_SERVICE), PREVIEW_SIZE_BOUND); <|endfocus|> maxRawSize = (rawSizes != null) ? CameraTestUtils.getMaxSize(rawSizes) : null; maxPrivSizes[PREVIEW] = getMaxSize(privSizes, maxPreviewSize); maxYuvSizes[PREVIEW] = getMaxSize(yuvSizes, maxPreviewSize); maxJpegSizes[PREVIEW] = getMaxSize(jpegSizes, maxPreviewSize); maxPrivSizes[RECORD] = getMaxRecordingSize(cameraId); maxYuvSizes[RECORD] = getMaxRecordingSize(cameraId); maxJpegSizes[RECORD] = getMaxRecordingSize(cameraId); maxPrivSizes[MAXIMUM] = CameraTestUtils.getMaxSize(privSizes);
<|startcomment|> unnecessary <|endcomment|>  public void registerFixes(@NotNull PsiJavaCodeReferenceElement reference, @NotNull QuickFixActionRegistrar registrar) { <|startfocus|> final Module contextModule = findModuleForPsiElement(reference); <|endfocus|> if (contextModule == null) { return; } final AndroidGradleFacet gradleFacet = AndroidGradleFacet.getInstance(contextModule); if (gradleFacet == null) { return; } final PsiFile contextFile = reference.getContainingFile(); if (contextFile == null) { return; } // Since this is a gradle android project, we need to unregister: // "add module dependency fix", // "add junit to module quick fix", // "all add library to module quick fix", // since those quick fixes would make the iml file and the gradle file out of sync. registrar.unregister(new Condition<IntentionAction>() { @Override public boolean value(IntentionAction intentionAction) { return intentionAction instanceof OrderEntryFix; } }); // Currently our API doesn't address the case that gradle.build file does not exist at the module folder, so just skip for now.
<|startcomment|> CURRENT_MINOR = 0 ? <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.jayce.v0003; /** * Version. */ public class Version { public static final int MINOR_MIN = 14; <|startfocus|> public static final int CURRENT_MINOR = 15; <|endfocus|> } 
<|startcomment|> Not possible <|endcomment|>  File candidateNodeListing = AbstractTestTools.createTempFile("nodeListing", ".txt"); toolchain.addProperty(ShrinkStructurePrinter.STRUCTURE_PRINTING.getName(), "true"); toolchain.addProperty(ShrinkStructurePrinter.STRUCTURE_PRINTING_FILE.getName(), candidateNodeListing.getPath()); toolchain.addProperty(Options.METHOD_FILTER.getName(), "supported-methods"); toolchain.disableDxOptimizations(); <|startfocus|> // don't turn on optimization in this test suite to avoid failure toolchain.addProperty("jack.optimization.enum.switch", "disable-optimization"); <|endfocus|> SourceToDexComparisonTestHelper env = new SourceToDexComparisonTestHelper(new File(testFolder, "jack")); // Otherwise test10_001 cannot work with jill based toolchains env.setWithDebugInfo(true); env.setCandidateTestTools(toolchain); env.setReferenceTestTools(new DummyToolchain()); env.setWithDebugInfo(true); env.setProguardFlags(dontObfuscateFlagFile, new ProguardFlags(shrobTestsDir, "keepAllAttributes.flags"), new ProguardFlags(testFolder, "proguard.flags" + flagNumber)); env.runTest(new ComparatorMapping(new File(refFolder, "expected-" + flagNumber + ".txt"), candidateNodeListing)); } @Test
<|startcomment|> Space after cast? <|endcomment|>  } } @Nullable private InsertType performDrop(int dropAction, @Nullable Transferable transferable) { if (!(myCurrentInteraction instanceof DragDropInteraction)) { return null; } InsertType insertType = updateDropInteraction(dropAction, transferable); finishInteraction(myLastMouseX, myLastMouseY, myLastStateMask, (insertType == null)); return insertType; } @Nullable private InsertType updateDropInteraction(int dropAction, @Nullable Transferable transferable) { <|startfocus|> DragDropInteraction interaction = (DragDropInteraction)myCurrentInteraction; assert interaction != null; <|endfocus|> if (transferable == null) { return null; } DnDTransferItem item = NlModel.getTransferItem(transferable, false /* no placeholders */); if (item == null) { return null; } ScreenView screenView = mySurface.getScreenView(myLastMouseX, myLastMouseY); if (screenView == null) { return null; } NlModel model = screenView.getModel(); DragType dragType = dropAction == DnDConstants.ACTION_COPY ? DragType.COPY : DragType.MOVE;
<|startcomment|> Why not remove this code and change the following if condition. <|endcomment|>  } // make sure only one synthetic class is created every prefix JDefinedClass syntheticClass = syntheticClassMap.get(syntheticClassPackage); if (syntheticClass == null) { syntheticClass = getSyntheticClassUnderPackage(syntheticClassPackage); } if (syntheticClass != null) { // do nothing } else if (!createIfNotExist) { // if synthetic class is not found and createIfNotExist is set to false throw new AssertionError("Not found synthetic class under prefix: " + syntheticClassPackage); <|startfocus|> <|endfocus|> } GlobalFeatureMarker globalFeatureMarker = session.getMarker(GlobalFeatureMarker.class); assert globalFeatureMarker != null; SwitchEnumOptStrategy optStrategy = globalFeatureMarker.getSwitchEnumOptimizationStrategy(); SwitchEnumUsageMarker enumUsageMarker = syntheticClassPackage.getMarker( SwitchEnumUsageMarker.class); if (optStrategy == SwitchEnumOptStrategy.FEEDBACK && enumUsageMarker == null) { // feedback based optimization should set usage marker throw new AssertionError(); } boolean isOptWorth = false; Set<JDefinedEnum> usedEnumsType = Sets.newHashSet(); if (optStrategy == SwitchEnumOptStrategy.FEEDBACK) {
<|startcomment|> newline after <|endcomment|>  @Nullable StringBuilder errorLog) { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; Document document; try { db = dbf.newDocumentBuilder(); document = db.parse(new InputSource(new StringReader(xmlFileContent))); } catch (Exception e) { if (errorLog != null) { errorLog.append("Exception while parsing XML file:\n").append(e.getMessage()); } return null; } return document; <|startfocus|> } <|endfocus|> /** * Convert the input file into the VectorDrawable's XML, and then generate * a BufferedImage according to the XML content. * * The pipeline is : * SVG files or XML icons * | (conversion) * V * Original VectorDrawable's XML * | (overriden by user input) * V * Overriden VectorDrawable's XML */ @NotNull private BufferedImage getSvgImage(@NotNull String path, @NotNull StringBuilder errorLog, @NotNull SourceType sourceType) { String xmlFileContent;
<|startcomment|> tac is the prefix used to identify variable created by the three address code builder. It could be better if you can use another prefix. <|endcomment|>  private void fillSyntheticSwitchMapInitializer(@Nonnull TransformationRequest transformRequest) { assert syntheticSwitchMapInitializer.getBody() == null; // create body block JBlock bodyBlock = new JBlock(SourceInfo.UNKNOWN); JMethodBody methodBody = new JMethodBody(SourceInfo.UNKNOWN, bodyBlock); OptimizationUtil.setMethodBody(syntheticSwitchMapInitializer, methodBody); // create transformation request with this method. They will be used to create locals <|startfocus|> LocalVarCreator localVarCreator = new LocalVarCreator(syntheticSwitchMapInitializer, "tac"); <|endfocus|> /**create the outer most if-else statement * {@code * int[] switchmap = field reference to switch map * if (switchmap != null) { * return switchmap; * } * else { * switchmap = new int[enum.values().length]; * switchmap[Enum1.ordinal()] = compileTimeOrdinal1; * switchmap[Enum2.ordinal()] = compileTimeOrdinal2; * ... * return switchmap; * } * } */ // load the static field into local variable
<|startcomment|> +": " for consistency. <|endcomment|>  method.setAccessible(true); printer.println("os.system.cpu.load: " + ((Double) method.invoke(os)).doubleValue()); } catch (Throwable t) { // Best effort } } catch (Throwable e) { logger.log(Level.SEVERE, "Unexpected exception: ", e); response.setStatus(Status.INTERNAL_SERVER_ERROR); } } catch (UnsupportedEncodingException e) { logger.log(Level.SEVERE, "Unsupported charset", e); response.setStatus(Status.NOT_ACCEPTABLE); } catch (IOException e) { <|startfocus|> logger.log(Level.SEVERE, "Exception during IO: ", e); <|endfocus|> response.setStatus(Status.INTERNAL_SERVER_ERROR); }
<|startcomment|> this can be 1 line, the way it is now it kind of looks like a anon class <|endcomment|>  private void configureFilter() { if (myPanel.isAdvancedMode()) { myAttributesFilter.setFilterEnabled(false); myAttributesSorter.setRowFilter(myAttributesFilter); myAttributesSorter.setSortKeys(null); } else { mySimpleModeFilter.configure(myModel.getDefinedAttributes(), ThemeEditorUtils.isAppCompatTheme( myThemeEditorContext.getConfiguration())); myAttributesSorter.setRowFilter(mySimpleModeFilter); myAttributesSorter.setComparator(0, SIMPLE_MODE_COMPARATOR); <|startfocus|> myAttributesSorter.setSortKeys(ImmutableList.of( new RowSorter.SortKey(0, SortOrder.ASCENDING) )); <|endfocus|> }
<|startcomment|> Ditto <|endcomment|>  /** * A common interface for Android module models. */ public interface AndroidModel { /** * @return the currently selected main Android artifact produced by this Android module. * TODO: To be build-system-agnostic, eliminate the assumption of a single artifact. */ @NotNull AndroidArtifact getMainArtifact(); /** * @return the currently selected test artifact produced by this Android module. * TODO: To be build-system-agnostic, eliminate the assumption of a single selected test artifact. <|startfocus|> */ <|endfocus|> @Nullable BaseArtifact getTestArtifact(); /** * @return the default source provider. * TODO: To be build-system-agnostic, simplify source provider usage. * {@link AndroidFacet#getMainSourceProvider()} */ @NotNull SourceProvider getDefaultSourceProvider(); /** * @return the currently active (non-test) source providers for this Android module in * overlay order (meaning that later providers override earlier providers when they redefine * resources).
<|startcomment|> You can move this declaration a little bit to the top... <|endcomment|>  public void actionPerformed(ActionEvent e) { String themeName = myItem.getSourceStyle().getName(); CreateXmlResourceDialog resourceDialog = new CreateXmlResourceDialog(myContext.getCurrentContextModule(), ResourceType.STYLE, themeName, " ", false); resourceDialog.setTitle(String.format("Create Theme '%1$s' Variant", themeName)); if (!resourceDialog.showAndGet()) { return; } <|startfocus|> Module module = myContext.getCurrentContextModule(); <|endfocus|> String fileName = resourceDialog.getFileName(); List<String> dirNames = resourceDialog.getDirNames(); String resValue = resourceDialog.getValue(); String resName = resourceDialog.getResourceName(); if (!AndroidResourceUtil.createValueResource(module, resName, ResourceType.STYLE, fileName, dirNames, resValue)) { return; } PsiDocumentManager.getInstance(myContext.getProject()).commitAllDocuments();
<|startcomment|> It's probably safer to just do: if (hasUserRestriction) { clearUserRestriction } <|endcomment|>  public void finish() { <|startfocus|> if (mDisallowByPolicy) { <|endfocus|> mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent, UserManager.DISALLOW_OUTGOING_BEAM); } super.finish();
<|startcomment|> toLowerCase(Locale.US) to avoid the Turkish i problem <|endcomment|>  private static String getLanguage() { Locale locale = Locale.getDefault(); if (locale == null) { return "en-us"; } String language = locale.getLanguage(); if (language == null) { return "en-us"; } String country = locale.getCountry(); <|startfocus|> return country == null ? language.toLowerCase() : language.toLowerCase() + "-" + country.toLowerCase(); <|endfocus|>
<|startcomment|> Why not using the showDumbModeNotification instead? <|endcomment|>  allowedTypes = COLORS_ONLY; } else if (attributeName.contains("drawable") || !ThemeEditorUtils.acceptsFormat(attrDefinition, AttributeFormat.Color)) { allowedTypes = DRAWABLES_ONLY; } else { allowedTypes = COLORS_AND_DRAWABLES; } ChooseResourceDialog dialog = ThemeEditorUtils.getResourceDialog(myItem, myContext, allowedTypes); if (dialog == null) { <|startfocus|> Messages.showInfoMessage("Editing is not possible - indexing is in progress", "Error"); <|endfocus|> ColorRendererEditor.this.cancelCellEditing(); return; } final String oldValue = myItem.getSelectedValue().getValue(); dialog.setResourcePickerListener(new ChooseResourceDialog.ResourcePickerListener() { @Override public void resourceChanged(final @Nullable String resource) { myItem.getSelectedValue().setValue(resource == null ? oldValue : resource); myPreviewPanel.invalidateGraphicsRenderer(); } }); if (e.getSource() instanceof JBMenuItem) { // This has been triggered from the "Add variations" menu option so display location settings dialog.openLocationSettings(); } dialog.show(); 
<|startcomment|> Nit: the code style is to avoid space after type when doing casts (this is not implemented consistently across the code base, but it would be better to avoid new inconsistencies) <|endcomment|>  public Component getEditorComponent(JTable table, EditedStyleItem value, boolean isSelected, int row, int column) { <|startfocus|> myModel = (AttributesTableModel) table.getModel(); <|endfocus|> return super.getEditorComponent(table, value, isSelected, row, column);
<|startcomment|> I would rather delete code if it is actually unnecessary. I assume this is removed so that the failed frame is mostly silent (except for the logging). Is this a case that is expected to happen often? Should we be tearing down the entire app instead if such a condition occurs? I am not all that familiar with this camera API, nor have I seen this fail. <|endcomment|>  if (mProcessInProgress || mState != STATE_PREVIEW) { mCamera.addCallbackBuffer(data); return; } if (data == null) { return; } int expectedBytes = mPreviewSize.width * mPreviewSize.height * ImageFormat.getBitsPerPixel(ImageFormat.NV21) / 8; if (expectedBytes != data.length) { Log.e(TAG, "Mismatched size of buffer! Expected "); <|startfocus|> //mState = STATE_NO_CALLBACKS; //mCamera.setPreviewCallbackWithBuffer(null); <|endfocus|> return; } mProcessInProgress = true; if ((mFilterYuv == null) || (mPreviewSize.width != mFilterYuv.getWidth()) || (mPreviewSize.height != mFilterYuv.getHeight()) ) { mFilterYuv.reset(mPreviewSize.width, mPreviewSize.height); } mProcessInProgress = true; new ProcessPreviewDataTask().execute(data);
<|startcomment|> How big do we expect this to be? Would it be more efficient to maintain a sorted list and not sort each time we render? <|endcomment|>  public void render(HtmlWriter html) { mHtmlWriter = html; List<Instance> insts = mInstances; Collections.sort(insts, Sort.defaultInstanceCompare(mSnapshot)); <|startfocus|> int numInstancesToShow = getNumInstancesToShow(); <|endfocus|> List<Instance> shown = new ArrayList<Instance>(insts.subList(0, numInstancesToShow)); List<Instance> hidden = insts.subList(numInstancesToShow, insts.size()); final Map<Heap, Long> hiddenSizes = new HashMap<Heap, Long>(); for (Heap heap : mSnapshot.getHeaps()) { hiddenSizes.put(heap, 0l); } if (!hidden.isEmpty()) { for (Instance inst : hidden) { for (Heap heap : mSnapshot.getHeaps()) { int index = mSnapshot.getHeapIndex(heap); long size = inst.getRetainedSize(index); hiddenSizes.put(heap, hiddenSizes.get(heap) + size); } } // Add 'null' as a marker for "all the rest of the objects". shown.add(null); } 
<|startcomment|> These are tested by the first assertion in the loop for i=0 and i=Integer.SIZE-1. <|endcomment|>  public static void test_Integer_numberOfLeadingZeros() { Assert.assertEquals(Integer.numberOfLeadingZeros(0), Integer.SIZE); Assert.assertEquals(Integer.numberOfLeadingZeros(1), Integer.SIZE - 1); <|startfocus|> Assert.assertEquals(Integer.numberOfLeadingZeros(1 << (Integer.SIZE-1)), 0); <|endfocus|> for (int i = 0; i < Integer.SIZE; i++) { Assert.assertEquals(Integer.numberOfLeadingZeros(1 << i), Integer.SIZE - 1 - i); Assert.assertEquals(Integer.numberOfLeadingZeros((1 << i) | 1), Integer.SIZE - 1 - i); Assert.assertEquals(Integer.numberOfLeadingZeros(0xFFFFFFFF >>> i), i); }
<|startcomment|> extra line <|endcomment|>  protected void checkInvokeReply(ReplyPacket reply) { // Check result is 'void' Value invokeResult = reply.getNextValueAsValue(); assertNull("Expect null result value for 'void'", invokeResult); // Check exception is null. TaggedObject invokeException = reply.getNextValueAsTaggedObject(); assertEquals("Invalid exception object id", 0, invokeException.objectID); assertAllDataRead(reply); <|startfocus|> <|endfocus|>
<|startcomment|> What happens if you call after cancel? What happens if you call twice in a row? <|endcomment|>  public void finalizeCapture(@NotNull final CaptureHandle captureHandle, @Nullable FutureCallback<Capture> onCompletion, @Nullable Executor executor) { ApplicationManager.getApplication().assertIsDispatchThread(); <|startfocus|> assert captureHandle.myFileOutputStream != null; assert myAsyncWriterDelegate != null; <|endfocus|> ListenableFutureTask<Capture> task = ListenableFutureTask.create(new Callable<Capture>() { @Override public Capture call() throws Exception { ApplicationManager.getApplication().assertIsDispatchThread(); return finalizeCaptureSynchronous(captureHandle); } }); try { myAsyncWriterDelegate.queueMessage(new AsyncWriterDelegate.CloseMessage(captureHandle, task)); } catch (InterruptedException ignored) {} if (onCompletion != null) { assert executor != null; Futures.addCallback(task, onCompletion, executor); } myOpenCaptureHandles.remove(captureHandle); if (myOpenCaptureHandles.isEmpty()) { // Opportunistically shut down the asynchronous writer delegate. try { assert myAsyncWriterDelegate != null; myAsyncWriterDelegate.queueMessage(new AsyncWriterDelegate.ExitMessage(captureHandle)); } catch (InterruptedException ignored) {} myAsyncWriterDelegate = null; }
<|startcomment|> I recommend to check FEATURE_LIVE_TV. https://cs.corp.google.com/#android/cts/tests/tests/tv/src/android/media/tv/cts/Utils.java&type=cs&l=10 <|endcomment|>  */ public class LauncherAppsSingleUserTest extends BaseLauncherAppsTest { private boolean mHasLauncherApps; private boolean mRunningOnTv; @Override protected void setUp() throws Exception { super.setUp(); mHasLauncherApps = getDevice().getApiLevel() >= 21; if (mHasLauncherApps) { installTestApps(); } <|startfocus|> UiModeManager uiModeManager = (UiModeManager) getSystemService(UI_MODE_SERVICE); mRunningOnTv = uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION; <|endfocus|> } @Override protected void tearDown() throws Exception { if (mHasLauncherApps) { uninstallTestApps(); } super.tearDown(); } public void testInstallAppMainUser() throws Exception { if (!mHasLauncherApps) { return; } installApp(SIMPLE_APP_APK); try { int serialNumber = getUserSerialNumber(0); assertTrue(runDeviceTests(LAUNCHER_TESTS_PKG, LAUNCHER_TESTS_CLASS, "testSimpleAppInstalledForUser", 0, "-e testUser " + serialNumber)); } finally { getDevice().uninstallPackage(SIMPLE_APP_PKG); } } 
<|startcomment|> add //$NON-NLS-1$ for all constants that should not be localized similar to other detectors. <|endcomment|>  * <p/> * First detects if the app is a TV app, then scans for issues. */ public class TVDetector extends ResourceXmlDetector implements Detector.XmlScanner { private static final Implementation IMPLEMENTATION = new Implementation( TVDetector.class, Scope.MANIFEST_SCOPE); private static final String LEANBACK_LIB_ARTIFACT = "com.android.support:leanback-v17"; private static final String CATEGORY_LEANBACK_LAUNCHER = "android.intent.category.LEANBACK_LAUNCHER"; // Features <|startfocus|> private static final String HARDWARE_FEATURE_TOUCHSCREEN = "android.hardware.touchscreen"; <|endfocus|> private static final String HARDWARE_FEATURE_FAKETOUCH = "android.hardware.faketouch"; private static final String HARDWARE_FEATURE_TELEPHONY = "android.hardware.telephony"; private static final String HARDWARE_FEATURE_CAMERA = "android.hardware.camera"; private static final String HARDWARE_FEATURE_BLUETOOTH = "android.hardware.bluetooth"; private static final String HARDWARE_FEATURE_BLUETOOTHLE = "android.hardware.bluetooth_le"; private static final String HARDWARE_FEATURE_NFC = "android.hardware.nfc"; private static final String HARDWARE_FEATURE_LOCATION = "android.hardware.location";
<|startcomment|> probably the 200's should a constant? or at least perhaps the logic should be in a small helper instead of cut/paste <|endcomment|>  link.append("(null)"); return link; } // Annotate classes as classes. if (inst instanceof ClassObj) { link.append("class "); } link.append(inst.toString()); // Annotate Strings with their values. String stringValue = InstanceUtils.asString(inst); if (stringValue != null) { <|startfocus|> boolean isLong = stringValue.length() > 200; link.append("\"%.200s%s", stringValue, isLong ? "..." : "\""); <|endfocus|> } // Annotate DexCache with its location. String dexCacheLocation = InstanceUtils.getDexCacheLocation(inst); if (dexCacheLocation != null) { boolean isLong = dexCacheLocation.length() > 200; link.append(" for %.200s%s", dexCacheLocation, isLong ? "..." : "\""); } URI objTarget = DocString.uri("object?id=%d", inst.getId()); DocString formatted = DocString.link(objTarget, link); // Annotate bitmaps with a thumbnail. Instance bitmap = InstanceUtils.getAssociatedBitmapInstance(inst);
<|startcomment|> Worth documenting this more clearly. e.g. Calculates the numeric value (6-bit, 0 >= x >= 63) of the next Base64 encoded byte in {@code in} at or after {@code pos[0]} and before {@code inLength}. Returns {@link #WHITESPACE_AS_BYTE}, {@link #PAD_AS_BYTE}, {@link #END_OF_INPUT} or the 6-bit value. {@code pos[0]} is updated as a side effect of this method. <|endcomment|>  } catch (InvalidBase64ByteException e) { return null; } } /** * On decoding, an illegal character always return null. * * Using this exception to avoid "if" checks every time. */ private static class InvalidBase64ByteException extends Exception { } /** * Skips whitespace. Returns 0 on end of string. */ private static byte getNextByte(byte[] in, int[] pos, int inLength) throws InvalidBase64ByteException { <|startfocus|> byte c = 0; <|endfocus|> // Ignore all whitespace. while (pos[0] < inLength && (c = base64AlphabetToNumericalValue(in[pos[0]])) == WHITESPACE_AS_BYTE) { pos[0]++; } return c; } private static byte[] checkNoTrailingAndReturn( ByteArrayOutputStream output, byte[] in, int i, int inLength) throws InvalidBase64ByteException{ // Allow only whitespace bytes after the padding. byte c; while (i < inLength && ((c = base64AlphabetToNumericalValue(in[i])) == WHITESPACE_AS_BYTE
<|startcomment|> AOSP contributions are usually required to use "The Android Open Source Project" in their copyright line (this also applies to all other .java files in this CL). See https://source.android.com/source/code-style.html. If you insist on keeping the current copyright line, I can find out whether that's permitted. <|endcomment|> <|startfocus|> * Copyright (C) 2015 The MITRE Corporation <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.tools.lint.checks; import java.util.List; import org.objectweb.asm.Opcodes; import org.objectweb.asm.tree.AbstractInsnNode; import org.objectweb.asm.tree.ClassNode; import org.objectweb.asm.tree.InsnList; import org.objectweb.asm.tree.MethodNode; import com.android.annotations.NonNull; import com.android.tools.lint.detector.api.Category; import com.android.tools.lint.detector.api.ClassContext;
<|startcomment|> I wonder whether "withDeletedExtension" or "copyWithDeletedExtension" is a better name given the semantics... <|endcomment|> <|startfocus|> public OpenSSLX509Certificate deleteExtension(String oid) { <|endfocus|> long copy = NativeCrypto.X509_dup(mContext); NativeCrypto.X509_delete_ext(copy, oid); return new OpenSSLX509Certificate(copy);
<|startcomment|> sections ? <|endcomment|>  */ abstract class IdMerger<T extends Comparable<T>> { private final Dex.Section out; protected IdMerger(Dex.Section out) { this.out = out; } /** * Merges already-sorted sections, reading one value from each dex into memory * at a time. */ public final void mergeSorted() { TableOfContents.Section[] sections = new TableOfContents.Section[dexes.length]; <|startfocus|> Dex.Section[] in = new Dex.Section[dexes.length]; <|endfocus|> int[] offsets = new int[dexes.length]; int[] indexes = new int[dexes.length]; // values contains one value from each dex, sorted for fast retrieval of the smallest // value. The list associated with a value has the indexes of the dexes that had that value. // One a value is extracted, all the dexes associated with it are re-read. TreeMap<T, List<Integer>> values = new TreeMap<T, List<Integer>>(); for (int i = 0; i < dexes.length; i++) {
<|startcomment|> we should rather move this call before the if to avoid dupliated code. <|endcomment|>  if (getChildAtPosition(ev.getX(), y) == null) { setIsBeingDragged(false); recycleVelocityTracker(); mScrolledToTopOnFirstDown = isScrolledToTop(); break; } /* * Remember location of down touch. * ACTION_DOWN always refers to pointer index 0. */ mLastMotionY = y; mDownX = (int) ev.getX(); mActivePointerId = ev.getPointerId(0); <|startfocus|> mScrolledToTopOnFirstDown = isScrolledToTop(); <|endfocus|> initOrResetVelocityTracker(); mVelocityTracker.addMovement(ev); /* * If being flinged and user touches the screen, initiate drag; * otherwise don't. mScroller.isFinished should be false when * being flinged. */ boolean isBeingDragged = !mScroller.isFinished(); setIsBeingDragged(isBeingDragged); break; } case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: /* Release the drag */ setIsBeingDragged(false); mActivePointerId = INVALID_POINTER; recycleVelocityTracker();
<|startcomment|> A random red pixel in the middle of a large solid blue image should still fail. I don't think this tolerance is correct. <|endcomment|>  final int db = (((p1 & 0x00FF0000) >> 16)*a1 - ((p2 & 0x00FF0000) >> 16)*a2)/0xFF; if (Math.abs(db) > threshold || Math.abs(dg) > threshold || Math.abs(dr) > threshold) { diffs++; } } } <|startfocus|> if (diffs > tolerance) { return false; } <|endfocus|> return true;
<|startcomment|> This does not sound right. "Country" codes are valid if they are alpha2 or digit3, not alpha3. See http://www.rfc-editor.org/rfc/bcp/bcp47.txt and http://www.unicode.org/reports/tr35/tr35.html#unicode_region_subtag <|endcomment|>  if (hasValidatedFields) { this.languageCode = adjustLanguageCode(language); this.countryCode = country; this.variantCode = variant; } else { if (language.isEmpty() && country.isEmpty()) { languageCode = ""; countryCode = ""; variantCode = variant; } else { languageCode = adjustLanguageCode(language); countryCode = country.toUpperCase(Locale.US); variantCode = variant; } } <|startfocus|> validCountry = isValidBcp47Alpha(country, 2, 3) || country.length() == 0; <|endfocus|> this.scriptCode = scriptCode; if (hasValidatedFields) { Set<String> attribsCopy = new TreeSet<String>(unicodeAttributes); Map<String, String> keywordsCopy = new TreeMap<String, String>(unicodeKeywords); Map<Character, String> extensionsCopy = new TreeMap<Character, String>(extensions); // We need to transform the list of attributes & keywords set on the // builder to a unicode locale extension. i.e, if we have any keywords // or attributes set, Locale#getExtension('u') should return a well
<|startcomment|> Same as below. <|endcomment|>  * limitations under the License. */ public class Main { public static int $inline$method() { return 5; } /// CHECK-START: int Main.p(int) dead_code_elimination_final (before) /// CHECK-DAG: PackedSwitch /// CHECK-START: int Main.p(int) dead_code_elimination_final (after) /// CHECK-DAG: <<Const100:i\d+>> IntConstant 100 /// CHECK-NOT: PackedSwitch /// CHECK-DAG: Return [<<Const100>>] <|startfocus|> public static int p(int j) { <|endfocus|> int i = $inline$method(); int l = 100; if (i > 100) { switch(j) { case 1: i++; break; case 2: i = 99; break; case 3: i = 100; break; case 4: i = -100; break; case 5: i = 7; break; case 6: i = -9; break; } l += i; } return l; } 
<|startcomment|> use @KnownIssue to eventually be able to pass it outside PreSubimitTests ? <|endcomment|>  new RuntimeTestHelper(DEFAULTMETHOD011) .setSourceLevel(SourceLevel.JAVA_8) .compileAndRunTest(); } @Test public void testDefaultMethod012() throws Exception { new RuntimeTestHelper(DEFAULTMETHOD012) .setSourceLevel(SourceLevel.JAVA_8) .compileAndRunTest(); } @Test public void testDefaultMethod013() throws Exception { new RuntimeTestHelper(DEFAULTMETHOD013) .setSourceLevel(SourceLevel.JAVA_8) .compileAndRunTest(); } @Test @Ignore("Runtime failures") public void testDefaultMethod014() throws Exception { <|startfocus|> new RuntimeTestHelper(DEFAULTMETHOD014) .setSourceLevel(SourceLevel.JAVA_8) .compileAndRunTest(); <|endfocus|> } @Test public void testDefaultMethod015() throws Exception { new RuntimeTestHelper(DEFAULTMETHOD015) .setSourceLevel(SourceLevel.JAVA_8) .compileAndRunTest(); } } 
<|startcomment|> Think the "& 0xff" here and on the line below is unnecessary because the cast will only take the bottom 8 bits anyway. <|endcomment|>  * * <p>- the remainder of the buffer contains the modified-utf8 output (equivalent to * {@code encode(buf, 2, s)}). */ public static byte[] encode(String s) throws UTFDataFormatException { long size = countBytes(s, true); byte[] output = new byte[(int) size + 2]; encode(output, 2, s); <|startfocus|> output[0] = (byte) ((size >>> 8) & 0xff); output[1] = (byte) (size & 0xff); <|endfocus|> return output; } /** * Decodes {@code length} utf-8 bytes from {@code in} starting at offset {@code offset} to * {@code out}, * * <p>A maximum of {@code length} chars are written to the output starting at offset 0. * {@out} is assumed to have enough space for the output (a standard * {@code ArrayIndexOutOfBoundsException} is thrown otherwise). * * <p>If a 0 byte is encountered, it is converted to U+0000.
<|startcomment|> naming: Using ALL_CAPS is a bit misleading as these are not constants but "plain" fields initialized during setUp. <|endcomment|> import javax.net.ssl.HandshakeCompletedListener; import javax.net.ssl.KeyManager; import javax.net.ssl.TrustManager; import javax.net.ssl.KeyManagerFactory; import javax.net.ssl.TrustManagerFactory; import javax.net.ssl.SSLHandshakeException; import static org.conscrypt.TestUtils.openTestFile; import static org.conscrypt.TestUtils.readTestFile; public class OpenSSLSocketImplTest extends TestCase { private static final long TIMEOUT_SECONDS = 5; private X509Certificate CA; private X509Certificate CERT; private X509Certificate CERT_EMBEDDED; private PrivateKey CERT_KEY; private CTVerifier CT_VERIFIER; <|startfocus|> private Field CONTEXT_SSL_PARAMETERS; <|endfocus|> @Override public void setUp() throws Exception { CONTEXT_SSL_PARAMETERS = OpenSSLContextImpl.class.getDeclaredField("sslParameters"); CONTEXT_SSL_PARAMETERS.setAccessible(true); CA = OpenSSLX509Certificate.fromX509PemInputStream(openTestFile("ca-cert.pem")); CERT = OpenSSLX509Certificate.fromX509PemInputStream(openTestFile("cert.pem")); CERT_EMBEDDED = OpenSSLX509Certificate.fromX509PemInputStream( openTestFile("cert-ct-embedded.pem")); CERT_KEY = OpenSSLKey.fromPrivateKeyPemInputStream(
<|startcomment|> "Debug info not available (imported)" or something with "not available"? <|endcomment|>  public void annotateTo(DexFile file, AnnotatedOutput out, String prefix) { <|startfocus|> out.annotate(" (debug info was imported)"); <|endfocus|>
<|startcomment|> (i != 0) || !one.isClosure() ? <|endcomment|>  int wordCount = wordCount(orig); int sz = orig.size(); if (wordCount == sz) { return orig; } RegisterSpecList result = new RegisterSpecList(wordCount); int wordAt = 0; for (int i = 0; i < sz; i++) { RegisterSpec one = orig.get(i); result.set(wordAt, one); <|startfocus|> if (one.getCategory() == 2 && ((i == 0 && !one.isClosure()) || (i != 0))) { <|endfocus|> result.set(wordAt + 1, RegisterSpec.make(one.getReg() + 1, Type.VOID)); wordAt += 2; } else { wordAt++; } } result.setImmutable(); return result;
<|startcomment|> If we have two calls, we would need to waitForMessage or better two tests. I think one is enough, using testAllocation1 and testAllocation2. <|endcomment|>  public void run() { RenderScript pRS = RenderScript.create(mCtx); ScriptC_single_source_script s = new ScriptC_single_source_script(pRS); pRS.setMessageHandler(mRsMessage); initializeGlobals(pRS, s); s.invoke_entrypoint(testAllocation1, testAllocation2); <|startfocus|> s.invoke_entrypoint(testAllocation1, testAllocation1); <|endfocus|> pRS.finish(); waitForMessage(); pRS.destroy();
<|startcomment|> This is missing PTP. <|endcomment|>  getText(R.string.usb_use_photo_transfers), getText(R.string.usb_use_MIDI)}; mFunctions = new String[] { null, UsbManager.USB_FUNCTION_MTP, UsbManager.USB_FUNCTION_PTP, UsbManager.USB_FUNCTION_MIDI }; } else { items = new CharSequence[] { <|startfocus|> getText(R.string.usb_use_charging_only), getText(R.string.usb_use_file_transfers) }; mFunctions = new String[] { null, UsbManager.USB_FUNCTION_MTP }; <|endfocus|> } } final AlertDialog levelDialog; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(R.string.usb_use); builder.setSingleChoiceItems(items, getCurrentFunction(), new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { if (!ActivityManager.isUserAMonkey()) { setCurrentFunction(which); } dialog.dismiss(); UsbModeChooserActivity.this.finish(); } }); builder.setOnDismissListener(new DialogInterface.OnDismissListener() { @Override public void onDismiss(DialogInterface dialog) { UsbModeChooserActivity.this.finish();
<|startcomment|> Missing space between ) and cert. <|endcomment|>  Collection<? extends Certificate> certs; InputStream in = null; try { CertificateFactory factory = CertificateFactory.getInstance("X.509"); in = mContext.getResources().openRawResource(mResourceId); certs = factory.generateCertificates(in); } catch (CertificateException e) { throw new RuntimeException("Failed to load trust anchors", e); } finally { IoUtils.closeQuietly(in); } for (Certificate cert : certs) { <|startfocus|> if (cert instanceof X509Certificate) { certificates.add((X509Certificate)cert); } <|endfocus|> } mCertificates = certificates; return mCertificates; }
<|startcomment|> Domain isn't a rule. Suggestion: Whether this domain includes subdomains. <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.security.net.config; import java.util.Locale; /** @hide */ public final class Domain { /** * The lower case hostname for this domain rule. */ public final String hostname; /** <|startfocus|> * If this rule matches subdomains of hostname and not just exact hostname match. <|endfocus|> */ public final boolean subdomainsIncluded; public Domain(String hostname, boolean subdomainsIncluded) { if (hostname == null) { throw new NullPointerException("Hostname must not be null"); } this.hostname = hostname.toLowerCase(Locale.US); this.subdomainsIncluded = subdomainsIncluded; } @Override public int hashCode() { return hostname.hashCode() ^ (subdomainsIncluded ? 1231 : 1237); } @Override public boolean equals(Object other) { if (other == this) { return true; } if (!(other instanceof Domain)) { return false; }
<|startcomment|> More concise alternative: Creates a Runner for JUnit 3 or JUnit 4 tests. <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package vogar.target.junit; import com.google.common.annotations.VisibleForTesting; import java.util.concurrent.atomic.AtomicReference; import javax.annotation.Nullable; import vogar.monitor.TargetMonitor; import vogar.target.Runner; import vogar.target.RunnerFactory; import vogar.target.TestEnvironment; /** <|startfocus|> * Supports treating a class as containing JUnit 3 or JUnit 4 tests. <|endfocus|> */ public class JUnitRunnerFactory implements RunnerFactory { @Override @Nullable public Runner newRunner( TargetMonitor monitor, String actionName, String qualification, Class<?> klass, AtomicReference<String> skipPastReference, TestEnvironment testEnvironment, int timeoutSeconds, boolean profile) { if (supports(klass)) { return new JUnitRunner( monitor, actionName, qualification, klass, skipPastReference, testEnvironment, timeoutSeconds); } else { return null; } } @VisibleForTesting boolean supports(Class<?> klass) {
<|startcomment|> Suggestion: Move this check before seenPinSet. If it's base-config, it doesn't matter whether you've seen a pin-set yet or not. <|endcomment|>  XmlResourceParser parser, Set<String> seenDomains, NetworkSecurityConfig.Builder parentBuilder, int configType) throws IOException, XmlPullParserException, ParserException { List<Pair<NetworkSecurityConfig.Builder, Set<Domain>>> builders = new ArrayList<>(); NetworkSecurityConfig.Builder builder = new NetworkSecurityConfig.Builder(); builder.setParent(parentBuilder); Set<Domain> domains = new ArraySet<>(); boolean seenPinSet = false; <|startfocus|> boolean seenTrustAnchors = false; <|endfocus|> String configName = parser.getName(); int outerDepth = parser.getDepth(); // Add this builder now so that this builder occurs before any of its children. This // makes the final build pass easier. builders.add(new Pair<>(builder, domains)); // Parse config attributes. Only set values that are present, config inheritence will // handle the rest. for (int i = 0; i < parser.getAttributeCount(); i++) { String name = parser.getAttributeName(i); if ("hstsEnforced".equals(name)) { builder.setHstsEnforced( parser.getAttributeBooleanValue(i, NetworkSecurityConfig.DEFAULT_HSTS_ENFORCED));
<|startcomment|> Add a comma after "TrustAnchors" and after "without" for readability. <|endcomment|>  public Set<TrustAnchor> getTrustAnchors() { synchronized (mAnchorsLock) { if (mAnchors != null) { return mAnchors; } // Merge trust anchors based on the X509Certificate. <|startfocus|> // If we see the same certificate in two TrustAnchors one with overridesPins and one // without the one with overridesPins must take precedence. <|endfocus|> Map<X509Certificate, TrustAnchor> anchorMap = new ArrayMap<>(); for (CertificatesEntryRef ref : mCertificatesEntryRefs) { Set<TrustAnchor> anchors = ref.getTrustAnchors(); for (TrustAnchor anchor : anchors) { if (anchor.overridesPins) { anchorMap.put(anchor.certificate, anchor); } else if (!anchorMap.containsKey(anchor.certificate)) { anchorMap.put(anchor.certificate, anchor); } } } ArraySet<TrustAnchor> anchors = new ArraySet<TrustAnchor>(anchorMap.size()); anchors.addAll(anchorMap.values()); mAnchors = anchors; return mAnchors; }
<|startcomment|> ditto <|endcomment|>  public static double Div2(double arg) { <|startfocus|> if (doThrow) { // Try to defeat inlining. throw new Error(); } <|endfocus|> return arg / 2.0;
<|startcomment|> this should be 'else {' <|endcomment|>  mRecordsToLoad++; } break; case READ_SPN_SHORT_CPHS: if (ar != null && ar.exception == null) { data = (byte[]) ar.result; final String spn = IccUtils.adnStringFieldToString(data, 0, data.length); setServiceProviderName(spn); if (spn == null || spn.length() == 0) { if (DBG) log("No SPN loaded in either CHPS or 3GPP"); <|startfocus|> } if (spn != null) { <|endfocus|> // Display CPHS Operator Name only when not roaming mSpnDisplayCondition = 2; if (DBG) log("Load EF_SPN_SHORT_CPHS: " + spn); mTelephonyManager.setSimOperatorNameForPhone( mParentApp.getPhoneId(), spn); } } else { setServiceProviderName(null); if (DBG) log("No SPN loaded in either CHPS or 3GPP"); } mSpnState = GetSpnFsmState.IDLE; break; default: mSpnState = GetSpnFsmState.IDLE; }
<|startcomment|> end with full stop. please also use a 4 char indent. <|endcomment|>  // Add path to libraries in apk for current abi if (mApplicationInfo.primaryCpuAbi != null) { for (String apk : apkPaths) { libPaths.add(apk + "!/lib/" + mApplicationInfo.primaryCpuAbi); } } if (mApplicationInfo.isSystemApp()) { <|startfocus|> // Add path to system libraries to libPaths; // Access to system libs should be limited // to bundled applications libPaths.add(System.getProperty("java.library.path")); <|endfocus|> } final String lib = TextUtils.join(File.pathSeparator, libPaths); /* * With all the combination done (if necessary, actually * create the class loader. */ if (ActivityThread.localLOGV) Slog.v(ActivityThread.TAG, "Class path: " + zip + ", JNI path: " + lib); // Temporarily disable logging of disk reads on the Looper thread // as this is early and necessary. StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,
<|startcomment|> Suggestion: Rename to getConfigSource which returns a ConfigSource. Combined with dropping mInitialized, this will lead to neater and more obviously concurrency-safe code in getDefaultConfig and getPerDomainConfigs. <|endcomment|>  private void ensureInitialized() { synchronized (mLock) { <|startfocus|> if (mInitialized) { return; <|endfocus|> } ApplicationInfo info; try { info = mContext.getPackageManager().getApplicationInfo(mContext.getPackageName(), PackageManager.GET_META_DATA); } catch (PackageManager.NameNotFoundException e) { throw new RuntimeException("Failed to look up ApplicationInfo", e); } int configResourceId = 0; if (info != null && info.metaData != null) { configResourceId = info.metaData.getInt(META_DATA_NETWORK_SECURITY_CONFIG); } ConfigSource source; if (configResourceId != 0) { boolean debugBuild = (info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0; if (DBG) { Log.d(LOG_TAG, "Using Network Security Config from resource " + mContext.getResources().getResourceEntryName(configResourceId) + " debugBuild: " + debugBuild); } source = new XmlConfigSource(mContext, configResourceId, debugBuild); } else { if (DBG) {
<|startcomment|> * Drop true -- this expression can be empty just fine. * It might be better to reorder isCaRemoved and file exists checks. This will make it easier to see the loop's termination condition. * Use index >= 0 as the termination expression. In theory, this could overflow... <|endcomment|>  private X509Certificate findCert(X500Principal subj, CertSelector selector) { String hash = getHash(subj); for (int index = 0; true; index++) { String fileName = hash + "." + index; <|startfocus|> if (isCaRemoved(fileName)) { continue; } if (!new File(mCaDir, fileName).exists()) { <|endfocus|> break; } X509Certificate cert = readCertificate(fileName); if (selector.match(cert)) { return cert; } } return null;
<|startcomment|> nit: update the comment to reflect the change. <|endcomment|>  if (i < WIFI_SCAN_TEST_ITERATIONS - 1) { // Wait before running next iteration. Thread.sleep(WIFI_SCAN_TEST_INTERVAL_MILLIS); } } } // Return true if location is enabled. private boolean isLocationEnabled() { return Settings.Secure.getInt(getContext().getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF) != Settings.Secure.LOCATION_MODE_OFF; } <|startfocus|> // Returns true if the device has location feature. <|endfocus|> private boolean hasLocationFeature() { return getContext().getPackageManager() .hasSystemFeature(PackageManager.FEATURE_LOCATION_NETWORK); } /** * test point of wifiManager NetWork: * 1.add NetWork * 2.update NetWork * 3.remove NetWork * 4.enable NetWork * 5.disable NetWork * 6.configured Networks * 7.save configure; */ public void testWifiManagerNetWork() throws Exception { if (!WifiFeature.isWifiSupported(getContext())) { // skip the test if WiFi is not supported return; } 
<|startcomment|> Move between iFields and sFields. That's the order that the class linker will assign and also the order you have in art/runtime/mirror/class.h . <|endcomment|>  * appended. For abstract classes, methods may be created in the vtable that aren't in * virtual_ methods_ for miranda methods. */ private transient Object vtable; /** Short-cut to dexCache.strings */ private transient long dexCacheStrings; /** access flags; low 16 bits are defined by VM spec */ private transient int accessFlags; <|startfocus|> /** All methods with this class as the base for virtual dispatch. */ private transient long methods; <|endfocus|> /** * Instance fields. These describe the layout of the contents of an Object. Note that only the * fields directly declared by this class are listed in iFields; fields declared by a * superclass are listed in the superclass's Class.iFields. * * All instance fields that refer to objects are guaranteed to be at the beginning of the field * list. {@link Class#numReferenceInstanceFields} specifies the number of reference fields. */ private transient long iFields; /** Static fields */ private transient long sFields; 
<|startcomment|> * Returns {@code true} ... * {@hostname} -> {@code hostname}. <|endcomment|>  * if all configurations permit cleartext traffic, to check if cleartext is permitted for * connections to a specific host use {@link #isCleartextTrafficPermitted(String)}. */ public boolean isCleartextTrafficPermitted() { for (Pair<Domain, NetworkSecurityConfig> entry : mConfigs) { if (!entry.second.isCleartextTrafficPermitted()) { return false; } } return mDefaultConfig.isCleartextTrafficPermitted(); } /** <|startfocus|> * Returns if cleartext traffic is permitted for this application when connecting to * {@hostname}. <|endfocus|> */ public boolean isCleartextTrafficPermitted(String hostname) { return getConfigForHostname(hostname).isCleartextTrafficPermitted(); } private void ensureInitialized() { synchronized(mLock) { if (mInitialized) { return; } mConfigs = mConfigSource.getPerDomainConfigs(); mDefaultConfig = mConfigSource.getDefaultConfig(); mConfigSource = null; mTrustManager = new RootTrustManager(this); mInitialized = true; } } public static void setDefaultInstance(ApplicationConfig config) { synchronized (sLock) { sInstance = config; }
<|startcomment|> Get the Stride of the raw data associated with this 2D allocation. <|endcomment|>  mByteBufferStride = xBytesSize; return bBuffer; } // Create a new ByteBuffer if it is not initialized or using IO_INPUT. if (mByteBuffer == null || (mUsage & USAGE_IO_INPUT) != 0) { mByteBuffer = mRS.nAllocationGetByteBuffer(getID(mRS), xBytesSize, mType.getY(), mType.getZ()); } return mByteBuffer; } /** * @hide <|startfocus|> * Get the Stride of raw data associated with Allocation. <|endfocus|> */ public long getStride() { if (mByteBufferStride ==0) { if (mRS.getDispatchAPILevel() > 21) { mByteBufferStride = mRS.nAllocationGetStride(getID(mRS)); } else { mByteBufferStride = mType.getX() * mType.getElement().getBytesSize(); } } return mByteBufferStride; } /** * Receive the latest input into the Allocation. This operation * is only valid if {@link #USAGE_IO_INPUT} is set on the Allocation. * */
<|startcomment|> Idem <|endcomment|>  TestsProperties.getProperty(LEGACY_COMPILER_KEY); String runtimeList = printProperty(RUNTIME_LIST_KEY); if (runtimes.size() == 0) { System.err.println( "WARNING: no runtime has been provided"); } else { for (String runtimeName : listSplitter.split(runtimeList)) { printProperty(RUNTIME_LOCATION_PREFIX + runtimeName); } } String legacyCompiler = printProperty(LEGACY_COMPILER_KEY); if (!legacyCompiler.equals("")) { <|startfocus|> System.out.println(getReferenceCompilerVersion()); <|endfocus|> } 
<|startcomment|> Always check assert statement <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.transformations.assertion; import com.android.sched.item.Description; import com.android.sched.item.Feature; import com.android.sched.item.Name; /** * Feature used to indicate if assertion policy is always enabled. */ @Name("EnabledAssertionFeature") <|startfocus|> @Description("Feature always turning on assertion") <|endfocus|> public class EnabledAssertionFeature implements Feature { } 
<|startcomment|> ditto. <|endcomment|>  public static Client[] findAllClients(IDevice device) { if (device.hasClients()) { return device.getClients(); } <|startfocus|> WaitForClients wfc = new WaitForClients(device, 10000); <|endfocus|> return wfc.get();
<|startcomment|> Can you please remove these annotations? <|endcomment|>  protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); try { <|startfocus|> /* SPRD: Add for runtime permission bug @{ */ <|endfocus|> PackageManager pm = getPackageManager(); PackageInfo packageInfo = pm.getPackageInfo( getApplicationInfo().packageName, PackageManager.GET_PERMISSIONS); if (packageInfo.requestedPermissions != null) { for (String permission : packageInfo.requestedPermissions) { try { PermissionInfo info = pm.getPermissionInfo(permission, 0); if ((info.protectionLevel & PermissionInfo.PROTECTION_DANGEROUS) == 0) { continue; } } catch (NameNotFoundException e) { Log.v(TAG, "Checking permissions for: " + permission + "not found"); continue; } Log.v(TAG, "Checking permissions for: " + permission); /* @} */ if (checkSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) { requestPermissions(packageInfo.requestedPermissions, CTS_VERIFIER_PERMISSION_REQUEST); return; } } } createContinue(); } catch (NameNotFoundException e) {
<|startcomment|> fail here ? <|endcomment|>  public static void main(String[] args) { try { String.class.getDeclaredField("value"); <|startfocus|> } catch (Exception e) { <|endfocus|> // Ignore... }
<|startcomment|> OOB? (And likewise below.) <|endcomment|>  expectEquals(x[i], i); expectEquals(y[i], i); } // Null deopt on x. z = 0; reset(x, y); try { init(null, y, 0, 100, 0, 100); } catch (NullPointerException e) { z = 1; } expectEquals(z, 1); for (int i = 0; i < 100; i++) { expectEquals(x[i], 0); expectEquals(y[i], 0); } <|startfocus|> // Lower OOO on x. <|endfocus|> z = 0; reset(x, y); try { init(x, y, -1, 100, 0, 100); } catch (ArrayIndexOutOfBoundsException e) { z = 1; } expectEquals(z, 1); for (int i = 0; i < 100; i++) { expectEquals(x[i], 0); expectEquals(y[i], 0); } // Upper OOO on x. z = 0; reset(x, y); try { init(x, y, 0, 101, 0, 100);
<|startcomment|> Ditto? <|endcomment|>  public static int testFalseBranch(int x, int y) { int z; if (inlineFalse()) { z = x + y; } else { z = x - y; <|startfocus|> System.nanoTime(); // prevent simplification to HSelect <|endfocus|> } return z;
<|startcomment|> shouldn't it be " <message/>\n" ? <|endcomment|>  escape(sb, record.getSourceMethodName()); sb.append("</method>\n"); } sb.append(" <thread>"); sb.append(record.getThreadID()); sb.append("</thread>\n"); if (record.getMessage() != null) { // Format the message string and its accompanying parameters. String message = formatMessage(record); sb.append(" <message>"); escape(sb, message); sb.append("</message>"); sb.append("\n"); } else { <|startfocus|> sb.append("<message/>"); <|endfocus|> } // If the message is being localized, output the key, resource // bundle name, and params. ResourceBundle bundle = record.getResourceBundle(); try { if (bundle != null && bundle.getString(record.getMessage()) != null) { sb.append(" <key>"); escape(sb, record.getMessage()); sb.append("</key>\n"); sb.append(" <catalog>"); escape(sb, record.getResourceBundleName()); sb.append("</catalog>\n"); } } catch (Exception ex) {
<|startcomment|> I, personally, like tests that also execute all the methods. <|endcomment|> <|startfocus|> public static void main(String[] args) { <|endfocus|>
<|startcomment|> Line looks too long. <|endcomment|>  String[] tokenizedTransformation, NeedToSet type, Provider.Service service) throws InvalidKeyException, InvalidAlgorithmParameterException { try { /* * Check to see if the Cipher even supports the attributes before * trying to instantiate it. */ if (!matchAttribute(service, ATTRIBUTE_MODES, tokenizedTransformation[1]) || !matchAttribute(service, ATTRIBUTE_PADDINGS, tokenizedTransformation[2])) { return null; } <|startfocus|> CipherSpiAndProvider sap = new CipherSpiAndProvider((CipherSpi) service.newInstance(null), service.getProvider()); <|endfocus|> if (sap.cipherSpi == null || sap.provider == null) { return null; } CipherSpi spi = sap.cipherSpi; if (((type == NeedToSet.MODE) || (type == NeedToSet.BOTH)) && (tokenizedTransformation[1] != null)) { spi.engineSetMode(tokenizedTransformation[1]); } if (((type == NeedToSet.PADDING) || (type == NeedToSet.BOTH)) && (tokenizedTransformation[2] != null)) { spi.engineSetPadding(tokenizedTransformation[2]); } if (initParams != null) {
<|startcomment|> Can you elaborate why we change from mAlarmManager.set() to mAlarmManager.setRepeating()? What's the issue with existing implementation? <|endcomment|>  String state; if (enabled) state = "enabled"; else state = "disabled"; logd("setScanAlarm " + state + " defaultperiod " + mDefaultFrameworkScanIntervalMs); } if (enabled == mAlarmEnabled) return; if (enabled) { /* Set RTC_WAKEUP alarms if PNO is not supported - because no one is */ /* going to wake up the host processor to look for access points */ mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + mDefaultFrameworkScanIntervalMs, <|startfocus|> mDefaultFrameworkScanIntervalMs, <|endfocus|> mScanIntent); mAlarmEnabled = true; } else { mAlarmManager.cancel(mScanIntent); mAlarmEnabled = false; }
<|startcomment|> nit: No dot here, I think. <|endcomment|>  serviceLoader = ServiceLoader.load(JackProvider.class, classLoader); } else { serviceLoader = ServiceLoader.load(JackProvider.class); } configProvider = serviceLoader.iterator().next(); if (jackPrebuilt != null && configProvider.getClass().getClassLoader() != classLoader) { throw new TestConfigurationException("Jack compiler is not loaded from '" + jackPrebuilt <|startfocus|> + "'. Unset jack prebuilt property in configuration file."); <|endfocus|> } } catch (MalformedURLException e1) { throw new TestConfigurationException(e1); } catch (NoSuchElementException e) { if (jackPrebuilt == null) { throw new TestConfigurationException( "JackProvider could not be loaded. Ensure Jack prebuilt is specified in configuration" + " file", e); } else { throw new TestConfigurationException(e); } } assert configProvider != null; releaseName = configProvider.getCompilerReleaseName(); releaseCode = configProvider.getCompilerReleaseCode(); subReleaseKind = configProvider.getCompilerSubReleaseKind(); subSubReleaseCode = configProvider.getCompilerSubReleaseCode();
<|startcomment|> remove <|endcomment|>  import javax.annotation.Nonnull; /** * A configuration for API level 02 of the Jack compiler compatible with API level 01 */ public interface Api02Config extends Api01Config { /** * Sets the Java source version (from 3 to 8). * @param javaSourceVersion the Java source version * @throws ConfigurationException */ void setJavaSourceVersion(@Nonnull JavaSourceVersion javaSourceVersion) throws ConfigurationException; /** <|startfocus|> * Sets the base directory against all relative path will be based on. <|endfocus|> * @param baseDir the base directory * @throws ConfigurationException */ void setBaseDirectory(@Nonnull File incrementalDir) throws ConfigurationException; } 
<|startcomment|> human-readable <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.api.v01; /** * Available reporters. */ public enum ReporterKind { /** <|startfocus|> * The default human readable reporter. <|endfocus|> */ DEFAULT, /** * A reporter formating in a JSON like structure. */ SDK } 
<|startcomment|> generateDexAndPush? <|endcomment|> <|startfocus|> private void dexAndPush(Set<Task> tasks, String name, File jar, Action action) { <|endfocus|> File localDex = run.localDexFile(name); File deviceDex = run.targetDexFile(name); Task createDexJarTask = createCreateDexJarTask(run.classpath, jar, name, action, localDex); tasks.add(createDexJarTask); tasks.add(run.target.pushTask(localDex, deviceDex).afterSuccess(createDexJarTask));
<|startcomment|> why these braces ? <|endcomment|>  public SSLSession getSession(byte[] sessionId) { // First see if AbstractSessionContext can satisfy the request. <|startfocus|> { SSLSession session = super.getSession(sessionId); if (session != null) { // This will already have gone through Platform#wrapSSLSession return session; } <|endfocus|> } // Then check the persistent cache. if (persistentCache != null) { byte[] data = persistentCache.getSessionData(sessionId); if (data != null) { OpenSSLSessionImpl session = toSession(data, null, -1); if (session != null && session.isValid()) { super.putSession(session); return Platform.wrapSSLSession(session); } } } return null;
<|startcomment|> nit <|endcomment|> <|startfocus|> * Copyright (C) 2014 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.library; import com.android.sched.vfs.VPath; import javax.annotation.Nonnull; /** * Location describing a resource in an input library. */ public class ResourceInInputLibraryLocation extends ResourceOrMetaInInputLibraryLocation { public ResourceInInputLibraryLocation(@Nonnull InputLibraryLocation inputLibLoc, @Nonnull VPath path) { super(inputLibLoc, path); } @Override @Nonnull
<|startcomment|> another place to put a . if you are feeling the spring cleaning mood too <|endcomment|>  } javac.classpath(run.classpath) .destination(classesDir) .javaVersion(run.language.getJavacSourceAndTarget()) .extra(run.javacArgs) .compile(sourceFiles); } new Command(run.log, run.javaPath("jar"), "cvfM", jar.getPath(), "-C", classesDir.getPath(), "./").execute(); } /** * Compile sources using the Jack compiler. */ private void compileWithJack(Action action, File jackFile) throws IOException { <|startfocus|> // Create a folder for resources <|endfocus|> File resourcesDir = run.localFile(action, "resources"); run.mkdir.mkdirs(resourcesDir); createJarMetadataFiles(action, resourcesDir); File javaFile = action.getJavaFile(); Jack compiler = Jack.getJackCommand(run.log); if (run.debugging) { compiler.setDebug(); } compiler.sourceVersion(run.language.getJackArg()); Set<File> sourceFiles = Sets.newHashSet(); // Add the source files to be compiled. // The javac compiler supports the -sourcepath directive although jack
<|startcomment|> What is this 1? <|endcomment|>  // Get debuggee class ID. String debuggeeClassSig = getClassSignature(InvokeMethodDebuggee.class); long debuggeeTypeID = debuggeeWrapper.vmMirror.getClassID(debuggeeClassSig); assertTrue("Failed to find debuggee class", debuggeeTypeID != 0); // Set METHOD_ENTRY event request so application is suspended. CommandPacket packet = new CommandPacket( JDWPCommands.EventRequestCommandSet.CommandSetID, JDWPCommands.EventRequestCommandSet.SetCommand); packet.setNextValueAsByte(JDWPConstants.EventKind.METHOD_ENTRY); packet.setNextValueAsByte(JDWPConstants.SuspendPolicy.ALL); <|startfocus|> packet.setNextValueAsInt(1); <|endfocus|> packet.setNextValueAsByte(EventMod.ModKind.ClassOnly); // class-only modifier. packet.setNextValueAsReferenceTypeID(debuggeeTypeID); ReplyPacket reply = debuggeeWrapper.vmMirror.performCommand(packet); checkReplyPacket(reply, "EventRequest::Set command"); int requestID = reply.getNextValueAsInt(); logWriter.println(" EventRequest.Set: requestID=" + requestID); assertAllDataRead(reply); synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE); long targetThreadID = 0; // Wait for METHOD_ENTRY event and collect event thread. CommandPacket event = debuggeeWrapper.vmMirror.receiveEvent();
<|startcomment|> Long line <|endcomment|>  public void run() { // Preload TestClass so it is available during the test. Class c = null; try { <|startfocus|> c = Class.forName("org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Debuggee$TestClass"); <|endfocus|> } catch (ClassNotFoundException e) { e.printStackTrace(); } synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_READY); logWriter.println("InvokeMethodDefault002Debuggee"); synchronizer.receiveMessageWithoutException("org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Debuggee(#1)"); execMethod(); synchronizer.receiveMessageWithoutException("org.apache.harmony.jpda.tests.jdwp.ObjectReference.InvokeMethodDefault002Debuggee(#2)");
<|startcomment|> nit: lib? <|endcomment|>  JackBasedToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); File[] defaultClasspath = toolchain.getDefaultBootClasspath(); File lib = AbstractTestTools.createTempFile("lib", toolchain.getLibraryExtension()); File sourceDir = AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test037.lib"); toolchain.addToClasspath(defaultClasspath).srcToLib(lib, /* zipFiles = */ true, sourceDir); toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); <|startfocus|> File lixDexFolder = AbstractTestTools.createTempDir(); <|endfocus|> toolchain.addToClasspath(defaultClasspath) .setSourceLevel(SourceLevel.JAVA_8) .libToExe(lib, lixDexFolder, /* zipFiles = */ false); toolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); File srclib = AbstractTestTools.createTempFile("srclib", toolchain.getLibraryExtension()); sourceDir = AbstractTestTools.getTestRootDir("com.android.jack.java8.lambda.test037.jack"); toolchain.addToClasspath(defaultClasspath) .addToClasspath(lib) .setSourceLevel(SourceLevel.JAVA_8) .srcToLib(srclib, /* zipFiles = */ true, sourceDir); toolchain =
<|startcomment|> assertTagEquals (in superclass JDWPTestCase) will also print tag's code name <|endcomment|>  //check number of retrieved values int numberOfValues = reply.getNextValueAsInt(); assertEquals("Invalid number of values", numberOfValues, 1); Value val = reply.getNextValueAsValue(); assertEquals("Invalid value tag", val.getTag(), tag); long longVal = val.getLongValue(); if (tag == JDWPConstants.Tag.STRING_TAG) { String strLocalVariable = getStringValue(longVal); assertEquals("Invalid value tag", strLocalVariable, expectedValue); } else if (tag == JDWPConstants.Tag.LONG_TAG) { <|startfocus|> assertEquals("Invalid value tag", longVal, expectedValue); <|endfocus|> } logWriter.println(testName + " done");
<|startcomment|> https://lh3.googleusercontent.com/S4BxWILnfDY2kJCIzC4uo98VVhNX7uMPsRHVoFU701gLYy_RUIYXnNAoSTPA-c34S6aTI-ygqC1Hq6fRZTks7sN2fE5yNIaok7YKTc_E=h288 <|endcomment|> <|startfocus|> * Copyright (C) 2013 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.bluetooth.gatt; import android.bluetooth.le.ScanSettings; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.Iterator; import java.util.List; import com.android.bluetooth.btservice.BluetoothProto; /** * ScanStats class helps keep track of information about scans * on a per application basis. * @hide */
<|startcomment|> Somewhere in Optimizations ? <|endcomment|> @HasKeyId @Description("Expressions simplifier") @Constraint(no = {ImplicitCast.class, JCastOperation.WithIntersectionType.class}, need = {ThreeAddressCodeForm.class}) @Transform(add = {ExpressionSimplifier.ExpressionsSimplified.class, JPrefixNotOperation.class, JBooleanLiteral.class, JIntLiteral.class, JLongLiteral.class, JDoubleLiteral.class, JFloatLiteral.class, JByteLiteral.class, JShortLiteral.class, JCharLiteral.class}) @Support(Optimizations.ExpressionSimplifier.class) public class ExpressionSimplifier implements RunnableSchedulable<JMethod> { <|startfocus|> @Nonnull public static final BooleanPropertyId ENABLE_NULL_INSTANCEOF = BooleanPropertyId.create( "jack.optimization.null-instanceof-simplifier", "Optimize null instanceof") .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class); <|endfocus|> /** * A {@link Tag} meaning that expressions were simplified. */ @Description("Expressions are simplified.") public static final class ExpressionsSimplified implements Tag { } @Nonnull private final Filter<JMethod> filter = ThreadConfig.get(Options.METHOD_FILTER); static class Simplifier extends JVisitor { @CheckForNull private JMethod currentMethod; 
<|startcomment|> <= Same comments as above. <|endcomment|>  long batchUs = environment.getMaxReportLatencyUs(); long sampleUs = environment.getExpectedSamplingPeriodUs(); long adjustedTestDurationUs = testDurationUs - ALLOWED_SENSOR_DELIVERING_DELAY_US; Assert.assertTrue( String.format("improper test case: adjusted test duration (%d) < sampling period (%d)", adjustedTestDurationUs, sampleUs), adjustedTestDurationUs > sampleUs); if (batchUs > 0) { Assert.assertTrue( <|startfocus|> String.format("improper test case: adjusted test duration (%d) < batchUs (%d)", <|endfocus|> adjustedTestDurationUs, batchUs), adjustedTestDurationUs > batchUs); // Events generated in the last batchUs of the set are not due for // arrival when the test ends. Don't expect to receive those events minTestDurationUs = adjustedTestDurationUs - batchUs; } else { minTestDurationUs = adjustedTestDurationUs; } long expectedMinNumEvent = minTestDurationUs / sampleUs; return new EventBasicVerification(expectedMinNumEvent, environment.getSensor());
<|startcomment|> // Repackage lib2 <|endcomment|>  exclude.add(JillBasedToolchain.class); // Build lib2 File lib2NoJarjar; { IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, exclude); lib2NoJarjar = AbstractTestTools.createTempFile("jarjar006", "lib2-nojarjar" + toolchain.getLibraryExtension()); toolchain.addToClasspath(toolchain.getDefaultBootClasspath()) .srcToLib(lib2NoJarjar, /* zipFiles = */ true, new File (testRootDir,"lib2")); } <|startfocus|> File lib2Jarjar; <|endfocus|> { IToolchain toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class, exclude); lib2Jarjar = AbstractTestTools.createTempFile("jarjar006", "lib2-jarjar" + toolchain.getLibraryExtension());toolchain.setJarjarRules( Collections.singletonList(new File(testRootDir, "jarjar-rules.txt"))) .libToLib(lib2NoJarjar, lib2Jarjar, /* zipFiles */ true); } File lib2Dex = AbstractTestTools.createTempFile("jarjar006", "lib2.dex.zip"); { AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class) .libToExe(lib2Jarjar, lib2Dex, /* zipFile = */ true); }
<|startcomment|> The style use to be to just name "e" as "expected", and not waste a line on a comment. <|endcomment|>  public void testSystem_setSecurityManager_notNull_throwsException() { try { System.setSecurityManager(new SecurityManager()); fail("Expected " + SecurityException.class.getName()); <|startfocus|> } catch (SecurityException e) { // Expected. <|endfocus|> }
<|startcomment|> (existing: xxx, new: yyy) <|endcomment|>  * @throws UnsupportedOperationException */ protected void transform( @Nonnull JNode existingNode, @CheckForNull JNode newNode, @Nonnull Transformation transformation) throws UnsupportedOperationException { throw new UnsupportedOperationException(getClass().getName() + " does not support transformation '" + transformation.name() <|startfocus|> + "' with existing node of class " + existingNode.getClass().getName() + " and newNode " + (newNode == null ? "null" : "of class " + newNode.getClass().getName())); <|endfocus|> } protected static <T> boolean transform( @Nonnull List<T> list, @Nonnull JNode existingNode, @CheckForNull T newNode, @Nonnull Transformation transformation) { assert existingNode != null; int indexOfExisting = list.indexOf(existingNode); if (indexOfExisting != -1) { // TODO(jmhenaff): Rethink how this is done eventually. // The fact that Jack uses Lists lead to this implementation. switch (transformation) { case INSERT_AFTER: assert newNode != null;
<|startcomment|> All this is unnecessary... <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package benchmarks; public class InvokeInterface { static MultiClass multi; // static SingleClass single; static { multi = new MultiClass(); <|startfocus|> // single = new SingleClass(); <|endfocus|> } public void timeCall0Concrete(int nreps) { MultiClass m = multi; for (int i = 0; i < nreps; i++) { doCall0Concrete(m); } } public void timeCall1Concrete(int nreps) { MultiClass m = multi; for (int i = 0; i < nreps; i++) { doCall1Concrete(m); } } public void timeCall2Concrete(int nreps) { MultiClass m = multi; for (int i = 0; i < nreps; i++) {
<|startcomment|> cancelUserTimeoutAlarm sets mRemoveTimeoutMsg to false so we don't need to set it again here <|endcomment|>  if (mRemoteDevice == null || device == null) { Log.i(TAG, "Unexpected error!"); return; } if (DEBUG) Log.d(TAG,"ACL disconnected for " + device); if (mRemoteDevice.equals(device)) { if (mRemoveTimeoutMsg) { // Send any pending timeout now, as ACL got disconnected. cancelUserTimeoutAlarm(); mSessionStatusHandler.removeMessages(USER_TIMEOUT); sendCancelUserConfirmationIntent(mRemoteDevice); <|startfocus|> mRemoveTimeoutMsg = false; <|endfocus|> } mIsWaitingAuthorization = false; setState(BluetoothSap.STATE_DISCONNECTED); // Ensure proper cleanup, and prepare for new connect. mSessionStatusHandler.sendEmptyMessage(MSG_SERVERSESSION_CLOSE); } }
<|startcomment|> add a line here <|endcomment|>  /* Connect if we do not have a connection, and start the content observers providing * this thread as Handler. */ if (isConnected() == false) { if(D) Log.d(TAG, "handleRegistration: connect"); connect(); } sendObserverRegistration = isConnected(); mRegisteredMasIds.put(masId, true); // We don't use the value for anything // Clear last saved MNSSdpSearchInfo after connect is processed. mMnsLstRegRqst = null; <|startfocus|> } <|endfocus|> if (mRegisteredMasIds.size() == 0) { // No more registrations - disconnect if(D) Log.d(TAG, "handleRegistration: disconnect"); disconnect(); } //Register ContentObserver After connect/disconnect MNS channel. if(V) Log.v(TAG, "Send registerObserver: " + sendObserverRegistration); if (mCallback != null && sendObserverRegistration) { Message msg = Message.obtain(mCallback); msg.what = BluetoothMapService.MSG_OBSERVER_REGISTRATION; msg.arg1 = masId; msg.arg2 = notificationStatus; msg.sendToTarget(); } } public boolean isValidMnsRecord() {
<|startcomment|> Why isn't this code guarded by "if (mCachePath != nullptr)", the same way similar code was in ScriptC.java? (I realize this CL doesn't change whether or not the code is guarded.) Even if there's a good reason not to guard the code, perhaps the assignment to mCachePath ought to be? I don't think this (writer) method is synchronized on a lock along with all readers of this field. Unless the Java memory model considers accesses to object references to be atomic, and allows concurrent readers and writers, in which case an explicit lock in our code would be unnecessary? Even if the model lets us get away with this, is it possible some other method that accesses mCachePath multiple times might get confused if mCachePath is rewritten to a different value between two accesses? <|endcomment|>  rs.mContextType = ct; rs.mContextFlags = flags; rs.mContextSdkVersion = sdkVersion; if (rs.mContext == 0) { throw new RSDriverException("Failed to create RS context."); } // set up cache directory for entire context <|startfocus|> final String CACHE_PATH = "com.android.renderscript.cache"; File f = new File(RenderScriptCacheDir.mCacheDir, CACHE_PATH); mCachePath = f.getAbsolutePath(); f.mkdirs(); rs.nContextSetCacheDir(mCachePath); <|endfocus|> rs.mMessageThread = new MessageThread(rs); rs.mMessageThread.start(); return rs; } /** * calls create(ctx, ContextType.NORMAL, CREATE_FLAG_NONE) * * See documentation for @create for details * * @param ctx The context. * @return RenderScript */ public static RenderScript create(Context ctx) { return create(ctx, ContextType.NORMAL); } /** * calls create(ctx, ct, CREATE_FLAG_NONE) * * See documentation for @create for details *
<|startcomment|> Why not assuming here, and not on windows? <|endcomment|>  */ @Test public void testFileAccessError001() throws Exception { assumeNotWindows(); ErrorTestHelper te = new ErrorTestHelper(); AbstractTestTools.createFile(te.getSourceFolder(), "jack.incremental", "A.java", "package jack.incremental; \n"+ "public class A {} \n"); File jackOutputFile = AbstractTestTools.createTempDir(); try { <|startfocus|> if (!jackOutputFile.setReadable(false)) { Assert.fail("Fails to change file permissions of " + jackOutputFile.getAbsolutePath()); } <|endfocus|> JackApiToolchainBase jackApiToolchain = AbstractTestTools.getCandidateToolchain(JackApiToolchainBase.class); try { jackApiToolchain.addToClasspath(jackApiToolchain.getDefaultBootClasspath()) .srcToLib(jackOutputFile, /* zipFiles = */ false, te.getSourceFolder()); Assert.fail(); } catch (PropertyIdException e) { // Failure is ok since jack output folder is not readable } } finally { if (!jackOutputFile.setReadable(true)) { Assert.fail("Fails to change file permissions of " + jackOutputFile.getAbsolutePath());
<|startcomment|> And you should check `e.getCause() instanceof NullPointerException` here. <|endcomment|>  public static void main(String[] args) throws Exception { try { Class<?> v = Class.forName("VerifyError"); throw new Error("Expected LinkageError"); } catch (LinkageError e) { // expected } Class<?> c = Class.forName("[LVerifyError;"); try { Class.forName("TestCase").getMethod("topLevel", c).invoke(null, new Object[] { null }); throw new Error("Expected InvocationTargetException"); } catch (InvocationTargetException e) { <|startfocus|> // expected <|endfocus|> } } } 
<|startcomment|> Could work with cli as well? So maybe JackBasedToolchain \ JackApiv01 because of source level 8, and JillBasedToolchain. Thus this test will continue to be executed with JackApiV03 and up. <|endcomment|>  Assert.fail(); } catch (JackAbortException e) { Assert.assertTrue( errOut.toString().contains("not supported in Android API level less than 24")); } } /** * Ensure that can compile a lib including a default method with min api 23 and then import it to * a dex with min api 24. */ @Test public void testDefaultMethod001_3() throws Exception { JackBasedToolchain toolchain = <|startfocus|> AbstractTestTools.getCandidateToolchain(JackApiV02Toolchain.class); <|endfocus|> File lib23 = AbstractTestTools.createTempFile("lib23", toolchain.getLibraryExtension()); toolchain.addProperty( Options.ANDROID_MIN_API_LEVEL.getName(), String.valueOf(23)) .setSourceLevel(SourceLevel.JAVA_8) .addToClasspath(toolchain.getDefaultBootClasspath()) .srcToLib(lib23, /* zipFiles = */ true, new File(DEFAULTMETHOD001.directory, DEFAULTMETHOD001.srcDirName)); File dex24 = AbstractTestTools.createTempDir(); toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); toolchain.addProperty( Options.ANDROID_MIN_API_LEVEL.getName(),
<|startcomment|> I could only find one. But I guess it doesn't really matter. <|endcomment|>  private static void fork(Runnable r) { for (int i = 0; i < 10; i++) { sThreads[i] = new Thread(r); } // Start the threads only after the full array has been written with new threads, <|startfocus|> // because some tests rely on the contents of this array to be consistent. <|endfocus|> for (int i = 0; i < 10; i++) { sThreads[i].start(); }
<|startcomment|> Why ACCOUNT_NAME and ACCOUNT_TYPE are different from ContactsTest.TEST_ACCOUNT_NAME, TEST_ACCOUNT_TYPE and manifest? <|endcomment|>  * limitations under the License. */ package com.android.cts.managedprofile; import android.accounts.AbstractAccountAuthenticator; import android.accounts.Account; import android.accounts.AccountAuthenticatorResponse; import android.accounts.AccountManager; import android.accounts.NetworkErrorException; import android.content.Context; import android.os.Bundle; /* package */ class AccountAuthenticator extends AbstractAccountAuthenticator { private static AccountAuthenticator sAuthenticator = null; <|startfocus|> private static final String ACCOUNT_NAME = "com.android.cts.deviceandprofileowner.account.name"; static final String ACCOUNT_TYPE = "com.android.cts.deviceandprofileowner.account.type"; <|endfocus|> private static final String AUTH_TOKEN = "authToken"; private static final String AUTH_TOKEN_LABEL = "authTokenLabel"; private AccountAuthenticator(Context context) { super(context); } private Bundle createResultBundle() { Bundle result = new Bundle(); result.putString(AccountManager.KEY_ACCOUNT_NAME, ACCOUNT_NAME); result.putString(AccountManager.KEY_ACCOUNT_TYPE, ACCOUNT_TYPE); result.putString(AccountManager.KEY_AUTHTOKEN, AUTH_TOKEN); return result; } @Override public Bundle addAccount(AccountAuthenticatorResponse response, String accountType,
<|startcomment|> rename to fieldId ? <|endcomment|>  public boolean visit(@Nonnull JDefinedClassOrInterface type) { if (!type.isExternal()) { NameProvider fieldNameProvider = nameProviderFactory.getFieldNameProvider(); for (JField field : type.getFields()) { JFieldId fieldId = field.getId(); if (mustBeRenamed(fieldId)) { <|startfocus|> String name = null; <|endfocus|> try { do { String newName = fieldNameProvider.getNewName(getKey(fieldId)); if (newName.equals(name)) { throw new MaskedHierarchy(fieldId.getName(), type, newName); } name = newName; } while (FieldInHierarchyFinderVisitor.containsFieldKey(name, field)); } catch (MaskedHierarchy e) { Jack.getSession() .getReporter() .report(Severity.NON_FATAL, new ObfuscationContextInfo(e)); } rename(fieldId, fieldNameProvider); } } NameProvider methodNameProvider = nameProviderFactory.getMethodNameProvider(); for (JMethod method : type.getMethods()) { JMethodIdWide methodId = method.getMethodId().getMethodIdWide(); if (mustBeRenamed(methodId)) {
<|startcomment|> 2016 <|endcomment|> <|startfocus|> * Copyright (C) 2015 The Android Open Source Project <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.optimizations.defuse.test004.dx; import com.android.jack.optimizations.defuse.test004.jack.DefUse004; import org.junit.Assert; import org.junit.Test; public class Tests { @Test public void test001() { Assert.assertEquals(1, DefUse004.get(true, true)); Assert.assertEquals(0, DefUse004.get(true, false));
<|startcomment|> Sure? <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.library.v0002; /** * Library version. */ public class Version { public static final int MINOR_MIN = 3; public static final int MINOR = 3; <|startfocus|> public static final int MAJOR = 3; <|endfocus|> } 
<|startcomment|> Please use JUnit4 syntax and annotate with @RunWith(AndroidJUnit4.class) <|endcomment|> import static android.support.test.espresso.action.ViewActions.repeatedlyUntil; import static android.support.test.espresso.action.ViewActions.swipeUp; import static android.support.test.espresso.assertion.ViewAssertions.matches; import static android.support.test.espresso.matcher.ViewMatchers.hasDescendant; import static android.support.test.espresso.matcher.ViewMatchers.withId; import static android.support.test.espresso.matcher.ViewMatchers.withText; import static org.junit.rules.ExpectedException.none; /** * Integration tests for repeat action until view state. */ @LargeTest <|startfocus|> public class RepeatActionUntilViewStateIntegrationTest extends ActivityInstrumentationTestCase2<SwipeActivity> { <|endfocus|> @Rule public ExpectedException expectedException = none(); @SuppressWarnings("deprecation") public RepeatActionUntilViewStateIntegrationTest() { // Keep froyo happy. super("android.support.test.testapp", SwipeActivity.class); } @Override public void setUp() throws Exception { super.setUp(); getActivity(); } /** Tests that trying to perform action on view repeatedly takes it to the view state matched by given view matcher*/ public void testPerformingActionOnViewUntilItHasDesiredState() {
<|startcomment|> Leave this in, you can remove rest of the comment. <|endcomment|>  public void notifyDataActivityForSubscriber(int subId, int state) { if (!checkNotifyPermission("notifyDataActivity()" )) { return; } synchronized (mRecords) { int phoneId = SubscriptionManager.getPhoneId(subId); if (validatePhoneId(phoneId)) { mDataActivity[phoneId] = state; for (Record r : mRecords) { <|startfocus|> //Fix "TelephonyRegistry notifies wrong data status".Need to nofify by correct //subId. //Otherwise SIM1 data status will be overrided by SIM2 data status in some case, //Such as screen on/off action. <|endfocus|> if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVITY) && idMatch(r.subId, subId, phoneId)) { try { r.callback.onDataActivity(state); } catch (RemoteException ex) { mRemoveList.add(r.binder); } } } } handleRemoveListLocked(); }
<|startcomment|> OK but may I suggest "on the IR outside of the class or interface it runs on," <|endcomment|> import com.android.sched.schedulable.Support; import com.android.sched.schedulable.Transform; import javax.annotation.Nonnull; /** * A {@link RunnableSchedulable} that is only useful as a separation between the * {@link Keeper} and the shrinkers, so that they don't run in the same * "type" subplan. * <|startfocus|> * The Keeper is a visitor that puts markers the IR while not running on it which necessitate for * the shrinkers to wait for the Keeper to finish visiting all types before using the markers. <|endfocus|> */ @Description("A separation between the Keeper and the Shrinkers") @Transform(remove = KeeperSchedulingSeparator.SeparatorTag.class) @Constraint(need = KeeperSchedulingSeparator.SeparatorTag.class) @Support(Shrinking.class) public class KeeperSchedulingSeparator implements RunnableSchedulable<JSession> { @Override public void run(@Nonnull JSession session) throws Exception { // do nothing } /** * The tag that is used by the {@link Keeper} and the Shrinkers to * express the need for a separation. */
<|startcomment|> put it in finally block otherwise if the assertion fails it would be missed <|endcomment|>  public void compareSameBitmapImage() { Bitmap bitmap = BitmapFactory.decodeResource( getInstrumentation().getContext().getResources(), android.R.drawable.alert_dark_frame); <|startfocus|> assertTrue(HasBackgroundMatcher.compareBitmaps(bitmap, bitmap)); bitmap.recycle(); bitmap = null; <|endfocus|>
<|startcomment|> Does this uuid have a name? <|endcomment|>  return (IBinder) mMethod.invoke(null, service); } public void mediaPlayerTest(Context ctx) throws Throwable { IBinder serviceBinder = getService("media.player"); serviceBinder.getInterfaceDescriptor(); Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken("android.media.IMediaPlayerService"); serviceBinder.transact(MediaPlayerServiceOps.MAKE_CRYPTO, data, reply, 0); IBinder crypto = reply.readStrongBinder(); crypto.getInterfaceDescriptor(); <|startfocus|> byte uuid[] = { <|endfocus|> (byte) 0x10, (byte) 0x77, (byte) 0xEF, (byte) 0xEC, (byte) 0xC0, (byte) 0xB2, (byte) 0x4D, (byte) 0x02, (byte) 0xAC, (byte) 0xE3, (byte) 0x3C, (byte) 0x1E, (byte) 0x52, (byte) 0xE2, (byte) 0xFB, (byte) 0x4B }; CryptoProxy cryptoProxy = new CryptoProxy(crypto); cryptoProxy.getIsCryptoSupported(uuid); cryptoProxy.createPlugin(uuid, null);
<|startcomment|> javadoc the delta between this and the original impl <|endcomment|>  if (!contextPackageName.equals(intentComponentName.getPackageName())) { if (activityClassPackageName.equals(intentComponentName.getPackageName())) { intent.setComponent( new ComponentName(contextPackageName, intentComponentName.getClassName())); } } return super.newActivity(clazz, context, token, application, intent, info, title, parent, id, lastNonConfigurationInstance); } @Override public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { <|startfocus|> return this.mActivityProvider!=null && mActivityProvider.getActivityClass().getName().equals(className) ? mActivityProvider.getActivity() : super.newActivity(cl, className, intent); <|endfocus|> } /** * Use the given ActivityProvider to create instance of a specific Activity rather than using * default mechanism of Activity instance creation. This can be used to override some of the * behavior in tests e.g. mocking startService() method in Activity under test, to avoid
<|startcomment|> I believe we should have the reverse logic. i.e if (first_api_level < min_pai_level) return false; else return !hasLowRam <|endcomment|>  private boolean isRequired() { int first_api_level = System.GetProperty("ro.product.first_api_level"); // Optional before min_api_level or if the device has low RAM if (first_api_level && first_api_level >= min_api_level) { return !hasLowRAM(); } <|startfocus|> return false; <|endfocus|>
<|startcomment|> These line-by-line comments just say what the code says. See http://go/java-practices/comments. <|endcomment|> import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject; import android.support.test.uiautomator.UiSelector; import com.android.devtools.systemimage.uitest.annotations.TestInfo; import com.android.devtools.systemimage.uitest.common.Res; import com.android.devtools.systemimage.uitest.framework.SystemImageTestFramework; import com.android.devtools.systemimage.uitest.utils.AppLauncher; import org.junit.Rule; import org.junit.Test; import org.junit.rules.Timeout; import org.junit.runner.RunWith; <|startfocus|> <|endfocus|> import java.util.Date; import static org.junit.Assert.assertTrue; /** * Test for app interactions. */ @RunWith(AndroidJUnit4.class) public class AppTest { @Rule public final SystemImageTestFramework testFramework = new SystemImageTestFramework(); @Rule public Timeout globalTimeout = Timeout.seconds(90); /** * Verifies an app runs on the emulator. * <p/> * The test installs, launches, and uninstalls the app. * <p/> * This is run to qualify releases. Please involve the test team in substantial changes. * <p/> * TR ID: C14578823
<|startcomment|> JExpressionStatement.class <|endcomment|> import com.android.sched.util.config.HasKeyId; import com.android.sched.util.config.ThreadConfig; import com.android.sched.util.config.id.PropertyId; import java.util.ArrayList; import java.util.Collections; import javax.annotation.CheckForNull; import javax.annotation.Nonnull; /** * Raise locked region priority for certain types of locks. */ @Description("Raise locked region priority for certain types of locks.") <|startfocus|> @Transform( add = {JMethodCall.class, JTryStatement.class, JBlock.class, JLocal.class, JCatchBlock.class} ) @HasKeyId <|endfocus|> public class BoostLockedRegionPriority implements RunnableSchedulable<JMethod> { // TODO(jack-team): Rewrite this as a plugin. @Nonnull public static final PropertyId<String> BOOST_LOCK_CLASSNAME = PropertyId.create( "jack.optimizations.boostlockregionpriority.classname", "The class signature where acquiring it as a lock should boost a thread's prioirty", new ClassSignatureCodec()) .addDefaultStringValue("") .addCategory(DumpInLibrary.class); @Nonnull public static final PropertyId<String> BOOST_LOCK_REQUEST_METHOD = PropertyId.create(
<|startcomment|> What hack? Doesn't the else block below use the same if (.exists()) construct? Probably just delete the confusing comment. <|endcomment|>  * <p> * TR ID: C14581151 * <p> * <pre> * Test Steps: * 1. Start the emulator. * 2. Open Contacts app. * 3. Tap on "Add Account" * 4. Tap on "Add Contact" and choose "Add Account" * Verify: * User is prompted to sign in to a Google Account. * </pre> */ <|startfocus|> @Test @TestInfo(id = "14581151") <|endfocus|> public void testAddAccountUsingContactsApp() throws Exception { Instrumentation instrumentation = testFramework.getInstrumentation(); UiDevice mDevice = testFramework.getDevice(); if (testFramework.getApi() > 19) { AppLauncher.launch(instrumentation, "Contacts"); // Check if the app is running for the first time. UiObject checkingInfo = mDevice.findObject(new UiSelector().textContains("Checking Info")); if (checkingInfo.exists()) { mDevice.pressBack(); } AppLauncher.launch(instrumentation, "Contacts"); } else { AppLauncher.launch(instrumentation, "People");
<|startcomment|> Strange that no tools check that. Could you check your development environment? Because you catches exceptions in the constructor, I think this field can be null in case of lookup problem. My bad here, you have to test against null in run(). A good support for the sched-lib here to avoid boilerplate. <|endcomment|>  * * Try blocks are inserted to make sure that the reset call is always executed even in place of * exceptions. This is important for threads that might be reused like worker threads. */ @Description("Raise locked region priority for certain types of locks.") @Transform( add = { JBlock.class, JCatchBlock.class, JExpressionStatement.class, JMethodCall.class, JTryStatement.class } ) public class BoostLockedRegionPriority implements RunnableSchedulable<JMethod> { <|startfocus|> @Nonnull private JClass lockClass; @Nonnull private JClass requestClass; @Nonnull private JClass resetClass; @Nonnull private JMethodIdWide requestMethodId; @Nonnull private JMethodIdWide resetMethodId; @Nonnull private JClass throwable; <|endfocus|> @Nonnull private final Filter<JMethod> filter = ThreadConfig.get(Options.METHOD_FILTER); public BoostLockedRegionPriority() { String className = ThreadConfig.get(Optimizations.BoostLockedRegionPriorityFeature.BOOST_LOCK_CLASSNAME); String requestMethodFullName = ThreadConfig.get(Optimizations.BoostLockedRegionPriorityFeature.BOOST_LOCK_REQUEST_METHOD); String resetMethodFullName = ThreadConfig.get(Optimizations.BoostLockedRegionPriorityFeature.BOOST_LOCK_RESET_METHOD); 
<|startcomment|> Strange wrapping. <|endcomment|>  test_futureReadWrite(false /* useDirectByteBuffer */); } public void test_futureReadWrite_DirectByteBuffer() throws Throwable { test_futureReadWrite(true /* useDirectByteBuffer */); } private void test_completionHandlerReadWrite(boolean useDirectByteBuffer) throws Throwable { ServerSocket ss = new ServerSocket(0); AsynchronousSocketChannel asc = AsynchronousSocketChannel.open(); // Connect FutureLikeCompletionHandler<Void> connectCompletionHandler = new FutureLikeCompletionHandler<Void>(); asc.connect(ss.getLocalSocketAddress(), null, connectCompletionHandler); connectCompletionHandler.get(1000); <|startfocus|> assertNotNull(asc.getRemoteAddress()); <|endfocus|> // Accept & write data ByteBuffer sendData = allocateByteBuffer(32, useDirectByteBuffer); Socket sss = ss.accept(); sss.getOutputStream().write(sendData.array(), sendData.arrayOffset(), 32); // Read data from async channel ByteBuffer receivedData = allocateByteBuffer(32, useDirectByteBuffer); FutureLikeCompletionHandler<Integer> readCompletionHandler = new FutureLikeCompletionHandler<Integer>(); asc.read(receivedData, null, readCompletionHandler); assertEquals(32, (int)readCompletionHandler.get(1000)); // Compare results
<|startcomment|> @CheckForNull here is elsewhere. <|endcomment|>  * * Try blocks are inserted to make sure that the reset call is always executed even in place of * exceptions. This is important for threads that might be reused like worker threads. */ @Description("Raise locked region priority for certain types of locks.") @Transform( add = { JBlock.class, JCatchBlock.class, JExpressionStatement.class, JMethodCall.class, JTryStatement.class } ) public class BoostLockedRegionPriority implements RunnableSchedulable<JMethod> { <|startfocus|> private final JClass lockClass; private final JClass requestClass; private final JClass resetClass; private final JMethodIdWide requestMethodId; private final JMethodIdWide resetMethodId; <|endfocus|> @Nonnull private final Filter<JMethod> filter = ThreadConfig.get(Options.METHOD_FILTER); public BoostLockedRegionPriority() { String className = ThreadConfig.get(BoostLockedRegionPriorityFeature.BOOST_LOCK_CLASSNAME); String requestMethodFullName = ThreadConfig.get(BoostLockedRegionPriorityFeature.BOOST_LOCK_REQUEST_METHOD); String resetMethodFullName = ThreadConfig.get(BoostLockedRegionPriorityFeature.BOOST_LOCK_RESET_METHOD); int requestMethodSeperatorIdx = requestMethodFullName.indexOf('#');
<|startcomment|> Usually I see this on the same line, not a separate line. (Same elsewhere.) <|endcomment|> import com.android.devtools.systemimage.uitest.utils.AppLauncher; import org.junit.Rule; import org.junit.Test; import org.junit.rules.Timeout; import org.junit.runner.RunWith; import android.app.Instrumentation; import android.support.test.runner.AndroidJUnit4; import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject; import android.support.test.uiautomator.UiSelector; import java.util.concurrent.TimeUnit; /** * Test for adding a Google account. */ @RunWith(AndroidJUnit4.class) public class AddGoogleAccountTest { @Rule public final SystemImageTestFramework testFramework = new SystemImageTestFramework(); <|startfocus|> @Rule public Timeout globalTimeout = Timeout.seconds(60); <|endfocus|> /** * Verifies able to add a Google account using Contacts app. * <p> * This is run to qualify releases. Please involve the test team in substantial changes. * <p> * TR ID: C14581151 * <p> * <pre> * Test Steps: * 1. Start the emulator. * 2. Open Contacts app.
<|startcomment|> uninformative <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.devtools.systemimage.uitest.utils; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; <|startfocus|> /** * Shell utility. */ <|endfocus|> public class ShellUtil { public static final String TAG = ShellUtil.class.getName(); /** * Invokes shell command. * <p> * Note shell commands that require system privilege cannot be invoked through the method. * * @param cmd the command to call in shell * @return {@link ShellResult} * @throws IOException if File IO fails. */ public static ShellResult invokeCommand(String cmd) throws IOException { Process p = Runtime.getRuntime().exec(cmd);
<|startcomment|> Seems really strange ! <|endcomment|>  public boolean visit(@Nonnull JDefinedClassOrInterface type) { if (!type.isExternal()) { NameProvider fieldNameProvider = nameProviderFactory.getFieldNameProvider(); for (JField field : type.getFields()) { JFieldId fieldId = field.getId(); if (mustBeRenamed(fieldId)) { String name = null; try { do { String newName = fieldNameProvider.getNewName(getKey(fieldId)); if (newName.equals(name)) { throw new MaskedHierarchy(fieldId.getName(), type, newName); } <|startfocus|> name = newName; } while (FieldInHierarchyFinderVisitor.containsFieldKey(name, field)); <|endfocus|> } catch (MaskedHierarchy e) { Jack.getSession() .getReporter() .report(Severity.NON_FATAL, new ObfuscationContextInfo(e)); } rename(fieldId, fieldNameProvider); } } NameProvider methodNameProvider = nameProviderFactory.getMethodNameProvider(); for (JMethod method : type.getMethods()) { JMethodIdWide methodId = method.getMethodId().getMethodIdWide(); if (mustBeRenamed(methodId)) {
<|startcomment|> Location is better <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.shrob.obfuscation; import com.android.jack.reporting.Reportable; import com.android.sched.util.location.LineLocation; import javax.annotation.Nonnull; /** * A {@link Reportable} information that occurs during the obfuscation phase. */ public class ObfuscationContextInfo implements Reportable { @Nonnull <|startfocus|> private final LineLocation location; <|endfocus|> @Nonnull private final ProblemLevel level; @Nonnull private final Throwable cause; public ObfuscationContextInfo( @Nonnull LineLocation location, @Nonnull ProblemLevel level, @Nonnull Throwable cause) { this.location = location; this.cause = cause; this.level = level; } @Override @Nonnull public String getMessage() { return location.getDescription() + ": Obfuscation: " + cause.getMessage(); } @Override @Nonnull public ProblemLevel getDefaultProblemLevel() { return level; } } 
<|startcomment|> Remove code in comment. <|endcomment|>  private Constant buildPrimitiveConstant(@Nonnull JValueLiteral literal) { Constant cst = null; assert literal.getType() instanceof JPrimitiveType; JPrimitiveTypeEnum primitiveType = ((JPrimitiveType) literal.getType()).getPrimitiveTypeEnum(); switch (primitiveType) { case BOOLEAN: cst = CstBoolean.make(((JBooleanLiteral) literal).getValue()); <|startfocus|> //cst = CstInteger.make(((JBooleanLiteral) literal).getValue() ? 1 : 0); <|endfocus|> break; case BYTE: cst = CstInteger.make(((JByteLiteral) literal).getValue()); break; case CHAR: cst = CstInteger.make(((JCharLiteral) literal).getValue()); break; case DOUBLE: cst = CstDouble.make(Double.doubleToLongBits(((JDoubleLiteral) literal).getValue())); break; case FLOAT: cst = CstFloat.make(Float.floatToIntBits(((JFloatLiteral) literal).getValue())); break; case INT: cst = CstInteger.make(((JIntLiteral) literal).getValue()); break; case LONG: cst = CstLong.make(((JLongLiteral) literal).getValue()); break;
<|startcomment|> should we only call this if mBluetoothPan.get() is non-null? <|endcomment|>  public void onDestroy() { BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter(); if (adapter != null) { <|startfocus|> adapter.closeProfileProxy(BluetoothProfile.PAN, mBluetoothPan.get()); <|endfocus|> } super.onDestroy();
<|startcomment|> call.getReceiverType != method.getEnclosingType (getEnclosingType is of course a JDefined) <|endcomment|>  if (!call.getMethodId().isInit() || !(call.getInstance() instanceof JThisRef)) { return; } assert call.getDispatchKind() == JMethodCall.DispatchKind.DIRECT; assert method.getMethodIdWide().getKind() == MethodKind.INSTANCE_NON_VIRTUAL; // Well, we assume that if the type of the receiver is not the type of the // constructor we are analyzing, this must be a call to a super constructor <|startfocus|> if (!call.getReceiverType().isSameType(method.getEnclosingType())) { <|endfocus|> return; } for (Map.Entry<JField, Integer> e : field2id.entrySet()) { JField field = e.getKey(); if (field.isStatic()) { continue; } int index = e.getValue().intValue(); if (outBs.maybeAssigned.get(index)) { // An instance field assigned at this point is going to // be reassigned inside the constructor during delegation fields.remove(field); } // It is definitely assigned after the call outBs.maybeAssigned.set(index);
<|startcomment|> Suites <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package vogar.target.junit4; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Suite; import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class) @SuiteClasses({SimpleTest3.class}) public class SimpleTest { <|startfocus|> // This should be ignored as Suite's are processed first. <|endfocus|> @Test public void simple() { } } 
<|startcomment|> Probably need an assert cfg != null, getMarker does not return @Nonnull ? <|endcomment|>  @Override public ControlFlowGraph getCfg() { <|startfocus|> return constructor.getMarker(ControlFlowGraph.class); <|endfocus|>
<|startcomment|> "key derivation function" <|endcomment|>  /** * Example showing how to decrypt data that was encrypted using SHA1PRNG * * The Crypto provider providing the SHA1PRNG algorithm for random number * generation was deprecated in SDK 24. * * There was an usual anti-pattern of using that algorithm to derive keys. * This example provides a helper class ({@link InsecureSHA1PRNGKeyDerivator} and shows how to treat * data that was encrypted in the incorrect way and re-encrypt it in a proper way, <|startfocus|> * by using a KeyDerivationFunction. <|endfocus|> * * The {@link #onCreate(Bundle)} method retrieves encrypted data twice and displays the results. * * The mock data is encrypted with an insecure key. The first time it is reencrypted properly and * the plain text is returned together with a warning message. The second time, as the data is * properly encrypted, the plain text is returned with a congratulations message. */ public class BrokenKeyDerivationActivity extends Activity { /**
<|startcomment|> If we are all agree with this new Jack IR capability, it will be better to move it into a separate CL, merge it and rebase this CL. jp what is your opinion ? <|endcomment|>  */ @Description("Java literal expression") public abstract class JValueLiteral extends JLiteral implements Cloneable { public JValueLiteral(SourceInfo sourceInfo) { super(sourceInfo); } @Override @Nonnull public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } } /** Does the literal represent default type value, i.e. it is zero, false or null */ <|startfocus|> public abstract boolean isDefaultTypeValue(); <|endfocus|> } 
<|startcomment|> byteBufferAddress <|endcomment|>  } } public void testArrayOffset() { try { buf.arrayOffset(); fail("Should throw UnsupportedOperationException"); //$NON-NLS-1$ } catch (UnsupportedOperationException e) { } } // http://b/28964300 public void testJNIAccessByAddress() throws Exception { DirectByteBuffer directByteBuffer = (DirectByteBuffer) ByteBuffer.allocateDirect(10); directByteBuffer.put((byte)'a'); CharBuffer charBuffer = directByteBuffer.asCharBuffer(); charBuffer.put('b'); <|startfocus|> long addressDB = NIOAccess.getBasePointer(directByteBuffer); long addressCB = NIOAccess.getBasePointer(charBuffer); <|endfocus|> assertEquals(addressDB + SizeOf.CHAR, addressCB); } public void testIsDirect() { assertTrue(buf.isDirect()); } public void testOrder() { assertEquals(ByteOrder.BIG_ENDIAN, buf.order()); } } 
<|startcomment|> Avoid, that trigger a TLS access. Try to cache that in a field. Or cache directly the NPE type. <|endcomment|>  private JBlock createThenBlock( @Nonnull SourceInfo srcInfo, @Nonnull TransformationRequest request) { JClass exceptionType = <|startfocus|> Jack.getSession().getPhantomLookup() <|endfocus|> .getClass(CommonTypes.JAVA_LANG_NULL_POINTER_EXCEPTION); JNewInstance newInstance = new JNewInstance(srcInfo, exceptionType, exceptionType.getOrCreateMethodIdWide( NamingTools.INIT_NAME, Collections.<JType>emptyList(), MethodKind.INSTANCE_NON_VIRTUAL)); JExpression[] expressions = SplitNewInstance.NewExpressionSplitter .splitNewInstance(newInstance, request, varCreator); assert expressions.length > 0; JExpression lastExpr = expressions[expressions.length - 1]; JBlock block = new JBlock(srcInfo); for (JExpression expression : expressions) { block.addStmt( expression == lastExpr ? new JThrowStatement(srcInfo, expression) : new JExpressionStatement(srcInfo, expression)); } return block;
<|startcomment|> I am not sure that doing that sort of optimization is good. Why not just create the request, and commit it at the end? <|endcomment|>  if (jlsNullabilityHelper != null) { if (!field.isStatic()) { JExpression instance = ref.getInstance(); assert instance != null; jlsNullabilityHelper.addNullCheckIfNeeded(instance, request); } } } } @Override public void run(@Nonnull JMethod method) throws Exception { if (method.isNative() || method.isAbstract()) { return; } Visitor visitor = new Visitor(method, preserveJls); visitor.accept(method); <|startfocus|> if (visitor.request != null) { visitor.request.commit(); } <|endfocus|> } } 
<|startcomment|> Uses CstBoolean.make(true) ? it is probably safe since we use CstBoolean at line 913 to represent boolean. <|endcomment|>  || unary.getType() == JPrimitiveTypeEnum.INT.getType() || unary.getType() == JPrimitiveTypeEnum.LONG.getType(); opcode = Rops.opNot(srcRegisterSpec); break; } case NOT: { // Since Dalvik code does not have NOT operator, we will use // x = y ^ true to represent x = !y assert unary.getType() == JPrimitiveTypeEnum.BOOLEAN.getType(); addInstruction( new PlainCstInsn( <|startfocus|> Rops.opXor(sources), unarySrcPos, destReg, sources, CstInteger.make(1))); <|endfocus|> return; } default: { throw new AssertionError("Unary operation not supported."); } } addInstruction(new PlainInsn(opcode, unarySrcPos, destReg, sources));
<|startcomment|> Returns <|endcomment|>  for (int i = 0; i < size(); i++) { if (!isMultipleOrNonLiteralValue(getRawValue(i))) { return true; } } return false; } /** Returns true if there are multiple values, or the value is non-literal */ public final boolean isMultipleOrNonLiteralValue(@Nonnegative int arg) { return isMultipleOrNonLiteralValue(getRawValue(arg)); } /** <|startfocus|> * Return the consolidated single value. Note that the value may be null. <|endfocus|> * Should only be called if isMultipleOrNonLiteralValue() returns false. */ @CheckForNull public final JValueLiteral getConsolidatedValue(@Nonnegative int arg) { assert !isMultipleOrNonLiteralValue(arg); return getRawValue(arg); } /** Update tracked values with the new expression list */ public final void updateWith(@Nonnull List<JExpression> args) { int size = size(); assert size == args.size(); for (int i = 0; i < size; i++) { mergeWith(i, asLiteral(args.get(i))); } }
<|startcomment|> Ditto. <|endcomment|>  System.out.println("Deadlock test main thread bailing."); System.out.println("A initialized: " + aInitialized); System.out.println("B initialized: " + bInitialized); System.exit(0); } } class A { static { System.out.println("A initializing..."); try { Main.barrier.await(); } catch (Exception e) { } new B(); System.out.println("A initialized"); Main.aInitialized = true; } } class B { static { <|startfocus|> System.out.println("B initializing..."); <|endfocus|> try { Main.barrier.await(); } catch (Exception e) { } new A(); System.out.println("B initialized"); Main.bInitialized = true; } } 
<|startcomment|> To make it even simpler, I would also remove the interface. You can introduce it in the plugin that exercises the @ImplementationName. <|endcomment|>  * limitations under the License. */ package com.android.jack.sample.structureprinting; import com.android.jack.ir.ast.JDefinedClassOrInterface; import com.android.jack.ir.ast.JField; import com.android.jack.ir.ast.JMethod; import com.android.jack.ir.formatter.BinarySignatureFormatter; import com.android.jack.ir.formatter.TypeAndMethodFormatter; import com.android.sched.util.config.ThreadConfig; import java.io.PrintWriter; import javax.annotation.Nonnull; /** * Lists all types and members in text format. */ <|startfocus|> public class TextTypeAndMemberWriter implements TypeAndMemberWriter { <|endfocus|> @Nonnull private static final TypeAndMethodFormatter formatter = BinarySignatureFormatter.getFormatter(); @Nonnull private final PrintWriter writer; public TextTypeAndMemberWriter() { writer = ThreadConfig.get(StructurePrinter.STRUCTURE_PRINTING_FILE).getPrintWriter(); } @Override public void write(@Nonnull JDefinedClassOrInterface type) { writer.print(formatter.getName(type)); writer.println(":"); } @Override public void write(@Nonnull JField field) { writer.print(formatter.getName(field.getType())); writer.print(" ");
<|startcomment|> Based on the style guide: For javaDoc sentence should start with a third person descriptive verb. Remove "To" Also have the first sentence as the description. Return the more descriptive detail to new lines below. <|endcomment|>  new UiSelector().resourceIdMatches(Res.SETTINGS_LIST_CONTAINER_RES) ); itemList.setAsVerticalList(); UiObject item = itemList.getChildByText( new UiSelector().className("android.widget.TextView"), "Apps" ); item.clickAndWaitForNewWindow(); } /** <|startfocus|> * To show all the system apps for API >= 23, clicks "Show system" text option from the * "More options" drop down. For APIs <= 22 scrolls to the last tab to select "All" option. <|endfocus|> * * @param instrumentation see {@link android.test.InstrumentationTestCase#getInstrumentation() * getInstrumentation} * @throws UiObjectNotFoundException if it fails to find a UI widget. */ public static void openSystemAppList(Instrumentation instrumentation) throws UiObjectNotFoundException { UiDevice device = UiDevice.getInstance(instrumentation); // Launch the "Apps" page. openAppList(instrumentation); if (SystemUtil.getApiLevel() > 22) { // From "More options" drop down click "Show system" device.pressMenu();
<|startcomment|> do we want a test where testBClass is loaded with loaderA? <|endcomment|>  public static String runClassLoaderNamespaces() throws Exception { String apkPath = getTargetPath("android.jni.cts"); String nativePath = getNativePath("android.jni.cts"); PathClassLoader loaderA = new PathClassLoader( apkPath, nativePath, ClassLoader.getSystemClassLoader()); Class<?> testAClass = loaderA.loadClass("android.jni.cts.ClassNamespaceA"); PathClassLoader loaderB = new PathClassLoader( apkPath, nativePath, ClassLoader.getSystemClassLoader()); Class<?> testBClass = loaderB.loadClass("android.jni.cts.ClassNamespaceB"); <|startfocus|> int globalA = invokeGetGlobal(testAClass); <|endfocus|> int globalB = invokeGetGlobal(testBClass); if (globalA != 0 || globalB != 0) { return "Expected globals to be 0/0: globalA=" + globalA + " globalB=" + globalB; } invokeIncrementGlobal(testAClass); globalA = invokeGetGlobal(testAClass); globalB = invokeGetGlobal(testBClass); if (globalA != 1 || globalB != 0) {
<|startcomment|> i think it will be more readable if this extracted into a local variable. <|endcomment|>  */ final long currentTime = System.currentTimeMillis(); if (time <= currentTime) { parkState = ParkState.UNPARKED; } else { long delayMillis = time - currentTime; // Long.MAX_VALUE / NANOS_PER_MILLI (0x8637BD05SF6) is the largest // long value that won't overflow to negative value when // multiplyed by NANOS_PER_MILLI (10^6). <|startfocus|> if (delayMillis > (Long.MAX_VALUE / NANOS_PER_MILLI)) { delayMillis = (Long.MAX_VALUE / NANOS_PER_MILLI); <|endfocus|> } parkFor$(delayMillis * NANOS_PER_MILLI); } } } } 
<|startcomment|> Used extensively, consider moving into a separate field of 'candidate'. <|endcomment|>  params.get(i).getType(), params.get(i).getModifier() | JModifier.SYNTHETIC, (JMethodBody) candidate.target.getBody()); prologue.parameterMap.put(params.get(i), local); JMethodBody enclosingBody = candidate.callSiteMethodBody; assert enclosingBody != null; tr.append(new AddJLocalInMethodBody(local, enclosingBody)); tr.append( new AppendBefore( candidate.callSiteStmt, new JExpressionStatement( candidate.callSite.getSourceInfo(), new JAsgOperation( <|startfocus|> candidate.callSite.getSourceInfo(), local.makeRef(candidate.callSite.getSourceInfo()), <|endfocus|> arg)))); } if (prologue.targetThis != null) { JLocal local = new JLocal( candidate.callSite.getSourceInfo(), ".inline_this", prologue.targetThis.getType(), JModifier.SYNTHETIC, (JMethodBody) candidate.target.getBody()); JMethodBody enclosingBody = candidate.callSiteMethodBody; assert enclosingBody != null; tr.append(new AddJLocalInMethodBody(local, enclosingBody)); tr.append( new AppendBefore( candidate.callSiteStmt,
<|startcomment|> nit: line limit exceeded <|endcomment|>  * has called startActivityForResult. * * This method must not be called before Acitivity.finish() was called. * * @return */ @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public Instrumentation.ActivityResult getActivityResult() { T activity = getActivity(); assertThat("Activity did not finish, getActivityResult must not called before the activity finished " + "(activity destroyed: " + activity.isDestroyed() + ")", activity.isFinishing()); try { <|startfocus|> Field resultCodeField = Activity.class.getDeclaredField("mResultCode"); <|endfocus|> resultCodeField.setAccessible(true); Field resultDataField = Activity.class.getDeclaredField("mResultData"); resultDataField.setAccessible(true); return new Instrumentation.ActivityResult((int) resultCodeField.get(activity), (Intent) resultDataField.get(activity)); } catch (NoSuchFieldException e) { throw new RuntimeException("Looks like the Android Activity class has changed it's" + "private fields for mResultCode or mResultData. Time to update the reflection code.", e); } catch (Exception e) {
<|startcomment|> Remove, I guess? <|endcomment|>  File sourceDir = AbstractTestTools.getTestRootDir("com.android.jack.liboflib.lib2"); toolchain.addProperty(TracerFactory.TRACER.getName(), "stat-only"); toolchain.addProperty("sched.tracer.file", "/usr/local/google/home/benoitlamarche/stat.out"); // toolchain.addProperty(StatsTracerFtl.TRACER_DIR.getName(), "/usr/local/google/home/benoitlamarche/statdir"); // toolchain.addProperty(ScheduleInstance.DEFAULT_RUNNER.getName(), "single-threaded"); toolchain.addToClasspath(defaultClasspath) .srcToLib(libOfLibOut, /* zipFiles = */ true, sourceDir); <|startfocus|> toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); <|endfocus|> File libOut = AbstractTestTools.createTempFile("libOut", toolchain.getLibraryExtension()); sourceDir = AbstractTestTools.getTestRootDir("com.android.jack.liboflib.lib"); toolchain.addToClasspath(defaultClasspath) .addToClasspath(libOfLibOut) .srcToLib(libOut, /* zipFiles = */ true, sourceDir); toolchain = AbstractTestTools.getCandidateToolchain(JackBasedToolchain.class); File mainOut = AbstractTestTools.createTempFile("mainOut", toolchain.getLibraryExtension());
<|startcomment|> I find this a little hard to read, I find the following easier, but it is subjective. if (!isDst || dstAmount != 0) { <|endcomment|>  } // If the time zone matched uses the same name // (abbreviation) for both standard and daylight time, // let the time zone in the Calendar decide which one. // // Also if tz.getDSTSaving() returns 0 for DST, use tz to // determine the local time. (6645292) boolean isDst = timeType.value == TimeZoneFormat.TimeType.DAYLIGHT; int dstAmount = isDst ? timeZone.getDSTSavings() : 0; <|startfocus|> if (!(isDst && dstAmount == 0)) { <|endfocus|> calb.clear(Calendar.ZONE_OFFSET).set(Calendar.DST_OFFSET, dstAmount); } return position.getIndex(); } /** * find time zone 'text' matched zoneStrings and set to internal * calendar. */ private int subParseZoneStringFromSymbols(String text, int start, CalendarBuilder calb) { boolean useSameName = false; // true if standard and daylight time use the same abbreviation. TimeZone currentTimeZone = getTimeZone(); // At this point, check for named time zones by looking through
<|startcomment|> tabs <|endcomment|>  boolean matchesDescription(Description description) { <|startfocus|> // TODO(JUnit4.10) - because JUnit 4.10 has no separation of display name and unique method <|endfocus|> // id, we need to do some mangling of the name to get a match String displayName = description.getDisplayName(); int endIndex = displayName.lastIndexOf("(", displayName.length() - 1); String uniqueName = (endIndex == - 1) ? displayName : displayName.substring(0, endIndex); return uniqueName.equals(uniqueMethodId);
<|startcomment|> Remove it <|endcomment|>  protected void fillRtTestInfos() { rtTestInfos.add(ADVANCEDTEST); rtTestInfos.add(CFGTEST); rtTestInfos.add(FASTPATH); rtTestInfos.add(SIMPLETEST); <|startfocus|> rtTestInfos.add(SHORTCONDITION); <|endfocus|>
<|startcomment|> toLowerCase(Locale.US) <|endcomment|>  public static boolean hasExtension(String extension) { if (extension == null || extension.isEmpty()) { return false; } <|startfocus|> extension = extension.toLowerCase(); <|endfocus|> return extensionToMimeTypeMap.containsKey(extension);
<|startcomment|> Change from "menu_dial_string" to "menu_dial" because it causes build error. <|endcomment|>  public void showPopUp() { <|startfocus|> getMenu().add(0, MENU_DIAL, 0, getString(R.string.menu_dial_string)); <|endfocus|> getMenu().add(0, MENU_EDIT, 0, getString(R.string.menu_edit)); setOnMenuItemClickListener(mMenuItemListener); show();
<|startcomment|> "Inline methods annotated with @ForceInline" <|endcomment|>  .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class) .addCategory(Private.class); } /** * A {@link Feature} that represents inlining of methods based on @ForceInline annotations. */ @HasKeyId @Description("Inline methods with @ForceInline annotation") public static class InlineAnnotatedMethods implements Feature { @Nonnull public static final BooleanPropertyId ENABLE = BooleanPropertyId.create( "jack.optimizations.force-inline-annotation", "Uses @ForceInline annotation") <|startfocus|> .addDefaultValue(Boolean.FALSE) <|endfocus|> .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class); } /** * A {@link Feature} that represents field value propagation optimization. */ @HasKeyId @Description("Apply field value propagation optimization") public static class FieldValuePropagation implements Feature { @Nonnull public static final BooleanPropertyId ENABLE = BooleanPropertyId .create("jack.optimization.field-value-propagation", "Apply field value propagation optimization") .addDefaultValue(Boolean.FALSE) .addCategory(DumpInLibrary.class) .addCategory(PrebuiltCompatibility.class) .addCategory(Private.class); @Nonnull
<|startcomment|> idem <|endcomment|> import com.android.sched.util.log.stats.StatisticId; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.List; import javax.annotation.CheckForNull; import javax.annotation.Nonnegative; import javax.annotation.Nonnull; /** * Jayce internal reader implementation. */ public class JayceInternalReaderImpl implements JayceInternalReader { @Nonnull public static final StatisticId<Percent> SKIPPED_TYPE_STRUCTURE = new StatisticId<Percent>( <|startfocus|> "jack.jayce-to-nnode.ndeclaredtype.skipped", "Type structure reading skipped by the reader", <|endfocus|> PercentImpl.class, Percent.class); @Nonnull public static final StatisticId<Percent> SKIPPED_BODY = new StatisticId<Percent>( "jack.jayce-to-nnode.body.skipped", "Method body reading skipped by the reader", PercentImpl.class, Percent.class); @Nonnull private final Tokenizer tokenizer; @Nonnull private NodeLevel nodeLevel = NodeLevel.FULL; @CheckForNull private NDeclaredType type; @CheckForNull private String currentFileName; @Nonnegative private int currentLine; @Nonnull
<|startcomment|> I think the use of LocalVarCreator could help you (here and below) 1) According to the code here, if you inline N method calls to the same target method, you will have N JLocal with the same name. The LocalVarCreator would avoid that because it generates unique JLocal names (using an increasing index). 2) The name of your JLocal should be wrapped by NamingTools.getNonSourceConflictingName. It ensures the name will not conflict. LocalVarCreator uses this helper. 3) The enclosing method body of this JLocal should be 'candidate.callSiteMethodBody', the method body of the call site, right? The LocalVarCreator needs to be recreated each time you visit a new JMethod. <|endcomment|>  List<JParameter> params = candidate.target.getParams(); for (int i = 0; i < candidate.callSite.getArgs().size(); i++) { JExpression arg = candidate.callSite.getArgs().get(i); JLocal local = new JLocal( src, ".inline_param_" + params.get(i).getName(), params.get(i).getType(), params.get(i).getModifier() | JModifier.SYNTHETIC, (JMethodBody) candidate.target.getBody()); prologue.parameterMap.put(params.get(i), local); JMethodBody enclosingBody = candidate.callSiteMethodBody; assert enclosingBody != null; tr.append(new AddJLocalInMethodBody(local, enclosingBody)); <|startfocus|> tr.append( new AppendBefore( candidate.callSiteStmt, new JExpressionStatement( src, new JAsgOperation( src, local.makeRef(src), arg)))); <|endfocus|> } if (prologue.targetThis != null) { JLocal local = new JLocal( src, ".inline_this", prologue.targetThis.getType(), JModifier.SYNTHETIC,
<|startcomment|> From your other change, it looks like you require this buffer to be Direct. Is that to avoid having to copy the buffer ? I wonder if we can ever avoid copying the buffer because apps can write to the underlying memory (even if if dexBuffer.isReadOnly()).. For now, maybe you'll want to throw here if !dexBuffer.isDirect() || !dexBuffer.isReadOnly() <|endcomment|>  public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) { super(parent); <|startfocus|> this.pathList = new DexPathList(this, dexPath, librarySearchPath, null); if (reporter != null) { reporter.report(this.pathList.getDexPaths()); } <|endfocus|>
<|startcomment|> Shouldn't this be assertNull? <|endcomment|>  public void testGetAlgorithmParameterSpec() { byte[] salt = new byte[] {1, 2, 3, 4, 5}; int iterationCount = 10; // Check that the constructor works with a null AlgorithmParameterSpec and it's correctly // returned in the getter. PBEParameterSpec pbeps = new PBEParameterSpec(salt, iterationCount, null); assertEquals("The returned AlgorithmParameterSpec is not equal to the specified " + "in the constructor.", <|startfocus|> null, pbeps.getParameterSpec()); <|endfocus|> // Check that a non-null AlgorithmParameterSpec is returned correctly. AlgorithmParameterSpec aps = new IvParameterSpec(new byte[16]); pbeps = new PBEParameterSpec(salt, iterationCount, aps); assertEquals("The returned AlgorithmParameterSpec is not equal to the specified " + "in the constructor.", aps, pbeps.getParameterSpec());
<|startcomment|> constant? <|endcomment|>  public SourceInfo create(int startCol, int endCol, @Nonnegative int startLine, @Nonnegative int endLine, @Nonnull String fileName) { <|startfocus|> FileSourceInfo fileSourceInfo = create(fileName); if (startLine <= 0) { assert endLine <= 0; return fileSourceInfo; } <|endfocus|> LineSourceInfo lineSourceOrigin = create(startLine, endLine, fileSourceInfo); if (startCol <= 0) { assert endCol <= 0; return lineSourceOrigin; } ColumnSourceInfo newInstance = new ColumnSourceInfo(lineSourceOrigin, startCol, endCol); ColumnSourceInfo canonical = canonicalColumnSourceInfos.get(newInstance); assert canonical == null || (newInstance != canonical && newInstance.equals(canonical)); if (canonical != null) { return canonical; } else { ColumnSourceInfo previousValue = canonicalColumnSourceInfos.putIfAbsent(newInstance, newInstance); if (previousValue != null) { newInstance = previousValue; } return newInstance; }
<|startcomment|> why is this not a Pair<Provider, T> ? <|endcomment|>  private final A fst; private final B snd; Pair(A fst, B snd) { this.fst = fst; this.snd = snd; } } /* Holder class for the provider parameter and the parameter for the operation. */ private class ProviderAndOperationParameter<T> { private final Provider provider; private final T operationParameters; ProviderAndOperationParameter(Provider p, T o) { provider = p; operationParameters = o; } } private static final Consumer<ProviderAndOperationParameter<Pair<String, String>>> PUT = (ProviderAndOperationParameter<Pair<String, String>> provAndParam) -> { <|startfocus|> provAndParam.provider.put(provAndParam.operationParameters.fst, provAndParam.operationParameters.snd); <|endfocus|> }; private static final Consumer<ProviderAndOperationParameter<Map<String, String>>> PUT_ALL = (ProviderAndOperationParameter<Map<String, String>> provAndParam) -> provAndParam.provider.putAll(provAndParam.operationParameters); private static final Consumer<ProviderAndOperationParameter<String>> REMOVE = (ProviderAndOperationParameter<String> provAndParam) -> provAndParam.provider.remove(provAndParam.operationParameters); 
<|startcomment|> // Check the decoder with behavior common to both RFC4648 table 1 and table 2 decoding. <|endcomment|>  // ignore the padding int endIndex = encodedBytes.length; while (endIndex > 0 && encodedBytes[endIndex - 1] == '=') { endIndex--; } for (byte b : Arrays.copyOfRange(encodedBytes, 0, endIndex)) { char c = (char) b; actualAlphabet.add(c); } assertEquals(expectedAlphabet, actualAlphabet); } public void testDecoder_extraChars_basic() throws Exception { <|startfocus|> Decoder basicDecoder = Base64.getDecoder(); checkDecoder_extraChars_strict(basicDecoder); <|endfocus|> // Table 1 chars assertBad(basicDecoder, "_aGVsbG8sIHdvcmx"); assertBad(basicDecoder, "aGV_sbG8sIHdvcmx"); assertBad(basicDecoder, "aGVsbG8sIHdvcmx_"); } public void testDecoder_extraChars_url() throws Exception { Decoder urlDecoder = Base64.getUrlDecoder(); checkDecoder_extraChars_strict(urlDecoder); // Table 2 chars. assertBad(urlDecoder, "/aGVsbG8sIHdvcmx"); assertBad(urlDecoder, "aGV/sbG8sIHdvcmx"); assertBad(urlDecoder, "aGVsbG8sIHdvcmx/"); } 
<|startcomment|> static <|endcomment|>  checkRoundTrip_wrapInputStream(encoder, decoder); } public void testRoundTrip_wrap_url() throws Exception { Encoder encoder = Base64.getUrlEncoder(); Decoder decoder = Base64.getUrlDecoder(); checkRoundTrip_wrapInputStream(encoder, decoder); } /** * Checks that the {@link Decoder#wrap(InputStream) wrapping} an * InputStream of encoded data yields the plain data that was * previously {@link Encoder#encode(byte[]) encoded}. */ <|startfocus|> private void checkRoundTrip_wrapInputStream(Encoder encoder, Decoder decoder) <|endfocus|> throws IOException { Random random = new Random(32176L); int[] writeLengths = { -10, -5, -1, 0, 1, 1, 2, 2, 3, 10, 100 }; // Test input needs to be at least 2048 bytes to fill up the // read buffer of Base64InputStream. byte[] plain = new byte[4567]; random.nextBytes(plain); byte[] encoded = encoder.encode(plain); byte[] actual = new byte[plain.length * 2]; int b; 
<|startcomment|> Please move this into StringResource in a similar way <|endcomment|>  public String resourceToString(@NotNull String key, @NotNull Locale locale) { <|startfocus|> StringResource stringResource = myKeyToResourceMap.get(key); assert stringResource != null; <|endfocus|> ResourceItem item = stringResource.getLocaleToTranslationMap().get(locale); return item == null ? "" : resourceToString(item);
<|startcomment|> This should be unnecessary as FilesSetup is a rule so any initialization and cleanup should be done in its Statement implementation and so will have been called already. <|endcomment|>  /** * CTS doesn't allow creating files in the test directory, however, Vogar allows creation of * new files in the test directory. Therefore, for the tests which don't require write * permission, dummyPath would serve the purpose, however, for the others, {@link * FilesSetup#getTestDirPath()} should be used. */ private static final Path dummyPath = Paths.get("dummyPath"); <|startfocus|> @Before public void setup() throws Exception { filesSetup.setUp(); } @After public void tearDown() throws Exception { filesSetup.tearDown(); } <|endfocus|> @Test public void test_getFileSystem() { assertTrue(dummyPath.getFileSystem().provider() instanceof sun.nio.fs.LinuxFileSystemProvider); } @Test public void test_isAbsolute() { assertFalse(dummyPath.isAbsolute()); Path absolutePath = dummyPath.toAbsolutePath(); assertTrue(absolutePath.isAbsolute()); } @Test public void test_getRoot() { assertEquals(Paths.get("/"), dummyPath.toAbsolutePath().getRoot());
<|startcomment|> private final. Rename this to string. <|endcomment|>  public ResourceItemEntry(@NotNull ResourceItem resourceItem, @NotNull String stringRepresentation) { myResourceItem = resourceItem; <|startfocus|> myStringRepresentation = stringRepresentation; <|endfocus|>
<|startcomment|> @Nonnegative int columnIdx <|endcomment|>  } @Nonnull public StatisticId<? extends Statistic> getId() { return id; } @Override @Nonnull public String toString() { return id.getName(); } public boolean isEnabled() { return false; } // // Adapter for deprecated API // @Nonnull @Deprecated public final String getDescription(int columnIdx) { return getDataView().getDataNames()[columnIdx]; } @Nonnull @Deprecated <|startfocus|> public final String getType(int columnIdx) { <|endfocus|> switch (getDataView().getDataTypes()[columnIdx]) { case STRING: case BUNDLE: return "string"; case BOOLEAN: case DURATION: case NUMBER: case PERCENT: case QUANTITY: return "number"; case LIST: case NOTHING: case STRUCT: throw new AssertionError(getDataView().getDataTypes()[columnIdx].toString()); } throw new AssertionError(getDataView().getDataTypes()[columnIdx].toString()); } @Nonnull @Deprecated public final Object getValue(@Nonnegative int columnIdx) {
<|startcomment|> should be -> is? <|endcomment|>  // The following depend on the user setting of "Use 24-Hour Format". As there is no nice // way of checking that setting in order to determine what the expected result should be // this simply checks the result against both the expected 12 and 24 hour results. That // does mean it will not detect if the 12 hour format accidentally uses the 24 hour format <|startfocus|> // or vice versa but that should be checked in libcore tests. <|endfocus|> check12And24HourFormat("5:30:15 AM", "05:30:15", DateUtils.formatSameDayTime(fixedTime + HOUR_DURATION, fixedTime, java.text.DateFormat.FULL, java.text.DateFormat.DEFAULT)); check12And24HourFormat("5:30:15 AM", "05:30:15", DateUtils.formatSameDayTime(fixedTime + HOUR_DURATION, fixedTime, java.text.DateFormat.FULL, java.text.DateFormat.MEDIUM)); check12And24HourFormat("5:30 AM", "05:30", DateUtils.formatSameDayTime(fixedTime + HOUR_DURATION, fixedTime, java.text.DateFormat.FULL, java.text.DateFormat.SHORT));
<|startcomment|> Will we find a better one? Can we terminate the loop? <|endcomment|>  Collection<TimeZoneNames.MatchInfo> matches = tzNames.find(text, start, NAME_TYPES); for (TimeZoneNames.MatchInfo match : matches) { if (bestMatch == null || bestMatch.matchLength() < match.matchLength()) { bestMatch = match; } else if (bestMatch.matchLength() == match.matchLength()) { if (currentTimeZoneID.equals(match.tzID())) { // Prefer the currently set timezone over other matches, even if they are // the same length. <|startfocus|> bestMatch = match; <|endfocus|> } else if (match.mzID() != null) { if (currentTzMetaZoneIds == null) { currentTzMetaZoneIds = tzNames.getAvailableMetaZoneIDs(currentTimeZoneID); } if (currentTzMetaZoneIds.contains(match.mzID())) { bestMatch = match; } } } } if (bestMatch == null) { // No match found, return error. return 0; } } String tzId = bestMatch.tzID(); if (tzId == null) {
<|startcomment|> wait, isn't this conditional on setting the feature on? you presubmit passed though <|endcomment|>  /// CHECK-NEXT: <<Length:i\d+>> ArrayLength [<<Array>>] is_string_length:false emitted_at_use:true loop:none /// CHECK-NEXT: <<CheckedIndex:i\d+>> BoundsCheck [<<Index>>,<<Length>>] <|startfocus|> /// CHECK-NEXT: mov <<LengthReg:\w+>>, [<<BaseReg:\w+>> + 8] /// CHECK-NEXT: and <<LengthReg>>, <<CompressionFlag:\d+>> /// CHECK-NEXT: cmp <<LengthReg>>, e<<IndexReg:\w+>> <|endfocus|> /// CHECK: <<ArraySet:v\d+>> ArraySet [<<Array>>,<<Index>>,<<Value>>] /// CHECK-NEXT: mov [<<BaseReg>> + r<<IndexReg>> * 4 + 12], 9 static void testArrayLengthBoundsCheckX86(int[] array, int index) { array[index] = 9; } } 
<|startcomment|> Just curious, instead of having this API, would it make more sense to pass the necessary parameters to the implementation of NetworkEvaluator constructor (on creation), since each NetworkEvaluator implementation might requires different dependencies. For example, an upcoming PasspointNetworkEvaluator might not need WifiConfigManager but will need PasspointManager. <|endcomment|>  * @param currentBssid BSSID of the current connected network or null if * disconnected * @param connected a flag to indicate if WifiStateMachine is in connected * state * @param untrustedNetworkAllowed a flag to indidate if untrusted networks like <|startfocus|> * ephemeral networks are allowed <|endfocus|> * @param connectableNetworks a list of the ScanDetail and WifiConfiguration * pair which is used by the WifiLastResortWatchdog * @return configuration of the chosen network; * null if no network in this category is available. */ @Nullable WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks); } private final NetworkEvaluator[] mEvaluators = new NetworkEvaluator[MAX_NUM_EVALUATORS]; // A helper to log debugging information in the local log buffer, which can // be retrieved in bugreport. private void localLog(String log) { mLocalLog.log(log); } 
<|startcomment|> not needed <|endcomment|>  public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, WifiNetworkScoreCache scoreCache, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) { if (scoreCache == null) { localLog("has no network score cache."); return null; } final ExternalScoreTracker externalScoreTracker = new ExternalScoreTracker(mLocalLog); <|startfocus|> ArrayList<NetworkKey> unscoredNetworks = new ArrayList<NetworkKey>(); <|endfocus|> for (ScanDetail scanDetail : scanDetails) { ScanResult scanResult = scanDetail.getScanResult(); Integer score; // One ScanResult can be associated with more than one networks, hence we calculate all // the scores and use the highest one as the ScanResult's score. // TODO(b/31065385): WifiConfigManager does not support passpoint networks currently. // So this list has just one entry always. List<WifiConfiguration> associatedConfigs = null; WifiConfiguration associatedConfig = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail); if (associatedConfig != null) { associatedConfigs =
<|startcomment|> extra line <|endcomment|>  assertEquals(ALL_LOOKUP_MODES & ~(PROTECTED | PRIVATE), siblingLookup.lookupModes()); // The new lookup isn't in the same package, so it loses all its privileges except // for public. MethodHandles.Lookup nonSibling = defaultLookup.in(Vector.class); assertEquals(PUBLIC, nonSibling.lookupModes()); // Special case, sibling inner classes in the same parent class MethodHandles.Lookup inner2 = Inner1.lookup.in(Inner2.class); assertEquals(PUBLIC | PRIVATE | PACKAGE, inner2.lookupModes()); <|startfocus|> <|endfocus|> try { MethodHandles.lookup().in(null); fail(); } catch (NullPointerException expected) { } // Callers cannot change the lookup context to anything within the java.lang.invoke package. try { MethodHandles.lookup().in(MethodHandle.class); fail(); } catch (IllegalArgumentException expected) { }
<|startcomment|> can this not be final as well? <|endcomment|>  import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * This class is the WifiNetworkSelector.NetworkEvaluator implementation for * externally scored networks. */ public class ExternalScoreEvaluator implements WifiNetworkSelector.NetworkEvaluator { private static final String NAME = "WifiExternalScoreEvaluator"; private static final String TAG = NAME; private final WifiConfigManager mWifiConfigManager; private final Clock mClock; private final LocalLog mLocalLog; private NetworkScoreManager mScoreManager; private WifiNetworkScoreCache mScoreCache; <|startfocus|> <|endfocus|> ExternalScoreEvaluator(Context context, WifiConfigManager configManager, Clock clock, LocalLog localLog) { mWifiConfigManager = configManager; mClock = clock; mLocalLog = localLog; mScoreManager = (NetworkScoreManager) context.getSystemService(Context.NETWORK_SCORE_SERVICE); if (mScoreManager != null) { mScoreCache = new WifiNetworkScoreCache(context); mScoreManager.registerNetworkScoreCache(NetworkKey.TYPE_WIFI, mScoreCache); } else { Log.e(TAG, "Couldn't get NETWORK_SCORE_SERVICE."); mScoreCache = null; } } 
<|startcomment|> I don't think this is correct style. <|endcomment|> <|startfocus|> public static Boolean[] WrapArray(boolean[] array) { <|endfocus|> Boolean[] wrappedArray = new Boolean[array.length]; Arrays.setAll(wrappedArray, n -> array[n]); return wrappedArray;
<|startcomment|> To avoid this allocation all the time, let's have the caller pass in the ArraySet to use and we can .clear it before using in this method. The caller should use a class variable like final ArraySet<BroadcastQueue> mTmpReceivingBroadcast = new ArraySet<BroadcastQueue>(); to avoid the allocation. <|endcomment|>  private ArraySet<BroadcastQueue> isReceivingBroadcast(ProcessRecord app) { final ArraySet<BroadcastQueue> queues = new ArraySet<BroadcastQueue>(); if (app.curReceivers.size() > 0) { for (BroadcastRecord r : app.curReceivers) { <|startfocus|> queues.add(r.queue); <|endfocus|> } return queues; } // It's not the current receiver, but it might be starting up to become one synchronized (this) { for (BroadcastQueue queue : mBroadcastQueues) { BroadcastRecord r = queue.mPendingBroadcast; if (r != null && r.curApp == app) { // found it; report which queue it's in queues.add(queue); } } } return queues;
<|startcomment|> Unused import <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.conscrypt; import java.io.File; import java.io.FileWriter; import java.security.KeyStore; import java.security.MessageDigest; import java.security.Principal; import java.security.cert.Certificate; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; <|startfocus|> import java.util.ArrayList; <|endfocus|> import java.util.Arrays; import java.util.List; import javax.net.ssl.SSLPeerUnverifiedException; import javax.net.ssl.SSLSession; import javax.net.ssl.SSLSessionContext; import javax.net.ssl.X509TrustManager; import junit.framework.TestCase; import libcore.java.security.TestKeyStore; public class TrustManagerImplTest extends TestCase { /** * Ensure that our non-standard behavior of learning to trust new * intermediate CAs does not regress. http://b/3404902 */ public void testLearnIntermediate() throws Exception { // chain3 should be server/intermediate/root
<|startcomment|> locale -> uncategorized or legacy locale...? <|endcomment|> <|startfocus|> public Locales(Locale locale, Locale displayLocale, Locale formatLocale) { this.locale = locale; <|endfocus|> this.displayLocale = displayLocale; this.formatLocale = formatLocale;
<|startcomment|> Here too. <|endcomment|>  defaultWriteFields(obj, slotDesc); } } } /** * Fetches and writes values of serializable fields of given object to * stream. The given class descriptor specifies which field values to * write, and in which order they should be written. */ private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException { <|startfocus|> Class<?> cl = desc.forClass(); if (cl != null && obj != null && !cl.isInstance(obj)) { throw new ClassCastException(); } <|endfocus|> desc.checkDefaultSerialize(); int primDataSize = desc.getPrimDataSize(); if (primVals == null || primVals.length < primDataSize) { primVals = new byte[primDataSize]; } desc.getPrimFieldValues(obj, primVals); bout.write(primVals, 0, primDataSize, false); ObjectStreamField[] fields = desc.getFields(false); Object[] objVals = new Object[desc.getNumObjFields()]; int numPrimFields = fields.length - objVals.length; desc.getObjFieldValues(obj, objVals);
<|startcomment|> Make these Strings static final while you're here. <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package libcore.java.io; import java.io.InputStream; import java.util.Vector; import java.io.IOException; import java.io.SequenceInputStream; import tests.support.Support_ASimpleInputStream; public class OldSequenceInputStreamTest extends junit.framework.TestCase { Support_ASimpleInputStream simple1, simple2; SequenceInputStream si; <|startfocus|> String s1 = "Hello"; String s2 = "World"; <|endfocus|> public void test_available() throws IOException { assertEquals("Returned incorrect number of bytes!", s1.length(), si.available()); simple2.throwExceptionOnNextUse = true; assertTrue("IOException on second stream should not affect at this time!", si.available() == s1.length()); simple1.throwExceptionOnNextUse = true; try { si.available(); fail("IOException not thrown!"); } catch (IOException e) { // expected } } public void test_close2() throws IOException { simple1.throwExceptionOnNextUse = true; try { si.close();
<|startcomment|> Not sure about the case, can give an example ? From what I remember the Jack IR does not have implicit return. Thus, all calls that should be follow by instruction and thus requires a returnTarget. <|endcomment|>  JExpression expr = returnStmt.getExpr(); JStatement newStmt; if (expr != null) { if (returnLocal == null) { newStmt = new JExpressionStatement(info, cloneExpression(expr)); } else { newStmt = new JExpressionStatement(info, new JAsgOperation(info, returnLocal.makeRef(info), cloneExpression(expr))); } curBlocks.peek().addStmt(newStmt); updateCatchBlockList(newStmt, returnStmt); } <|startfocus|> if (returnTarget == null) { newStmt = new JReturnStatement(info, null); } else { newStmt = new JGoto(info, returnTarget); } statement = updateCatchBlockList(newStmt, returnStmt); <|endfocus|> return false;
<|startcomment|> method ? <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.optimizations.inlining; import com.android.jack.ir.ast.JMethod; import com.android.jack.ir.ast.JMethodCall; import com.android.sched.item.Description; import com.android.sched.marker.Marker; import com.android.sched.marker.ValidOn; import javax.annotation.Nonnull; /** * Marker instruct Jack to inline a specific function. */ <|startfocus|> @Description("Marker instruct Jack to inline a specific function.") <|endfocus|> @ValidOn(value = {JMethodCall.class}) public class InlineMarker implements Marker { @Nonnull private final JMethod target; public InlineMarker(@Nonnull JMethod target) { this.target = target; } @Nonnull public JMethod getTarget() { return target; } @Override @Nonnull public Marker cloneIfNeeded() { return this; } } 
<|startcomment|> After discussion, let's go with a default value at -1. We will modify that if required in a future release. <|endcomment|>  public int getShutdownDelay() { <|startfocus|> return getDelay(ConfigFile.SHUTDOWN_PROPERTY, 6 * 60 * 60); <|endfocus|>
<|startcomment|> This comment should use standard "Android-changed" terminology. Please fix. Please also consider adding a test to verify that this type doesn't change, e.g.: // Check that the compile time type of keySet() is Set, // as opposed to KeySetView or some other subclass that // would make the following fail to compile: interface CustomSet extends Set {} ... public void test...() { try { CustomSet hashSet = (CustomSet) map.keySet(); } catch (ClassCastException expected) { fail(); } } (Or does the API check already catch this?) <|endcomment|>  * {@link KeySetView}. * * <p>The view's iterators and spliterators are * <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>. * * <p>The view's {@code spliterator} reports {@link Spliterator#CONCURRENT}, * {@link Spliterator#DISTINCT}, and {@link Spliterator#NONNULL}. * * @return the set view */ <|startfocus|> // NOTE: The upstream version of this function returns KeySetView (See http://b/28099367). <|endfocus|> public Set<K> keySet() { KeySetView<K,V> ks; return (ks = keySet) != null ? ks : (keySet = new KeySetView<K,V>(this, null)); } /** * Returns a {@link Collection} view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. The collection * supports element removal, which removes the corresponding
<|startcomment|> >No<SslFallback, perhaps. <|endcomment|>  TestSSLContext testSSLContext = createDefaultTestSSLContext(); SSLSocketFactory serverSocketFactory = new LimitedProtocolsSocketFactory( testSSLContext.serverContext.getSocketFactory(), enabledProtocols); SSLSocketFactory clientSocketFactoryDelegate = new LimitedProtocolsSocketFactory( testSSLContext.clientContext.getSocketFactory(), enabledProtocols); checkNoFallbackOnFailedHandshake(serverSocketFactory, clientSocketFactoryDelegate, enabledProtocols); } public void testSslFallback_defaultProtocols() throws Exception { <|startfocus|> // Will need to be updated if the enabled protocols in Android's SSLSocketFactory change String[] expectedEnabledProtocols = { "TLSv1.2", "TLSv1.1", "TLSv1" }; <|endfocus|> TestSSLContext testSSLContext = createDefaultTestSSLContext(); SSLSocketFactory serverSocketFactory = testSSLContext.serverContext.getSocketFactory(); SSLSocketFactory clientSocketFactoryDelegate = testSSLContext.clientContext.getSocketFactory(); checkNoFallbackOnFailedHandshake(serverSocketFactory, clientSocketFactoryDelegate, expectedEnabledProtocols); } private static void assertSslSocket(TlsFallbackDisabledScsvSSLSocket socket, boolean expectedWasFallbackScsvSet, String... expectedEnabledProtocols) { Set<String> enabledProtocols = new HashSet<String>(Arrays.asList(socket.getEnabledProtocols()));
<|startcomment|> no empty blocks: follow K & R style ... { return smsAddress; } https://engdoc.corp.google.com/eng/doc/devguide/java/styleguide.shtml?cl=head#s4.1.2-blocks-k-r-style <|endcomment|>  return description; } public Result setDescription(String description) { this.description = description; return this; } public String getRequestBody() { return requestBody; } public Result setRequestBody(String requestBody) { this.requestBody = requestBody; return this; } public String getWindowHierarchy() { return windowHierarchy; } public Result setWindowHierarchy(String windowHierarchy) { this.windowHierarchy = windowHierarchy; return this; } <|startfocus|> public String getSmsAddress() {return smsAddress; } <|endfocus|> public Result setSmsAddress(String smsAddress) { this.smsAddress = smsAddress; return this; } public String getSmsTextMessage() {return smsTextMessage; } public Result setSmsTextMessage(String smsTextMessage) { this.smsTextMessage = smsTextMessage; return this; } } 
<|startcomment|> Tobias and I have generally moved to calling methods like this "check....", unless they're simple enough to be called "assert....". Makes it easier to detect what are tests and what are support methods (and avoid confusion in the JUnit4 world / parameterized tests, etc.). Here it actually looks like it's a straight assert: assertEntriesEqual(T[] expectedEntries, Map<Integer, String> map) While here, you don't need to use a generic param. Java's going to throw a fit *somewhere* (probably at array creation time, should suppress with @SuppressWarnings on the new Map.Entry[5], etc.), but you can happily make the param of type Map.Entry<Integer, String>[] without issues once that's out the way, and then lose the cast here. <|endcomment|>  private <T> void testEntrySetToArray(Map<Integer, String> map, T[] entries) { HashSet<Integer> seenKeys = new HashSet<>(); <|startfocus|> for (int i = 0; i < map.size(); ++i) { Map.Entry<Integer, String> e = (Map.Entry<Integer, String>) entries[i]; assertEquals(map.get(e.getKey()), e.getValue()); <|endfocus|> seenKeys.add(e.getKey()); } assertEquals(map.size(), seenKeys.size());
<|startcomment|> Missing Javadoc description for this interface. <|endcomment|> import android.media.Rating; import android.media.VolumeProvider; import android.media.session.PlaybackState; import android.media.session.MediaSession; import android.media.session.MediaSession.QueueItem; import android.net.Uri; import android.os.Bundle; import android.os.Handler; import android.os.Looper; import android.os.Message; import android.os.RemoteException; import android.os.ResultReceiver; import android.text.TextUtils; import android.util.Log; import android.view.KeyEvent; import java.lang.ref.WeakReference; import java.util.ArrayList; import java.util.List; <|startfocus|> public interface MediaController { <|endfocus|> @Nullable public static MediaController wrap(@Nullable android.media.session.MediaController delegate) { return (delegate != null) ? new MediaControllerImpl(delegate) : null; } public android.media.session.MediaController getWrappedInstance(); public @NonNull TransportControls getTransportControls(); public boolean dispatchMediaButtonEvent(@NonNull KeyEvent keyEvent); public @Nullable PlaybackState getPlaybackState(); public @Nullable MediaMetadata getMetadata(); public @Nullable List<MediaSession.QueueItem> getQueue(); public @Nullable CharSequence getQueueTitle(); public @Nullable Bundle getExtras();
<|startcomment|> idem <|endcomment|>  } catch (IOException stopException) { logger.log(Level.SEVERE, "Cannot close the service processor: ", stopException); } } if (adminProcessor != null) { try { adminProcessor.stop(); } catch (IOException stopException) { logger.log(Level.SEVERE, "Cannot close the admin processor: ", stopException); } } shutdown(); throw e; } } /** * Check that given file or directory is accessible only by {@link #currentUser}. */ <|startfocus|> private void checkAccess(@Nonnull File file) throws IOException { FileAccess fileAccess = FileAccess.get(file); <|endfocus|> fileAccess.checkAccessibleOnlyByOwner(); fileAccess.checkOwner(currentUser); } private void refreshPEMFiles(@Nonnull KeyStore keystoreServer, @Nonnull KeyStore keystoreClient) throws IOException, UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException, CannotCreateFileException, CannotChangePermissionException { { File clientPEM = new File(getServerDir(), PEM_CLIENT); PEMWriter pem = new PEMWriter(clientPEM); try {
<|startcomment|> same - instanceof? <|endcomment|>  public boolean equals(Object thatObject) { if (this == thatObject) { return true; } <|startfocus|> if (thatObject == null || getClass() != thatObject.getClass()) { <|endfocus|> return false; } UserCredential that = (UserCredential) thatObject; return TextUtils.equals(username, that.username) && TextUtils.equals(password, that.password) && eapType == that.eapType && TextUtils.equals(nonEapInnerMethod, that.nonEapInnerMethod);
<|startcomment|> Let's add @GuardedBy("mLock"). (Right, Adam?) <|endcomment|>  private DisplayManager mDisplayManager; private PowerManager mPowerManager; private IBatteryStats mBatteryStats; private final SparseArray<UserUsageStatsService> mUserState = new SparseArray<>(); private File mUsageStatsDir; long mRealTimeSnapshot; long mSystemTimeSnapshot; boolean mAppIdleEnabled; boolean mAppIdleParoled; private boolean mScreenOn; private long mLastAppIdleParoledTime; private volatile boolean mPendingOneTimeCheckIdleStates; private boolean mSystemServicesReady = false; @GuardedBy("mLock") private AppIdleHistory mAppIdleHistory; <|startfocus|> <|endfocus|> private ArrayList<UsageStatsManagerInternal.AppIdleStateChangeListener> mPackageAccessListeners = new ArrayList<>(); private boolean mHaveCarrierPrivilegedApps; private List<String> mCarrierPrivilegedApps; public UsageStatsService(Context context) { super(context); } @Override public void onStart() { mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE); mUserManager = (UserManager) getContext().getSystemService(Context.USER_SERVICE); mPackageManager = getContext().getPackageManager(); mHandler = new H(BackgroundThread.get().getLooper()); 
<|startcomment|> typo: gzip <|endcomment|>  * a ZipOutputStream will do that. */ public void testNoCloseInReadTrialerDueToRead() throws IOException { byte[] data = new byte[128]; final boolean[] closedHolder = new boolean[]{false}; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try (ZipOutputStream zipOutputStream = new ZipOutputStream(byteArrayOutputStream)) { zipOutputStream.putNextEntry(new ZipEntry("entry1")); <|startfocus|> try (GZIPOutputStream gzizOutputStream = new GZIPOutputStream(zipOutputStream)) { gzizOutputStream.write(data); <|endfocus|> } } ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()) { @Override public void close() throws IOException { closedHolder[0] = true; } }; try (ZipInputStream zipInputStream = new ZipInputStream(byteArrayInputStream)) { zipInputStream.getNextEntry(); try (InputStream in = new GZIPInputStream(zipInputStream)) { assertEquals(128, in.skip(256)); assertFalse(closedHolder[0]); } assertTrue(closedHolder[0]); } } 
<|startcomment|> Should you check that in the loop? In theory, we allow overflow and going back to 0... <|endcomment|>  long result = 0; for (int i = 0; i < 10000; i++) { try { result += (Long)m.invoke(null); } catch (InvocationTargetException e) { if (!(e.getCause() instanceof NullPointerException)) { throw e; } } } // Not compilable methods should not increase their hotness counter. // The golden file expects this to be 0. <|startfocus|> hotnessCounter = getHotnessCounter(c, "errMethod"); System.out.println(hotnessCounter); <|endfocus|> } public static native int getHotnessCounter(Class cls, String method_name); } 
<|startcomment|> Nit: This is the only class in this directory whose name does not start with a capital letter. <|endcomment|>  */ public void testDebugContextK() { setupDebugContext(); Soob.forEach_write_k(AUnused); // Write to invalid location. // Flush messages through the pipeline. mRS.sendMessage(RS_MSG_TEST_FLUSH, null); waitForMessage(); Soob.destroy(); assertTrue(mRanErrorHandler); // The context is dead at this point so make sure it's not reused RenderScript.releaseAllContexts(); } /** * Helper for rsAllocationCopy tests */ <|startfocus|> protected class setupAllocationCopyTests { DebugContext DB; <|endfocus|> int Width; int Height; int ArrLen; Allocation aIn; Allocation aOut; Random RN; setupAllocationCopyTests(DebugContext db, int dimension, int size, Function<RenderScript, Type.Builder> TB) { setupDebugContext(); DB = db; RN = new Random(0x172d8ab9); Width = RN.nextInt(size); Height = RN.nextInt(size); if (dimension == 1) { ArrLen = Width; } else { ArrLen = Width * Height; } 
<|startcomment|> nit <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.multidex.test004.jack; public class Unused { <|startfocus|> /** * */ public Unused() { // TODO(yroussel): Auto-generated constructor stub } <|endfocus|> } 
<|startcomment|> how do you know this permission denial isn't due to selinux ? It's best to use a temporary file in a controlled location instead of /sdcard . That way you know for sure that the file is accessible. <|endcomment|>  // and whenever a thread makes the system call, android.system.ErrnoException // (EPERM - Operation not permitted) will be raised. public void testExistsOnSystem() throws ErrnoException { assertEquals("SECCOMP filter is not installed.", 0, installSeccompFilter()); try { android.system.Os.stat("/sdcard"); fail("Seccomp filter didn't obstruct stat call."); } catch (android.system.ErrnoException expected) { assertEquals(OsConstants.EPERM, expected.errno); } <|startfocus|> File sh = new File("/sdcard"); assertTrue(sh.exists()); <|endfocus|> } private static native int installSeccompFilter(); // http://b/25859957 // // OpenJdk is treating empty parent string as a special case, // it substitutes parent string with the filesystem default parent value "/" // This wasn't the case before the switch to openJdk. public void testEmptyParentString() { File f1 = new File("", "foo.bar"); File f2 = new File((String)null, "foo.bar"); assertEquals("foo.bar", f1.toString());
<|startcomment|> I don't understand this comment. What does "not used" mean? Do you mean "the mtime field is not set"? I don't understand what "since we HAVE to set the time" refers to? <|endcomment|>  entries.add(zipEntry = new ZipEntry("test_setTime")); zipEntry.setTime(0); assertNotNull(mtimeField.get(zipEntry)); entries.add(zipEntry = new ZipEntry("test_setLastModifiedTime")); zipEntry.setLastModifiedTime(FileTime.fromMillis(1000)); // Set creation time AND check that last-modified time is not used // for 1980<x<2099 (since we HAVE to set time) entries.add(zipEntry = new ZipEntry("test_setCreationTime")); <|startfocus|> zipEntry.setTime(someTimestampBefore2099); assertNull(mtimeField.get(zipEntry)); <|endfocus|> zipEntry.setCreationTime(FileTime.fromMillis(1000)); // Set last access time AND check that last-modified time is used // for x>2099 (since we HAVE to set time) entries.add(zipEntry = new ZipEntry("test_setLastAccessTime")); zipEntry.setTime(someTimestampAfter2099); assertNotNull(mtimeField.get(zipEntry)); zipEntry.setLastAccessTime(FileTime.fromMillis(3000)); for (ZipEntry entry : entries) { zos.putNextEntry(entry); zos.write(data.getBytes()); zos.closeEntry(); }
<|startcomment|> Nit: Unneeded blank line? <|endcomment|>  aIn.copyFrom(inArray); aOut.copyFrom(outArray); } // Setup script environment if (dimension == 1) { Soob.set_aIn1D(aIn); Soob.set_aOut1D(aOut); } else { Soob.set_aIn2D(aIn); Soob.set_aOut2D(aOut); } } protected void finishAllocationCopyTests() { mRS.finish(); // Flush messages through the pipeline. mRS.sendMessage(RS_MSG_TEST_FLUSH, null); waitForMessage(); Soob.destroy(); } <|startfocus|> <|endfocus|> } /** * 1D copy - things should work under DebugContext if given * legitimate arguments */ public void testDebugContextRsAllocationCopy1D_Byte_Normal() { SetupAllocationCopyTests AC = new SetupAllocationCopyTests(1, 512, (RenderScript rs)-> new Type.Builder(rs, Element.I8(rs)), 0x172d8ab9); int Offset = AC.RN.nextInt(AC.Width); int Count = AC.RN.nextInt(AC.Width - Offset); Soob.set_dstXOff(Offset); Soob.set_srcXOff(Offset);
<|startcomment|> I can see that numberOfComponents < 0 here would lead to the negative array size you mention in line 2215, however I have insufficient information to judge whether this is the right way to fix this. I'm trying to find you the right reviewer; in the meantime, how would you feel about a) Expand your commit message: Be more specific about which field has an invalid value and point to the EXIF format specification for how that field should be interpreted b) perhaps expand coverage of ExifInterfaceTest to this case using your "crafted jpeg file"? <|endcomment|>  if (DEBUG) { Log.d(TAG, String.format("hint: %d, tagNumber: %d, tagName: %s, dataFormat: %d, " + "numberOfComponents: %d", hint, tagNumber, tag != null ? tag.name : null, dataFormat, numberOfComponents)); } if (tag == null || dataFormat <= 0 || <|startfocus|> dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length || numberOfComponents < 0) { // Skip if the parsed tag number is not defined or invalid data format or invalid // number of components. <|endfocus|> if (tag == null) { Log.w(TAG, "Skip the tag entry since tag number is not defined: " + tagNumber); } else if (dataFormat <= 0 || dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length) { Log.w(TAG, "Skip the tag entry since data format is invalid: " + dataFormat); } else { Log.w(TAG, "Skip the tag entry since number of components is invalid: " + numberOfComponents); }
<|startcomment|> Is "sleep" guaranteed to be found on all the various test environments? If you look at shell() it goes to some trouble to handle different cases. This might just be working because the CWD contains the sleep command. There's probably no PATH handling, because that's shell behavior. <|endcomment|>  } finally { process.destroy(); } } /** * Tests that a child process can INHERIT this parent process's * stdin / stdout / stderr file descriptors. */ public void testRedirectInherit() throws Exception { // We can't run shell() here because that exits when run with INHERITed // file descriptors from this process; "sleep" is less picky. Process process = new ProcessBuilder() <|startfocus|> .command("sleep", "5") // in seconds <|endfocus|> .redirectInput(Redirect.INHERIT) .redirectOutput(Redirect.INHERIT) .redirectError(Redirect.INHERIT) .start(); try { List<Long> parentInodes = Arrays.asList( Os.fstat(FileDescriptor.in).st_ino, Os.fstat(FileDescriptor.out).st_ino, Os.fstat(FileDescriptor.err).st_ino); long childPid = getChildProcessPid(process); // Get the inode numbers of the ends of the symlink chains List<Long> childInodes = Arrays.asList( Os.stat("/proc/" + childPid + "/fd/0").st_ino,
<|startcomment|> Same comment as above. <|endcomment|>  when(mockContext.getSystemService(Context.TELEPHONY_SERVICE)) .thenReturn(mockTelephony); when(mockContext.getSystemService(Context.USER_SERVICE)) .thenReturn(mockUserService); BluetoothMapContentObserver observer; try { // The constructor of BluetoothMapContentObserver calls initMsgList observer = new BluetoothMapContentObserver(mockContext, null, mockMas, null, true); } catch(RemoteException e) { fail("Failed to created BluetoothMapContentObserver object"); } catch(SQLiteException e) { fail("Threw SQLiteException instead of failing cleanly"); } <|startfocus|> <|endfocus|>
<|startcomment|> Dot on next line. <|endcomment|>  return input; } @Override protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) { return input; } } // http://b/32643789, check that CipherSpi.engineGetOutputSize is called and applied // to output buffer size before calling CipherSpi.egineUpdate(byte[],int,int,byte[],int). public void testCipherOutputSizeChange() throws Exception { <|startfocus|> Constructor<Cipher> c = Cipher.class. getDeclaredConstructor(CipherSpi.class, Provider.class, String.class); c.setAccessible(true); <|endfocus|> CipherSpi cipherSpi = new CipherSpiWithGrowingOutputSize(100); Provider provider = mock(Provider.class); Cipher cipher = c.newInstance(cipherSpi, provider, "mock/mock/mock"); cipher.init(Cipher.DECRYPT_MODE, key, iv); try (InputStream is = new CipherInputStream(new ByteArrayInputStream(new byte[1024]), cipher)) { byte[] buffer = new byte[512]; // engineGetOutputSize return 100, engineUpdate expects buf >= 100 assertEquals(100, is.read(buffer)); // engineGetOutputSize return 101, engineUpdate expects buf >= 101
<|startcomment|> nit: These comments are incorrect now. <|endcomment|>  public void testCipherOutputSizeChange() throws Exception { Provider mockProvider = new MockProvider(); Cipher cipher = Cipher.getInstance("GrowingOutputSize", mockProvider); cipher.init(Cipher.DECRYPT_MODE, key, iv); InputStream mockEncryptedInputStream = new ByteArrayInputStream(new byte[1024]); try (InputStream is = new CipherInputStream(mockEncryptedInputStream, cipher)) { byte[] buffer = new byte[1024]; // engineGetOutputSize return 100, engineUpdate expects buf >= 100 assertEquals(512, is.read(buffer)); <|startfocus|> // engineGetOutputSize return 101, engineUpdate expects buf >= 101 <|endfocus|> // and will throw ShortBufferException buffer is smaller. assertEquals(513, is.read(buffer)); } } } 
<|startcomment|> One line please <|endcomment|>  * @param nsdServiceInfo The service info to check * @return True if service is supported by the print service plugin */ boolean matchesCriteria(NsdServiceInfo nsdServiceInfo); } /** Printer identifiers of the mPrinters found. */ @GuardedBy("mLock") private final @NonNull HashSet<String> mPrinters; /** Service types discovered by this plugin */ private final @NonNull HashSet<String> mServiceTypes; /** Context of the user of this plugin */ <|startfocus|> private final @NonNull Context mContext; <|endfocus|> /** mDNS services filter */ private final @NonNull PrinterFilter mPrinterFilter; /** * Call back to report the number of mPrinters found. * * We assume that {@link #start} and {@link #stop} are never called in parallel, hence it is * safe to not synchronize access to this field. */ private @Nullable PrintServicePlugin.PrinterDiscoveryCallback mCallback; /** Queue used to resolve nsd infos */ private final @NonNull NsdResolveQueue mResolveQueue; /**
<|startcomment|> Replace enum with static int constants <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.server.wifi.hotspot2; import android.text.TextUtils; import com.android.server.wifi.hotspot2.Utils; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; /** * Utility class for matching domain names. */ public class DomainMatcher { <|startfocus|> /** * Match status. */ public enum Match {None, Primary, Secondary} <|endfocus|> /** * The root of the Label tree. */ private final Label mRoot; /** * Label tree representation for the domain name. Labels are delimited by "." in the domain * name. * * For example, the tree representation of "android.google.com" as a primary domain: * [com, None] -> [google, None] -> [android, Primary] * */ private static class Label { private final Map<String, Label> mSubDomains; private Match mMatch; Label(Match match) {
<|startcomment|> g -> G (and throughout, will stop commenting about this, please fix generally) <|endcomment|>  // Create FileChannel from FileOutputStream created from FileDescriptor FileChannel fc = fosFromFd.getChannel(); // Invalidate FileDescriptor fos.close(); assertFalse(fd.valid()); // Close FileOutputStream and therefore close the FileChannel. // Without the fix for b/27351214 this will throw an exception // due to channel preClosing the file descriptor after it's // closed. fosFromFd.close(); } <|startfocus|> public void test_closeguardSupport_open_without_append() throws IOException { <|endfocus|> File tmpFile = File.createTempFile("file", "txt"); try (FileOutputStream fos = new FileOutputStream(tmpFile)) { FileDescriptor fd = fos.getFD(); String path = tmpFile.getPath(); try (FileChannel fc = FileChannelImpl.open(fd, path, false, true, fos)) { guardRule.assertUnreleasedResourceCount(fc, 1); } } } public void test_closeguardSupport_open_with_append() throws IOException { File tmpFile = File.createTempFile("file", "txt"); try (FileOutputStream fos = new FileOutputStream(tmpFile)) {
<|startcomment|> vary <|endcomment|>  // Read each TryItem into a MutatableTryBlock. for (TryItem tryItem : codeItem.tries) { MTryBlock mTryBlock = new MTryBlock(); // Get the MInsns that form the start and end of the try block. int startLocation = tryItem.startAddr; mTryBlock.startInsn = insnLocationMap.get(startLocation); <|startfocus|> // The instructions wary in size, so we have to find last instruction in the block in a few tries. <|endfocus|> int endLocation = tryItem.startAddr + tryItem.insnCount - 1; mTryBlock.endInsn = insnLocationMap.get(endLocation); while ((mTryBlock.endInsn == null) && (endLocation >= startLocation)) { endLocation--; mTryBlock.endInsn = insnLocationMap.get(endLocation); } // Sanity checks. if (mTryBlock.startInsn == null) { Log.errorAndQuit(String.format( "Couldn't find a mutatable insn at start offset 0x%x", startLocation)); } if (mTryBlock.endInsn == null) { Log.errorAndQuit(String.format(
<|startcomment|> Can this be a lambda? <|endcomment|>  private void startNextJob() { if (mJobs.isEmpty() || mCurrent != null) return; mCurrent = mJobs.remove(0); <|startfocus|> mCurrent.start(new Callback<LocalPrintJob>() { @Override public void onCallback(LocalPrintJob job) { mCurrent = null; startNextJob(); } <|endfocus|> });
<|startcomment|> This does not call back on the main thread, how inconvenient <|endcomment|>  public void onDiscoveryStopped(String s) { if (DEBUG) Log.d(TAG, "onDiscoveryStopped"); // On the main thread, notify loss of all known printers <|startfocus|> mMainHandler.post(new Runnable() { @Override public void run() { allPrintersLost(); } }); <|endfocus|>
<|startcomment|> Is this needed? <|endcomment|> import android.content.Intent; import android.content.IntentFilter; import android.database.ContentObserver; import android.net.wifi.WifiManager; import android.os.Handler; import android.os.Looper; import android.provider.Settings; import com.android.internal.annotations.VisibleForTesting; import java.io.FileDescriptor; import java.io.PrintWriter; /** * Handles enabling Wi-Fi for the Wi-Fi Wakeup feature. * @hide */ final class WifiWakeupController { private Context mContext; private final FrameworkFacade mFrameworkFacade; <|startfocus|> private final WifiInjector mWifiInjector; <|endfocus|> private final Handler mHandler; @VisibleForTesting final ContentObserver mContentObserver; @VisibleForTesting boolean mWifiWakeupEnabled; WifiWakeupController(Context context, Looper looper, FrameworkFacade frameworkFacade, WifiInjector wifiInjector) { mContext = context; mFrameworkFacade = frameworkFacade; mWifiInjector = wifiInjector; IntentFilter filter = new IntentFilter(); filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION); filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION); mHandler = new Handler(looper); mContext.registerReceiver(mBroadcastReceiver, filter, null, mHandler);
<|startcomment|> Does this need the check on sigSpi != null? <|endcomment|>  public SignatureSpi getCurrentSpi() { <|startfocus|> if (lock == null && sigSpi != null) { <|endfocus|> // sigSpi was assigned in constructor. // No need synchronized protection in this case. return sigSpi; } synchronized (lock) { return sigSpi; }
<|startcomment|> typo: non-wifi <|endcomment|>  assertNotNull("Could not get active network", info); // If the active network is not metered it has to be a WiFi for us to be // able to enable metering. if (info.getType() == ConnectivityManager.TYPE_WIFI) { return true; } <|startfocus|> // If the network is not WiFi it is only treated as if metering can be // disabled if metering is already disabled. Metering cannot be disabled // on on-WiFi networks where metering is enabled. return !mCm.isActiveNetworkMetered(); <|endfocus|> } /** * Puts the device in a state where the active network is metered, or fail if it can't achieve * that state. */ protected void setMeteredNetwork() throws Exception { assertTrue(canUseMeteredNetwork()); final NetworkInfo info = mCm.getActiveNetworkInfo(); final boolean metered = mCm.isActiveNetworkMetered(); if (metered) { Log.d(TAG, "Active network already metered: " + info); return; } else {
<|startcomment|> these are pretty much identical except passing a different bit of data and calling a different callback. Can we combine these two with a activationType parameter (still two callbacks). <|endcomment|> <|startfocus|> public void notifyVoiceActivationStateChangedForPhoneId(int phoneId, int subId, int activationState) { if (!checkNotifyPermission("notifyVoiceActivationState()")){ <|endfocus|> return; } if (VDBG) { log("notifyVoiceActivationStateForPhoneId: subId=" + subId + " phoneId=" + phoneId + " state=" + activationState); } synchronized (mRecords) { if (validatePhoneId(phoneId)) { mVoiceActivationState[phoneId] = activationState; for (Record r : mRecords) { if (VDBG) { log("notifyVoiceActivationStateForPhoneId: r=" + r + " subId=" + subId + " phoneId=" + phoneId + " state=" + activationState); } if (r.matchPhoneStateListenerEvent( PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) && idMatch(r.subId, subId, phoneId)) { try { if (DBG) { log("notifyVoiceActivationStateForPhoneId: callback.onVASC r=" + r + " subId=" + subId + " phoneId=" + phoneId
<|startcomment|> idem <|endcomment|>  public void endTraceSeed(@Nonnull JField field) { composedStatus.pop(); <|startfocus|> for (TracerBrush config : brushes) { config.endTraceSeed(field); <|endfocus|> }
<|startcomment|> this should be handed the WifiAwareStateManager instead of WifiInjector <|endcomment|> <|startfocus|> public WifiAwareNative(WifiInjector wifiInjector, boolean doRegistration) { sWifiAwareStateManager = wifiInjector.getWifiAwareStateManager(); <|endfocus|> if (doRegistration) { registerAwareNatives(); }
<|startcomment|> nit: ideally we want to use bit operations like (1 << 0 | 1 << 1) <|endcomment|>  * B0 B1 B2 B3 B4 - B7 */ public class HSWanMetricsElement extends ANQPElement { public static final int LINK_STATUS_RESERVED = 0; public static final int LINK_STATUS_UP = 1; public static final int LINK_STATUS_DOWN = 2; public static final int LINK_STATUS_TEST = 3; @VisibleForTesting public static final int EXPECTED_BUFFER_SIZE = 13; @VisibleForTesting <|startfocus|> public static final int LINK_STATUS_MASK = 0x3; <|endfocus|> @VisibleForTesting public static final int SYMMETRIC_LINK_MASK = 0x4; @VisibleForTesting public static final int AT_CAPACITY_MASK = 0x8; private final int mStatus; private final boolean mSymmetric; private final boolean mCapped; private final long mDownlinkSpeed; private final long mUplinkSpeed; private final int mDownlinkLoad; private final int mUplinkLoad; private final int mLMD; // Load Measurement Duration. @VisibleForTesting public HSWanMetricsElement(int status, boolean symmetric, boolean capped, long downlinkSpeed,
<|startcomment|> how was the value 8 chosen? Does it have any significance? <|endcomment|>  * A ZoneRulesProvider that generates rules from ICU4J TimeZones. * This provider ensures that classes in {@link java.time} use the same time zone information * as ICU4J. */ public class IcuZoneRulesProvider extends ZoneRulesProvider { // Arbitrary upper limit to number of transitions including the final rules. private static final int MAX_TRANSITIONS = 10000; private static final int SECONDS_IN_DAY = 24 * 60 * 60; <|startfocus|> private final BasicLruCache<String, ZoneRules> CACHE = new ZoneRulesCache(8); <|endfocus|> @Override protected Set<String> provideZoneIds() { return new HashSet<>(Arrays.asList(TimeZone.getAvailableIDs())); } @Override protected ZoneRules provideRules(String zoneId, boolean forCaching) { // Ignore forCaching, as this is a static provider. return CACHE.get(zoneId); } @Override protected NavigableMap<String, ZoneRules> provideVersions(String zoneId) { return new TreeMap<>( Collections.singletonMap(TimeZone.getTZDataVersion(), provideRules(zoneId, /* forCaching */ false))); } /*
<|startcomment|> Given we check the files in MultiDexExtractror.load, presumably this was all dead code and we never actually saw this exception at runtime? <|endcomment|>  } File dexDir = getDexDir(context, applicationInfo); List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); installSecondaryDexes(loader, dexDir, files); } } catch (Exception e) { Log.e(TAG, "Multidex installation failure", e); throw new RuntimeException("Multi dex installation failed (" + e.getMessage() + ")."); } Log.i(TAG, "install done"); } <|startfocus|> private static ApplicationInfo getApplicationInfo(Context context) throws NameNotFoundException { PackageManager pm; String packageName; <|endfocus|> try { pm = context.getPackageManager(); packageName = context.getPackageName(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a null * base Context. */ Log.w(TAG, "Failure while trying to obtain ApplicationInfo from Context. " + "Must be running in test mode. Skip patching.", e); return null; }
<|startcomment|> 200 seems quite short given this is only treated in join as an upper bound. 200 millis for things like this is occasionally too fast for some slow devices. <|endcomment|>  * connections by shutting down the server thread. * * @return the number of connections that were attempted during the proxy's lifetime */ public int shutdownAndGetConnectionCount() throws IOException, InterruptedException { try { serverSocket.close(); // Check that the server shuts down quickly and gracefully via the expected // code path (as opposed to an uncaught exception). shutdownLatch.await(1, TimeUnit.SECONDS); <|startfocus|> serverThread.join(200); <|endfocus|> assertFalse("serverThread failed to shut down quickly", serverThread.isAlive()); } finally { return connectionAttempts.get(); } } @Override public String toString() { return serverThread.toString() ; } } } 
<|startcomment|> Let's change every reference to Delete to Dismiss, so it's clearer that this means that user dismissed the notification. I realize the PendingIntent is called a deleteIntent, but even the documentation for it mentions user dismissal. <|endcomment|>  private void handleNotificationDeleted() { mNotificationShown = false; <|startfocus|> mRecommendedNetwork = null; <|endfocus|>
<|startcomment|> Consider documenting the fact that |flags| is ignored. <|endcomment|>  */ package com.android.server.wifi.wificond; import android.os.Parcel; import android.os.Parcelable; /** * ChannelSettings for wificond * * @hide */ public class ChannelSettings implements Parcelable { public int frequency; /** public constructor */ public ChannelSettings() { } /** copy constructor */ public ChannelSettings(ChannelSettings source) { frequency = source.frequency; } /** implement Parcelable interface */ @Override public int describeContents() { return 0; } <|startfocus|> /** implement Parcelable interface */ <|endfocus|> @Override public void writeToParcel(Parcel out, int flags) { out.writeInt(frequency); } /** implement Parcelable interface */ public static final Parcelable.Creator<ChannelSettings> CREATOR = new Parcelable.Creator<ChannelSettings>() { @Override public ChannelSettings createFromParcel(Parcel in) { ChannelSettings result = new ChannelSettings(); result.frequency = in.readInt(); return result; } @Override public ChannelSettings[] newArray(int size) { return new ChannelSettings[size]; } }; } 
<|startcomment|> nit: inline initialization <|endcomment|>  * Handles behavior when notification is deleted. */ static final String ACTION_NOTIFICATION_DELETED = "com.android.networkrecommendation.NOTIFICATION_DELETED"; /** * Network recommended by {@link NetworkScoreManager#requestRecommendation}. */ private WifiConfiguration mRecommendedNetwork; private Bitmap mNotificationBadgeBitmap; /** * Whether {@link WifiNotificationController} has been started. */ private final AtomicBoolean mStarted; /** * Runnable to show Failed To Connect notification. */ @VisibleForTesting <|startfocus|> final Runnable mShowFailedToConnectNotificationRunnable; <|endfocus|> private final Context mContext; private final Handler mHandler; private final ContentResolver mContentResolver; private final NetworkScoreManager mScoreManager; private final WifiManager mWifiManager; private final NotificationManager mNotificationManager; private final WifiNotificationHelper mWifiNotificationHelper; private NetworkInfo mNetworkInfo; private NetworkInfo.DetailedState mDetailedState; private volatile int mWifiState; WifiNotificationController(Context context, ContentResolver contentResolver, Handler handler, NetworkScoreManager networkScoreManager, WifiManager wifiManager, NotificationManager notificationManager, WifiNotificationHelper helper) { mContext = context;
<|startcomment|> also log config for context <|endcomment|>  } // convert from string -> action idx list if found a matching entry String[] actions = null; if (!TextUtils.isEmpty(actionStr)) { actions = actionStr.split(INTRA_GROUP_DELIMITER); } if (!ArrayUtils.isEmpty(actions)) { List<Integer> ret = new ArrayList<>(); for (String idx : actions) { try { ret.add(Integer.parseInt(idx)); } catch (NumberFormatException e) { <|startfocus|> Rlog.e(TAG, "NumberFormatException on " + idx); return null; <|endfocus|> } } return ret; } return null;
<|startcomment|> Just "ND offload" is enough. <|endcomment|>  /** @hide */ public static final int WIFI_FEATURE_HAL_EPNO = 0x40000; // WiFi PNO enhanced /** @hide */ public static final int WIFI_FEATURE_RSSI_MONITOR = 0x80000; // RSSI Monitor /** @hide */ public static final int WIFI_FEATURE_MKEEP_ALIVE = 0x100000; // Wifi mkeep_alive /** @hide */ public static final int WIFI_FEATURE_CONFIG_NDO = 0x200000; // ND offload configure /** @hide */ <|startfocus|> public static final int WIFI_FEATURE_TRANSMIT_POWER = 0x400000; // Capture Tx transmit power levels <|endfocus|> /** @hide */ public static final int WIFI_FEATURE_CONTROL_ROAMING = 0x800000; // Enable/Disable firmware roaming /** @hide */ public static final int WIFI_FEATURE_IE_WHITELIST = 0x1000000; // Support Probe IE whitel listing /** @hide */ public static final int WIFI_FEATURE_SCAN_RAND = 0x2000000; // Support MAC & Probe Sequence Number randomization private int getSupportedFeatures() { try { return mService.getSupportedFeatures();
<|startcomment|> Might be worth a comment explaining why it might be null, and why that's ok. Is there a way of asserting in advanced whether this is OK to return null? e.g. if it's size 1 or 0, perhaps...? Not sure of this API myself or the implementations to know whether that's true. I assume it would be bad to return null when it shouldn't - we'd still pass. <|endcomment|>  ArrayList<T> iteration1 = new ArrayList<>(); ArrayList<T> iteration2 = new ArrayList<>(); spliterable.spliterator().forEachRemaining(value -> iteration1.add(value)); spliterable.spliterator().forEachRemaining(value -> iteration2.add(value)); assertEquals(iteration1, iteration2); iteration1.clear(); iteration2.clear(); Spliterator<T> sa = spliterable.spliterator().trySplit(); Spliterator<T> sb = spliterable.spliterator().trySplit(); if (sa == null) { assertNull(sb); <|startfocus|> } else { <|endfocus|> sa.forEachRemaining(value -> iteration1.add(value)); sb.forEachRemaining(value -> iteration2.add(value)); assertEquals(iteration1, iteration2); } } /** * Checks that the specified SIZED Spliterator reports containing the * specified number of elements. */ public static <T> void runSizedTests(Spliterator<T> spliterator, int expectedSize) { assertHasCharacteristics(SIZED, spliterator); assertEquals(expectedSize, spliterator.estimateSize()); assertEquals(expectedSize, spliterator.getExactSizeIfKnown()); } 
<|startcomment|> is this used yet? I tried to find where it was defined before but do not see it. <|endcomment|>  } catch (RemoteException e) { // Not really very much we can do here. } // If TetherMasterSM is in ErrorState, TetherMasterSM stays there. // Thus we give a chance for TetherMasterSM to recover to InitialState // by sending CMD_CLEAR_ERROR if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) { mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who); } int which; switch (state) { case IControlsTethering.STATE_UNAVAILABLE: case IControlsTethering.STATE_AVAILABLE: <|startfocus|> which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE; <|endfocus|> break; case IControlsTethering.STATE_TETHERED: case IControlsTethering.STATE_LOCAL_HOTSPOT: which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE; break; default: Log.wtf(TAG, "Unknown interface state: " + state); return; } mTetherMasterSM.sendMessage(which, state, 0, who); sendTetherStateChangedBroadcast();
<|startcomment|> I suggest: private String[] copy(String[] a) { return Arrays.copyOf(a, a.length); } public String[] getTetherableUsbRegexs() { return copy(mConfig.tetherableUsbRegexs); } ... There is only one mConfig read, so it ensures that array and array length are consistent. <|endcomment|> <|startfocus|> private void tetherMatchingInterfaces(Mode mode, int interfaceType) { if (VDBG) { Log.d(TAG, "tetherMatchingInterfaces(" + mode.description + ", " + interfaceType + ")"); } <|endfocus|> String[] ifaces = null; try { ifaces = mNMService.listInterfaces(); } catch (Exception e) { Log.e(TAG, "Error listing Interfaces", e); return; } String chosenIface = null; if (ifaces != null) { for (String iface : ifaces) { if (ifaceNameToType(iface) == interfaceType) { chosenIface = iface; break; } } } if (chosenIface == null) { Log.e(TAG, "could not find iface of type " + interfaceType); return; } int result = (mode != Mode.IDLE ? tether(chosenIface, mode) : untether(chosenIface)); if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) { Log.e(TAG, "unable start or stop tethering on iface " + chosenIface); return; }
<|startcomment|> Do we need this here? If the wif HALi service is not up for some reason, this might cause errors. We should only wait for the service manager callback to invoke this method. <|endcomment|>  private void initializeInternal() { initIServiceManagerIfNecessary(); <|startfocus|> initIWifiIfNecessary(); <|endfocus|>
<|startcomment|> needless whitespace difference against upstream here, please make this consistent with upstream <|endcomment|>  } // !Double.isInfinite(value) && !Double.isNaN(value) private void print(StringBuilder sb, double value, Locale l, Flags f, char c, int precision, boolean neg) throws IOException { if (c == Conversion.SCIENTIFIC) { // Create a new FormattedFloatingDecimal with the desired // precision. int prec = (precision == -1 ? 6 : precision); FormattedFloatingDecimal fd <|startfocus|> = FormattedFloatingDecimal.valueOf(value, prec, FormattedFloatingDecimal.Form.SCIENTIFIC); <|endfocus|> char[] mant = addZeros(fd.getMantissa(), prec); // If the precision is zero and the '#' flag is set, add the // requested decimal point. if (f.contains(Flags.ALTERNATE) && (prec == 0)) mant = addDot(mant); char[] exp = (value == 0.0) ? new char[] {'+','0','0'} : fd.getExponent(); int newW = width; if (width != -1) newW = adjustWidth(width - exp.length - 1, f, neg);
<|startcomment|> Consider using an interface in order to increase your lambda github score, unless there are good chance that additional methods are needed here. <|endcomment|>  * observing a new SIM card having been loaded. * * @hide */ public class SimChangeListener { private static final String TAG = SimChangeListener.class.getSimpleName(); private static final boolean DBG = false; private final Context mContext; private final Handler mTarget; private final AtomicInteger mSimBcastGenerationNumber; private final Callback mCallback; private BroadcastReceiver mBroadcastReceiver; <|startfocus|> public static class Callback { public void onSimCardLoaded() {} } public SimChangeListener(Context ctx, Handler handler, Callback cb) { <|endfocus|> mContext = ctx; mTarget = handler; mCallback = cb; mSimBcastGenerationNumber = new AtomicInteger(0); } public int generationNumber() { return mSimBcastGenerationNumber.get(); } public void startListening() { if (DBG) Log.d(TAG, "startListening for SIM changes"); if (mBroadcastReceiver != null) return; mBroadcastReceiver = new SimChangeBroadcastReceiver( mSimBcastGenerationNumber.incrementAndGet()); final IntentFilter filter = new IntentFilter(); filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED); 
<|startcomment|> c <|endcomment|>  */ public IWifiChip getChip(IWifiIface iface) { if (DBG) Log.d(TAG, "getChip: iface(name)=" + getName(iface)); synchronized (mLock) { IfaceCacheEntry cacheEntry = mInterfaceInfoCache.get(iface); if (cacheEntry == null) { Log.e(TAG, "getChip: no entry for iface(name)=" + getName(iface)); return null; } return cacheEntry.chip; } } /** <|startfocus|> * Register an InterfadeDestroyedListener to the specified iface - returns true on success <|endfocus|> * and false on failure. This listener is in addition to the one registered when the interface * was created - allowing non creators to monitor interface status. * * Listener called-back on the specified looper - or on the current looper if a null is passed. */ public boolean registerDestroyedListener(IWifiIface iface, InterfaceDestroyedListener destroyedListener, Looper looper) { if (DBG) Log.d(TAG, "registerDestroyedListener: iface(name)=" + getName(iface)); synchronized (mLock) {
<|startcomment|> reference to ISO 7816-4? Indicate 00 for default behavior. <|endcomment|>  } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges * * @param AID Application id. See ETSI 102.221 and 101.220. <|startfocus|> @ @param p2 P2 paramter. <|endfocus|> * @return an IccOpenLogicalChannelResponse object. */ public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, byte p2) { return iccOpenLogicalChannel(getSubId(), AID, p2); } /** * Opens a logical channel to the ICC card. * * Input parameters equivalent to TS 27.007 AT+CCHO command. * * <p>Requires Permission: * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE} * Or the calling app has carrier privileges. @see #hasCarrierPrivileges *
<|startcomment|> Not sure of this myself, but wouldn't Parcel.createByteArray() let you avoid having to serialize manually the array length ? <|endcomment|>  private IpSecAlgorithm(Parcel in) { mAlgorithm = in.readString(); int len = in.readInt(); <|startfocus|> mKey = new byte[len]; in.readByteArray(mKey); <|endfocus|> mTruncLenBits = in.readInt(); return;
<|startcomment|> . ? <|endcomment|>  public MethodType getMethodType() { // The "nominal" type of a cracked method handle is the same as the type <|startfocus|> // of the handle itself, except in the cases enumerated below : <|endfocus|> MethodType handleType = handle.type(); boolean omitLeadingParam = false; // For constructs, the return type is always void.class, and not the type of // the object returned. if (member instanceof Constructor) { handleType = handleType.changeReturnType(void.class); omitLeadingParam = true; } // For instance field gets/puts and instance method gets/puts, we omit the // leading reference parameter to |this|. switch (handle.getHandleKind()) { case IGET: case IPUT: case INVOKE_INTERFACE: case INVOKE_DIRECT: case INVOKE_VIRTUAL: case INVOKE_SUPER: omitLeadingParam = true; } return omitLeadingParam ? handleType.dropParameterTypes(0, 1) : handleType;
<|startcomment|> No need for type annotation here. <|endcomment|>  * @hide */ public class IpSecAlgorithm implements Parcelable { /** Refer to the ip-xfrm man pages for support-able key types; * however, only keys specified here will be supported. */ public static final String ALGO_AES_CBC = "cbc(aes)"; public static final String ALGO_HMAC_MD5 = "hmac(md5)"; public static final String ALGO_HMAC_SHA1 = "hmac(sha1)"; <|startfocus|> private static final Set<String> ALL_ALGOS = new HashSet<String>( <|endfocus|> Arrays.asList(ALGO_AES_CBC, ALGO_HMAC_MD5, ALGO_HMAC_SHA1)); private final String mAlgorithm; private final byte[] mKey; private final int mTruncLenBits; public IpSecAlgorithm(String algorithm, byte[] key) { this(algorithm, key, key.length * 8); } /** Specify a IpSecAlgorithm of one of the supported types * @param algorithm type for IpSec. * @param key non-null Key padded to a multiple of 8 bits
<|startcomment|> nit: remove <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.jack.java8.parameter.test007; import com.android.jack.java8.parameter.common.ParameterTestModifier; import junit.framework.Assert; import org.junit.Test; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.Parameter; public class Tests { private int field = 0; <|startfocus|> public class InnerClass { <|endfocus|> public void setValue() { field = 10; } } @Test public void testStaticMethod() throws NoSuchMethodException, SecurityException { Method[] methods = Tests.class.getDeclaredMethods(); for (Method method : methods) { if (method.isSynthetic()) { Parameter[] parameters = method.getParameters(); Assert.assertEquals(2, parameters.length); check(parameters[0], "arg0", /* isNamePresent= */ false, /* isImplicit= */ false, /* isSynthetic= */ false, ParameterTestModifier.MODIFIER_NONE);
<|startcomment|> Can we use FileChannel APIs instead of using FileChannelImpl? e.g. FileChannel.open(tmpFile....) <|endcomment|>  // due to channel preClosing the file descriptor after it's // closed. fosFromFd.close(); } public void test_closeGuardSupport_open_without_append() throws IOException { File tmpFile = File.createTempFile("file", "txt"); <|startfocus|> try (FileOutputStream fos = new FileOutputStream(tmpFile)) { FileDescriptor fd = fos.getFD(); String path = tmpFile.getPath(); try (FileChannel fc = FileChannelImpl.open(fd, path, false, true, fos)) { <|endfocus|> guardRule.assertUnreleasedResourceCount(fc, 1); } } } public void test_closeGuardSupport_open_with_append() throws IOException { File tmpFile = File.createTempFile("file", "txt"); try (FileOutputStream fos = new FileOutputStream(tmpFile)) { FileDescriptor fd = fos.getFD(); String path = tmpFile.getPath(); try (FileChannel fc = FileChannelImpl.open(fd, path, false, true, false, fos)) { guardRule.assertUnreleasedResourceCount(fc, 1); } } } 
<|startcomment|> Wrong service type. <|endcomment|>  public IpSecManager(Context context, INetworkManagementService service) { mContext = checkNotNull(context, "missing context"); <|startfocus|> mService = checkNotNull(service, "missing ConnectivityManager"); <|endfocus|>
<|startcomment|> can we add one for softap? <|endcomment|>  if (mP2pThread != null) stopLooper(mP2pThread.getLooper()); mWsmThread = null; mP2pThread = null; mSyncThread = null; mWsmAsyncChannel = null; mWsm = null; } @Test public void createNew() throws Exception { assertEquals("InitialState", getCurrentState().getName()); mWsm.sendMessage(WifiStateMachine.CMD_BOOT_COMPLETED); mLooper.dispatchAll(); assertEquals("InitialState", getCurrentState().getName()); } @Test <|startfocus|> public void loadComponents() throws Exception { <|endfocus|> when(mWifiNative.startHal(anyBoolean())).thenReturn(true); mWsm.setSupplicantRunning(true); mLooper.dispatchAll(); assertEquals("SupplicantStartingState", getCurrentState().getName()); when(mWifiNative.setDeviceName(anyString())).thenReturn(true); when(mWifiNative.setManufacturer(anyString())).thenReturn(true); when(mWifiNative.setModelName(anyString())).thenReturn(true); when(mWifiNative.setModelNumber(anyString())).thenReturn(true); when(mWifiNative.setSerialNumber(anyString())).thenReturn(true);
<|startcomment|> nit. I' not a fan of this new suffix. <|endcomment|> import android.os.HandlerThread; import android.os.RemoteException; import android.util.Log; import java.util.ArrayList; /** * Hal calls for bring up/shut down of the supplicant daemon and for * sending requests to the supplicant daemon * * {@hide} */ public class WifiSupplicantHal { private static final boolean DBG = false; private static final String TAG = "WifiSupplicantHal"; private IServiceManager mIServiceManager = null; // Supplicant HAL interface objects <|startfocus|> private ISupplicant mISupplicantHal; private ISupplicantStaIface mISupplicantStaIfaceHal; <|endfocus|> private final Object mLock = new Object(); private final HandlerThread mHandlerThread; private boolean mInitializationComplete = false; public WifiSupplicantHal(HandlerThread handlerThread) { mHandlerThread = handlerThread; } /** * Registers a service notification for the ISupplicant service, which triggers intialization of * the ISupplicantStaIface * @return true if the service notification was successfully registered */ public boolean initialize() { if (DBG) Log.i(TAG, "Registering ISupplicant service ready callback."); synchronized (mLock) {
<|startcomment|> Here too; suggest using only setPackage() for targeting Settings rather than using the precise setClass() <|endcomment|>  mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM); } if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_TURNING_OFF) { intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED); } else if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) { intent = new Intent(BluetoothAdapter.ACTION_BLE_ACL_DISCONNECTED); } <|startfocus|> debugLog("aclStateChangeCallback: From: " + BluetoothAdapter.nameForState(state) + " to Disconnected: " + device); <|endfocus|> } intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT); mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);
<|startcomment|> seems like this needs to be addressed <|endcomment|>  public static boolean isSupportedDexMagic(byte[] magic) { int api = magicToApi(magic); <|startfocus|> // return api == API_NO_EXTENDED_OPCODES || api == API_CURRENT || api >= 35; // TODO(oth): 35 here is a hack. return true; // TODO(oth): FIX ME. <|endfocus|>
<|startcomment|> Remove the else and move the line below left. <|endcomment|>  public String getLine() { try { byte[] line = getLineAsBytes(); <|startfocus|> if (line == null) { return null; } else if (line.length == 0) { return null; } else { return new String(line, "UTF-8"); } <|endfocus|> } catch (UnsupportedEncodingException e) { Log.w(TAG, e); return null; }
<|startcomment|> :( <|endcomment|>  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package android.telecom.cts; <|startfocus|> import static android.telecom.cts.TestUtils.*; <|endfocus|> import static org.hamcrest.CoreMatchers.not; import static org.hamcrest.CoreMatchers.equalTo; import static org.junit.Assert.assertThat; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.graphics.Color; import android.net.Uri; import android.os.Bundle; import android.os.SystemClock; import android.telecom.Call; import android.telecom.CallAudioState; import android.telecom.Conference; import android.telecom.Connection; import android.telecom.InCallService; import android.telecom.PhoneAccount; import android.telecom.PhoneAccountHandle; import android.telecom.TelecomManager; import android.telecom.VideoProfile;
<|startcomment|> Why mock it? <|endcomment|>  public void test_constructor() { <|startfocus|> IOException mockIOException = mock(IOException.class); DirectoryIteratorException exception = new DirectoryIteratorException(mockIOException); <|endfocus|> assertEquals(mockIOException, exception.getCause()); // When cause is null. try { new DirectoryIteratorException(null); fail(); } catch (NullPointerException expected) {}
<|startcomment|> This needs to false. <|endcomment|>  mNetworkListStoreData.setUserConfigurations(networkList); byte[] expectedData = getTestNetworksXmlBytes(networkList.get(0), networkList.get(1)); assertTrue(Arrays.equals(expectedData, serializeData(false /* shared */))); } /** * Verify that the user configurations are parsed correctly from a XML string containing * test networks (an open and an EAP network). * @throws Exception */ @Test public void deserializeUserConfigurations() throws Exception { <|startfocus|> List<WifiConfiguration> networkList = getTestNetworksConfig(true /* shared */); <|endfocus|> byte[] xmlData = getTestNetworksXmlBytes(networkList.get(0), networkList.get(1)); WifiConfigurationTestUtil.assertConfigurationsEqualForConfigStore( networkList, deserializeData(xmlData, true /* shared */)); } /** * Verify that a XmlPullParserException will be thrown when parsing a <Network> block * containing an unknown tag. * * @throws Exception */ @Test(expected = XmlPullParserException.class) public void parseNetworkWithUnknownTag() throws Exception { String configFormat = "<Network>\n"
<|startcomment|> line too long <|endcomment|>  String line = smapsLines[i]; if (line.startsWith("Shared_Dirty") || line.startsWith("Private_Dirty")) { String lineTrimmed = line.trim(); String[] lineSplit = lineTrimmed.split(" +"); String sizeUsuallyInKb = lineSplit[lineSplit.length - 2]; sizeUsuallyInKb = sizeUsuallyInKb.trim(); if (!sizeUsuallyInKb.equals("0")) { <|startfocus|> System.out.println("ERROR: Memory mapping for " + CLASS_PATH + " is unexpectedly dirty"); <|endfocus|> System.out.println(line); } else { validated = true; } } // VmFlags marks the "end" of an smaps entry. if (line.startsWith("VmFlags")) { break; } } if (validated) { System.out.println("Secondary dexfile mmap is clean"); } else { System.out.println("ERROR: Memory mapping is missing Shared_Dirty/Private_Dirty entries"); } return true;
<|startcomment|> Nit: remove line <|endcomment|>  JCharLiteral jCharLiteral = (JCharLiteral) node; value = jCharLiteral.getValue(); sourceInfo = loader.load(jCharLiteral.getSourceInfo()); } @Override @Nonnull public JCharLiteral exportAsJast(@Nonnull ExportSession exportSession) { assert sourceInfo != null; SourceInfo jSourceInfo = sourceInfo.exportAsJast(exportSession); JCharLiteral jCharLiteral = new JCharLiteral(jSourceInfo, value); return jCharLiteral; } @Override public void readContent(@Nonnull JayceInternalReaderImpl in) throws IOException { value = in.readChar(); <|startfocus|> <|endfocus|> } @Override @Nonnull public Token getToken() { return TOKEN; } @Override @Nonnull public NSourceInfo getSourceInfos() { assert sourceInfo != null; return sourceInfo; } @Override public void setSourceInfos(@Nonnull NSourceInfo sourceInfo) { this.sourceInfo = sourceInfo; } } 
<|startcomment|> unused? <|endcomment|>  // TODO: Possibly move these to IccRecords.java private static final int SYSTEM_EVENT_BASE = 0x100; private static final int EVENT_CARRIER_CONFIG_CHANGED = 1 + SYSTEM_EVENT_BASE; private static final int EVENT_APP_LOCKED = 2 + SYSTEM_EVENT_BASE; private static final int EVENT_SIM_REFRESH = 3 + SYSTEM_EVENT_BASE; <|startfocus|> // maximum time to block waiting for a sychronous operation on the UICC private static final int UICC_MAX_SYNC_WAIT = 2000; <|endfocus|> // Lookup table for carriers known to produce SIMs which incorrectly indicate MNC length. private static final String[] MCCMNC_CODES_HAVING_3DIGITS_MNC = { "302370", "302720", "310260", "405025", "405026", "405027", "405028", "405029", "405030", "405031", "405032", "405033", "405034", "405035", "405036", "405037", "405038", "405039", "405040", "405041", "405042", "405043", "405044", "405045", "405046", "405047", "405750",
<|startcomment|> occurred <|endcomment|>  return; case CONFIG_MULTIPLE_PBC_DETECTED: sendMessage(iface, WPS_FAIL_EVENT, WifiManager.WPS_OVERLAP_ERROR); return; default: if (reason == 0) { reason = cfgError; } break; } //For all other errors, return a generic internal error sendMessage(iface, WPS_FAIL_EVENT, WifiManager.ERROR, reason); } <|startfocus|> /** * Handle the WPS success event. * * @param iface Name of iface on which this occured. */ public void handleWpsSuccessEvent(String iface) { sendMessage(iface, WPS_SUCCESS_EVENT); } <|endfocus|> /** * Handle the WPS overlap event. * * @param iface Name of iface on which this occured. */ public void handleWpsOverlapEvent(String iface) { sendMessage(iface, WPS_OVERLAP_EVENT); } /** * Handle the WPS timeout event. * * @param iface Name of iface on which this occured. */ public void handleWpsTimeoutEvent(String iface) { sendMessage(iface, WPS_TIMEOUT_EVENT); } } 
<|startcomment|> unused? <|endcomment|>  { Instant.EPOCH, Duration.between(Instant.EPOCH, Instant.MIN).minusNanos(1) }, { Instant.EPOCH, Duration.between(Instant.MIN, Instant.MAX) }, { Instant.EPOCH, MAX_DURATION }, { Instant.MIN, MAX_DURATION }, { Instant.MAX, Duration.ofNanos(1) }, { LocalDateTime.MAX, Duration.ofNanos(1) }, { LocalDateTime.now(), MAX_DURATION }, { ZonedDateTime.of(LocalDateTime.MAX, ZoneOffset.UTC ), Duration.ofNanos(1) }, }; <|startfocus|> int i=0; <|endfocus|> for (Object[] values : breakingValues) { Temporal temporal = (Temporal) values[0]; Duration duration = (Duration) values[1]; try { duration.addTo(temporal); fail(" Should have failed to add " + duration + " to " + temporal); } catch (DateTimeException expected) { } }
<|startcomment|> nit: space <|endcomment|>  Log.i(LOG_TAG, "Feature disabled on slotId: " + slotId + " for feature: " + feature); mIsAvailable = false; } } } @Override public void imsStatusChanged(int slotId, int feature, int status) throws RemoteException { synchronized (mLock) { Log.i(LOG_TAG, "imsStatusChanged: slot: " + slotId + " feature: " + feature + " status: " + status); <|startfocus|> if(mSlotId == slotId && feature == mSupportedFeature) { <|endfocus|> mFeatureStatusCached = status; } } if (mStatusCallback != null) { mStatusCallback.notifyStatusChanged(); } } }; public ImsServiceProxy(int slotId, IBinder binder, int featureType) { super(slotId, binder); mSupportedFeature = featureType; } public ImsServiceProxy(int slotId, int featureType) { super(slotId, null /*IBinder*/); mSupportedFeature = featureType; } public IImsServiceFeatureListener getListener() { return mListenerBinder; } public void setBinder(IBinder binder) {
<|startcomment|> String so compiler can inline this. <|endcomment|>  * throughout the lifetime of the underlying transform. If a transform object leaves scope, the * underlying transform may be disabled automatically. * * <p>An IpSecTransform may either represent a tunnel mode transform that operates on a wide array * of traffic or may represent a transport mode transform operating on a single socket. * * @hide */ public final class IpSecTransform { <|startfocus|> private static final String TAG = IpSecTransform.class.getSimpleName(); <|endfocus|> /** * IpSec Transform applies to inbound traffic. * * <p>IpSecTransforms are fundamentally unidirectional. Thus a two way connection requires two * Transform objects. This primitive specifies the direction of the transform as inbound. */ public static final int DIRECTION_IN = 0; /** * IpSec Transform applies to outbound traffic. * * <p>See detail in {@link #DIRECTION_IN} */ public static final int DIRECTION_OUT = 1; /**
<|startcomment|> Optional: rename this to something like testAdditionalStateCallbacks? <|endcomment|>  defaultNetworkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent); } private class TestRequestUpdateCallback extends TestNetworkCallback { @Override public void onCapabilitiesChanged(Network network, NetworkCapabilities netCap) { setLastCallback(CallbackState.NETWORK_CAPABILITIES, network, netCap); } @Override public void onLinkPropertiesChanged(Network network, LinkProperties linkProp) { setLastCallback(CallbackState.LINK_PROPERTIES, network, linkProp); } } @SmallTest public void testRequestCallbackUpdates() throws Exception { // File a network request for mobile. <|startfocus|> final TestNetworkCallback cellNetworkCallback = new TestRequestUpdateCallback(); <|endfocus|> final NetworkRequest cellRequest = new NetworkRequest.Builder() .addTransportType(TRANSPORT_CELLULAR).build(); mCm.requestNetwork(cellRequest, cellNetworkCallback); // Bring up the mobile network. mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR); mCellNetworkAgent.connect(true); // We should get onAvailable(), onCapabilitiesChanged(), and // onLinkPropertiesChanged() in rapid succession. cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent); cellNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
<|startcomment|> If this is a JUnit 4 test, you don't need to extent TestCase (or call the tests test_, or use the try{ fail(); } catch (Exception expected) {} pattern if the test is small). <|endcomment|> import java.util.Enumeration; import java.util.HashMap; import java.util.Map; import java.util.Set; import java.util.jar.JarFile; import java.util.jar.JarInputStream; import java.util.jar.JarOutputStream; import dalvik.system.DexClassLoader; import dalvik.system.PathClassLoader; import junitparams.JUnitParamsRunner; import sun.misc.IOUtils; import sun.nio.ch.IOUtil; import static java.nio.file.StandardOpenOption.CREATE; import static java.nio.file.StandardOpenOption.WRITE; @RunWith(JUnitParamsRunner.class) <|startfocus|> public class FileSystemsTest extends TestCase { <|endfocus|> @Rule public FilesSetup filesSetup = new FilesSetup(); @Test public void test_getDefault() { FileSystem fs = FileSystems.getDefault(); assertNotNull(fs.provider()); } @Test public void test_getFileSystem() { Path testPath = Paths.get("/"); FileSystem fs = FileSystems.getFileSystem(testPath.toUri()); assertNotNull(fs.provider()); try { FileSystems.getFileSystem(null); fail(); } catch (NullPointerException expected) {} } @Test
<|startcomment|> The custom <|endcomment|>  FileSystem fs = FileSystems.newFileSystem(filesSetup.getDataFilePath(), fileSystemsClassLoader); assertEquals("mypackage.MockFileSystem", fs.getClass().getName()); Path pathValue = (Path)fs.getClass().getDeclaredMethod("getPath").invoke(fs); assertEquals(filesSetup.getDataFilePath(), pathValue); } /** <|startfocus|> * The method creates a custom classlaoder for the mock FileSystem and FileSystemProvider * classes. Custom classloader is created by providing filesystemtest.jar which contains <|endfocus|> * MockFileSystemProvider and MockFileSystem classes. * @throws Exception */ ClassLoader createClassLoaderForTestFileSystems() throws Exception { File jarFile = new File(filesSetup.getTestDir().toString(), "filesystemstset.jar"); InputStream jis = getClass().getResource("/filesystemstest.jar").openStream(); OutputStream jos = new FileOutputStream(jarFile); jos.write(IOUtils.readFully(jis, -1, true)); return new PathClassLoader(jarFile.getAbsolutePath(), getClass().getClassLoader()); } } 
<|startcomment|> You could move the L2cap and RFCOMM socket setups here. <|endcomment|>  private void startSocketListener() { if (D) Log.d(TAG, "start Socket Listeners"); stopListeners(); mServerSocket = BluetoothOppServerSockets.create(mHandler); SdpManager sdpManager = SdpManager.getDefaultManager(); <|startfocus|> if (mServerSocket == null || sdpManager != null) { Log.e(TAG, "mServerSocket :" + mServerSocket + " sdp manager :" + sdpManager); <|endfocus|> return; } sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SdpManager.OPP_FORMAT_ALL);
<|startcomment|> This text is confusing. What is the standard IKE implementatoin? <|endcomment|>  /** @hide */ private static final int MODE_TRANSPORT = 1; /** * Specifies IpSec traffic will be encapsulated in IP. This is the default mode for a Tunnel * mode transform, and needs not be specified explicitly. * * @hide */ public static final int ENCAP_ESPINIP = 0; /** <|startfocus|> * IpSec traffic will be encapsulated within UDP using the standard IKE implementation. These * packets will have a UDP header applied encapsulating the ESP header. <|endfocus|> */ public static final int ENCAP_ESPINUDP = 1; /** * IpSec traffic will be encapsulated within a UDP header with an additional 8-byte header pad * that prevents traffic from being interpreted as IKE or as ESP over UDP. */ public static final int ENCAP_ESPINUDP_NONIKE = 2; /** @hide */ @IntDef(value = {ENCAP_ESPINIP, ENCAP_ESPINUDP, ENCAP_ESPINUDP_NONIKE}) @Retention(RetentionPolicy.SOURCE) public @interface EncapType {} /**
<|startcomment|> why did old RIL code use DisplayListener and selecting DEFAULT_DISPLAY? This code seems simpler, but is it sufficient? <|endcomment|>  mIsPowerSaveOn = isPowerSaveModeOn(); mIsInteractive = isInteractive(); mIsCharging = isDeviceCharging(); mIsTetheringOn = false; mIsLowDataExpected = false; if (DBG) { log("DeviceStateMonitor mIsPowerSaveOn=" + mIsPowerSaveOn + ",mIsInteractive=" + mIsInteractive + ",mIsCharging=" + mIsCharging); } final IntentFilter filter = new IntentFilter(); <|startfocus|> filter.addAction(Intent.ACTION_SCREEN_ON); filter.addAction(Intent.ACTION_SCREEN_OFF); <|endfocus|> filter.addAction(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED); filter.addAction(BatteryManager.ACTION_CHARGING); filter.addAction(BatteryManager.ACTION_DISCHARGING); filter.addAction(ConnectivityManager.ACTION_TETHER_STATE_CHANGED); mPhone.getContext().registerReceiver(mBroadcastReceiver, filter, null, mPhone); mPhone.mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
<|startcomment|> "Invalid branchingness: " + opcode.getBranchingNess() <|endcomment|>  public InvokePolymorphicInsn(Rop opcode, SourcePosition position, RegisterSpecList sources, TypeList catches, CstMethodRef callSiteMethod) { super(opcode, position, null, sources); if (opcode.getBranchingness() != Rop.BRANCH_THROW) { <|startfocus|> throw new IllegalArgumentException("bogus branchingness"); <|endfocus|> } if (catches == null) { throw new NullPointerException("catches == null"); } this.catches = catches; if (callSiteMethod == null) { throw new NullPointerException("callSiteMethod == null"); } else if (!callSiteMethod.isSignaturePolymorphic()) { throw new IllegalArgumentException("callSiteMethod is not signature polymorphic"); } this.callSiteMethod = callSiteMethod; this.invokeMethod = makeInvokeMethod(callSiteMethod); this.callSiteProto = makeCallSiteProto(callSiteMethod);
<|startcomment|> to a given destination address <|endcomment|>  * @param algo {@link IpSecAlgorithm} specifying the authentication to be applied. */ public IpSecTransform.Builder setAuthentication( @TransformDirection int direction, IpSecAlgorithm algo) { mConfig.flow[direction].authenticationAlgo = algo; return this; } /** * Set the SPI, which uniquely identifies a particular IPsec session from others. Because <|startfocus|> * IPsec operates at the IP layer, this 32-bit identifier uniquely identifies packets * between a given sender and receiver. <|endfocus|> * * <p>Care should be chosen when selecting an SPI to ensure that is is as unique as * possible. Random number generation is a reasonable approach to selecting an SPI. For * outbound SPIs, they must be reserved by calling {@link * IpSecManager#reserveOutboundSpi(InetAddress, int)}. Otherwise, Transforms will fail to * activate. * * <p>Unless an SPI is set for a given direction, traffic in that direction will be * sent/received without any Ipsec applied. *
<|startcomment|> And this one. <|endcomment|>  wifiConfig.enterpriseConfig.setCaCertificateAlias(caCertificateAlias); wifiConfig.enterpriseConfig.setClientCertificateAlias(clientCertificateAlias); // Setup expected {@link PasspointConfiguration} PasspointConfiguration passpointConfig = new PasspointConfiguration(); HomeSp homeSp = new HomeSp(); homeSp.setFqdn(fqdn); homeSp.setFriendlyName(friendlyName); homeSp.setRoamingConsortiumOis(rcOIs); passpointConfig.setHomeSp(homeSp); Credential credential = new Credential(); Credential.CertificateCredential certCredential = new Credential.CertificateCredential(); <|startfocus|> certCredential.setCertType("x509v3"); <|endfocus|> credential.setCertCredential(certCredential); credential.setRealm(realm); passpointConfig.setCredential(credential); assertTrue(PasspointManager.addLegacyPasspointConfig(wifiConfig)); verifyInstalledConfig(passpointConfig); } /** * Verify that adding a legacy Passpoint configuration containing certificate credential will * fail when CA certificate is not provided. * * @throws Exception */ @Test public void addLegacyPasspointConfigWithCertCredentialWithoutCaCert() throws Exception { // Test data. String fqdn = "test.com"; String friendlyName = "Friendly Name";
<|startcomment|> Same. <|endcomment|>  private boolean boolResult(boolean result) { if (mLog == sNoLog) return result; // Currently only seen if verbose logging is on Thread cur = Thread.currentThread(); StackTraceElement[] trace = cur.getStackTrace(); <|startfocus|> mLog.err("th % % returns %") .c(cur.getId()) <|endfocus|> .c(niceMethodName(trace, 3)) .c(result) .flush(); return result;
<|startcomment|> If you move this from the catch block to outside the try block then Error Prone should detect that there is no fail(). While that will not change anything here given that you are going to call fail() it would make it more idiomatic. <|endcomment|>  try { // Ensure that BoringSSL throws an exception if you try to manually trigger // SSL renegotiation, which is what we expect. If the exception isn't thrown, // the SSL_write in the catch block won't execute, so the client.get() below // won't complete and the test will fail. NativeCrypto.SSL_renegotiate(s); } catch (SSLException e) { NativeCrypto.SSL_write(s, fd, callback, new byte[] {42}, 0, 1, 0); <|startfocus|> } <|endfocus|> super.afterHandshake(session, s, c, sock, fd, callback); } }; Future<TestSSLHandshakeCallbacks> client = handshake(listener, 0, true, cHooks, null); Future<TestSSLHandshakeCallbacks> server = handshake(listener, 0, false, sHooks, null); client.get(TIMEOUT_SECONDS, TimeUnit.SECONDS); server.get(TIMEOUT_SECONDS, TimeUnit.SECONDS); } @Test public void test_SSL_get_certificate() throws Exception { try { NativeCrypto.SSL_get_certificate(NULL); fail(); } catch (NullPointerException expected) { } 
<|startcomment|> I like these. These test the actual end output from the module. <|endcomment|>  public void testEnterLogging() { mWifiVendorHal.mErrLog = spy(mWifiLog); mWifiVendorHal.enableVerboseLogging(true); mWifiVendorHal.installPacketFilter(new byte[0]); <|startfocus|> verify(mWifiVendorHal.mErrLog).trace("% filter length %"); <|endfocus|>
<|startcomment|> Needs a generated serial UID <|endcomment|>  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.designstudio.toscagenerator.vo.protobuf; import java.io.Serializable; import java.util.List; <|startfocus|> public class Operation implements Serializable{ <|endfocus|> private String operationType = ""; private String operatioName = ""; private List<InputMessage> listOfInputMessages; private List<OutputMessage> listOfOutputMessages; public String getOperationType() { return operationType; } public void setOperationType(String operationType) { this.operationType = operationType; } public String getOperatioName() { return operatioName; } public void setOperatioName(String operatioName) { this.operatioName = operatioName; } public List<InputMessage> getListOfInputMessages() { return listOfInputMessages;
<|startcomment|> Don't use "1" as the serial version UID. <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.designstudio.cdump; import java.io.Serializable; public class NodeType implements Serializable { /** * */ <|startfocus|> private static final long serialVersionUID = 1L; <|endfocus|> private String nodeTypeName = ""; /** * @return the nodeTypeName */ public String getNodeTypeName() { return nodeTypeName; } /** * @param nodeTypeName * the nodeTypeName to set */ public void setNodeTypeName(String nodeTypeName) { this.nodeTypeName = nodeTypeName; } } 
<|startcomment|> Why are these org.cognita prefixes still present? This was a high-priority item to rename everything <|endcomment|> import org.acumos.onboarding.component.docker.cmd.PushImageCommand; import org.acumos.onboarding.component.docker.cmd.TagImageCommand; import org.acumos.onboarding.component.docker.preparation.H2ODockerPreparator; import org.acumos.onboarding.component.docker.preparation.JavaGenericDockerPreparator; import org.acumos.onboarding.component.docker.preparation.Metadata; import org.acumos.onboarding.component.docker.preparation.MetadataParser; import org.acumos.onboarding.component.docker.preparation.PythonDockerPreprator; import org.acumos.onboarding.component.docker.preparation.RDockerPreparator; import org.acumos.onboarding.services.DockerService; import org.apache.commons.io.FileUtils; <|startfocus|> import org.cognita.nexus.NexusArtifactClient; import org.cognita.nexus.RepositoryLocation; import org.cognita.nexus.data.UploadArtifactInfo; <|endfocus|> import org.json.simple.JSONObject; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.Resource; import org.springframework.core.io.ResourceLoader; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestPart;
<|startcomment|> Suggest this way instead: logger.error("compare failed", ex); <|endcomment|>  public int compare(MessageargumentList firstObject, MessageargumentList secondObject) { try{ return firstObject.getTag().compareTo(secondObject.getTag()); }catch(Exception ex){ <|startfocus|> logger.error("--------- Exception in TOSCA Model Generator Client ----------- "+ex); <|endfocus|> return 0; }
<|startcomment|> please add get() method to fetch name <|endcomment|>  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.cds; public enum StepStatusCode { <|startfocus|> <|endfocus|> ST("Started"), // SU("Succeeded"), // FA("Failed"); private String statusName; private StepStatusCode(final String statusName) { this.statusName = statusName; } } 
<|startcomment|> How can this value be set? I think the setter method is missing <|endcomment|> <|startfocus|> public MLPUserNotificationPrefernce getUserNotificationPreference(Long userNotifPrefID) { return this.usrNotifPrefById; <|endfocus|>
<|startcomment|> Why the extra blank lines? <|endcomment|>  @NotNull(message = "Title cannot be null") @Size(max = 100) private String title; @Column(name = "MESSAGE", columnDefinition = "VARCHAR(2048)") @Size(max = 2048) private String message; @Column(name = "MSG_SEVERITY_CD", nullable = false, columnDefinition = "CHAR(2)") @NotNull(message = "Message Severity Code cannot be null") @Size(max = 2) private String msgSeverityCode; <|startfocus|> <|endfocus|> @Column(name = "URL", columnDefinition = "VARCHAR(512)") @Size(max = 512) private String url; // No auto-update behaviors here @Column(name = "START_DATE", nullable = false) private Date start; // No auto-update behaviors here @Column(name = "END_DATE", nullable = false) private Date end; /** * No-arg constructor. */ public MLPNotification() { // no-arg constructor } /** * This constructor accepts the required fields; i.e., the minimum that the user
<|startcomment|> Why log "started" multiple times? It's confusing. Just put that at the top of the method. <|endcomment|>  } else if (isMessage && !line.contains("}")) { messageargumentList = new ArrayList<MessageargumentList>(); messageBody = costructMessage(line, messageBody, messageargumentList); } else if (isMessage && line.startsWith("}")) { messageBodyList.add(messageBody); protoBufClass.setListOfMessages(messageBodyList); isMessage = false; logger.debug(EELFLoggerDelegator.debugLogger, " costructMessage() end "); } if (line.startsWith("service")) { <|startfocus|> logger.debug(EELFLoggerDelegator.debugLogger, " constructService() started "); <|endfocus|> service = new org.acumos.designstudio.toscagenerator.vo.protobuf.Service(); service = constructService(line, service); } else if (isItservice && !line.contains("}") && !line.isEmpty()) { operation = new Operation(); listOfOperation = new ArrayList<Operation>(); line = line.replace(";", "").replace("\t", "").trim(); String operationType = ""; String operationName = ""; String inputParameterString = ""; String outPutParameterString = ""; 
<|startcomment|> Remove this logger from the constructor. It's not good practice. <|endcomment|>  public AcumosException() { super(); } /** * * @param errmessage * Error message */ public AcumosException(String errmessage) { super(errmessage); this.errorDesc = errmessage; } /** * * @param message * Error message * @param errorCode * Error code * @param errorDesc * Error description */ public AcumosException(String message, String errorCode, String errorDesc) { super(message); <|startfocus|> logger.debug(EELFLoggerDelegator.debugLogger, message); <|endfocus|> this.errorCode = errorCode; this.errorDesc = errorDesc; } /** * * @param message * Error message * @param errorCode * Error code * @param errorDesc * Error description * @param cause * Throwable */ public AcumosException(String message, String errorCode, String errorDesc, Throwable cause) { super(message, cause); this.errorCode = errorCode; this.errorDesc = errorDesc; } /** * * * @param message
<|startcomment|> This catches and discards <|endcomment|>  } } catch (JsonParseException e) { logger.error(EELFLoggerDelegator.errorLogger, " JsonParseException in deleteNode() ", e); } catch (JsonMappingException e) { logger.error(EELFLoggerDelegator.errorLogger, " JsonMappingException in deleteNode() ", e); } catch (IOException e) { logger.error(EELFLoggerDelegator.errorLogger, " IOException in deleteNode() ", e); } } } catch (Exception e) { <|startfocus|> logger.error(EELFLoggerDelegator.errorLogger, " Exception in deleteNode() ", e); <|endfocus|> } logger.debug(EELFLoggerDelegator.debugLogger, " deleteNode() in SolutionServiceImpl : Ends "); return deletedNode;
<|startcomment|> please remove code, don't comment it out, let git remember <|endcomment|>  log.debug(EELFLoggerDelegate.debugLogger, "addSolutionUserAccess"); ICommonDataServiceRestClient dataServiceRestClient = getClient(); MLPSolutionRating rating = dataServiceRestClient.getSolutionRating(solutionId, userId); return rating; } @Override public RestPageResponseBE<MLSolution> findPortalSolutions(RestPageRequestPortal pageReqPortal) { log.debug(EELFLoggerDelegate.debugLogger, "findPortalSolutions"); ICommonDataServiceRestClient dataServiceRestClient = getClient(); <|startfocus|> //String[] accessTypeCodes = {AccessTypeCode.PB.toString(), AccessTypeCode.OR.toString()}; <|endfocus|> RestPageResponse<MLPSolution> response = dataServiceRestClient.findPortalSolutions( pageReqPortal.getNameKeyword(), pageReqPortal.getDescriptionKeyword(), pageReqPortal.isActive(), pageReqPortal.getOwnerIds(), pageReqPortal.getAccessTypeCodes(), pageReqPortal.getModelTypeCodes(), pageReqPortal.getValidationStatusCodes(), pageReqPortal.getTags(), pageReqPortal.getPageRequest()); List<MLSolution> content = new ArrayList<>(); RestPageResponseBE<MLSolution> mlSolutionsRest = new RestPageResponseBE<>(content); Set<String> filteredTagSet = new HashSet<>(); List<MLPSolution> filteredSolList = new ArrayList<>();
<|startcomment|> Use logger, not System.out <|endcomment|>  public void testSolutionRevisionArtifactsSuccess() { ((HttpComponentsClientHttpRequestFactory) this.restTemplate.getRestTemplate().getRequestFactory()) .setHttpClient(prepareHttpClient()); ResponseEntity<JsonResponse<List<MLPArtifact>>> response = this.restTemplate.exchange("/solutions/00000000-0000-0000-0000-000000000000/revisions/01010101-0101-0101-0101-010101010101/artifacts", HttpMethod.GET, prepareRequest(), new ParameterizedTypeReference<JsonResponse<List<MLPArtifact>>>() {}); if (response != null) { <|startfocus|> System.out.println("testSolutionRevisionsArtifacts: " + response.getBody()); System.out.println("testSolutionRevisionsArtifacts: " + response); <|endfocus|> } assertTrue(response != null); assertTrue(response.getStatusCodeValue() == 200); assertTrue(response.getBody().getContent().size() == 1); //no errors
<|startcomment|> Remove assert true <|endcomment|>  public void executeTest() { try { tagImageCommand.execute(); <|startfocus|> assert (true); <|endfocus|> } catch (Exception e) { e.printStackTrace(); }
<|startcomment|> Why do you comment this as TODO? Isn't it a limitation which cannot be avoided? <|endcomment|>  @Size(max = 2) @ApiModelProperty(required = true, example = "LO") private String msgSeverityCode; @Column(name = "URL", columnDefinition = "VARCHAR(512)") @Size(max = 512) private String url; // No auto-update behaviors here // TODO: Column definition is not provided here because in Derby it's // created as TIMESTAMP but for Mariadb the DDL uses Datetime. @Column(name = "START_DATE", nullable = false) <|startfocus|> @ApiModelProperty(required = true) <|endfocus|> private Date start; // No auto-update behaviors here // TODO: Column definition is not provided here because in Derby it's // created as TIMESTAMP but for Mariadb the DDL uses Datetime. @Column(name = "END_DATE", nullable = false) @ApiModelProperty(required = true) private Date end; /** * No-arg constructor. */ public MLPNotification() { // no-arg constructor } /** * This constructor accepts the required fields; i.e., the minimum that the user
<|startcomment|> What can you assert here to check that it's working? <|endcomment|>  mlpPeer.setName("peerName"); peer.setContent(mlpPeer); HttpClientBuilder clientBuilder = HttpClients.custom(); when(env.getProperty("gateway.url")).thenReturn("http://abc.com"); when(gatewayClientConfiguration.buildClient()).thenReturn(clientBuilder.build()); GatewayClient client = new GatewayClient(env.getProperty("gateway.url"), gatewayClientConfiguration.buildClient()); when(clients.getGatewayClient()).thenReturn(client); when(gateway.ping("peer123")).thenReturn(peer); <|startfocus|> gatewayController.pingGateway(request, "ggre34gsd", response); <|endfocus|>
<|startcomment|> Remove, don't comment out <|endcomment|>  notification.setTitle(notifMsg); notificationService.generateNotification(notification, userId); // throw new RuntimeException("Failed : HTTP error code : " + // response.getStatusLine().getStatusCode()); } } } catch (Exception e) { // TODO Auto-generated catch block log.error(EELFLoggerDelegate.errorLogger, "Exception Occurred Onboarding the solution ", e); } finally { httpclient.getConnectionManager().shutdown(); // Remove all files once the process is completed <|startfocus|> //log.info("inside finallly callOnboarding ---->>>"); //log.debug("inside finallly callOnboarding---->>>"); //log.error("inside finallly callOnboarding---->>>"); <|endfocus|> fileSystemStorageService.deleteAll(userId); } return new AsyncResult<HttpResponse>(response); } /*void generateNotification(String msg, String userId) { MLPNotification notification = new MLPNotification(); try { if (msg != null) { notification.setTitle("Web Based Onboarding"); notification.setMessage(msg); Date startDate = new Date(); Date endDate = new Date(startDate.getTime() + (1000 * 60 * 60 * 24));
<|startcomment|> Follow naming conventions <|endcomment|>  public void createUserNotificationPreferenceTest() { MLUserNotifPref mlpNotification = new MLUserNotifPref(); JsonResponse<MLUserNotifPref> data = new JsonResponse<>(); <|startfocus|> mlpNotification.setMsgSeverityCode("notification created"); <|endfocus|> mlpNotification.setUserNotifPrefId(123l); mlpNotification.setUserId("41058105-67f4-4461-a192-f4cb7fdafd34"); mlpNotification.setNotfDelvMechCode("41058105-67f4-4461-a192-f4cb7fdafd34"); JsonRequest<MLUserNotifPref> notificationReq = new JsonRequest<>(); notificationReq.setBody(mlpNotification); when(notificationService.createUserNotificationPreference(mlpNotification)).thenReturn(mlpNotification); data = notificationController.createUserNotificationPreference(request, notificationReq, response); notificationReq.setBody(null); when(notificationService.createUserNotificationPreference(mlpNotification)).thenReturn(mlpNotification); data = notificationController.createUserNotificationPreference(request, notificationReq, response); if (data != null) { logger.debug(EELFLoggerDelegate.debugLogger, "Successfully created User Notification Preference : " + data.getResponseBody()); } else { logger.error(EELFLoggerDelegate.errorLogger, "Error Occurred createUserNotificationPreference :"); }
<|startcomment|> Please do not log passwords <|endcomment|>  this.probeInternalPort=probeInternalPort; this.probeNexusEndPoint=probeNexusEndPoint; this.subnet=subnet; this.vnet=vnet; } public void run() { logger.debug("<-----------------AzureCompositeSolution-----Run Started-------------------------->"); logger.debug("<-----------------AzureCompositeSolution-----Run Started---*************----------------------->"); logger.debug("<-------azure-------->"+azure); logger.debug("<-------deployDataObject-------->"+deployDataObject); logger.debug("<-------dockerContainerPrefix-------->"+dockerContainerPrefix); <|startfocus|> logger.debug("<-------dockerUserName-------->"+dockerUserName); logger.debug("<-------dockerPwd-------->"+dockerPwd); logger.debug("<-------localEnvDockerHost-------->"+localEnvDockerHost); logger.debug("<-------localEnvDockerCertPath-------->"+localEnvDockerCertPath); <|endfocus|> logger.debug("<-------list-------->"+list); logger.debug("<-------bluePrintName-------->"+bluePrintName); logger.debug("<-------bluePrintUser-------->"+bluePrintUser); logger.debug("<-------bluePrintPass-------->"+bluePrintPass); logger.debug("<-------networkSecurityGroup-------->"+networkSecurityGroup); logger.debug("<-------dockerRegistryName-------->"+dockerRegistryName); logger.debug("<-------uidNumStr-------->"+uidNumStr); logger.debug("<-------sequenceList-------->"+sequenceList); logger.debug("<-------imageMap-------->"+imageMap); 
<|startcomment|> See above. <|endcomment|>  notification.setTitle(msg); // Provide the IP address and port of the probe Instance notification.setMessage(msg); Date startDate = new Date(); Date endDate = new Date(startDate.getTime() + (1000 * 60 * 60 * 24)); notification.setStart(startDate); notification.setEnd(endDate); CommonDataServiceRestClientImpl client=getClient(dataSource,dataUserName,dataPassword); notification.setMsgSeverityCode(MessageSeverityCode.ME.toString()); MLNotification mLNotification = createNotification(notification); <|startfocus|> logger.debug("=====mLNotification.getNotificationId()====="+mLNotification.getNotificationId()); <|endfocus|> client.addUserToNotification(mLNotification.getNotificationId(),userId); } } catch (Exception e) { logger.error("Exception Occurred while getNotifications", e); } logger.debug("End===generateNotification============"); } public String getTagFromImage(String imageName){ String imageTag=null; final int endColon = imageName.lastIndexOf(':'); if (endColon < 0) { imageTag=null; }else{
<|startcomment|> Should log the exception <|endcomment|>  conf.getRemoteDir(), "default.sh"); if(!confService.isShellFileCreated()){ executor.createshellFile(conf.getData_broker_map().getScript()); confService.setShellFileCreated(true); } // executor = new RemoteScriptExecutor(conf.getHost(), conf.getPort(), conf.getUserName(), conf.getPassword(),"/home/techmahindra/vaibhav/", "default.sh"); executor.executeShell(out); <|startfocus|> } catch (CloneNotSupportedException e) { <|endfocus|> throw new ServiceException("No environment configuration found! Please set the Environment configuration.","401", "Exception in writeDataTo()"); } } @Override public byte[] getOneRecord() throws ServiceException { ConfigurationService confService = ConfigurationService.getInstance(); Configuration conf = null; RemoteScriptExecutor executor = null; byte[] result = null; try { conf = confService.getConf(); executor = new RemoteScriptExecutor(conf.getHost(), conf.getPort(), conf.getUserName(), conf.getPassword(), conf.getRemoteDir(), "default.sh"); if(!confService.isShellFileCreated()){
<|startcomment|> debug (not info) <|endcomment|>  public byte[] mapData(@RequestBody byte[] inputData){ byte[] result = null; <|startfocus|> logger.info("mapData : Begin"); <|endfocus|> InputStream inputStream = new ByteArrayInputStream(inputData); OutputStream outputStream = gdmService.mapData(inputStream); if(null == outputStream){ result = new byte[0]; } else { result = ((ByteArrayOutputStream) outputStream).toByteArray(); } logger.info("mapData : End"); return result;
<|startcomment|> SC_INTERNAL_SERVER_ERROR <|endcomment|>  logger.error(EELFLoggerDelegator.errorLogger, "No Data Found !!!", e); response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED); return new Result(HttpServletResponse.SC_EXPECTATION_FAILED, "No Data Found !!!"); } return result; } else if (resultsetSize == -1){ return new StreamingResponseBody() { @Override public void writeTo (OutputStream out) throws IOException { try { service.writeDataTo(out); } catch (Exception e){ <|startfocus|> response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED); out.write((new Result(HttpServletResponse.SC_EXPECTATION_FAILED, e.getMessage()).toString()).getBytes()); <|endfocus|> } } }; } else { //TODO : Need to implement to return set of n records. return new Result(); }
<|startcomment|> Perhaps this should be a constant since it's reused at line 233? Sonar will complain about this also. <|endcomment|>  MLSolution solutionDetail = catalogService.getSolution(newSolutionId); solutionDetail.setName(solution.getName()); log.info("inside callOnboarding if before updateSolution ---->>>"); catalogService.updateSolution(solutionDetail, newSolutionId); log.info("inside callOnboarding if after updateSolution ---->>>"); } String notifMsg = "Solution " + solution.getName() + " Added to Catalog Successfully"; notification.setMessage(notifMsg); <|startfocus|> notification.setTitle("Web Based Onboarding"); <|endfocus|> notificationService.generateNotification(notification, userId); //Send notification to user according to preference Map<String, String> notifyBody = new HashMap<String, String>(); notifyBody.put("solutionName", solution.getName()); notifyOnboardingStatus(userId, "HI", notifMsg, notifyBody, "ONBD_SUCCESS"); } else { InputStream instream = response.getEntity().getContent(); String result = convertStreamToString(instream); ObjectMapper mapper = new ObjectMapper(); log.info("inside callOnboarding else before readValue ---->>>"); Map<String, Object> resp = mapper.readValue(result, Map.class);
<|startcomment|> please fix indentation <|endcomment|>  dataBrokerContName = nd.getContainerName(); // getting its operation name : to be used later ...OR is it always get_image? ListOfDataBrokerOpSigList = nd.getOperationSignatureList(); for (OperationSignatureList dbosl : ListOfDataBrokerOpSigList) { dataBrokerOperation = dbosl.getOperationSignature().getOperationName(); // here we are assuming <|startfocus|> // databroker will have // only 1 operation. // //this can be // changed. <|endfocus|> } break; } } String urlBase = null; String databrokerurl = null; byte[] output = null; // Find the url etc. for this data broker. if (dataBrokerPresent == true) { DockerInfo d1 = dockerList.findDockerInfoByContainer(dataBrokerContName); if (d1 == null) { // what to do if the deployer passed // incomplete docker info ??? logger.error("Cannot find docker info about the data broker {}", dataBrokerContName); dbresults.put("status", "ok");
<|startcomment|> Why is this still here since you now have getCollaterType and setCollatorType methods? <|endcomment|>  this.compositionErrorCode = compositionErrorCode; } /** * @return the compositionErrorDescription */ public String getCompositionErrorDescription() { return compositionErrorDescription; } /** * @param compositionErrorDescription the compositionErrorDescription to set */ public void setCompositionErrorDescription(String compositionErrorDescription) { this.compositionErrorDescription = compositionErrorDescription; } /** * @return the successCode */ public String getSuccessCode() { return successCode; } /** <|startfocus|> * @param successCode the successCode to set */ public void setSuccessCode(String successCode) { this.successCode = successCode; } /** <|endfocus|> * @return the compositionSolutionErrorCode */ public String getCompositionSolutionErrorCode() { return compositionSolutionErrorCode; } /** * @param compositionSolutionErrorCode the compositionSolutionErrorCode to set */ public void setCompositionSolutionErrorCode(String compositionSolutionErrorCode) { this.compositionSolutionErrorCode = compositionSolutionErrorCode; } /** * @return the compositionSolutionErrorDesc */ public String getCompositionSolutionErrorDesc() {
<|startcomment|> remove don't comment out <|endcomment|>  } s.close(); return val; } /** * print out output of an command * * @param bufferedReader * @return output * @throws IOException */ public static ArrayList<String> printCmdOutput(BufferedReader bufferedReader) throws IOException { String currentLine; ArrayList<String> output = new ArrayList<>(); while ((currentLine = bufferedReader.readLine()) != null) { <|startfocus|> /* Use it when we need it * logger.info("printCmdOutput: " + currentLine); */ <|endfocus|> int i; for (i = 0; i < currentLine.length(); i++) if (!Character.isWhitespace(currentLine.charAt(i))) { output.add(currentLine); break; } } bufferedReader.close(); return output; } /* print out command error message */ public static void printCmdError(InputStream error) throws IOException { for (int i = 0; i < error.available(); i++) { logger.error("printCmdError: " + error.read()); }
<|startcomment|> If you follow this column naming format, shouldn't it be used for other columns too for consistency? <|endcomment|>  /** * Supports federation. */ @Column(name = "ORIGIN", columnDefinition = "VARCHAR(512)") @Size(max = 512) @ApiModelProperty(value = "URI of the peer that provided this item.", example = "http://acumos.remote.com/a/b/c") private String origin; /** * The Access Type Code value set is defined by server-side configuration. */ <|startfocus|> @Column(name = ACCESS_TYPE_CODE_COL_NAME, nullable = false, columnDefinition = "CHAR(2)") <|endfocus|> @NotNull(message = "Access type code cannot be null") @Size(max = 2) @ApiModelProperty(value = "Access type code that is valid for this site", example = "PB") private String accessTypeCode; /** * The Validation Status Code value set is defined by server-side configuration. */ @Column(name = "VALIDATION_STATUS_CD", nullable = false, columnDefinition = "CHAR(2)") @Size(max = 2)
<|startcomment|> Please specify one liner description of public method. <|endcomment|>  */ public void populatePublicModelCacheForMatching(List<DSModelVO> models) throws ServiceException; /** * * @param models * models * @throws ServiceException * In Exception Case */ public void removePublicModelCacheForMatching(List<DSModelVO> models) throws ServiceException; /** * * @return * list of DSModelVo * @throws ServiceException * In Exception Case */ public List<DSModelVO> getPublicDSModels() throws ServiceException; /** <|startfocus|> * <|endfocus|> * @param userId * UserId * @return * list of DSModelVo * @throws ServiceException * In Exception Case */ public List<DSModelVO> getPrivateDSModels(String userId) throws ServiceException; /** * * @param userId * UserId * @param models * models * @throws ServiceException * In Exception Case */ public void populatePrivateModelCacheForMatching(String userId, List<DSModelVO> models) throws ServiceException; } 
<|startcomment|> javadoc <|endcomment|>  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.streamercatalog.controller; import javax.ws.rs.core.Response; import org.acumos.streamercatalog.model.CatalogObject; <|startfocus|> <|endfocus|> public interface RestCatalogService { public Response saveCatalog(String authorization, String codeCloudAuthorization, CatalogObject objCatalog); public Response updateCatalog(String authorization, String codeCloudAuthorization, String catalogKey, CatalogObject objCatalog); public Response getCatalog(String authorization, String catalogKey, String mode); public Response getCatalogs(String authorization, String category, String textSearch); public Response deleteCatalog(String authorization, String catalogKey); } 
<|startcomment|> Lic hdr pls <|endcomment|> <|startfocus|> kage org.acumos.datasource.service; <|endfocus|> import java.io.IOException; import org.apache.spark.SparkConf; import org.apache.spark.api.java.JavaSparkContext; import org.springframework.stereotype.Service; import org.slf4j.LoggerFactory; import org.acumos.datasource.common.HelperTool; import org.acumos.datasource.exception.CmlpDataSrcException; import org.acumos.datasource.model.SparkSAModel; import org.slf4j.Logger; @Service public class SparkStandaloneSvcImpl implements SparkStandaloneSvc { private static Logger log = LoggerFactory.getLogger(SparkStandaloneSvcImpl.class); public SparkStandaloneSvcImpl() { } @Override public String getConnectionStatus(String sparkHostName, String port) throws IOException, InterruptedException, CmlpDataSrcException { SparkConf sparkConf = new SparkConf(); sparkConf.setMaster("spark://" + sparkHostName + ":" + port).setAppName("sprkTest") .set("spark.submit.deployMode", HelperTool.getEnv("spark_deploy_mode", HelperTool.getComponentPropertyValue("spark_deploy_mode"))) .set("spark.driver.memory", HelperTool.getEnv("spark_driver_memory", HelperTool.getComponentPropertyValue("spark_driver_memory")))
<|startcomment|> Pls remove @author <|endcomment|>  * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.streamercatalog.service; import java.io.IOException; import java.util.ArrayList; import org.acumos.streamercatalog.exception.CmlpDataSrcException; import org.acumos.streamercatalog.model.CatalogObject; import org.acumos.streamercatalog.model.RelativeModel; <|startfocus|> /** * @author sg453d * */ <|endfocus|> public interface CatalogService { /** * Saves catalog object to the database. */ public String saveCatalog(String user, String authorization, String codeCloudAuthorization, CatalogObject objCatalog) throws IOException, CmlpDataSrcException; /** * Updates catalog object in the database using catalogKey. */ public String updateCatalog(String user, String authorization, String codeCloudAuthorization, String catalogKey, CatalogObject objCatalog) throws IOException, CmlpDataSrcException; /**
<|startcomment|> Don't use System.err nor stacktrace, use the logger. <|endcomment|>  + " - " + responsemessage); setfail(); return (reschedule); } // 5xx, can't connect, or unparsable response - Server problem System.err.println("Publish attempt for " + fid + " to " + saveurl + " temporarily rejected code " + rc + " - " + responsemessage); setfail(); reschedule = true; return (reschedule); } catch (Exception e) { <|startfocus|> System.err.println("Unexpected error during publish attempt"); e.printStackTrace(); <|endfocus|> return (reschedule); }
<|startcomment|> Please add descriptions <|endcomment|>  * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.streamer.controller; import java.io.InputStream; import javax.ws.rs.core.Response; public interface RestConsumerService { /** * Does data operation based on the data received from the files through the * datastreamer project. <|startfocus|> * @param authorization <|endfocus|> * @param feedAuthorization * @param catalogKey * @param fileName * @param attachedFiles * @return javax.ws.rs.core.Response.status */ public Response operateData(String authorization, String feedAuthorization, String catalogKey, String fileName, InputStream attachedFiles); } 
<|startcomment|> This should also be private <|endcomment|> import org.acumos.streamercatalog.service.CatalogService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Service; @SuppressWarnings("rawtypes") @Service public class RestCatalogServiceImpl implements RestCatalogService { private static final String MSG_ROUTER = "MsgRouter"; private static Logger log = LoggerFactory.getLogger(RestCatalogServiceImpl.class); @Autowired private CatalogService aCatalogService; @Autowired private HttpServletRequest request; @Autowired Environment env; @Autowired DataStreamerCatalogUtil dataStreamerCatalogUtil; <|startfocus|> @SuppressWarnings("unchecked") <|endfocus|> @Override public ResponseEntity saveCatalog(String authorization, CatalogObject objCatalog) { ResponseMessage aResponseMessage = new ResponseMessage(); String user = dataStreamerCatalogUtil.getRemoteUser(request); log.info("RestCatalogServiceImpl::saveCatalog::the request has been itiated by user: " + user); try { dataStreamerCatalogUtil.validateRequest(user, objCatalog); } catch (Exception e) { aResponseMessage.setCode(400); aResponseMessage.setMessage(e.getMessage()); throw new RuntimeException(e); } try {
<|startcomment|> Although you can distinguish by char (peer) vs int (group),better to say failed on "peer" ID in the warning message to distinguish it from the group ID failure case. <|endcomment|>  response = SuccessTransport.class) @RequestMapping(value = "/{groupId}/" + CCDSConstants.PEER_PATH + "/{peerId}", method = RequestMethod.POST) @ResponseBody public Object addPeerToGroup(@PathVariable("groupId") Long groupId, @PathVariable("peerId") String peerId, @RequestBody MLPPeerGrpMemMap map, HttpServletResponse response) { logger.debug("addPeerToGroup groupId {} peerId {}", groupId, peerId); if (peerRepository.findOne(peerId) == null) { <|startfocus|> logger.warn("addPeerToGroup: failed on ID {}", peerId); <|endfocus|> response.setStatus(HttpServletResponse.SC_BAD_REQUEST); return new ErrorTransport(HttpServletResponse.SC_BAD_REQUEST, NO_ENTRY_WITH_ID + peerId, null); } if (peerGroupRepository.findOne(groupId) == null) { logger.warn("addPeerToGroup: failed on ID {}", groupId); response.setStatus(HttpServletResponse.SC_BAD_REQUEST); return new ErrorTransport(HttpServletResponse.SC_BAD_REQUEST, NO_ENTRY_WITH_ID + groupId, null); } // Use path parameters only map.setGroupId(groupId);
<|startcomment|> maybe this is too much white space? <|endcomment|>  MDC.put(MDCs.STATUS_CODE, ResponseStatus.INPROGRESS.toString()); } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // // Enums. // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * Response success or not, for setting StatusCode. */ public enum ResponseStatus { /** Success. */ COMPLETED, /** Not. */ ERROR, /** In Progress. */ INPROGRESS } /** * Response of log level, for setting Severity. */ public enum ResponseSeverity { INFO, ERROR, <|startfocus|> <|endfocus|> TRACE, DEBUG, WARN, FATAL } /** * Synchronous or asynchronous execution, for setting invocation marker. */ public enum InvocationMode { /** Synchronous, blocking. */ SYNCHRONOUS("SYNCHRONOUS", Markers.INVOKE_SYNCHRONOUS), /** Asynchronous, non-blocking. */ ASYNCHRONOUS("ASYNCHRONOUS", Markers.INVOKE_ASYNCHRONOUS); /** Enum value. */ private String mString; /** Corresponding marker. */ private Marker mMarker; /** * Construct enum. * * @param s * enum value. * @param m
<|startcomment|> Please make Kernel type code non null <|endcomment|>  @Size(max = 36) // Users MAY submit an ID; readOnly annotation must NOT be used @ApiModelProperty(value = "UUID; omit for system-generated value", example = "12345678-abcd-90ab-cdef-1234567890ab") private String notebookId; @Column(name = "NOTEBOOK_TYPE_CD", columnDefinition = "CHAR(2)") @Size(max = 2) @ApiModelProperty(value = "Two-character notebook type code", example = "AB") private String notebookTypeCode; <|startfocus|> @Column(name = "KERNEL_TYPE_CD", columnDefinition = "CHAR(2)") <|endfocus|> @Size(max = 2) @ApiModelProperty(value = "Two-character kernel type code", example = "AB") private String kernelTypeCode; /** * No-arg constructor. */ public MLPNotebook() { // no-arg constructor } /** * This constructor accepts the required fields; i.e., the minimum that the user * must supply to create a valid instance. Defaults active to true. Omits ID, * which is generated on save. * 
<|startcomment|> License text is missing. <|endcomment|> <|startfocus|> kage org.acumos.licensemanager.service; <|endfocus|> import static org.assertj.core.api.Assertions.*; import static org.junit.Assert.assertEquals; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest(properties = { "licenseclient.message=Hello", "licenseclient.deployAllowed=false", "licenseclient.downloadAllowed=true"}) public class LicenseClientTest { @Autowired private LicenseService licenseSrvc; @Test public void contextLoads() throws InterruptedException, ExecutionException { LicenseRequest licenseDownloadRequest = new LicenseRequest(new String[]{"deploy","download"}, "dummysolutionid", "dummyuserid"); CompletableFuture<LicenseResponse> verifyUserRTU = licenseSrvc.verifyRTU(licenseDownloadRequest); CompletableFuture.allOf(verifyUserRTU).join(); assertThat(verifyUserRTU).isNotNull(); assertEquals(true, verifyUserRTU.get().getAllowedToUse().get("download").booleanValue());
<|startcomment|> Use an enum instead of hardcoded strings <|endcomment|>  // If there is a right to use (any for solution/user both download and deploy // are allowed in Boreas) if (rightToUse != null && !rightToUse.isEmpty()) { rightToUseFlag = true; } LicenseResponse response = new LicenseResponse(); for (String workflow : request.getWorkflow()) { // we will get all rtu for user and solution id from CDS fake that here <|startfocus|> switch (workflow) { case "download": <|endfocus|> response.addWorkflow(workflow, rightToUseFlag); break; case "deploy": response.addWorkflow(workflow, rightToUseFlag); break; default: break; } } return response; 
<|startcomment|> 2019 <|endcomment|>  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.workbench.projectservice.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; /** * Interceptor Configuration * 
<|startcomment|> Missing license <|endcomment|> <|startfocus|> kage org.acumos.workbench.notebookservice.exception; <|endfocus|> import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(HttpStatus.NOT_FOUND) public class EntityNotFoundException extends RuntimeException { private static final long serialVersionUID = 3173826165751170837L; public EntityNotFoundException(String msg) { super(msg); } } 
<|startcomment|> 2019 <|endcomment|>  * ===============LICENSE_START======================================================= * Acumos * =================================================================================== <|startfocus|> * Copyright (C) 2017 AT&T Intellectual Property & Tech Mahindra. All rights reserved. <|endfocus|> * =================================================================================== * This Acumos software file is distributed by AT&T and Tech Mahindra * under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.elk.client.controller; import com.fasterxml.jackson.databind.ObjectMapper; public abstract class AbstractController { protected final ObjectMapper mapper; public AbstractController() { mapper = new ObjectMapper(); } } 
<|startcomment|> Why do you define interfaces that are error responses? <|endcomment|>  * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END================================================== */ package org.acumos.licensemanager.client.model; import java.util.Map; /** * <p> * ILicenseVerification interface. * </p> * *CreatedRtu * * @version 0.0.2 */ <|startfocus|> public interface ILicenseVerification extends IErrorResponse { <|endfocus|> /** * <p> * Returns the list of actions for which are allowed to use. * </p> * * @return a {@link java.util.Map} object. */ Map<LicenseAction, Boolean> getAllowedToUse(); /** * <p> * Convenience method to pass a license action and return true if a * RTU exists. * </p> * * @param action a * {@link org.acumos.licensemanager.client.model.LicenseAction} object.
<|startcomment|> I don't think you should litter your code with version strings. This causes unnecessary churn at each commit. I think this practice should be avoided. I have not seen this anywhere else in the Acumosm project. <|endcomment|> import org.acumos.licensemanager.client.model.IVerifyLicenseRequest; import org.acumos.licensemanager.client.model.LicenseAction; import org.acumos.licensemanager.client.model.LicenseVerification; import org.acumos.licensemanager.exceptions.RightToUseException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * LicenseVerifier will verify that user or site has the RTU for a solution id for a specific * action. * * <p>In Boreas release the action we only have one RTU for all actions. <|startfocus|> * * @version 0.0.2 <|endfocus|> */ public class LicenseVerifier implements ILicenseVerifier { /** Logger for any exceptions that happen while creating a RTU with CDS. */ private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass()); /** dataClient must be provided by consumer of this library. */ private final ICommonDataServiceRestClient dataClient; /** * Constructor for LicenseVerifier. * * @param dataServiceClient a {@link org.acumos.cds.client.ICommonDataServiceRestClient} object. */ public LicenseVerifier(final ICommonDataServiceRestClient dataServiceClient) {
<|startcomment|> well, maybe this is a little TOO anonymous. My point was not that the VARIABLE name was redundant. My point was that the FILE NAME has "schema" in it twice which looks kinda weird. <|endcomment|>  * limitations under the License. * ===============LICENSE_END================================================== */ package org.acumos.licensemanager.jsonvalidator.resource; import com.networknt.schema.JsonSchema; import com.networknt.schema.JsonSchemaFactory; import java.io.IOException; import java.io.InputStream; /** LicenseJsonSchema class. */ public final class LicenseJsonSchema { /** Do not instantiate. */ private LicenseJsonSchema() {} /** Name of the json schema for license. */ <|startfocus|> private static final String FILE_NAME = "/license-schema.schema.json"; <|endfocus|> /** * Get the license json schema as JsonSchema. * * @return a {@link com.networknt.schema.JsonSchema} object. * @throws java.io.IOException if any. */ public static JsonSchema getSchema() throws IOException { JsonSchemaFactory factory = JsonSchemaFactory.getInstance(); InputStream is = LicenseJsonSchema.class.getResource(FILE_NAME).openStream(); return factory.getSchema(is); } } 
<|startcomment|> It takes equal time to write the logger invocation, why not just do that up front? <|endcomment|>  //validate token if(validateToken(jwtTokenVO, secretKey)) { MLPUser mlpUser = userService.findUserByUsername(jwtTokenVO.getUserName()); //TODO : Need to implement role base authority UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(new AuthenticatedUser(mlpUser), authToken, new ArrayList<>()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpRequest)); SecurityContextHolder.getContext().setAuthentication(authentication); } } <|startfocus|> } else { //TODO : log the error } <|endfocus|> chain.doFilter(request, response); } private boolean validateToken(JWTTokenVO jwtTokenVO, String secretKey) { Boolean isVallidToken = false; if (jwtTokenVO != null) { // check token expired or not if (!JwtTokenUtil.isTokenExpired(jwtTokenVO.getExpirationDate())) { String userName = jwtTokenVO.getUserName(); MLPUser mlpUser = userService.findUserByUsername(userName); if (mlpUser != null) { String authTokenFromDB = mlpUser.getAuthToken(); if (authTokenFromDB != null) {
<|startcomment|> private ? <|endcomment|> import org.mockito.MockitoAnnotations; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule; import org.springframework.http.ResponseEntity; public class NotebookServiceControllerTest extends NotebookCommons { private static final String authenticatedUserId = "123"; @Rule public MockitoRule mockitoRule = MockitoJUnit.rule(); @InjectMocks private NotebookServiceController notebookServiceController; @Mock private InputValidationService inputValidationService; @Mock private NotebookValidationService notebookValidationService; @Mock private NotebookService notebookService; @Mock <|startfocus|> HttpServletRequest request; <|endfocus|> private NotebookValidationService notebookValidationServiceImpl; private NotebookService notebookServiceImpl; private InputValidationService inputValidationServiceImpl; @Before public void setUp() { MockitoAnnotations.initMocks(this); notebookValidationServiceImpl = mock(NotebookValidationService.class); notebookServiceImpl = mock(NotebookService.class); inputValidationServiceImpl = mock(InputValidationService.class); } @Test public void createNotebookUnderProjectTest(){ Notebook notebook = buildNotebook(); doNothing().when(notebookValidationServiceImpl).validateNotebook(authenticatedUserId, notebook);
<|startcomment|> Why are tabs embedded within lines? <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * This file is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ===============LICENSE_END========================================================= */ package org.acumos.federation.client.config; import lombok.Data; /** * Configuration for a client. */ @Data <|startfocus|> public class ClientConfig { <|endfocus|> /** * TLS (https) configuration for the client. * * @param ssl TLS configuration for the client. * @return TLS configuration for the client. */ private TlsConfig ssl; /** * Basic authentication credentials for the client. * * @param creds Credentials for the client. * @return Credentials for the client. */ private BasicAuthConfig creds; } 
<|startcomment|> Remove debugging code. <|endcomment|>  } public static boolean checkOutput(String candidate, String requiredSubString){ return candidate.contains(requiredSubString); } public static String processOut(Process p) throws IOException{ InputStream input = p.getInputStream(); String candidate = ""; candidate = IOUtils.toString(input,"UTF-8"); return candidate; } public static void printOutput(InputStream input){ String candidate = ""; try{ candidate = IOUtils.toString(input,"UTF-8"); } catch(IOException e){ } //debug System.out.println(candidate); } <|startfocus|> private static Process invoke(String... args) throws Exception{ <|endfocus|> ProcessBuilder pb = new ProcessBuilder(args); pb.redirectErrorStream(true); Process p = pb.start(); return p; } private static Process remoteInvoke(String cmd) throws Exception{ ProcessBuilder pb = new ProcessBuilder("vagrant","ssh","cc", "-c","MANAGIX_HOME=/tmp/asterix/ "+cmd); System.out.println("---- "+cmd); File cwd = new File(asterixProjectDir.toString()+"/"+CLUSTER_BASE); pb.directory(cwd);
<|startcomment|> This means that we allocate up to 5 buffers for each partition. Is that right? Could that turn out to be an issue (i.e. why was it 1 before)? <|endcomment|>  public void accept(ByteBuffer buffer) { PartitionId pid = readInitialMessage(buffer); if (LOGGER.isLoggable(Level.FINE)) { LOGGER.fine("Received initial partition request: " + pid + " on channel: " + ccb); } <|startfocus|> noc = new NetworkOutputChannel(ccb, 5); <|endfocus|> try { partitionManager.registerPartitionRequest(pid, noc); } catch (HyracksException e) { e.printStackTrace(); noc.abort(); }
<|startcomment|> just format it when you are done <|endcomment|>  * Copyright 2009-2013 by The Regents of the University of California * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * you may obtain a copy of the License from * * http://www.apache.org/licenses/LICENSE-2.0 <|startfocus|> * <|endfocus|> * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package edu.uci.ics.hyracks.algebricks.core.algebra.prettyprint; import java.io.File; import java.io.IOException; import java.util.Random; import org.apache.commons.io.FileUtils; import org.apache.commons.lang3.mutable.Mutable; import edu.uci.ics.hyracks.algebricks.common.exceptions.AlgebricksException; import edu.uci.ics.hyracks.algebricks.core.algebra.base.ILogicalOperator; import edu.uci.ics.hyracks.algebricks.core.algebra.base.ILogicalPlan;
<|startcomment|> Relying on the string representation containing a "." seems wrong. It probably should be a structured object. <|endcomment|>  leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<ILogicalOperator>(insertOp)); break; } case DELETE: { ILogicalOperator deleteOp = new InsertDeleteOperator(targetDatasource, varRef, varRefsForLoading, InsertDeleteOperator.Kind.DELETE, false); deleteOp.getInputs().add(new MutableObject<ILogicalOperator>(assign)); leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<ILogicalOperator>(deleteOp)); break; } case CONNECT_FEED: { <|startfocus|> ILogicalOperator feedInsertOp = new InsertDeleteOperator(targetDatasource, varRef, <|endfocus|> varRefsForLoading, InsertDeleteOperator.Kind.INSERT, false); feedInsertOp.getInputs().add(new MutableObject<ILogicalOperator>(assign)); leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<ILogicalOperator>(feedInsertOp)); break; } } topOp = leafOperator; } globalPlanRoots.add(new MutableObject<ILogicalOperator>(topOp)); ILogicalPlan plan = new ALogicalPlanImpl(globalPlanRoots); return plan; } private DatasetDataSource validateDatasetInfo(AqlMetadataProvider metadataProvider, String dataverseName,
<|startcomment|> I think that we could just reuse fieldType here. <|endcomment|>  throws AlgebricksException, IOException { int pos = 0; boolean openFieldCompositeIdx = false; for (String fieldName : keyFieldNames) { IAType fieldType = getFieldType(fieldName); if (fieldType == null) { fieldType = keyFieldTypes.get(pos); if (keyFieldTypes.get(pos) == BuiltinType.ANULL) throw new AlgebricksException("A field with this name \"" + fieldName + "\" could not be found."); <|startfocus|> } else if (openFieldCompositeIdx) throw new AlgebricksException("A closed field \"" + fieldName + "\" could be only in a prefix part of the composite index, containing opened field."); <|endfocus|> if (keyFieldTypes.get(pos) != BuiltinType.ANULL && fieldType.getTypeTag() != keyFieldTypes.get(pos).getTypeTag()) throw new AlgebricksException("A field \"" + fieldName + "\" is already defined with the type \"" + fieldType + "\""); switch (indexType) { case BTREE: switch (fieldType.getTypeTag()) { case INT8:
<|startcomment|> fix formatting. spaces before and after = and <. <|endcomment|> import edu.uci.ics.hyracks.algebricks.core.algebra.typing.OpRefTypeEnvPointer; import edu.uci.ics.hyracks.algebricks.core.algebra.typing.PropagatingTypeEnvironment; import edu.uci.ics.hyracks.algebricks.core.algebra.visitors.ILogicalExpressionReferenceTransform; import edu.uci.ics.hyracks.algebricks.core.algebra.visitors.ILogicalOperatorVisitor; public class SinkOperator extends AbstractLogicalOperator { @Override public void recomputeSchema() throws AlgebricksException { schema = new ArrayList<LogicalVariable>(); <|startfocus|> for (int i=0; i<inputs.size(); i++) { <|endfocus|> for (LogicalVariable v : inputs.get(i).getValue().getSchema()) { if (!schema.contains(v)) schema.add(v); } } } @Override public boolean acceptExpressionTransform(ILogicalExpressionReferenceTransform transform) throws AlgebricksException { return false; } @Override public <R, T> R accept(ILogicalOperatorVisitor<R, T> visitor, T arg) throws AlgebricksException { return visitor.visitSinkOperator(this, arg); } @Override public boolean isMap() { return false; } @Override public VariablePropagationPolicy getVariablePropagationPolicy() { return VariablePropagationPolicy.ALL;
<|startcomment|> remove space (red) <|endcomment|>  } } } deliveredProperties = new StructuralPropertiesVector(childsProperties.getPartitioningProperty(), propsLocal); } @Override public PhysicalRequirements getRequiredPropertiesForChildren(ILogicalOperator op, IPhysicalPropertiesVector reqdByParent) { return emptyUnaryRequirements(op.getInputs().size()); } @Override public void contributeRuntimeOperator(IHyracksJobBuilder builder, JobGenContext context, ILogicalOperator op, IOperatorSchema propagatedSchema, IOperatorSchema[] inputSchemas, IOperatorSchema outerPlanSchema) throws AlgebricksException { <|startfocus|> IOperatorDescriptorRegistry spec = builder.getJobSpec(); RecordDescriptor recordDescriptor = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), propagatedSchema, context); <|endfocus|> SinkOperatorDescriptor opDesc = new SinkOperatorDescriptor(spec, op.getInputs().size()); contributeOpDesc(builder, (AbstractLogicalOperator) op, opDesc); List<ILogicalOperator> src = new ArrayList<ILogicalOperator>(); for (int i=0; i< op.getInputs().size(); i++) { src.add(op.getInputs().get(i).getValue()); builder.contributeGraphEdge(src.get(i), 0, op, i); } } @Override
<|startcomment|> error checking if pos == -1? <|endcomment|>  private void prepareVarAndExpression(String field, String[] fieldNames, List<LogicalVariable> recordVar, List<Mutable<ILogicalExpression>> expressions, List<LogicalVariable> vars, IOptimizationContext context) { Mutable<ILogicalExpression> varRef = new MutableObject<ILogicalExpression>(new VariableReferenceExpression( recordVar.get(0))); int pos = -1; for (int j = 0; j < fieldNames.length; j++) { if (fieldNames[j].equals(field)) { pos = j; break; } <|startfocus|> } <|endfocus|> // Assumes the indexed field is in the closed portion of the type. Mutable<ILogicalExpression> indexRef = new MutableObject<ILogicalExpression>(new ConstantExpression( new AsterixConstantValue(new AInt32(pos)))); AbstractFunctionCallExpression func = new ScalarFunctionCallExpression( FunctionUtils.getFunctionInfo(AsterixBuiltinFunctions.FIELD_ACCESS_BY_INDEX), varRef, indexRef); expressions.add(new MutableObject<ILogicalExpression>(func)); LogicalVariable newVar = context.newVar(); vars.add(newVar);
<|startcomment|> unnecessary <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package edu.uci.ics.hyracks.dataflow.std.file; import java.io.DataOutput; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.nio.ByteBuffer; <|startfocus|> import java.security.SecureRandom; <|endfocus|> import java.util.Arrays; import edu.uci.ics.hyracks.api.comm.IFrameWriter; import edu.uci.ics.hyracks.api.context.IHyracksTaskContext; import edu.uci.ics.hyracks.api.dataflow.value.ISerializerDeserializer; import edu.uci.ics.hyracks.api.exceptions.HyracksDataException; import edu.uci.ics.hyracks.dataflow.common.comm.io.ArrayTupleBuilder; import edu.uci.ics.hyracks.dataflow.common.comm.io.FrameTupleAppender; import edu.uci.ics.hyracks.dataflow.common.comm.util.FrameUtils; import edu.uci.ics.hyracks.dataflow.common.data.marshalling.Integer64SerializerDeserializer; import edu.uci.ics.hyracks.dataflow.common.data.parsers.IValueParser;
<|startcomment|> why we don't commit transaction for open fields indexes?? <|endcomment|>  if (spec == null) { throw new AsterixException("Failed to create job spec for creating index '" + stmtCreateIndex.getDatasetName() + "." + stmtCreateIndex.getIndexName() + "'"); } if (!index.isEnforcingKeyFileds()) { MetadataManager.INSTANCE.commitTransaction(mdTxnCtx); bActiveTxn = false; } progress = ProgressState.ADDED_PENDINGOP_RECORD_TO_METADATA; //#. create the index artifact in NC. runJob(hcc, spec, true); <|startfocus|> if (!index.isEnforcingKeyFileds()) { mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); bActiveTxn = true; metadataProvider.setMetadataTxnContext(mdTxnCtx); } <|endfocus|> //#. load data into the index in NC. cis = new CompiledCreateIndexStatement(index.getIndexName(), dataverseName, index.getDatasetName(), index.getKeyFieldNames(), index.getKeyFieldTypes(), index.isEnforcingKeyFileds(), index.getGramLength(), index.getIndexType()); spec = IndexOperations.buildSecondaryIndexLoadingJobSpec(cis, aRecordType, enforcedType, metadataProvider); runJob(hcc, spec, true);
<|startcomment|> This should be Interval, <|endcomment|>  /* (non-Javadoc) * @see edu.uci.ics.hyracks.algebricks.data.IPrinter#init() */ @Override public void init() throws AlgebricksException { } /* (non-Javadoc) * @see edu.uci.ics.hyracks.algebricks.data.IPrinter#print(byte[], int, int, java.io.PrintStream) */ @Override public void print(byte[] b, int s, int l, PrintStream ps) throws AlgebricksException { <|startfocus|> throw new AlgebricksException("'Circle' type unsupported for CSV output"); <|endfocus|> } } 
<|startcomment|> Error handling should be done via exceptions <|endcomment|>  fieldValueBuffer.reset(); sourceTag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes[offset]); switch (sourceTag) { case INT8: case INT16: case INT32: case INT64: try { IntegerToDoubleTypeConvertComputer.INSTANCE.convertType(bytes, offset + 1, length - 1, fieldValueBufferOutput); } catch (IOException e) { <|startfocus|> System.err .println("A numeric type promotion error has occurred before doing hash(). Can't continue process. Detailed Error message:" <|endfocus|> + e.getMessage()); } numericTypePromotionApplied = true; break; case FLOAT: try { FloatToDoubleTypeConvertComputer.INSTANCE.convertType(bytes, offset + 1, length - 1, fieldValueBufferOutput); } catch (IOException e) { System.err .println("A numeric type promotion error has occurred before doing hash(). Can't continue process. Detailed Error message:" + e.getMessage()); } numericTypePromotionApplied = true; break; default: numericTypePromotionApplied = false; break;
<|startcomment|> We create a new String Object for each call to this method for the (hopefully rare) case that the check fails. On of the main goal in Hyracks and AsterixDB is to avoid memory allocation in the size of the data - even if it were used for the non-error case. <|endcomment|>  asterixNewConstantValue = new AsterixConstantValue(new ADouble( (double) ((AFloat) sourceObject).getFloatValue())); break; default: break; } break; default: break; } return asterixNewConstantValue; } else { return new AsterixConstantValue(sourceObject); } } // checks whether the source value is within the range of the target type <|startfocus|> private static void valueSanitycheck(ATypeTag sourceType, ATypeTag targetType, double sourceValue, String stringValue) throws AlgebricksException { <|endfocus|> boolean canConvert = true; switch (targetType) { case INT8: if (sourceValue > Byte.MAX_VALUE || sourceValue < Byte.MIN_VALUE) { canConvert = false; } break; case INT16: if (sourceValue > Short.MAX_VALUE || sourceValue < Short.MIN_VALUE) { canConvert = false; } break; case INT32: if (sourceValue > Integer.MAX_VALUE || sourceValue < Integer.MIN_VALUE) { canConvert = false; } break; case INT64:
<|startcomment|> Here you should check the logical operator tag itself: if (!join.getValue().getOperatorTag() == INNERJOIN || !join.getValue().getOperatorTag() == LEFTOUTERJOIN) <|endcomment|>  } //if (!assignUnion.getExpressions().get(0).toString().equalsIgnoreCase("union")) { // return false; //} List<Triple<LogicalVariable, LogicalVariable, LogicalVariable>> varMap = new ArrayList<Triple<LogicalVariable, LogicalVariable, LogicalVariable>>( 1); //Retrieving the logical variables for the union from the two aggregates which are inputs to the join Mutable<ILogicalOperator> join = assignUnion.getInputs().get(0); if (!join.getValue().getOperatorTag().toString().contains("join")) return false; <|startfocus|> <|endfocus|> List<Mutable<ILogicalOperator>> joinInputs = join.getValue().getInputs(); if (!joinInputs.get(0).getValue().getOperatorTag().toString().contains("aggregate") || !joinInputs.get(1).getValue().getOperatorTag().toString().contains("aggregate")) return false; AbstractAssignOperator left_branch = (AbstractAssignOperator) joinInputs.get(0).getValue(); AbstractAssignOperator right_branch = (AbstractAssignOperator) joinInputs.get(1).getValue(); List<LogicalVariable> input1Var = left_branch.getVariables();
<|startcomment|> Pass force flag <|endcomment|>  IBufferCache bufferCache = invIndex.getBufferCache(); int startPage = 0; int maxPage = invIndexComponent.getBloomFilter().getNumPages(); forceFlushDirtyPages(bufferCache, fileId, startPage, maxPage); // Flush inverted index second. forceFlushDirtyPages(invIndex.getBTree()); forceFlushInvListsFileDirtyPages(invIndex); markAsValidInternal(invIndex.getBTree(), true); // Flush deleted keys BTree. forceFlushDirtyPages(invIndexComponent.getDeletedKeysBTree()); <|startfocus|> markAsValidInternal(invIndexComponent.getDeletedKeysBTree(), true); <|endfocus|> } @Override public void validate() throws HyracksDataException { for (ILSMComponent c : memoryComponents) { LSMInvertedIndexMemoryComponent mutableComponent = (LSMInvertedIndexMemoryComponent) c; mutableComponent.getInvIndex().validate(); mutableComponent.getDeletedKeysBTree().validate(); } List<ILSMComponent> immutableComponents = diskComponents; for (ILSMComponent c : immutableComponents) { LSMInvertedIndexDiskComponent component = (LSMInvertedIndexDiskComponent) c; component.getInvIndex().validate(); component.getDeletedKeysBTree().validate(); } } @Override public String toString() {
<|startcomment|> Again, force flag seems redundant here, too. <|endcomment|>  throws HyracksDataException, IndexException; public void search(ILSMIndexOperationContext ctx, IIndexCursor cursor, ISearchPredicate pred) throws HyracksDataException, IndexException; public void endSearch(ILSMIndexOperationContext ctx) throws HyracksDataException; public void scheduleMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException, IndexException; public void scheduleFullMerge(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException, IndexException; <|startfocus|> public void merge(ILSMIndexOperationContext ctx, ILSMIOOperation operation, boolean force) throws HyracksDataException, IndexException; <|endfocus|> public void scheduleFlush(ILSMIndexOperationContext ctx, ILSMIOOperationCallback callback) throws HyracksDataException; public void flush(ILSMIndexOperationContext ctx, ILSMIOOperation operation, boolean force) throws HyracksDataException, IndexException; public void addBulkLoadedComponent(ILSMComponent index, boolean force) throws HyracksDataException, IndexException; public ILSMOperationTracker getOperationTracker(); } 
<|startcomment|> Force flag seems unnecessary <|endcomment|>  if (!cleanedUpArtifacts) { cleanedUpArtifacts = true; ((LSMRTreeDiskComponent) component).getRTree().deactivate(); ((LSMRTreeDiskComponent) component).getRTree().destroy(); ((LSMRTreeDiskComponent) component).getBTree().deactivate(); ((LSMRTreeDiskComponent) component).getBTree().destroy(); ((LSMRTreeDiskComponent) component).getBloomFilter().deactivate(); ((LSMRTreeDiskComponent) component).getBloomFilter().destroy(); } } } @Override <|startfocus|> public void markAsValid(ILSMComponent lsmComponent, boolean force) throws HyracksDataException { <|endfocus|> LSMRTreeDiskComponent component = (LSMRTreeDiskComponent) lsmComponent; // Flush the bloom filter first. int fileId = component.getBloomFilter().getFileId(); IBufferCache bufferCache = component.getBTree().getBufferCache(); int startPage = 0; int maxPage = component.getBloomFilter().getNumPages(); forceFlushDirtyPages(bufferCache, fileId, startPage, maxPage); forceFlushDirtyPages(component.getRTree()); markAsValidInternal(component.getRTree(), force); forceFlushDirtyPages(component.getBTree()); markAsValidInternal(component.getBTree(), force); } } 
<|startcomment|> Bad Whitespace? <|endcomment|>  } @Override public IFeedLoadManager getFeedLoadManager() { return feedLoadManager; } @Override public IFeedTrackingManager getFeedTrackingManager() { return feedTrackingManager; } public static class AQLExecutor { private static final PrintWriter out = new PrintWriter(System.out, true); public static void executeAQL(String aql) throws Exception { AQLParser parser = new AQLParser(new StringReader(aql)); List<Statement> statements; statements = parser.Statement(); SessionConfig pc = new SessionConfig(out, SessionConfig.OutputFormat.ADM); <|startfocus|> <|endfocus|> AqlTranslator translator = new AqlTranslator(statements, pc); translator.compileAndExecute(AsterixAppContextInfo.getInstance().getHcc(), null, ResultDelivery.SYNC); } } } 
<|startcomment|> why do we do this? is there a bug in yarn that might start/return a response to same container more than once? <|endcomment|>  LaunchAsterixContainer runnableLaunchContainer = new LaunchAsterixContainer(allocatedContainer, containerListener); Thread launchThread = new Thread(runnableLaunchContainer, "Asterix CC/NC"); // I want to know if this node is the CC, because it must start before the NCs. LOG.info("Allocated: " + allocatedContainer.getNodeId().getHost()); LOG.info("CC : " + cC.getId()); try { ncStartedLock.lock(); if (ccUp.get()) { ncStarted.remove(containerToNode(allocatedContainer, clusterDesc)); } <|startfocus|> } catch (UnknownHostException e) { } finally { ncStartedLock.unlock(); <|endfocus|> } if (containerIsCC(allocatedContainer)) { ccUp.set(true); } // launch and start the container on a separate thread to keep // the main thread unblocked // as all containers may not be allocated at one go. launchThreads.add(launchThread); launchThread.start(); }
<|startcomment|> make 4 a constant? <|endcomment|>  public int getFieldSlotsLength() { <|startfocus|> return getFieldCount() * 4; <|endfocus|>
<|startcomment|> Won't this be called "recordAccessor.getSchemeFieldCount(recType)" in every iteration to check the count? Would it, thus, be better to replace it with "int schemaFieldCount = recordAccessor.getSchemeFieldCount(recType); for (int i = 0; i < schemaFieldCount; ++i) {" or similar? <|endcomment|>  public void processRecord(ARecordPointable recordAccessor, ARecordType recType, DataOutput out, int level) throws IOException, AsterixException, AlgebricksException { ArrayBackedValueStorage itemValue = getTempBuffer(); ArrayBackedValueStorage fieldName = getTempBuffer(); OrderedListBuilder orderedListBuilder = getOrderedListBuilder(); orderedListBuilder.reset(listType); IARecordBuilder fieldRecordBuilder = getRecordBuilder(); fieldRecordBuilder.reset(null); <|startfocus|> for (int i = 0; i < recordAccessor.getSchemeFieldCount(recType); ++i) { <|endfocus|> itemValue.reset(); fieldRecordBuilder.init(); // write name fieldName.reset(); recordAccessor.getClosedFieldName(recType, i, fieldName.getDataOutput()); addNameField(fieldName, fieldRecordBuilder); // write type byte tag = recordAccessor.getClosedFieldTag(recType, i); if (recordAccessor.isClosedFieldNull(recType, i)) { // TODO should the optionally null field return null if the value is null? // tag = ATypeTag.NULL.serialize(); } addFieldType(tag, fieldRecordBuilder); // write open addIsOpenField(false, fieldRecordBuilder); 
<|startcomment|> This doesn't belong here. <|endcomment|>  int offset, int length) throws AlgebricksException { int tmpIntVal = 0; long tmpLongVal = 0; for (int i = offset; i < offset + length; i++) { tmpIntVal = transformHexCharToInt(hexArray[i]); if (tmpIntVal != -1) { tmpLongVal = tmpLongVal * 16 + tmpIntVal; } else { throw new AlgebricksException( "This is not a correct UUID value."); } } <|startfocus|> System.out.println(""); <|endfocus|> return tmpLongVal; } // Interpret a character to the corresponding integer value. private int transformHexCharToInt(byte val) throws AlgebricksException { switch (val) { case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7;
<|startcomment|> What's gonna happen in the following case? when there are pages in the queue, haltWriter can be set to true by destroyQueue(). Then, how the rest of the pages in the queue are written to disk? It seems that destroyQueue should set the haltWriter to true when the queue was empty. Am I missing something here? <|endcomment|>  public void run() { if(DEBUG) System.out.println("[FIFO] Writer started"); <|startfocus|> while (!haltWriter) { <|endfocus|> ICachedPage page = null; try { QueueEntry entry = queue.take(); if(entry.notifier == true){ synchronized(entry) { entry.notifyAll(); continue; } } page = entry.page; page.acquireReadLatch(); if(DEBUG) System.out.println("[FIFO] Write " + BufferedFileHandle.getFileId(((CachedPage)page).dpid)+"," + BufferedFileHandle.getPageId(((CachedPage)page).dpid)); try { entry.writer.write(page, entry.bufferCache); } catch (HyracksDataException e) { //TODO: What do we do, if we could not write the page? e.printStackTrace(); } } catch(InterruptedException e) { continue; } finally{ if(page!=null){ page.releaseReadLatch(); } } }
<|startcomment|> "remove"-->"choose"? <|endcomment|>  Map.Entry<Index, List<Integer>> indexEntry = indexIt.next(); Index chosenIndex = indexEntry.getKey(); if (!chosenIndex.getDatasetName().equals(rightSubTree.dataset.getDatasetName())) { indexIt.remove(); } } } } // Choose index to be applied. Pair<IAccessMethod, Index> chosenIndex = chooseIndex(analyzedAMs); if (chosenIndex == null) { context.addToDontApplySet(this, join); return false; } // Apply plan transformation using chosen index. AccessMethodAnalysisContext analysisCtx = analyzedAMs.get(chosenIndex.first); <|startfocus|> //For LOJ with GroupBy, prepare objects to reset LOJ nullPlaceHolderVariable in GroupByOp <|endfocus|> if (isLeftOuterJoin && hasGroupBy) { analysisCtx.setLOJGroupbyOpRef(opRef); ScalarFunctionCallExpression isNullFuncExpr = AccessMethodUtils .findLOJIsNullFuncInGroupBy((GroupByOperator) opRef.getValue()); analysisCtx.setLOJIsNullFuncInGroupBy(isNullFuncExpr); } boolean res = chosenIndex.first.applyJoinPlanTransformation(joinRef, leftSubTree, rightSubTree,
<|startcomment|> This should be (expression == null ...). You might factor it out with something like addCandidateFile() with the code in registerAll. <|endcomment|>  Path name = ev.context(); Path child = dir.resolve(name); // if directory is created then register it and its sub-directories if ((kind == StandardWatchEventKinds.ENTRY_CREATE)) { try { if (Files.isDirectory(child, LinkOption.NOFOLLOW_LINKS)) { registerAll(child); } else { // it is a file, add it to the files list. <|startfocus|> if (expression != null || Pattern.matches(expression, child.toString())) { files.add(new File(child.toString())); } <|endfocus|> } } catch (IOException e) { if (LOGGER.isEnabledFor(Level.WARN)) { LOGGER.warn(e.getMessage() + ":" + e.getStackTrace()); } } } }
<|startcomment|> better be getRequestType() or getReplicationRequestType() <|endcomment|>  DataOutputStream oos = new DataOutputStream(outputStream); lsmCompProp.serialize(oos); oos.close(); int requestSize = REPLICATION_REQUEST_HEADER_SIZE + oos.size(); if (buffer.capacity() < requestSize) { buffer = ByteBuffer.allocate(requestSize); } buffer.clear(); buffer.putInt(ReplicationFunctions.LSM_COMPONENT_PROPERTIES.ordinal()); buffer.putInt(oos.size()); buffer.put(outputStream.toByteArray()); buffer.flip(); } <|startfocus|> public static ReplicationFunctions getRequestFunction(SocketChannel socketChannel, ByteBuffer byteBuffer) <|endfocus|> throws IOException { //read replication request type NetworkingUtil.readBytes(socketChannel, byteBuffer, REPLICATION_FUNCATION_SIZE); ReplicationFunctions requestType = AsterixReplicationProtocol.ReplicationFunctions.values()[byteBuffer.getInt()]; return requestType; } public static LSMComponentProperties readLSMPropertiesRequest(ByteBuffer buffer) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream(buffer.array(), buffer.position(), buffer.limit()); DataInputStream dis = new DataInputStream(bais); return LSMComponentProperties.create(dis); } public static ByteBuffer getGoodbyeBuffer() {
<|startcomment|> lsmComponentLSNMappingService <|endcomment|>  IAsterixAppRuntimeContextProvider asterixAppRuntimeContextProvider) { this.logManager = logManager; this.localNodeID = nodeId; this.replicaResourcesManager = (ReplicaResourcesManager) replicaResoucesManager; this.replicationManager = replicationManager; this.replicationProperties = replicationProperties; this.asterixAppRuntimeContextProvider = asterixAppRuntimeContextProvider; <|startfocus|> lsmComponentsFilesSyncQ = new LinkedBlockingQueue<LSMComponentLSNSyncTask>(); lsmComponents = new ConcurrentHashMap<String, LSMComponentProperties>(); remoteLogsMap = new ConcurrentHashMap<Long, RemoteLogMapping>(); lsmComponentsSyncService = new LSMComponentsSyncService(); <|endfocus|> replicationThreads = Executors.newCachedThreadPool(appContext.getThreadFactory());
<|startcomment|> In which case the type environment returns a null for that expression? Should we throw an exception for that case? <|endcomment|>  } return false; } protected boolean performFinalAction() throws AlgebricksException { return false; } /* An expression will be constant at runtime if it has: * 1. A type * 2. No free variables */ public static boolean functionIsConstantAtRuntime(AbstractLogicalOperator op, AbstractFunctionCallExpression funcExpr, IOptimizationContext context) throws AlgebricksException { <|startfocus|> // make sure that the expression returns a type if (op.computeOutputTypeEnvironment(context).getType(funcExpr) == null) { return false; } <|endfocus|> //make sure that there are no variables in the expression Set<LogicalVariable> usedVariables = new HashSet<LogicalVariable>(); funcExpr.getUsedVariables(usedVariables); if (usedVariables.size() > 0) { return false; } return true; } protected boolean inlineVariables(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator op = (AbstractLogicalOperator) opRef.getValue(); // Update mapping from variables to expressions during top-down traversal. if (op.getOperatorTag() == LogicalOperatorTag.ASSIGN) {
<|startcomment|> I know this has been sit here a long time. Other than an assert, how about throwing an exception? <|endcomment|>  @Override public void computeDeliveredProperties(ILogicalOperator op, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator op2 = (AbstractLogicalOperator) op.getInputs().get(0).getValue(); deliveredProperties = (StructuralPropertiesVector) op2.getDeliveredPhysicalProperties().clone(); } @Override public void contributeRuntimeOperator(IHyracksJobBuilder builder, JobGenContext context, ILogicalOperator op, IOperatorSchema propagatedSchema, IOperatorSchema[] inputSchemas, IOperatorSchema outerPlanSchema) throws AlgebricksException { <|startfocus|> InsertOperator insertDeleteOp = (InsertOperator) op; assert insertDeleteOp.isBulkload(); <|endfocus|> IMetadataProvider mp = context.getMetadataProvider(); IVariableTypeEnvironment typeEnv = context.getTypeEnvironment(op); JobSpecification spec = builder.getJobSpec(); RecordDescriptor inputDesc = JobGenHelper.mkRecordDescriptor( context.getTypeEnvironment(op.getInputs().get(0).getValue()), inputSchemas[0], context); Pair<IOperatorDescriptor, AlgebricksPartitionConstraint> runtimeAndConstraints = mp.getInsertRuntime(dataSource, propagatedSchema, typeEnv, primaryKeys, payload, additionalFilteringKeys, inputDesc, context, spec, true); builder.contributeHyracksOperator(insertDeleteOp, runtimeAndConstraints.first);
<|startcomment|> what is this try for? <|endcomment|>  for (Iterator<TxnId> iterator = cachedEntityCommitTxns.iterator(); iterator.hasNext();) { TxnId txnId = iterator.next(); //serialize the object and remove it from memory txnId.serialize(buffer); iterator.remove(); } //name partition file based on job id and max lsn File partitionFile = createJobRecoveryFile(jobId, getPartitonName(partitionMaxLSN)); //write file to disk try (FileOutputStream fileOutputstream = new FileOutputStream(partitionFile, false); FileChannel fileChannel = fileOutputstream.getChannel()) { buffer.flip(); <|startfocus|> fileChannel.write(buffer); fileChannel.force(true); <|endfocus|> } jobEntitCommitOnDiskPartitionsFiles.add(partitionFile); } private void loadPartitionToMemory(File partition, Set<TxnId> partitionTxn) throws IOException { partitionTxn.clear(); //if we don't have enough memory to a load partition, we will ask recovery manager to free memory if (needToFreeMemroy()) { freeJobsCachedEntities(jobId); } ByteBuffer buffer = ByteBuffer.allocateDirect((int) partition.length()); //load partition to memory
<|startcomment|> One tiny space. <|endcomment|>  /** * Persistent the LSM component * * @param lsmComponent * , the component to be persistent * @throws HyracksDataException */ public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException; public boolean isCurrentMutableComponentEmpty() throws HyracksDataException; public void scheduleReplication(ILSMIndexOperationContext ctx, List<ILSMComponent> lsmComponents, boolean bulkload, ReplicationOperation operation, LSMOperationType opType) throws HyracksDataException; /** * Allocates the memory components of an LSM index in the buffer cache. <|startfocus|> * <|endfocus|> * @throws HyracksDataException */ public void allocateMemoryComponents() throws HyracksDataException; public boolean isMemoryComponentsAllocated(); } 
<|startcomment|> "abstract" is not needed because it is an interface. The same for the rest methods. <|endcomment|>  public void getColumns(Collection<LogicalVariable> columns) { } @Override public INodeDomain getNodeDomain() { return DOMAIN_FOR_UNPARTITIONED_DATA; } @Override public String toString() { return getPartitioningType().toString(); } @Override public void setNodeDomain(INodeDomain domain) { throw new IllegalStateException(); } @Override public void setSingle(boolean isSingle) { } @Override public boolean isSingle() { return false; } }; public abstract void setSingle(boolean isSingle); <|startfocus|> public abstract boolean isSingle(); <|endfocus|> public abstract PartitioningType getPartitioningType(); public abstract void normalize(Map<LogicalVariable, EquivalenceClass> equivalenceClasses, List<FunctionalDependency> fds); public abstract INodeDomain getNodeDomain(); public abstract void setNodeDomain(INodeDomain domain); } 
<|startcomment|> Is this class used? <|endcomment|>  */ package org.apache.asterix.metadata.feeds; import java.util.Map; import org.apache.asterix.common.feeds.api.IDatasourceAdapter; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.algebricks.common.constraints.AlgebricksPartitionConstraint; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.dataflow.value.RecordDescriptor; /** * Represents the base class that is required to be extended by every * implementation of the IDatasourceAdapter interface. */ public abstract class AbstractDatasourceAdapter implements IDatasourceAdapter { private static final long serialVersionUID = 1L; <|startfocus|> <|endfocus|> public static final String KEY_PARSER_FACTORY = "parser"; protected Map<String, Object> configuration; protected transient AlgebricksPartitionConstraint partitionConstraint; protected IAType atype; protected IHyracksTaskContext ctx; protected RecordDescriptor rDesc; public void setRecDesc(RecordDescriptor rDesc){ this.rDesc = rDesc; } } 
<|startcomment|> remove <|endcomment|>  public boolean validateEmpty(){ //TODO: collect all the dpids that should be reachable and then test finding them boolean valid = true; synchronized (cachedPages) { for (ICachedPageInternal internalPage : cachedPages) { CachedPage c = (CachedPage) internalPage; <|startfocus|> if (c.confiscated() || <|endfocus|> c.latch.getReadLockCount() != 0 || c.latch.getWriteHoldCount() != 0) { valid = false; } } } return valid;
<|startcomment|> clean up <|endcomment|>  LSMComponentFileReferences componentFileRefs = fileManager.getRelFlushFileReference(); return createDiskComponent(bulkLoadComponentFactory, componentFileRefs.getInsertIndexFileReference(), componentFileRefs.getBloomFilterFileReference(), true); } @Override public void markAsValid(ILSMComponent lsmComponent) throws HyracksDataException { // The order of forcing the dirty page to be flushed is critical. The // bloom filter must be always done first. LSMBTreeDiskComponent component = (LSMBTreeDiskComponent) lsmComponent; <|startfocus|> // // Flush the bloom filter first. <|endfocus|> int fileId = component.getBloomFilter().getFileId(); IBufferCache bufferCache = component.getBTree().getBufferCache(); int startPage = 0; int maxPage = component.getBloomFilter().getNumPages(); forceFlushDirtyPages(bufferCache, fileId, startPage, maxPage); forceFlushDirtyPages(component.getBTree()); markAsValidInternal(component.getBTree()); } public class LSMBTreeBulkLoader implements IIndexBulkLoader { private final ILSMComponent component; private final BTreeBulkLoader bulkLoader; private final IIndexBulkLoader builder; private boolean cleanedUpArtifacts = false; private boolean isEmptyComponent = true;
<|startcomment|> race condition. <|endcomment|>  final Pair<IVisitablePointable, Boolean> arg = new Pair<IVisitablePointable, Boolean>(accessor1, false); @Override public void evaluate(IFrameTupleReference tuple) throws AlgebricksException { try { abvs0.reset(); abvs1.reset(); eval0.evaluate(tuple); eval1.evaluate(tuple); accessor0.set(abvs0); accessor1.set(abvs1); // Using deep equality assessment to assess the equality of the two values <|startfocus|> boolean isEqual = DeepEqualAssessor.INSTANCE.isEqual(accessor0, accessor1); <|endfocus|> ABoolean result = isEqual ? ABoolean.TRUE : ABoolean.FALSE; boolSerde.serialize(result, out); } catch (Exception ioe) { throw new AlgebricksException(ioe); } } }; } };
<|startcomment|> Again, I think the we can do without this address. <|endcomment|>  CCNCFunctions.StateDumpResponseFunction fn = new CCNCFunctions.StateDumpResponseFunction(nodeId, stateDumpId, state); ipcHandle.send(-1, fn, null); } @Override public void notifyShutdown(String nodeId) throws Exception{ CCNCFunctions.ShutdownResponseFunction sdrf = new CCNCFunctions.ShutdownResponseFunction(nodeId); ipcHandle.send(-1,sdrf,null); } <|startfocus|> public void getUnqiueId(InetSocketAddress ncAddress, String nodeId) throws Exception { CCNCFunctions.GetUniqueIdFunction gridf = new CCNCFunctions.GetUniqueIdFunction(ncAddress, nodeId); <|endfocus|> ipcHandle.send(-1, gridf, null); } } 
<|startcomment|> "...called, no matter successfully or not, the..." <|endcomment|>  * <li>FAILED</li> * </ul> * A producer follows the following protocol when using an {@link IFrameWriter}. * Initially, the {@link IFrameWriter} is in the INITIAL state. * The first valid call to an {@link IFrameWriter} is always the {@link IFrameWriter#open()}. This call provides the opportunity for the {@link IFrameWriter} implementation to allocate any resources for its * processing. Once open() is called, the {@link IFrameWriter} is in the OPENED * state. <|startfocus|> * While the {@link IFrameWriter} is in the OPENED state, the producer can call * one of: <|endfocus|> * <ul> * <li>{@link IFrameWriter#close()} to give up any resources owned by the {@link IFrameWriter} and enter the CLOSED state.</li>
<|startcomment|> move up writer.open() a line? <|endcomment|>  nullWriters1[i] = nullWriterFactories1[i].createNullWriter(); } } IOperatorNodePushable op = new AbstractUnaryInputUnaryOutputOperatorNodePushable() { private BuildAndPartitionTaskState state; private IFrame rPartbuff = new VSizeFrame(ctx); @Override public void open() throws HyracksDataException { state = (BuildAndPartitionTaskState) ctx.getStateObject( new TaskId(new ActivityId(getOperatorId(), BUILD_AND_PARTITION_ACTIVITY_ID), partition)); writer.open(); state.hybridHJ.initProbe(); <|startfocus|> <|endfocus|> LOGGER.fine("OptimizedHybridHashJoin is starting the probe phase."); } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { state.hybridHJ.probe(buffer, writer); } @Override public void fail() throws HyracksDataException { writer.fail(); } @Override public void close() throws HyracksDataException { try { state.hybridHJ.closeProbe(writer); BitSet partitionStatus = state.hybridHJ.getPartitionStatus(); rPartbuff.reset();
<|startcomment|> Exception-->Throwable <|endcomment|>  accessor.reset(buffer); int tupleCount = accessor.getTupleCount(); for (int i = 0; i < tupleCount; i++) { tuple.reset(accessor, i); try { bulkLoader.add(tuple); } catch (IndexException e) { throw new HyracksDataException(e); } } } @Override public void close() throws HyracksDataException { if (index != null) { try { bulkLoader.end(); <|startfocus|> } catch (Exception e) { throw new HyracksDataException(e); <|endfocus|> } finally { try { indexHelper.close(); } finally { writer.close(); } } } } @Override public void fail() throws HyracksDataException { if (index != null) { try { ((ITwoPCIndexBulkLoader) bulkLoader).abort(); } finally { writer.fail(); } } } } 
<|startcomment|> Do you need to expose the IPCHandle? Where this get method is called? I couldn't find a place. <|endcomment|>  public void abortTasks(JobId jobId, List<TaskAttemptId> tasks) throws Exception; public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; public void dumpState(String stateDumpId) throws Exception; public void shutDown() throws Exception; <|startfocus|> public IIPCHandle getIPCHandle(); <|endfocus|> } 
<|startcomment|> s/cluser/cluster/ <|endcomment|>  LOGGER.warning("Unknown message: " + absMessage.getMessageType()); break; } } private synchronized void handleResourceIdRequest(IMessage message, String nodeId) throws Exception { ResourceIdRequestMessage msg = (ResourceIdRequestMessage) message; ResourceIdRequestResponseMessage reponse = new ResourceIdRequestResponseMessage(); reponse.setId(msg.getId()); //cluster is not active if (!AsterixClusterProperties.isClusterActive()) { reponse.setResourceId(-1); <|startfocus|> reponse.setException(new Exception("Cannot generate global resource id when cluser is not active.")); <|endfocus|> } else if (nodesReportedMaxResourceId.size() < AsterixClusterProperties.getNumberOfNodes()) { //some node has not reported max resource id reponse.setResourceId(-1); reponse.setException(new Exception("One or more nodes has not reported max resource id.")); requestMaxResourceID(); } else { reponse.setResourceId(globalResourceId.incrementAndGet()); } sendApplicationMessageToNC(reponse, nodeId); } private synchronized void handleReportResourceMaxIdResponse(IMessage message, String nodeId) throws Exception {
<|startcomment|> WS <|endcomment|>  * The data source type for a parser and a data source must match. * an instance of IDataParserFactory with RECORDS data source type must implement IRecordDataParserFactory<T> * an instance of IDataParserFactory with STREAM data source type must implement IStreamDataParserFactory */ public DataSourceType getDataSourceType(); /** * Configure the data parser factory. The passed map contains key value pairs from the * submitted AQL statement and any additional pairs added by the compiler <|startfocus|> * <|endfocus|> * @param configuration */ public void configure(Map<String, String> configuration) throws Exception; /** * Set the record type expected to be produced by parsers created by this factory * * @param recordType */ public void setRecordType(ARecordType recordType); } 
<|startcomment|> Let's make those non-static while we're touching it. <|endcomment|>  public TestExecutor() { <|startfocus|> TestExecutor.host = "127.0.0.1"; TestExecutor.port = 19002; <|endfocus|>
<|startcomment|> use same logic as in configure. <|endcomment|>  public DataSourceType getDataSourceType() { <|startfocus|> return isStreamParser ? DataSourceType.STREAM : DataSourceType.RECORDS; <|endfocus|>
<|startcomment|> This method has a bunch of issues: 1. you need to take the subdata type item and break it into its two components (dataverse name and data type name). then check and make sure that the dataverse of the subtype == the dataverse of the type to be deleted. 2. the way this is implemented means all the types will be loaded in memory. if the system was used for a very long time, then the memory cost of this will be too much. I know this is right now is done like this everywhere. can you please add a todo for this? 3. Did you add test cases to test this failure scenario? do some with fully qualified names and some without. 4. the error message in the exception is not correct. the second dataverse name should be the dataverse name of the other data type. <|endcomment|>  if (set.getItemTypeName().equals(datatypeName) && set.getItemTypeDataverseName().equals(dataverseName)) { throw new MetadataException("Cannot drop type " + dataverseName + "." + datatypeName + " being used by dataset " + set.getDataverseName() + "." + set.getDatasetName()); } } } private void confirmDatatypeIsUnusedByDatatypes(JobId jobId, String dataverseName, String datatypeName) throws MetadataException, RemoteException { <|startfocus|> //If any datatype uses this type, throw an error <|endfocus|> List<Datatype> datatypes = getAllDatatypes(jobId); for (Datatype type : datatypes) { if (!type.getDataverseName().equals(dataverseName)) { continue; } ARecordType recType = (ARecordType) type.getDatatype(); for (IAType subType : recType.getFieldTypes()) { if (subType.getTypeName().equals(datatypeName)) { throw new MetadataException("Cannot drop type " + dataverseName + "." + datatypeName + " being used by type " + dataverseName + "." + recType.getTypeName()); }
<|startcomment|> Is this used? <|endcomment|>  private static final byte SER_NULL_TYPE_TAG = ATypeTag.NULL.serialize(); private static final byte SER_ORDEREDLIST_TYPE_TAG = ATypeTag.ORDEREDLIST.serialize(); public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { public IFunctionDescriptor createFunctionDescriptor() { return new RecordRemoveFieldsDescriptor(); } }; private RecordRemoveFieldsDescriptor() { } private ARecordType outputRecordType; private ARecordType inputRecType; private AOrderedListType inputListType; <|startfocus|> private AOrderedList pathAList; private List<List<String>> pathList; <|endfocus|> public void reset(IAType outType, IAType inType, List<List<String>> pathList) { this.outputRecordType = (ARecordType) outType; this.inputRecType = (ARecordType) inType; this.pathList = pathList; } public void reset(IAType outType, IAType inType, IAType inListType) { outputRecordType = (ARecordType) outType; inputRecType = (ARecordType) inType; inputListType = (AOrderedListType) inListType; } public ICopyEvaluatorFactory createEvaluatorFactory(final ICopyEvaluatorFactory[] args) throws AlgebricksException {
<|startcomment|> Reformat <|endcomment|>  * Licensed to the Apache Software Foundation (ASF) under one <|startfocus|> * or more contributor license agreements. See the NOTICE file <|endfocus|> * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.adapter.factory; import java.util.List; import java.util.Map; import org.apache.asterix.external.api.IAdapterFactory; import org.apache.asterix.external.api.IDataFlowController; import org.apache.asterix.external.api.IDataParserFactory;
<|startcomment|> reformat <|endcomment|>  * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance <|startfocus|> * with the License. You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 <|endfocus|> * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.library; import java.io.DataOutput; import org.apache.asterix.common.exceptions.AsterixException; import org.apache.asterix.external.api.IResultCollector; import org.apache.asterix.formats.nontagged.AqlSerializerDeserializerProvider; import org.apache.asterix.om.base.AMutableDouble;
<|startcomment|> I think that this file could stay unmodified. <|endcomment|>  finished = false; writer.open(); } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { if (!finished) { fta.reset(buffer); int count = fta.getTupleCount(); if ((currentSize + count) > outputLimit) { FrameTupleAppender partialAppender = new FrameTupleAppender(new VSizeFrame(ctx)); int copyCount = outputLimit - currentSize; for (int i = 0; i < copyCount; i++) { <|startfocus|> FrameUtils.appendToWriter(writer, partialAppender,fta, i); <|endfocus|> currentSize++; } partialAppender.flush(writer,false); finished = true; } else { FrameUtils.flushFrame(buffer, writer); currentSize += count; } } } @Override public void fail() throws HyracksDataException { writer.fail(); } @Override public void close() throws HyracksDataException { writer.close(); } }; } } 
<|startcomment|> "return !name.endsWith(LSM_COMPONENT_MASK_SUFFIX);"? <|endcomment|>  private static final FilenameFilter LSM_COMPONENTS_MASKS_FILTER = new FilenameFilter() { public boolean accept(File dir, String name) { if (name.endsWith(LSM_COMPONENT_MASK_SUFFIX)) { return true; } else { return false; } } }; private static final FilenameFilter LSM_COMPONENTS_NON_MASKS_FILTER = new FilenameFilter() { public boolean accept(File dir, String name) { if (!name.endsWith(LSM_COMPONENT_MASK_SUFFIX)) { return true; } else { return false; } } }; private static final FilenameFilter LSM_INDEX_FILES_FILTER = new FilenameFilter() { public boolean accept(File dir, String name) { <|startfocus|> if (name.equalsIgnoreCase(PersistentLocalResourceRepository.METADATA_FILE_NAME)) { return true; } else if (!name.startsWith(".")) { return true; } else { return false; } <|endfocus|> } }; } 
<|startcomment|> This is the pipeline starter, therefore writer.flush() might be wanted. <|endcomment|>  @Override public void open() throws HyracksDataException { writer.open(); if (!appender.append(tb.getFieldEndOffsets(), tb.getByteArray(), 0, tb.getSize())) { throw new IllegalStateException(); } appender.flush(writer, true); } @Override public void close() throws HyracksDataException { writer.close(); } @Override public void flush() throws HyracksDataException { <|startfocus|> // This operator produces a single empty tuple and flush() doesn't make sense here <|endfocus|> } }; } } 
<|startcomment|> throw an exception here <|endcomment|>  if (writer == null) { FileReference file = ctx .createManagedWorkspaceFile(PartitionAndJoinActivityNode.class.getSimpleName()); writer = new RunFileWriter(file, ctx.getIOManager()); writer.open(); probeWriters[i] = writer; } writer.nextFrame(head); } @Override public void fail() throws HyracksDataException { writer.fail(); } <|startfocus|> @Override public void flush() throws HyracksDataException { // flush() on any join operator is a no op } <|endfocus|> }; return op; } } } 
<|startcomment|> Can we just revert this file as there are no changes? <|endcomment|>  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.om.types; import java.util.ArrayList; import java.util.List; /** * There is a unique tag for each primitive type and for each kind of <|startfocus|> * non-primitive type in the object model. * @author Nicola <|endfocus|> */ public enum ATypeTag implements IEnumSerializer { INT8(1), INT16(2), INT32(3), INT64(4), UINT8(5), UINT16(6), UINT32(7), UINT64(8), BINARY(9), BITARRAY(10), FLOAT(11), DOUBLE(12), STRING(13), NULL(14), BOOLEAN(15), DATETIME(16), DATE(17), TIME(18), DURATION(19), POINT(20), POINT3D(21), ORDEREDLIST(22), UNORDEREDLIST(23), RECORD(24), SPARSERECORD(25),
<|startcomment|> better error message. <|endcomment|>  if (j > 0){ sb.append("|"); } sb.append("f" + j + ":(" + getFieldStartOffset(tid, j) + ", " + getFieldEndOffset(tid, j) + ") "); sb.append("{"); bbis.setByteBuffer(buffer, getTupleStartOffset(tid) + getFieldSlotsLength() + getFieldStartOffset(tid, j)); try { sb.append(recordDescriptor.getFields()[j].deserialize(dis)); } catch (Exception e) { e.printStackTrace(); <|startfocus|> sb.append("AException!"); <|endfocus|> } sb.append("}"); } sb.append("\n");
<|startcomment|> Revise this behavior. <|endcomment|>  } @Override public void close() throws HyracksDataException { try { coreOperator.close(); } catch (Exception e) { e.printStackTrace(); // ignore } finally { if (inputSideHandler != null) { inputSideHandler.close(); } if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Ending Operator " + this.feedRuntime.getRuntimeId()); } } } @Override public void flush() throws HyracksDataException { <|startfocus|> if (inputSideHandler != null) { inputSideHandler.flush(); } else { coreOperator.flush(); } <|endfocus|> } } 
<|startcomment|> Why would we throw a HyracksDataException here? Shouldn't this be a ParseException? <|endcomment|>  int token = admLexer.next(); if (token == AdmLexer.TOKEN_CONSTRUCTOR_OPEN) { token = admLexer.next(); if (token == AdmLexer.TOKEN_STRING_LITERAL) { long chrononTimeInMs = 0; final String arg = admLexer.getLastTokenImage(); if (tag == ATypeTag.DATE) { try { chrononTimeInMs += (parseDatePart(arg, 0, arg.length() - 1) / GregorianCalendarSystem.CHRONON_OF_DAY); <|startfocus|> } catch (Exception e) { throw new HyracksDataException(e); } } else if (tag == ATypeTag.TIME) { try { <|endfocus|> chrononTimeInMs += parseTimePart(arg, 0, arg.length() - 1); } catch (Exception e) { throw new HyracksDataException(e); } } else if (tag == ATypeTag.DATETIME) { try { int timeSeperatorOffsetInDatetimeString = arg.indexOf('T'); if (timeSeperatorOffsetInDatetimeString < 0) { throw new AlgebricksException(
<|startcomment|> Socket adapter? <|endcomment|>  if (configuration.get(ExternalDataConstants.KEY_FORMAT) == null) { throw new AsterixException("Unspecified format parameter for local file system adapter"); } configuration.put(ExternalDataConstants.KEY_READER, configuration.get(ExternalDataConstants.KEY_FORMAT)); configuration.put(ExternalDataConstants.KEY_READER_STREAM, ExternalDataConstants.ALIAS_LOCALFS_ADAPTER); } // Socket if (adapterName.equalsIgnoreCase(ExternalDataConstants.ALIAS_SOCKET_ADAPTER)) { if (configuration.get(ExternalDataConstants.KEY_FORMAT) == null) { <|startfocus|> throw new AsterixException("Unspecified format parameter for local file system adapter"); <|endfocus|> } configuration.put(ExternalDataConstants.KEY_READER, configuration.get(ExternalDataConstants.KEY_FORMAT)); configuration.put(ExternalDataConstants.KEY_READER_STREAM, ExternalDataConstants.STREAM_SOCKET); } // Twitter (Pull) if (adapterName.equals(ExternalDataConstants.ALIAS_TWITTER_PULL_ADAPTER)) { configuration.put(ExternalDataConstants.KEY_READER, ExternalDataConstants.READER_TWITTER_PULL); configuration.put(ExternalDataConstants.KEY_PULL, ExternalDataConstants.TRUE); ExternalDataUtils.setRecordFormat(configuration, ExternalDataConstants.FORMAT_TWEET); } // Twitter (Push) if (adapterName.equals(ExternalDataConstants.ALIAS_TWITTER_PUSH_ADAPTER)) {
<|startcomment|> How about return (this == ATypeTag.RECORD || this == ATypeTag.ORDEREDLIST || this == ATypeTag.UNORDEREDLIST || this == ATypeTag.UNION)); <|endcomment|>  typeList.add(null); } typeList.set(index, tt); } VALUE_TYPE_MAPPING = typeList.toArray(new ATypeTag[typeList.size()]); } private ATypeTag(int value) { this.value = (byte) value; } @Override public byte serialize() { return value; } public boolean isDerivedType() { <|startfocus|> if (this == ATypeTag.RECORD || this == ATypeTag.ORDEREDLIST || this == ATypeTag.UNORDEREDLIST || this == ATypeTag.UNION) { return true; } return false; <|endfocus|> } } 
<|startcomment|> Update the variable name to represent the new type. <|endcomment|>  private static final long serialVersionUID = 1L; @SuppressWarnings("unchecked") private final ISerializerDeserializer<ANull> nullSerDe = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.ANULL); @Override public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws AlgebricksException { final PointableAllocator allocator = new PointableAllocator(); final IVisitablePointable vp0 = allocator.allocateRecordValue(inRecType); final IVisitablePointable vp1 = allocator.allocateListValue(inListType); <|startfocus|> final IPointable abvs0 = new VoidPointable(); final IPointable abvs1 = new VoidPointable(); <|endfocus|> final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx); final ArrayBackedValueStorage fieldNamePointable = new ArrayBackedValueStorage(); final ArrayBackedValueStorage fieldValuePointer = new ArrayBackedValueStorage(); final PointableHelper pointableHelper = new PointableHelper(); try { pointableHelper.serializeString("field-name", fieldNamePointable, true); pointableHelper.serializeString("field-value", fieldValuePointer, true); } catch (AsterixException e) { throw new AlgebricksException(e); } 
<|startcomment|> Can you use an immutable set (ImmutableSet.of(...)) to store all function identifiers that shouldn't be constant-folded? It should include: 1. All record functions: record-merge record-add-fields record-remove-fields get-record-fields get-record-field-value field-access-nested field-access-by-index field-access-by-name 2. All collection functions: ordered-list-constructor unordered-list-constructor get-item 3. All cast functions for complex types: cast-record cast-list <|endcomment|>  } @Override public Pair<Boolean, ILogicalExpression> visitScalarFunctionCallExpression(ScalarFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); if (!checkArgs(expr) || !expr.isFunctional()) { return new Pair<Boolean, ILogicalExpression>(changed, expr); } <|startfocus|> // Skip constant folding for record-relation functions. if (expr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.GET_RECORD_FIELDS) || expr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.RECORD_MERGE)) { <|endfocus|> return new Pair<Boolean, ILogicalExpression>(false, null); } //Current ARecord SerDe assumes a closed record, so we do not constant fold open record constructors if (expr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.OPEN_RECORD_CONSTRUCTOR) || expr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.CAST_RECORD)) { return new Pair<Boolean, ILogicalExpression>(false, null); } //Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors if they are not strongly typed if (expr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.UNORDERED_LIST_CONSTRUCTOR)
<|startcomment|> Prefer "filesystem" myself, but I guess both are acceptable. Do exactly one of these need to be specified? Should this error message be clarified to indicate what is expected? <|endcomment|>  } } // Local Filesystem if (adapterName.equals(ExternalDataConstants.ALIAS_LOCALFS_ADAPTER) || adapterName.contains(ExternalDataConstants.ADAPTER_LOCALFS_CLASSNAME) || adapterName.contains(ExternalDataConstants.ALIAS_LOCALFS_PUSH_ADAPTER)) { if (configuration.get(ExternalDataConstants.KEY_READER) == null) { if (configuration.get(ExternalDataConstants.KEY_FORMAT) == null) { throw new AsterixException( <|startfocus|> "Unspecified (\"reader\" or \"format\") parameter for local file system adapter"); <|endfocus|> } configuration.put(ExternalDataConstants.KEY_READER, configuration.get(ExternalDataConstants.KEY_FORMAT)); configuration.put(ExternalDataConstants.KEY_READER_STREAM, ExternalDataConstants.ALIAS_LOCALFS_ADAPTER); } } // Socket if (adapterName.equalsIgnoreCase(ExternalDataConstants.ALIAS_SOCKET_ADAPTER) || adapterName.equalsIgnoreCase(ExternalDataConstants.ALIAS_SOCKET_CLIENT_ADAPTER)) { if (configuration.get(ExternalDataConstants.KEY_FORMAT) == null) { throw new AsterixException("Unspecified format parameter for socket adapter"); } configuration.put(ExternalDataConstants.KEY_READER, configuration.get(ExternalDataConstants.KEY_FORMAT)); configuration.put(ExternalDataConstants.KEY_READER_STREAM, ExternalDataConstants.STREAM_SOCKET); }
<|startcomment|> trailing ws <|endcomment|>  newAd.clear(); name = "[" + serialized_nvp.toString() + "]"; if (parser.parseClassAd(name, newAd, true)) { return update(newAd); } else { return false; } } ExprTree newTree; // we did not hit in the cache... parse the expression newTree = parser.ParseExpression(szValue); if (newTree != null) { <|startfocus|> // if caching is enabled, and we got to here then we know that the <|endfocus|> // cache doesn't already have an entry for this name:value, so add // it to the cache now. if (newTree.getKind() != NodeKind.LITERAL_NODE) { Literal lit = parser.getLiteral(); lit.getValue().setStringValue(szValue); bRet = insert(name, lit, false); } else { bRet = insert(name, newTree, false); } } } // end if pos >=0 return bRet; } public boolean insert(String attrName, ExprTree expr) throws HyracksDataException {
<|startcomment|> Doesn't this instead duplicate the next character instead of reinstating the last one? <|endcomment|>  public void unreadCharacter() { if (position == 0) { <|startfocus|> System.arraycopy(buffer, 0, buffer, 1, buffer.length - 1); <|endfocus|> validBytes++; return; } else { position--; }
<|startcomment|> trailing ws <|endcomment|>  import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class ClassAdParserTest extends TestCase { /** * Create the test case * * @param testName * name of the test case */ public ClassAdParserTest(String testName) { super(testName); } /** * @return the suite of tests being tested */ public static Test suite() { return new TestSuite(ClassAdParserTest.class); } /** <|startfocus|> * <|endfocus|> */ public void testApp() { try { // test here ClassAd pAd = new ClassAd(); String szInput; String[] files = new String[] { "/testdata.txt" }; BufferedReader infile = null; for (String path : files) { infile = Files.newBufferedReader(Paths.get(getClass().getResource(path).getPath()), StandardCharsets.UTF_8); szInput = infile.readLine(); while (szInput != null) { if (szInput.trim().length() == 0) {
<|startcomment|> Let's remove this file from this patch set since there is no change. <|endcomment|>  compileSubplans(inputSchemas[0], gby, opSchema, context); IOperatorDescriptorRegistry spec = builder.getJobSpec(); IBinaryComparatorFactory[] comparatorFactories = JobGenHelper.variablesToAscBinaryComparatorFactories(gbyCols, aggOpInputEnv, context); RecordDescriptor recordDescriptor = JobGenHelper.mkRecordDescriptor(context.getTypeEnvironment(op), opSchema, context); IBinaryHashFunctionFamily[] hashFunctionFactories = JobGenHelper.variablesToBinaryHashFunctionFamilies( gbyCols, aggOpInputEnv, context); <|startfocus|> ICopySerializableAggregateFunctionFactory[] merges = new ICopySerializableAggregateFunctionFactory[n]; <|endfocus|> List<LogicalVariable> usedVars = new ArrayList<LogicalVariable>(); IOperatorSchema[] localInputSchemas = new IOperatorSchema[1]; localInputSchemas[0] = new OperatorSchemaImpl(); for (i = 0; i < n; i++) { AggregateFunctionCallExpression aggFun = (AggregateFunctionCallExpression) aggOp.getMergeExpressions() .get(i).getValue(); aggFun.getUsedVariables(usedVars); } i = 0; for (Object type : intermediateTypes) { aggOpInputEnv.setVarType(usedVars.get(i++), type); } for (LogicalVariable keyVar : keyAndDecVariables)
<|startcomment|> remove "public" since it is supposed to be only be "generated" by a file writer. <|endcomment|> <|startfocus|> public GeneratedRunFileReader(FileReference file, IIOManager ioManager, long size, boolean deleteAfterRead, <|endfocus|> int maxFrameSize) { super(file, ioManager, size, deleteAfterRead); this.maxFrameSize = maxFrameSize;
<|startcomment|> "externalGroup" --> "externalGroupBy" <|endcomment|>  implements IRunFileWriterGenerator { private static Logger LOGGER = Logger.getLogger("ExternalGroupBuildPhase"); private final IHyracksTaskContext ctx; private final Object stateId; private final int[] keyFields; private final IBinaryComparator[] comparators; private final INormalizedKeyComputer firstNormalizerComputer; private final IAggregatorDescriptorFactory aggregatorFactory; private final int framesLimit; private final ISpillableTableFactory spillableTableFactory; private final RecordDescriptor inRecordDescriptor; private final RecordDescriptor outRecordDescriptor; private final int tableSize; private ExternalHashGroupBy externalGroup; <|startfocus|> private ExternalGroupState state; <|endfocus|> public ExternalGroupBuildOperatorNodePushable(IHyracksTaskContext ctx, Object stateId, int tableSize, int[] keyFields, int framesLimit, IBinaryComparatorFactory[] comparatorFactories, INormalizedKeyComputerFactory firstNormalizerFactory, IAggregatorDescriptorFactory aggregatorFactory, RecordDescriptor inRecordDescriptor, RecordDescriptor outRecordDescriptor, ISpillableTableFactory spillableTableFactory) { this.ctx = ctx; this.stateId = stateId; this.framesLimit = framesLimit; this.aggregatorFactory = aggregatorFactory; this.keyFields = keyFields; this.comparators = new IBinaryComparator[comparatorFactories.length];
<|startcomment|> use tupleCount variable <|endcomment|>  if (hasEnoughSpace(fieldCount, dataLength + MAX_MESSAGE_SIZE)) { return true; } if (tupleCount == 0) { frame.ensureFrameSize(FrameHelper.calcAlignedFrameSizeToStore(fieldCount, dataLength + MAX_MESSAGE_SIZE, frame.getMinSize())); reset(frame.getBuffer(), true); return true; } return false; } @Override public void write(IFrameWriter outWriter, boolean clearFrame) throws HyracksDataException { <|startfocus|> if (getTupleCount() > 0) { <|endfocus|> appendMessage(); getBuffer().clear(); outWriter.nextFrame(getBuffer()); if (clearFrame) { frame.reset(); reset(getBuffer(), true); } } } public void appendMessage() { ByteBuffer message = (ByteBuffer) ctx.getSharedObject(); System.arraycopy(message.array(), message.position(), array, tupleDataEndOffset, message.limit()); tupleDataEndOffset += message.limit(); IntSerDeUtils.putInt(getBuffer().array(), FrameHelper.getTupleCountOffset(frame.getFrameSize()) - 4 * (tupleCount + 1), tupleDataEndOffset); ++tupleCount;
<|startcomment|> WS <|endcomment|>  ExprTreeHolder fChild1 = new ExprTreeHolder(); ExprTreeHolder fChild2 = new ExprTreeHolder();; Value val1 = new Value(); Value val2 = new Value(); Value val3 = new Value(); AMutableInt32 newOp = new AMutableInt32(opKind); int op = opKind; tree.setInnerTree(null);; // Just to be safe... wenger 2003-12-11. <|startfocus|> // if op is binary, but not associative or commutative, disallow splitting <|endfocus|> if ((op >= OpKind_COMPARISON_START && op <= OpKind_COMPARISON_END) || op == OpKind_SUBTRACTION_OP || op == OpKind_DIVISION_OP || op == OpKind_MODULUS_OP || op == OpKind_LEFT_SHIFT_OP || op == OpKind_RIGHT_SHIFT_OP || op == OpKind_URIGHT_SHIFT_OP) { if (opPtr != null) opPtr.setValue(OpKind_NO_OP); if (child1.publicFlatten(state, val1, fChild1) && child2.publicFlatten(state, val2, fChild2)) {
<|startcomment|> WS <|endcomment|>  if (!evaluate_expr(tree, value1, parameters)) { print_error_message("Couldn't evaluate first expression.\n", state); } else if (!evaluate_expr(tree2, value2, parameters)) { print_error_message("Couldn't evaluate second expressions.\n", state); } else if (value1.sameAs(value2)) { print_error_message("the expressions are the same.", state); assert (false); } } return; } /********************************************************************* * Function: handle_diffq * Purpose: <|startfocus|> * <|endfocus|> * @throws IOException *********************************************************************/ public static void handle_diffq(AMutableString line, State state, Parameters parameters) throws IOException { ExprTreeHolder tree = new ExprTreeHolder(); ExprTreeHolder tree2 = new ExprTreeHolder(); get_two_exprs(line, tree, tree2, state, parameters); if (tree.getInnerTree() != null || tree2.getInnerTree() != null) { if (tree.sameAs(tree2)) { print_error_message("the expressions are the same.", state); } } return; } /*********************************************************************
<|startcomment|> Proposals: - no space before the exclamation mark - just one exclamation mark - a space after the colon <|endcomment|>  fieldNameBuffer.reset(); fieldValueBuffer.reset(); expectingRecordField = false; if (recType != null) { String fldName = admLexer.getLastTokenImage().substring(1, admLexer.getLastTokenImage().length() - 1); fieldId = recBuilder.getFieldId(fldName); if (fieldId < 0 && !recType.isOpen()) { throw new ParseException( <|startfocus|> "This record is closed, you can not add extra fields !! new field name:" + fldName); <|endfocus|> } else if (fieldId < 0 && recType.isOpen()) { aStringFieldName.setValue(admLexer.getLastTokenImage().substring(1, admLexer.getLastTokenImage().length() - 1)); stringSerde.serialize(aStringFieldName, fieldNameBuffer.getDataOutput()); openRecordField = true; fieldType = null; } else { // a closed field nulls.set(fieldId); fieldType = recType.getFieldTypes()[fieldId]; openRecordField = false; } } else { aStringFieldName.setValue(
<|startcomment|> Could be package local - see above <|endcomment|> <|startfocus|> public static File getLibraryUninstallDir() { <|endfocus|> String workingDir = System.getProperty("user.dir"); return new File(workingDir + File.separator + "uninstall");
<|startcomment|> since when do we name member variables like this? :) <|endcomment|>  public class RSSFeedServlet extends HttpServlet { private static final long serialVersionUID = 1L; private static final String DEFAULT_FEED_TYPE = "default.feed.type"; private static final String FEED_TYPE = "type"; private static final String MIME_TYPE = "application/xml; charset=UTF-8"; private static final String COULD_NOT_GENERATE_FEED_ERROR = "Could not generate feed"; private static final DateFormat DATE_PARSER = new SimpleDateFormat("yyyy-MM-dd"); <|startfocus|> private String _defaultFeedType; <|endfocus|> @Override public void init() { _defaultFeedType = getServletConfig().getInitParameter(DEFAULT_FEED_TYPE); _defaultFeedType = (_defaultFeedType != null) ? _defaultFeedType : "atom_0.3"; } @Override public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException { try { SyndFeed feed = getFeed(req); String feedType = req.getParameter(FEED_TYPE); feedType = (feedType != null) ? feedType : _defaultFeedType; feed.setFeedType(feedType); res.setContentType(MIME_TYPE);
<|startcomment|> "FailedToDeserializeField" -> "Failed to deserialize field " <|endcomment|>  sb.append("|"); } sb.append("f" + j + ":(" + getFieldStartOffset(tid, j) + ", " + getFieldEndOffset(tid, j) + ") "); sb.append("{"); bbis.setByteBuffer(buffer, getTupleStartOffset(tid) + getFieldSlotsLength() + getFieldStartOffset(tid, j)); try { sb.append(recordDescriptor.getFields()[j].deserialize(dis)); } catch (Exception e) { e.printStackTrace(); <|startfocus|> sb.append("FailedToDeserializeField" + j); <|endfocus|> } sb.append("}"); } sb.append("\n");
<|startcomment|> That potentially might generate a lot of noise in the output. Instead could that go through standard Logger, so that one can disable unnecessary log entries? <|endcomment|>  try { out = socket.getOutputStream(); br = new BufferedReader(new FileReader(path)); String nextRecord; while ((nextRecord = br.readLine()) != null) { ByteBuffer b = StandardCharsets.UTF_8.encode(nextRecord); if (wait >= 1 && recordCount % batchSize == 0) { Thread.sleep(wait); } out.write(b.array(), 0, b.limit()); recordCount++; <|startfocus|> if (recordCount % 100000 == 0) { System.err.println("send " + recordCount); } <|endfocus|> if (recordCount == maxCount) { break; } } System.err.println("send " + recordCount); } catch (Exception e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } }
<|startcomment|> CodeStyle <|endcomment|>  .splitProviderAndPartitionConstraintsForDataset(dataset.getDataverseName(), datasetName, indexName, dataset.getDatasetDetails().isTemp()); // TODO: Here we assume there is only one search key field. int queryField = keyFields[0]; // Get tokenizer and search modifier factories. IInvertedIndexSearchModifierFactory searchModifierFactory = InvertedIndexAccessMethod .getSearchModifierFactory(searchModifierType, simThresh, secondaryIndex); <|startfocus|> IBinaryTokenizerFactory queryTokenizerFactory = InvertedIndexAccessMethod.getBinaryTokenizerFactory( searchModifierType, searchKeyType, secondaryIndex); <|endfocus|> IIndexDataflowHelperFactory dataflowHelperFactory; AsterixStorageProperties storageProperties = AsterixAppContextInfo.getInstance().getStorageProperties(); Pair<ILSMMergePolicyFactory, Map<String, String>> compactionInfo = DatasetUtils.getMergePolicyFactory( dataset, metadataProvider.getMetadataTxnContext()); boolean temp = dataset.getDatasetDetails().isTemp(); if (!isPartitioned) { dataflowHelperFactory = new LSMInvertedIndexDataflowHelperFactory( new AsterixVirtualBufferCacheProvider(dataset.getDatasetId()), compactionInfo.first, compactionInfo.second, new SecondaryIndexOperationTrackerProvider(dataset.getDatasetId()), AsterixRuntimeComponentsProvider.RUNTIME_PROVIDER, LSMInvertedIndexIOOperationCallbackFactory.INSTANCE,
<|startcomment|> You need to pass the IO device number from RecoveryManager#startRecoveryRedoPhase of the locaResource partition. You need to add a method in PersistentLocalResourceRepository that takes a partition and return the partition IO device number on this node. (similar to PersistentLocalResourceRepository#getPartitionPath) <|endcomment|>  this.tokenizerFactory = tokenizerFactory; this.isPartitioned = isPartitioned; this.mergePolicyFactory = mergePolicyFactory; this.mergePolicyProperties = mergePolicyProperties; this.invertedIndexFields = invertedIndexFields; this.filterFieldsForNonBulkLoadOps = filterFieldsForNonBulkLoadOps; this.invertedIndexFieldsForNonBulkLoadOps = invertedIndexFieldsForNonBulkLoadOps; } @Override public ILSMIndex createIndexInstance(IAsterixAppRuntimeContextProvider runtimeContextProvider, String filePath, <|startfocus|> int partition) throws HyracksDataException { List<IVirtualBufferCache> virtualBufferCaches = runtimeContextProvider.getVirtualBufferCaches(datasetID, partition); <|endfocus|> try { if (isPartitioned) { return InvertedIndexUtils.createPartitionedLSMInvertedIndex(virtualBufferCaches, runtimeContextProvider.getFileMapManager(), invListTypeTraits, invListCmpFactories, tokenTypeTraits, tokenCmpFactories, tokenizerFactory, runtimeContextProvider.getBufferCache(), filePath, runtimeContextProvider.getBloomFilterFalsePositiveRate(), mergePolicyFactory.createMergePolicy(mergePolicyProperties, runtimeContextProvider.getDatasetLifecycleManager()), new BaseOperationTracker(datasetID, runtimeContextProvider.getDatasetLifecycleManager().getDatasetInfo(datasetID)), runtimeContextProvider.getLSMIOScheduler(), LSMInvertedIndexIOOperationCallbackFactory.INSTANCE.createIOOperationCallback(),
<|startcomment|> WS <|endcomment|> <|startfocus|> public AlgebricksPartitionConstraint getPartitionConstraint() { <|endfocus|> clusterLocations = HDFSUtils.getPartitionConstraints(clusterLocations); return clusterLocations;
<|startcomment|> it's no longer field-access expressions, right? <|endcomment|>  // Tries transfomations one by one. for (final ILogicalExpressionReferenceTransform transformer : transformers) { if (transformer.transform(expression)) { return true; } } return false; } } class MetaKeyExpressionReferenceTransform implements ILogicalExpressionReferenceTransformWithCondition { private final List<LogicalVariable> keyVars; private final List<ScalarFunctionCallExpression> fieldAccessExpressions; MetaKeyExpressionReferenceTransform(final List<LogicalVariable> keyVars, final List<ScalarFunctionCallExpression> fieldAccessExpressions) { this.keyVars = keyVars; <|startfocus|> this.fieldAccessExpressions = fieldAccessExpressions; <|endfocus|> } @Override public boolean transform(final Mutable<ILogicalExpression> exprRef) throws AlgebricksException { final ILogicalExpression expr = exprRef.getValue(); if (expr.getExpressionTag() != LogicalExpressionTag.FUNCTION_CALL) { return false; } final AbstractFunctionCallExpression funcExpr = (AbstractFunctionCallExpression) expr; if (!funcExpr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.META_KEY)) { return false; } // Function is either field access or nested field access for (int i = 0; i < fieldAccessExpressions.size(); i++) {
<|startcomment|> inline "serde"? <|endcomment|>  throw new AlgebricksException("Feed not configured with a policy"); } feedPolicy.getProperties().put(BuiltinFeedPolicies.CONFIG_FEED_POLICY_KEY, feedPolicy.getPolicyName()); FeedConnectionId feedConnectionId = new FeedConnectionId(feedDataSource.getId().getDataverseName(), feedDataSource.getId().getDatasourceName(), feedDataSource.getTargetDataset()); <|startfocus|> feedCollector = new FeedCollectOperatorDescriptor(jobSpec, feedConnectionId, <|endfocus|> feedDataSource.getSourceFeedId(), feedOutputType, feedDesc, feedPolicy.getProperties(), feedDataSource.getLocation()); return new Pair<IOperatorDescriptor, AlgebricksPartitionConstraint>(feedCollector, determineLocationConstraint(feedDataSource)); } catch (Exception e) { throw new AlgebricksException(e); } } private AlgebricksAbsolutePartitionConstraint determineLocationConstraint(FeedDataSource feedDataSource) throws AsterixException { String[] locationArray = null; String locations = null;; switch (feedDataSource.getSourceFeedType()) { case PRIMARY: switch (feedDataSource.getLocation()) { case SOURCE_FEED_COMPUTE_STAGE: if (feedDataSource.getFeed().getFeedId().equals(feedDataSource.getSourceFeedId())) {
<|startcomment|> Is there a non-formatting change in this file? <|endcomment|>  public ExternalBTreeWithBuddyDataflowHelper(IIndexOperatorDescriptor opDesc, IHyracksTaskContext ctx, int partition, ILSMMergePolicy mergePolicy, ILSMOperationTrackerProvider opTrackerFactory, ILSMIOOperationScheduler ioScheduler, ILSMIOOperationCallbackFactory ioOpCallbackFactory, int[] buddyBtreeFields, int version, boolean durable) { <|startfocus|> super(opDesc, ctx, partition, null, mergePolicy, opTrackerFactory, ioScheduler, ioOpCallbackFactory, null, null, null, durable); <|endfocus|> this.buddyBtreeFields = buddyBtreeFields; this.version = version;
<|startcomment|> final <|endcomment|>  public class FileSystemWatcher { private static final Logger LOGGER = Logger.getLogger(FileSystemWatcher.class.getName()); private WatchService watcher; private final HashMap<WatchKey, Path> keys; private final LinkedList<File> files = new LinkedList<File>(); private Iterator<File> it; private final String expression; private FeedLogManager logManager; private final Path path; private final boolean isFeed; private boolean done; private File current; private AbstractFeedDataFlowController controller; <|startfocus|> private LinkedList<Path> dirs; <|endfocus|> public FileSystemWatcher(Path inputResource, String expression, boolean isFeed) { this.keys = isFeed ? new HashMap<WatchKey, Path>() : null; this.expression = expression; this.path = inputResource; this.isFeed = isFeed; this.dirs = new LinkedList<Path>(); } public void setFeedLogManager(FeedLogManager feedLogManager) { this.logManager = feedLogManager; } public void init() throws HyracksDataException { try { dirs.clear(); LocalFileSystemUtils.traverse(files, path.toFile(), expression, dirs);
<|startcomment|> put wr in a try with clause to ensure its closure. <|endcomment|>  URL url = new URL(targetURL); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("POST"); connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); connection.setRequestProperty("Content-Length", Integer.toString(urlParameters.getBytes().length)); connection.setRequestProperty("Content-Language", "en-US"); connection.setUseCaches(false); connection.setDoOutput(true); //Send message <|startfocus|> DataOutputStream wr = new DataOutputStream(connection.getOutputStream()); wr.writeBytes(urlParameters); wr.close(); <|endfocus|> int responseCode = connection.getResponseCode(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("\nSending 'POST' request to URL : " + url); LOGGER.info("Post parameters : " + urlParameters); LOGGER.info("Response Code : " + responseCode); } BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) { response.append(inputLine); }
<|startcomment|> 1. List->Set, ArrayList--> TreeSet Otherwise, the for-loop is of O(n^2). 2. So the number of partitions is the same the number of nodes? Therefore, no concurrent scanners in a node? (which should be fine for now.) <|endcomment|>  throw new AsterixException( "Invalid path: " + splitPath + "\nUsage- path=\"Host://Absolute File Path\""); } nodeName = resolver.resolveNode(trimmedValue.split(":")[0]); nodeLocalPath = trimmedValue.split("://")[1]; FileSplit fileSplit = new FileSplit(nodeName, new FileReference(new File(nodeLocalPath))); inputFileSplits[count++] = fileSplit; } } } private void configurePartitionConstraint() throws AsterixException { <|startfocus|> List<String> locs = new ArrayList<>(); <|endfocus|> for (int i = 0; i < inputFileSplits.length; i++) { String location = inputFileSplits[i].getNodeName(); if (!locs.contains(location)) { locs.add(location); } } constraints = new AlgebricksAbsolutePartitionConstraint(locs.toArray(new String[locs.size()])); } protected INodeResolver getNodeResolver() { if (nodeResolver == null) { synchronized (DEFAULT_NODE_RESOLVER) { if (nodeResolver == null) { nodeResolver = initializeNodeResolver(); } } } return nodeResolver; } 
<|startcomment|> Remove (ILSMIndexAccessor) cast <|endcomment|>  if (totalSize > maxMergableComponentSize || (isLastComponent && i - startIndex >= maxToleranceComponentCount)) { List<ILSMComponent> mergableComponents = new ArrayList<ILSMComponent>(); for (int j = startIndex + 1; j <= i; j++) { mergableComponents.add(immutableComponents.get(j)); } // Reverse the components order back to its original order Collections.reverse(mergableComponents); <|startfocus|> ILSMIndexAccessor accessor = (ILSMIndexAccessor) index.createAccessor(NoOpOperationCallback.INSTANCE, <|endfocus|> NoOpOperationCallback.INSTANCE); accessor.scheduleMerge(index.getIOOperationCallback(), mergableComponents); return true; } } return false; } } 
<|startcomment|> WS <|endcomment|>  resultPublicIPAddress = IniUtils.getString(ini, "localnc", "public.result.address", resultPublicIPAddress); resultPublicPort = IniUtils.getInt(ini, "localnc", "public.result.port", resultPublicPort); retries = IniUtils.getInt(ini, "localnc", "retries", retries); // Directories ioDevices = IniUtils.getString(ini, "localnc", "iodevices", ioDevices); // Hyracks client entrypoint appNCMainClass = IniUtils.getString(ini, "localnc", "app.class", appNCMainClass); } <|startfocus|> <|endfocus|> /* * Once all @Option fields have been loaded from command-line or otherwise * specified programmatically, call this method to: * 1. Load options from a config file (as specified by -config-file) * 2. Set default values for certain derived values, such as setting * clusterNetIpAddress to ipAddress */ public void loadConfigAndApplyDefaults() throws IOException { if (configFile != null) { loadINIFile(); } // "address" is the default for all IP addresses
<|startcomment|> Can you let the two variable names have more difference? It's very easy to get to use NILL for NIL or vice versa. <|endcomment|> import org.apache.hyracks.api.lifecycle.ILifeCycleComponent; /** * A concurrent implementation of the ILockManager interface. * * @see ResourceGroupTable * @see ResourceGroup */ public class ConcurrentLockManager implements ILockManager, ILifeCycleComponent { static final Logger LOGGER = Logger.getLogger(ConcurrentLockManager.class.getName()); static final Level LVL = Level.FINER; public static final boolean ENABLED_DEADLOCK_FREE_LOCKING_PROTOCOL = true; public static final int NIL = -1; <|startfocus|> public static final long NILL = -1l; <|endfocus|> public static final boolean DEBUG_MODE = false;//true public static final boolean CHECK_CONSISTENCY = false; private ResourceGroupTable table; private ResourceArenaManager resArenaMgr; private RequestArenaManager reqArenaMgr; private JobArenaManager jobArenaMgr; private ConcurrentHashMap<JobThreadId, Long> jobThreadId2JobSlotMap; private LockManagerStats stats = new LockManagerStats(10000); enum LockAction { ERR(false, false), GET(false, false), UPD(false, true), // version of GET that updates the max lock mode WAIT(true, false),
<|startcomment|> remove this annotation <|endcomment|>  * - If the transaction already has the "same" lock, then a redundant lock * call would be called on the resource - If the transaction already has a * "stronger" lock mode, then no action would be taken - If the transaction * has a "weaker" lock, then the request would be interpreted as a convert * request * Waiting transaction would eventually garb the lock, or get timed-out * <|startfocus|> * @param JobThreadId <|endfocus|> * @param datasetId * @param entityHashValue * @param lockMode * @param txnContext * @throws ACIDException */ public void lock(DatasetId datasetId, int entityHashValue, byte lockMode, ITransactionContext txnContext) throws ACIDException; /** * The method releases "All" the locks taken/waiting-on by a specific * transaction on "All" resources Upon releasing each lock on each resource, * potential waiters, which can be waken up based on their requested lock * mode and the waiting policy would be waken up *
<|startcomment|> remove assert <|endcomment|>  int tupleOff = slotManager.getTupleOff(slotManager.getSlotEndOff()); frameTuple.resetByTupleOffset(buf, tupleOff); int splitKeySize = tupleWriter.bytesRequired(frameTuple, 0, cmp.getKeyFieldCount()); splitKey.initData(splitKeySize); tupleWriter.writeTupleFields(frameTuple, 0, cmp.getKeyFieldCount(), splitKey.getBuffer().array(), 0); splitKey.getTuple().resetByTupleOffset(splitKey.getBuffer(), 0); <|startfocus|> assert getFreeSpaceOff() < buf.capacity(); <|endfocus|> } public void ensureCapacity(IMetaDataPageManager freePageManager, ITreeIndexMetaDataFrame metaFrame, IBufferCache bufferCache, ITupleReference tuple) throws HyracksDataException { int gapBytes = getBytesRequiredToWriteTuple(tuple) - getFreeContiguousSpace(); growCapacity(freePageManager, metaFrame, bufferCache, gapBytes); } public void growCapacity(IMetaDataPageManager freePageManager, ITreeIndexMetaDataFrame metaFrame, IBufferCache bufferCache, int delta) throws HyracksDataException { if (delta <= 0) { if (!isLargePage()) { setLargeFlag(true); } return; }
<|startcomment|> line too long <|endcomment|>  if (!isActive) { throw new HyracksDataException("Failed to clear the index since it is not activated."); } initEmptyTree(); } public boolean isEmptyTree(ITreeIndexFrame frame) throws HyracksDataException { if (rootPage == -1) { return true; } if(freePageManager.appendOnlyMode() && bufferCache.getNumPagesOfFile(fileId) <= MINIMAL_TREE_PAGE_COUNT){ return true; } <|startfocus|> ICachedPage rootNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), false, largePageHelper); <|endfocus|> rootNode.acquireReadLatch(); try { frame.setPage(rootNode); if (frame.getLevel() == 0 && frame.getTupleCount() == 0) { return true; } else { return false; } } finally { rootNode.releaseReadLatch(); bufferCache.unpin(rootNode); } } public byte getTreeHeight(ITreeIndexFrame frame) throws HyracksDataException { ICachedPage rootNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), false, largePageHelper); rootNode.acquireReadLatch(); try {
<|startcomment|> s/FeedMemoryManager/ConcurrentFramePool/ <|endcomment|>  public String toString() { <|startfocus|> return "FeedMemoryManager [" + nodeId + "]" + "(consumed:" + handedOut + "/" + budget + ")"; <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  } public LinkedBlockingDeque<ByteBuffer> getInternalBuffer() { return inbox; } @Override public void open() throws HyracksDataException { synchronized (writer) { writer.open(); } } @Override public void fail() throws HyracksDataException { synchronized (writer) { writer.fail(); } } @Override public void close() throws HyracksDataException { consumer.die(); synchronized (mutex) { if (DEBUG) { <|startfocus|> System.err.println("Producer is waking up consumer"); <|endfocus|> } mutex.notify(); } try { consumerThread.join(); } catch (InterruptedException e) { LOGGER.log(Level.WARNING, e.getMessage(), e); } try { framePool.release(inbox); } catch (Throwable th) { LOGGER.log(Level.WARNING, th.getMessage(), th); } try { spiller.close(); } catch (Throwable th) { LOGGER.log(Level.WARNING, th.getMessage(), th); } writer.close(); } @Override public void nextFrame(ByteBuffer frame) throws HyracksDataException { try {
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  synchronized (mutex) { // Check if there is memory ByteBuffer next = null; if (frame.capacity() <= framePool.getMaxFrameSize()) { next = getFreeBuffer(frame.capacity()); } if (next != null) { spiller.close(); numProcessedInMemory++; next.put(frame); inbox.offer(next); <|startfocus|> if (inbox.size() == 1) { if (DEBUG) { System.err.println("Producer is waking up consumer (size of inbox = 1)"); } mutex.notify(); } <|endfocus|> mode = Mode.PROCESS; } else { // spill. This will always succeed since spilled = 0 (TODO must verify that budget can't be 0) spiller.spill(frame); numSpilled++; if (DEBUG) { System.err.println("Producer is waking up consumer"); } mutex.notify(); } } } else { // try to spill. If failed switch to either discard or stall if (spiller.spill(frame)) { if (spiller.remaining() == 1) {
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  // TODO(amoudi): Add test cases and get rid of recursion release(buffer); } finally { subscribers.remove(); if (DEBUG) { System.err.println( "A subscription has been satisfied. " + subscribers.size() + " remaining subscribers"); } } } else { if (DEBUG) { System.err.println("Failed to allocate requested frames"); } break; } } <|startfocus|> if (DEBUG) { System.err.println(subscribers.size() + " remaining subscribers"); } <|endfocus|> } public synchronized boolean subscribe(FrameAction frameAction) throws HyracksDataException { // check if subscribers are empty? if (subscribers.isEmpty()) { ByteBuffer buffer; // check if we have enough and answer immediately. if (frameAction.getSize() == defaultFrameSize) { buffer = getIgnoreSubscribers(); } else { buffer = getIgnoreSubscribers(frameAction.getSize()); } if (buffer != null) { frameAction.call(buffer); // There is no need to subscribe. perform action and return false return false; }
<|startcomment|> CRITICAL SonarQube violation: Remove this assertion. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2186 <|endcomment|>  public void run() { try { writer.nextFrame(buffer); } catch (HyracksDataException e) { e.printStackTrace(); <|startfocus|> Assert.fail(); <|endfocus|> }
<|startcomment|> MAJOR SonarQube violation: Rename this constant name to match the regular expression '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00115 <|endcomment|>  import java.io.DataInputStream; import java.nio.ByteBuffer; import org.apache.asterix.om.base.AInt32; import org.apache.asterix.om.base.AInt64; import org.apache.asterix.om.types.ATypeTag; import org.apache.hyracks.api.dataflow.value.RecordDescriptor; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAccessor; import org.apache.hyracks.dataflow.common.comm.util.ByteBufferInputStream; public class RecordIdReader { <|startfocus|> private final static byte missingByte = ATypeTag.MISSING.serialize(); <|endfocus|> protected FrameTupleAccessor tupleAccessor; protected int fieldSlotsLength; protected int[] ridFields; protected RecordId rid; protected RecordDescriptor inRecDesc; protected ByteBufferInputStream bbis; protected DataInputStream dis; protected int tupleStartOffset; protected ByteBuffer frameBuffer; public RecordIdReader(int[] ridFields) { this.ridFields = ridFields; this.rid = new RecordId(); } public void set(FrameTupleAccessor accessor, RecordDescriptor inRecDesc) { this.tupleAccessor = accessor; this.fieldSlotsLength = accessor.getFieldSlotsLength(); this.inRecDesc = inRecDesc;
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  case UNION: { AUnionType u = (AUnionType) type0; if (u.isUnknownableType()) { IAType t1 = u.getActualType(); if (t1.getTypeTag() == ATypeTag.RECORD) { return (ARecordType) t1; } if (t1.getTypeTag() == ATypeTag.ANY) { return DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE; } } } default: { throw new AlgebricksException( "Unsupported type " + type0 + " for field access expression: " + expression); <|startfocus|> } <|endfocus|> } } } 
<|startcomment|> MAJOR SonarQube violation: Reduce this switch case number of lines from 27 to at most 20, for example by extracting code into methods. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1151 <|endcomment|>  case INT8: case INT16: case INT32: type = BuiltinType.AINT32; break; case INT64: type = BuiltinType.AINT64; break; case FLOAT: type = BuiltinType.AFLOAT; break; case DOUBLE: type = BuiltinType.ADOUBLE; break; case ANY: type = BuiltinType.ANY; break; default: { throw new NotImplementedException(errMsg + tag2); } } break; <|startfocus|> } case INT16: { <|endfocus|> switch (tag2) { case INT8: case INT16: type = BuiltinType.AINT16; break; case INT32: type = BuiltinType.AINT32; break; case INT64: type = BuiltinType.AINT64; break; case FLOAT: type = BuiltinType.AFLOAT; break; case DOUBLE: type = BuiltinType.ADOUBLE; break; case ANY: type = BuiltinType.ANY; break; default: { throw new NotImplementedException(errMsg + tag2); } } break;
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  throw new NotImplementedException(errMsg + tag2); } } break; } case YEARMONTHDURATION: { switch (tag2) { case DATE: type = BuiltinType.ADATE; break; case TIME: type = BuiltinType.ATIME; break; case DATETIME: type = BuiltinType.ADATETIME; break; case YEARMONTHDURATION: type = BuiltinType.AYEARMONTHDURATION; break; case ANY: type = BuiltinType.ANY; break; <|startfocus|> default: { throw new NotImplementedException(errMsg + tag2); } <|endfocus|> } break; } case DAYTIMEDURATION: { switch (tag2) { case DATE: type = BuiltinType.ADATE; break; case TIME: type = BuiltinType.ATIME; break; case DATETIME: type = BuiltinType.ADATETIME; break; case DAYTIMEDURATION: type = BuiltinType.ADAYTIMEDURATION; break; case ANY: type = BuiltinType.ANY; break; default: { throw new NotImplementedException(errMsg + tag2); } } break; } default: {
<|startcomment|> MAJOR SonarQube violation: Rename this field "NULL" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 <|endcomment|> import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { private static byte CERTAIN = 1; private static byte NULLABLE = 2; private static byte MISSABLE = 4; private static byte MISSING = 8; private static byte NULL = 16; <|startfocus|> <|endfocus|> public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } /** * Resolve the result type of an expression. * * @param expr, * the expression to consider. * @param env, * the type environment. * @param checker, * the argument type checker. * @param resultTypeGenerator, * the result type generator.
<|startcomment|> MAJOR SonarQube violation: Refactor the code in order to not assign to this loop counter from within the loop body. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AForLoopCounterChangedCheck <|endcomment|>  } if (fromIndex < 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } byte first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i <= max; i++) { /* Look for first character. */ if (source[i] != first) { <|startfocus|> while (++i <= max && source[i] != first) { ; } <|endfocus|> } /* Found first character, now look at the rest of v2 */ if (i <= max) { int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++) { ; } if (j == end) { /* Found whole string. */ return i - sourceOffset; } } } return -1;
<|startcomment|> MAJOR SonarQube violation: Make this anonymous inner class a lambda Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1604 <|endcomment|>  public IMissingWriter createMissingWriter() { <|startfocus|> return new IMissingWriter() { @Override public void writeMissing(DataOutput out) throws HyracksDataException { // do nothing } }; <|endfocus|>
<|startcomment|> Comment not updated? <|endcomment|>  types -> getResultType(types), true); } /** * Checks whether an input type violates the requirement. * * @param argIndex, * the index of the argument to consider. * @param type, * the type of the input argument. * @throws AlgebricksException */ protected void checkArgType(int argIndex, IAType type) throws AlgebricksException { } /** * Returns the result type without considering optional types. * <|startfocus|> * @param knownInputTypes, <|endfocus|> * the stripped input types. * @return the result type without considering optional types. */ protected abstract IAType getResultType(IAType... strippedInputTypes); } 
<|startcomment|> Pull data[start] out to make life easier for the compiler? <|endcomment|>  public boolean isMissing(IPointable arg, IPointable resultPointable) { byte[] data = arg.getByteArray(); int start = arg.getStartOffset(); <|startfocus|> if (data[start] == ATypeTag.SERIALIZED_MISSING_TYPE_TAG) { <|endfocus|> resultPointable.set(MISSING_BYTES, 0, 1); // resets meetNull for the next evaluate(...) call. meetNull = false; return true; } if (data[start] == ATypeTag.SERIALIZED_NULL_TYPE_TAG) { meetNull |= true; } return false;
<|startcomment|> MAJOR SonarQube violation: Make this anonymous inner class a lambda Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1604 <|endcomment|> import org.apache.hyracks.algebricks.data.IPrinter; import org.apache.hyracks.algebricks.data.IPrinterFactory; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.PrintStream; public class AInt32PrinterFactory implements IPrinterFactory { private static final long serialVersionUID = 1L; public static final AInt32PrinterFactory INSTANCE = new AInt32PrinterFactory(); public static final IPrinter PRINTER = new IPrinter() { @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { <|startfocus|> int d = AInt32SerializerDeserializer.getInt(b, s + 1); ps.print(d); <|endfocus|> } }; @Override public IPrinter createPrinter() { return PRINTER; } } 
<|startcomment|> MAJOR SonarQube violation: Make this anonymous inner class a lambda Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1604 <|endcomment|> import org.apache.hyracks.algebricks.data.IPrinter; import org.apache.hyracks.algebricks.data.IPrinterFactory; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.PrintStream; public class AInt64PrinterFactory implements IPrinterFactory { private static final long serialVersionUID = 1L; public static final AInt64PrinterFactory INSTANCE = new AInt64PrinterFactory(); public static final IPrinter PRINTER = new IPrinter() { @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { <|startfocus|> long d = AInt64SerializerDeserializer.getLong(b, s + 1); <|endfocus|> ps.print("{ \"int64\": "); ps.print(d); ps.print(" }"); } }; @Override public IPrinter createPrinter() { return PRINTER; } } 
<|startcomment|> MAJOR SonarQube violation: Rename this field "MISSABLE" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 <|endcomment|> import org.apache.asterix.om.types.BuiltinType; import org.apache.asterix.om.types.IAType; import org.apache.commons.lang3.mutable.Mutable; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression; import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment; public class TypeComputeUtils { <|startfocus|> private static byte CERTAIN = 1; private static byte NULLABLE = 2; private static byte MISSABLE = 4; private static byte MISSING = 8; private static byte NULL = 16; <|endfocus|> @FunctionalInterface public static interface ArgTypeChecker { public void checkArgTypes(int argIndex, IAType argType) throws AlgebricksException; } @FunctionalInterface public static interface ResultTypeGenerator { public IAType getResultType(IAType... knownInputTypes); } private TypeComputeUtils() { } /** * Resolve the result type of an expression. * * @param expr, * the expression to consider. * @param env, * the type environment. * @param checker,
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  throws HyracksDataException { final RecordDescriptor buildRd = recordDescProvider.getInputRecordDescriptor(buildAid, 0); final RecordDescriptor probeRd = recordDescProvider.getInputRecordDescriptor(getActivityId(), 0); final IBinaryComparator[] comparators = new IBinaryComparator[comparatorFactories.length]; final ITuplePairComparator nljComparatorProbe2Build = tuplePairComparatorFactoryProbe2Build .createTuplePairComparator(ctx); final ITuplePairComparator nljComparatorBuild2Probe = tuplePairComparatorFactoryBuild2Probe .createTuplePairComparator(ctx); <|startfocus|> final IPredicateEvaluator predEvaluator = (predEvaluatorFactory == null ? null : predEvaluatorFactory.createPredicateEvaluator()); <|endfocus|> for (int i = 0; i < comparatorFactories.length; i++) { comparators[i] = comparatorFactories[i].createBinaryComparator(); } final IMissingWriter[] nonMatchWriter = isLeftOuter ? new IMissingWriter[nonMatchWriterFactories.length] : null; final ArrayTupleBuilder nullTupleBuild = isLeftOuter ? new ArrayTupleBuilder(buildRd.getFieldCount()) : null; if (isLeftOuter) { DataOutput out = nullTupleBuild.getDataOutput(); for (int i = 0; i < nonMatchWriterFactories.length; i++) {
<|startcomment|> MAJOR SonarQube violation: Reduce this anonymous class number of lines from 34 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 <|endcomment|>  import org.apache.asterix.dataflow.data.nontagged.serde.AIntervalSerializerDeserializer; import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.EnumDeserializer; import org.apache.hyracks.algebricks.data.IPrinter; import org.apache.hyracks.algebricks.data.IPrinterFactory; import org.apache.hyracks.api.exceptions.HyracksDataException; import java.io.PrintStream; public class AIntervalPrinterFactory implements IPrinterFactory { private static final long serialVersionUID = 1L; public static final AIntervalPrinterFactory INSTANCE = new AIntervalPrinterFactory(); <|startfocus|> public static final IPrinter PRINTER = new IPrinter() { @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { ps.print("{ \"interval\": { \"start\": "); <|endfocus|> byte typetag = AIntervalSerializerDeserializer.getIntervalTimeType(b, s + 1); int startOffset = AIntervalSerializerDeserializer.getIntervalStartOffset(b, s + 1) - 1; int startSize = AIntervalSerializerDeserializer.getStartSize(b, s + 1); int endOffset = AIntervalSerializerDeserializer.getIntervalEndOffset(b, s + 1) - 1;
<|startcomment|> MAJOR SonarQube violation: Remove useless curly braces around statement Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1602 <|endcomment|>  import java.io.PrintStream; import org.apache.asterix.dataflow.data.nontagged.serde.AFloatSerializerDeserializer; import org.apache.hyracks.algebricks.data.IPrinter; import org.apache.hyracks.algebricks.data.IPrinterFactory; public class AFloatPrinterFactory implements IPrinterFactory { private static final long serialVersionUID = 1L; public static final AFloatPrinterFactory INSTANCE = new AFloatPrinterFactory(); <|startfocus|> public static final IPrinter PRINTER = (byte[] b, int s, int l, PrintStream ps) -> { ps.print(AFloatSerializerDeserializer.getFloat(b, s + 1) + "f"); }; <|endfocus|> @Override public IPrinter createPrinter() { return PRINTER; } } 
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|>  replicationManager.replicateTxnLogBatch(buffer); } else { int totalTransferLimit = buffer.limit(); while (buffer.hasRemaining()) { if (buffer.remaining() > batchSize) { /** * break into smaller batches */ //mark the beginning of this batch buffer.mark(); int currentBatchSize = 0; while (currentBatchSize < batchSize) { int logSize = replicationBuffer.getInt(); <|startfocus|> //add the size of the log record itself + 4 bytes for its size <|endfocus|> currentBatchSize += logSize + Integer.BYTES; //go to the beginning of the next log buffer.position(buffer.position() + logSize); } //set the limit to the end of this batch buffer.limit(buffer.position()); //return to the beginning of the batch position buffer.reset(); } replicationManager.replicateTxnLogBatch(buffer); //return the original limit to check the new remaining size buffer.limit(totalTransferLimit); } }
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  public void run() { Thread.currentThread().setName("LSMComponentsSyncService Thread"); while (true) { try { LSMComponentLSNSyncTask syncTask = lsmComponentRemoteLSN2LocalLSNMappingTaskQ.take(); LSMComponentProperties lsmCompProp = lsmComponentId2PropertiesMap.get(syncTask.getComponentId()); try { syncLSMComponentFlushLSN(lsmCompProp, syncTask); updateLSMComponentRemainingFiles(lsmCompProp.getComponentId()); } catch (Exception e) { e.printStackTrace(); } } catch (InterruptedException e) { <|startfocus|> //ignore <|endfocus|> } }
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  this.txnSubsystem = txnSubsystem; this.logPageSize = logPageSize; this.flushLSN = flushLSN; appendBuffer = ByteBuffer.allocate(logPageSize); flushBuffer = appendBuffer.duplicate(); unlockBuffer = appendBuffer.duplicate(); logBufferTailReader = getLogBufferTailReader(); full = new AtomicBoolean(false); appendOffset = 0; flushOffset = 0; isLastPage = false; <|startfocus|> syncCommitQ = new LinkedBlockingQueue<ILogRecord>(logPageSize / ILogRecord.JOB_TERMINATE_LOG_SIZE); flushQ = new LinkedBlockingQueue<ILogRecord>(); remoteJobsQ = new LinkedBlockingQueue<ILogRecord>(); <|endfocus|> reusableDsId = new DatasetId(-1); reusableJobId = new JobId(-1);
<|startcomment|> MAJOR SonarQube violation: Remove this unused "LOGGER" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|> import org.apache.http.util.EntityUtils; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.ByteBuffer; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.text.MessageFormat; import java.util.ArrayList; import java.util.List; import java.util.logging.Level; import java.util.logging.Logger; public class RunSQLPPFileAction extends AbstractAction { <|startfocus|> private final Logger LOGGER = Logger.getLogger(RunSQLPPFileAction.class.getName()); <|endfocus|> private static final String REST_URI_TEMPLATE = "http://{0}:{1}/sqlpp"; private final HttpClient httpClient; private final Path aqlFilePath; private final List<Path> queriesToRun; private final String restHost; private final int restPort; private final OutputStream os; public RunSQLPPFileAction(HttpClient httpClient, String restHost, int restPort, Path aqlFilePath) { this.httpClient = httpClient; this.aqlFilePath = aqlFilePath; this.restHost = restHost; this.restPort = restPort; os = null;
<|startcomment|> Could we undo this? <|endcomment|>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.experiment.client; import java.util.ArrayList; import java.util.Collection; import java.util.logging.Level; import java.util.logging.Logger; import java.util.regex.Pattern; import org.apache.asterix.experiment.action.base.SequentialActionList; <|startfocus|> import org.apache.asterix.experiment.builder.*; <|endfocus|> import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; public class LSMExperimentSetRunner { private static final Logger LOGGER = Logger.getLogger(LSMExperimentSetRunner.class.getName()); public static class LSMExperimentSetRunnerConfig { private final String logDirSuffix; private final int nQueryRuns; public LSMExperimentSetRunnerConfig(String logDirSuffix, int nQueryRuns) { this.logDirSuffix = logDirSuffix; this.nQueryRuns = nQueryRuns; } public String getLogDirSuffix() { return logDirSuffix; } 
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|> import org.apache.hyracks.algebricks.core.algebra.functions.AlgebricksBuiltinFunctions; import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier; import org.apache.hyracks.algebricks.core.algebra.functions.IFunctionInfo; public class AsterixBuiltinFunctions { public enum SpatialFilterKind { SI } public static final String FOO_BAR = "yeah this line is like way too long, but i just need to see how existing " + "failures will be reported."; private static final FunctionInfoRepository registeredFunctions = new FunctionInfoRepository(); <|startfocus|> <|endfocus|> private static final Map<IFunctionInfo, ATypeHierarchy.Domain> registeredFunctionsDomain = new HashMap<IFunctionInfo, ATypeHierarchy.Domain>(); // it is supposed to be an identity mapping private final static Map<IFunctionInfo, IFunctionInfo> builtinPublicFunctionsSet = new HashMap<IFunctionInfo, IFunctionInfo>(); private final static Map<IFunctionInfo, IFunctionInfo> builtinPrivateFunctionsSet = new HashMap<IFunctionInfo, IFunctionInfo>(); private final static Map<IFunctionInfo, IResultTypeComputer> funTypeComputer = new HashMap<IFunctionInfo, IResultTypeComputer>(); 
<|startcomment|> MAJOR SonarQube violation: Split this 126 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  list.add(new Pair<LogicalVariable, ILogicalExpression>(vars.get(i), exprs.get(i).getValue())); } return list; } private static boolean variableEqual(LogicalVariable var, LogicalVariable varArg) { if (var == null && varArg == null) { return true; } if (var.equals(varArg)) { return true; } else { return false; } } @Override <|startfocus|> public Boolean visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, ILogicalOperator arg) throws AlgebricksException { <|endfocus|> AbstractLogicalOperator aop = (AbstractLogicalOperator) arg; if (aop.getOperatorTag() != LogicalOperatorTag.LEFT_OUTER_UNNEST) { return Boolean.FALSE; } LeftOuterUnnestOperator unnestOpArg = (LeftOuterUnnestOperator) copyAndSubstituteVar(op, arg); boolean isomorphic = VariableUtilities.varListEqualUnordered(op.getVariables(), unnestOpArg.getVariables()) && variableEqual(op.getPositionalVariable(), unnestOpArg.getPositionalVariable()); if (!isomorphic) { return Boolean.FALSE; } isomorphic = op.getExpressionRef().getValue().equals(unnestOpArg.getExpressionRef().getValue()); return isomorphic; }
<|startcomment|> Should this just be an UnsupportedOperationException? <|endcomment|>  distinctOperator.getInputs().add(new MutableObject<ILogicalOperator>(returnOperator)); return new Pair<>(distinctOperator, returnVar); } else { return new Pair<>(returnOperator, returnVar); } } @Override public Pair<ILogicalOperator, LogicalVariable> visit(SelectElement selectElement, Mutable<ILogicalOperator> arg) throws AsterixException { throw new IllegalStateException(ERR_MSG); } @Override public Pair<ILogicalOperator, LogicalVariable> visit(SelectRegular selectRegular, Mutable<ILogicalOperator> arg) throws AsterixException { <|startfocus|> throw new IllegalStateException(ERR_MSG); <|endfocus|> } @Override public Pair<ILogicalOperator, LogicalVariable> visit(Projection projection, Mutable<ILogicalOperator> arg) throws AsterixException { throw new IllegalStateException(); } private Pair<ILogicalOperator, LogicalVariable> produceSelectPlan(boolean isSubquery, Mutable<ILogicalOperator> returnOpRef, LogicalVariable resVar) { if (isSubquery) { return aggListifyForSubquery(resVar, returnOpRef, false); } else { ProjectOperator pr = new ProjectOperator(resVar); pr.getInputs().add(returnOpRef); return new Pair<>(pr, resVar); } } } 
<|startcomment|> MAJOR SonarQube violation: Split this 137 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  ARecordType metaItemType = DatasetUtils.getMetaType(this, dataset); ITypeTraits[] typeTraits = DatasetUtils.computeTupleTypeTraits(dataset, itemType, metaItemType); IAsterixApplicationContextInfo appContext = (IAsterixApplicationContextInfo) context.getAppContext(); IBinaryComparatorFactory[] comparatorFactories = DatasetUtils.computeKeysBinaryComparatorFactories(dataset, itemType, context.getBinaryComparatorFactoryProvider()); <|startfocus|> Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( dataSource.getId().getDataverseName(), datasetName, indexName, temp); <|endfocus|> // prepare callback JobId jobId = ((JobEventListenerFactory) spec.getJobletEventListenerFactory()).getJobId(); int datasetId = dataset.getDatasetId(); int[] primaryKeyFields = new int[numKeys]; for (i = 0; i < numKeys; i++) { primaryKeyFields[i] = i; } ITypeTraits[] filterTypeTraits = DatasetUtils.computeFilterTypeTraits(dataset, itemType); IBinaryComparatorFactory[] filterCmpFactories = DatasetUtils.computeFilterBinaryComparatorFactories(dataset, itemType, context.getBinaryComparatorFactoryProvider()); int[] filterFields = DatasetUtils.createFilterFields(dataset);
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|>  /** * Factors out function expressions from each comparison function or similarity function in join condition by * assigning them to a variables, and replacing the function expressions with references to those variables. * Examples: * Plan with function expressions in comparison or similarity condition of join expression. * Generates one assign operator per extracted function expression. * * <pre> * Before plan: * * join ( eq( funcX($$1), funcX($$2) ) ) <|startfocus|> * <|endfocus|> * After plan: * * join (eq($$3,$$4)) * assign [$$4] <- [funcY($$2)] * assign [$$3] <- [funcX($$1)] * </pre> */ public class ExtractFunctionsFromJoinConditionRule implements IAlgebraicRewriteRule { @Override public boolean rewritePre(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException { return false; } @Override public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context) throws AlgebricksException {
<|startcomment|> MAJOR SonarQube violation: Use isEmpty() to check whether the collection is empty or not. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1155 <|endcomment|>  throws AlgebricksException { ILogicalOperator prodOp = null; for (Mutable<ILogicalOperator> opRef : root.getInputs()) { List<LogicalVariable> producedVars = new ArrayList<LogicalVariable>(); VariableUtilities.getProducedVariables(opRef.getValue(), producedVars); if (producedVars != null && producedVars.contains(pk)) { prodOp = opRef.getValue(); break; } else if (opRef.getValue().getInputs().size() > 0) { prodOp = extractPKProduction(opRef.getValue(), pk); if (prodOp != null) <|startfocus|> break; <|endfocus|> } } return prodOp; } private static void extractPrimaryKeys(IOptimizationContext context, ILogicalOperator root, List<LogicalVariable> prodVars) throws AlgebricksException { for (Mutable<ILogicalOperator> opRef : root.getInputs()) { if (opRef.getValue().getOperatorTag().equals(LogicalOperatorTag.DATASOURCESCAN)) { List<LogicalVariable> vars = new ArrayList<LogicalVariable>(); VariableUtilities.getProducedVariables(opRef.getValue(), vars); prodVars.addAll(vars); } else extractPrimaryKeys(context, opRef.getValue(), prodVars); }
<|startcomment|> We append a PK to a parser? That sounds confusing ... <|endcomment|>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.external.api; import java.io.DataOutput; import java.io.IOException; import org.apache.hyracks.dataflow.common.comm.io.ArrayTupleBuilder; public interface IRecordWithMetadataParser<T> extends IRecordDataParser<T> { public void parseMeta(DataOutput out) throws IOException; <|startfocus|> void appendPK(ArrayTupleBuilder tb) throws IOException; <|endfocus|> } 
<|startcomment|> Remove unused? or comment future use? <|endcomment|>  public List<IODeviceHandle> getIODevices(); public IFileHandle open(FileReference fileRef, FileReadWriteMode rwMode, FileSyncMode syncMode) throws HyracksDataException; public int syncWrite(IFileHandle fHandle, long offset, ByteBuffer data) throws HyracksDataException; public long syncWrite(IFileHandle fHandle, long offset, ByteBuffer[] dataArray) throws HyracksDataException; public int syncRead(IFileHandle fHandle, long offset, ByteBuffer data) throws HyracksDataException; <|startfocus|> public long syncRead(IFileHandle fHandle, long offset, ByteBuffer[] dataArray) throws HyracksDataException; <|endfocus|> public IIOFuture asyncWrite(IFileHandle fHandle, long offset, ByteBuffer data); public IIOFuture asyncRead(IFileHandle fHandle, long offset, ByteBuffer data); public void close(IFileHandle fHandle) throws HyracksDataException; public void sync(IFileHandle fileHandle, boolean metadata) throws HyracksDataException; public void setExecutor(Executor executor); public long getSize(IFileHandle fileHandle); public void deleteWorkspaceFiles(); /** * @param ioDeviceId * @param relativePath
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  mergePolicyFactory, mergePolicyFactoryProperties, storageProperties, spec); IndexInfoOperatorDescriptor filesIndexInfo = new IndexInfoOperatorDescriptor(filesIndexSplitProvider, AsterixRuntimeComponentsProvider.RUNTIME_PROVIDER, AsterixRuntimeComponentsProvider.RUNTIME_PROVIDER); ArrayList<ExternalBTreeWithBuddyDataflowHelperFactory> btreeDataflowHelperFactories = new ArrayList<ExternalBTreeWithBuddyDataflowHelperFactory>(); ArrayList<IndexInfoOperatorDescriptor> btreeInfos = new ArrayList<IndexInfoOperatorDescriptor>(); ArrayList<ExternalRTreeDataflowHelperFactory> rtreeDataflowHelperFactories = new ArrayList<ExternalRTreeDataflowHelperFactory>(); ArrayList<IndexInfoOperatorDescriptor> rtreeInfos = new ArrayList<IndexInfoOperatorDescriptor>(); for (Index index : indexes) { if (isValidIndexName(index.getDatasetName(), index.getIndexName())) { <|startfocus|> Pair<IFileSplitProvider, AlgebricksPartitionConstraint> indexSplitsAndConstraint = metadataProvider .splitProviderAndPartitionConstraintsForDataset(ds.getDataverseName(), ds.getDatasetName(), index.getIndexName(), temp); <|endfocus|> if (index.getIndexType() == IndexType.BTREE) { btreeDataflowHelperFactories.add(getBTreeDataflowHelperFactory(ds, index, mergePolicyFactory, mergePolicyFactoryProperties, storageProperties, spec)); btreeInfos.add(new IndexInfoOperatorDescriptor(indexSplitsAndConstraint.first,
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|> import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities; import org.apache.hyracks.algebricks.core.algebra.util.OperatorPropertiesUtil; import org.apache.hyracks.algebricks.core.rewriter.base.IAlgebraicRewriteRule; public class FuzzyJoinRule implements IAlgebraicRewriteRule { private static HashSet<FunctionIdentifier> simFuncs = new HashSet<FunctionIdentifier>(); static { simFuncs.add(AsterixBuiltinFunctions.SIMILARITY_JACCARD_CHECK); } private int nBranches = 0; <|startfocus|> private List<Set<LogicalVariable>> previousPK = new ArrayList<Set<LogicalVariable>>(); <|endfocus|> // Step1: Initial the host embedding aql to substitute the fuzzy euqal condition such as $r.a ~= $s.b private static final String AQLPLUS = "" // // -- - Stage 3 - -- // + "((#LEFT_%d_0), " + " (join((#RIGHT_%d_0), " // // -- -- - Stage 2 - -- // + " (" + " join( " + " ( " + " #LEFT_%d_1 "
<|startcomment|> A lot of memory copies here? <|endcomment|>  int position = content.readerIndex(); final int limit = content.writerIndex(); final int contentSize = content.readableBytes(); bytes.clear(); while (position < limit) { chars.clear(); if ((contentSize - position) < bytes.remaining()) { bytes.limit(contentSize - position); } content.getBytes(position + bytes.position(), bytes); position += bytes.position(); bytes.flip(); decoder.decode(bytes, chars, false); <|startfocus|> bytes.compact(); position -= bytes.position(); <|endfocus|> chars.flip(); record.append(chars); } record.endRecord(); } } 
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  + (((long) (bytes[offset + 2] & 0xff)) << 40) + (((long) (bytes[offset + 3] & 0xff)) << 32) + (((long) (bytes[offset + 4] & 0xff)) << 24) + (((long) (bytes[offset + 5] & 0xff)) << 16) <|startfocus|> + (((long) (bytes[offset + 6] & 0xff)) << 8) + ((bytes[offset + 7] & 0xff)); <|endfocus|>
<|startcomment|> line length <|endcomment|>  private IBinaryComparatorFactory[] createPrimaryIndexComparatorFactories(IAType[] primaryKeyTypes) { IBinaryComparatorFactory[] primaryIndexComparatorFactories = new IBinaryComparatorFactory[primaryKeyTypes.length]; for (int j = 0; j < primaryKeyTypes.length; ++j) { <|startfocus|> primaryIndexComparatorFactories[j] = AqlBinaryComparatorFactoryProvider.INSTANCE .getBinaryComparatorFactory(primaryKeyTypes[j], true); <|endfocus|> } return primaryIndexComparatorFactories;
<|startcomment|> How about this.format = format == null ? NonTaggedDataFormat.class.getName() : format; ? <|endcomment|>  public CreateDataverseStatement(Identifier dataverseName, String format, boolean ifNotExists) { this.dataverseName = dataverseName; <|startfocus|> if (format == null) { this.format = NonTaggedDataFormat.class.getName(); } else { this.format = format; } <|endfocus|> this.ifNotExists = ifNotExists;
<|startcomment|> MAJOR SonarQube violation: Split this 192 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public int messagingPort = 0; @Option(name = "-messaging-public-ip-address", usage = "Public IP Address to announce messaging listener (default: same as -messaging-ip-address)", required = false) public String messagingPublicIPAddress; <|startfocus|> @Option(name = "-messaging-public-port", usage = "Public IP port to announce messaging listener (default: same as -messaging-port; must set -messaging-public-port also)", required = false) <|endfocus|> public int messagingPublicPort = 0; @Argument @Option(name = "--", handler = StopOptionHandler.class) public List<String> appArgs; private transient Ini ini = null; private void loadINIFile() throws IOException { ini = IniUtils.loadINIFile(configFile); // QQQ This should default to cc/address if cluster.address not set, but // that logic really should be handled by the ini file sent from the CC ccHost = IniUtils.getString(ini, "cc", "cluster.address", ccHost); ccPort = IniUtils.getInt(ini, "cc", "cluster.port", ccPort); 
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  JobInfo info = hcc.getJobInfo(cInfo.getJobId()); List<String> collectLocations = new ArrayList<String>(); for (OperatorDescriptorId collectOpId : collectOperatorIds) { Map<Integer, String> operatorLocations = info.getOperatorLocations().get(collectOpId); int nOperatorInstances = operatorLocations.size(); for (int i = 0; i < nOperatorInstances; i++) { collectLocations.add(operatorLocations.get(i)); } } <|startfocus|> List<String> computeLocations = new ArrayList<String>(); <|endfocus|> for (OperatorDescriptorId computeOpId : computeOperatorIds) { Map<Integer, String> operatorLocations = info.getOperatorLocations().get(computeOpId); if (operatorLocations != null) { int nOperatorInstances = operatorLocations.size(); for (int i = 0; i < nOperatorInstances; i++) { computeLocations.add(operatorLocations.get(i)); } } else { computeLocations.clear(); computeLocations.addAll(collectLocations); } } List<String> storageLocations = new ArrayList<String>(); for (OperatorDescriptorId storageOpId : storageOperatorIds) {
<|startcomment|> MAJOR SonarQube violation: Split this 122 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  private static void printError(PrintWriter pw, Throwable e) { final boolean addStack = false; pw.print("\t\""); pw.print(ResultFields.ERRORS.str()); pw.print("\": [{ \n"); printField(pw, ErrorField.CODE.str(), "1"); final String msg = e.getMessage(); <|startfocus|> printField(pw, ErrorField.MSG.str(), JSONUtil.escape(msg != null ? msg : e.getClass().getSimpleName()), addStack); <|endfocus|> if (addStack) { StringWriter sw = new StringWriter(); PrintWriter stackWriter = new PrintWriter(sw); LOGGER.info(stackWriter.toString()); stackWriter.close(); printField(pw, ErrorField.STACK.str(), JSONUtil.escape(sw.toString()), false); } pw.print("\t}],\n");
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "fta". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|>  /** The original frame writer instantiated as part of job creation **/ private final IFrameWriter writer; /** The feed operation whose output is being distributed by the DistributeFeedFrameWriter **/ private final FeedRuntimeType feedRuntimeType; /** The value of the partition 'i' if this is the i'th instance of the associated operator **/ private final int partition; public DistributeFeedFrameWriter(EntityId feedId, IFrameWriter writer, FeedRuntimeType feedRuntimeType, <|startfocus|> int partition, FrameTupleAccessor fta) throws IOException { <|endfocus|> this.feedId = feedId; this.frameDistributor = new FrameDistributor(); this.feedRuntimeType = feedRuntimeType; this.partition = partition; this.writer = writer; } /** * @param fpa * Feed policy accessor * @param nextOnlyWriter * the writer which will deliver the buffers * @param connectionId * (Dataverse - Dataset - Feed) * @return A frame collector. * @throws HyracksDataException */ public void subscribe(FeedFrameCollector collector) throws HyracksDataException { frameDistributor.registerFrameCollector(collector);
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "p2". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  if (OperatorExpr.opIsComparison(ops.get(i))) { AbstractFunctionCallExpression c = createComparisonExpression(ops.get(i)); // chain the operators if (i == 0) { c.getArguments().add(new MutableObject<ILogicalExpression>(e)); currExpr = c; if (op.isBroadcastOperand(i)) { BroadcastExpressionAnnotation bcast = new BroadcastExpressionAnnotation(); bcast.setObject(BroadcastSide.LEFT); c.getAnnotations().put(BroadcastExpressionAnnotation.BROADCAST_ANNOTATION_KEY, bcast); } } else { <|startfocus|> ((AbstractFunctionCallExpression) currExpr).getArguments() .add(new MutableObject<ILogicalExpression>(e)); c.getArguments().add(new MutableObject<ILogicalExpression>(currExpr)); <|endfocus|> currExpr = c; if (i == 1 && op.isBroadcastOperand(i)) { BroadcastExpressionAnnotation bcast = new BroadcastExpressionAnnotation(); bcast.setObject(BroadcastSide.RIGHT); c.getAnnotations().put(BroadcastExpressionAnnotation.BROADCAST_ANNOTATION_KEY, bcast); } } } else { AbstractFunctionCallExpression f = createFunctionCallExpressionForBuiltinOperator(ops.get(i)); 
<|startcomment|> just print 'name' here? <|endcomment|>  if (nestClause.hasPositionalVariable()) { out.println(skip(step + 1) + " at "); nestClause.getPositionalVariable().accept(this, step + 2); } nestClause.getConditionExpression().accept(this, step + 2); return null; } @Override public Void visit(Projection projection, Integer step) throws AsterixException { projection.getExpression().accept(this, step); String name = projection.getName(); if (name != null) { <|startfocus|> out.print(" as " + projection.getName()); <|endfocus|> } return null; } @Override public Void visit(SelectBlock selectBlock, Integer step) throws AsterixException { selectBlock.getSelectClause().accept(this, step); if (selectBlock.hasFromClause()) { selectBlock.getFromClause().accept(this, step); } if (selectBlock.hasLetClauses()) { for (LetClause letClause : selectBlock.getLetList()) { letClause.accept(this, step); } } if (selectBlock.hasWhereClause()) { selectBlock.getWhereClause().accept(this, step); }
<|startcomment|> BLOCKER SonarQube violation: Change this condition so that it does not always evaluate to "true" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2583 <|endcomment|>  return false; } } return true; } private static ILogicalOperator extractPKProduction(ILogicalOperator root, LogicalVariable pk) throws AlgebricksException { ILogicalOperator prodOp = null; boolean validate; for (Mutable<ILogicalOperator> opRef : root.getInputs()) { validate = false; List<LogicalVariable> producedVars = new ArrayList<>(); VariableUtilities.getProducedVariables(opRef.getValue(), producedVars); <|startfocus|> if (producedVars != null && producedVars.contains(pk)) { <|endfocus|> prodOp = opRef.getValue(); validate = true; } else if (opRef.getValue().hasInputs()) { prodOp = extractPKProduction(opRef.getValue(), pk); if (prodOp != null) { validate = true; } } if (validate) { break; } } return prodOp; } private static void extractPrimaryKeys(IOptimizationContext context, ILogicalOperator root, List<LogicalVariable> prodVars) throws AlgebricksException { for (Mutable<ILogicalOperator> opRef : root.getInputs()) { if (opRef.getValue().getOperatorTag().equals(LogicalOperatorTag.DATASOURCESCAN)) {
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "isHomo". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  extractPrimaryKeys(context, peerOp, peerProduce); List<LogicalVariable> candPKs = new ArrayList<>(); lookupPrimaryKey(context, candProduce, candPKs); List<LogicalVariable> peerPKs = new ArrayList<>(); lookupPrimaryKey(context, peerProduce, peerPKs); // Merge the pk of the involving branches in terms of the bottom-up behavior in this rule. mergeHomogeneousPK(candOp, candPKs); mergeHomogeneousPK(peerOp, peerPKs); <|startfocus|> if (candPKs.size() != peerPKs.size()) { isHomo = false; } <|endfocus|> // Trigger the verification with merge and equal size determination. List<LogicalVariable> biPKs = new ArrayList<>(); biPKs.addAll(candPKs); biPKs.addAll(peerPKs); for (Mutable<ILogicalOperator> root : roots) mergeHomogeneousPK(root.getValue(), biPKs); if (biPKs.size() == candPKs.size()) isHomo = true; else { isHomo = false; } if (!isHomo) { break; } } } return isHomo; } } 
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  recBuilder.reset(curRecType); recBuilder.init(); if(curRecType!=null && !curRecType.isOpen()){ // closed record type fieldN = curFNames.length; for (int iter1 = 0; iter1 < fieldN; iter1++) { fieldValueBuffer.reset(); DataOutput fieldOutput = fieldValueBuffer.getDataOutput(); <|startfocus|> if(obj.isNull(curFNames[iter1])){ if(curRecType.isClosedField(curFNames[iter1])) throw new HyracksDataException("Closed field "+curFNames[iter1]+" has null value."); else <|endfocus|> continue; } else { if (writeField(obj.get(curFNames[iter1]), curTypes[iter1], fieldOutput)) recBuilder.addField(iter1, fieldValueBuffer); } } } else{ //open record type int closedFieldCount = 0; IAType curFieldType = null; for (String attrName : JSONObject.getNames(obj)){ if(obj.isNull(attrName)||obj.length()==0) continue; attrIdx = checkAttrNameIdx(curFNames, attrName); if(curRecType!=null)
<|startcomment|> CRITICAL SonarQube violation: Remove this misleading mutable servlet instance fields or make it "static" and/or "final" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2226 <|endcomment|>  import javax.servlet.http.HttpServletRequest; import org.apache.asterix.compiler.provider.ILangCompilationProvider; import org.apache.asterix.lang.common.base.Statement; public class AQLAPIServlet extends RESTAPIServlet { private static final long serialVersionUID = 1L; private static final String AQL_STMT_PARAM_NAME = "aql"; private static final List<Byte> allowedStatements = new ArrayList<>(); public AQLAPIServlet(ILangCompilationProvider compilationProvider) { super(compilationProvider); } <|startfocus|> static { for (Byte k : Statement.VALUES) { allowedStatements.add(k); } } <|endfocus|> @Override protected String getQueryParameter(HttpServletRequest request) { return request.getParameter(AQL_STMT_PARAM_NAME); } @Override protected List<Byte> getAllowedStatements() { return allowedStatements; } @Override protected String getErrorMessage() { throw new IllegalStateException(); } } 
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|>  ((dir == null) ? "" : (dir.endsWith(File.separator) ? dir : (dir + File.separator))) + STACK_FILE_NAME, stackId); this.iostream = new RandomAccessFile(file, "rw"); this.frame = new byte[frameSize]; } /** * @return the number of remaining frames to be read in the stack */ public int remaining() { return totalWriteCount - totalReadCount; } /** * copy content of buffer into the stack <|startfocus|> * <|endfocus|> * @param buffer * @throws IOException */ public synchronized void push(ByteBuffer buffer) throws IOException { int diff = totalWriteCount - totalReadCount; if (diff < numOfMemoryFrames) { ByteBuffer aBuffer = allocate(); aBuffer.put(buffer.array()); aBuffer.flip(); fullBuffers.push(aBuffer); } else { long position = (long) (diff - numOfMemoryFrames) * frameSize; if (position != iostream.getFilePointer()) { iostream.seek(position); } iostream.write(buffer.array()); }
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  in.close(); for (String name : prop.stringPropertyNames()) { nameClassNameMap.put(name, prop.getProperty(name)); } } catch (IOException e) { e.printStackTrace(); } } public IHeterogeneousTypeComputer getTypeComputer(String typeComputerName) throws AlgebricksException { IHeterogeneousTypeComputer typeComputer = loadedTypeComputer.get(typeComputerName); if (typeComputer == null) { try { String className = nameClassNameMap.get(typeComputerName); if (className == null) <|startfocus|> className = typeComputerName; <|endfocus|> Class<?> typeComputerClass = Class.forName(className); typeComputer = (IHeterogeneousTypeComputer) typeComputerClass.newInstance(); synchronized (loadedTypeComputer) { loadedTypeComputer.put(typeComputerName, typeComputer); } } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) { throw new AlgebricksException(e); } } return typeComputer; } public Set<String> getNameClassNameMap() { return nameClassNameMap.keySet(); } } 
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  case DOUBLE: current.addItem(FlatSchemaNode.DOUBLE_NODE); break; case DATE: case TIME: case DATETIME: case DURATION: case BINARY: case DAYTIMEDURATION: case UUID: current.addItem(FlatSchemaNode.STRING_NODE); break; case STRING: { if (!isPrintFieldName()) current.addItem(FlatSchemaNode.STRING_NODE); break; } case POINT: case POINT3D: { current.addItem(getPointNode()); break; } case LINE: // Line is a polygon case POLYGON: <|startfocus|> case RECTANGLE: { <|endfocus|> current.addItem(getPolygonNode()); break; } case CIRCLE: current.addItem(getCircleNode()); break; case YEARMONTHDURATION: { current.addItem(getYearMonthDuration()); break; } default: break; }
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  computeHeterogenousType(itemNode); } else { if (innerType.equals(NestedSchemaNodeType.RECORD)) { mergeFields(nestedNode); } else if (innerType.equals(NestedSchemaNodeType.LIST)) { innerListNode.resolveInternals(nestedNode.innerListNode); } else { boolean nullable = innerType == FlatSchemaNodeType.NULL || nestedNode.innerType == FlatSchemaNodeType.NULL; flatNode = FlatSchemaNode.computeFlatType(flatNode.type, nestedNode.flatNode.type, typeComputer); innerType = flatNode.type; <|startfocus|> if (nullable) setAsNullabe(); <|endfocus|> } } return this; } private void mergeFields(AbstractNestedSchemaNode nestedNode) { noneNullableFields.clear(); for (RecordSchemaNode r : nestedNode.innerFields) { AbstractNestedSchemaNode record = getInnerField(r.getFieldName()); if (record != null) { record.resolveInternals(r); } else { //That means @this didn't have record @r. @r must be nullable. r.setAsNullabe(); addRecord(r); } } /* * If nestedNode doesn't contain certain fields in 'this'
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  MutableInt count = fieldNameCountMap.get(fieldName); if (count == null) { count = new MutableInt(0); fieldNameCountMap.put(fieldName, count); } count.increment(); fieldName = fieldName + "Type" + count.getValue(); StringBuilder admTypeString = new StringBuilder(); int lastTypeEndOffset = -1; /* This to handle a corner case where the dataset type looks: * DatasetType { * list:[] * } <|startfocus|> * <|endfocus|> * i.e there's no name for the list */ if (node == this && node.innerType.equals(NestedSchemaNodeType.LIST)) { if (node.innerListNode.innerType == FlatSchemaNodeType.ANY) return null; admTypeString.append(ResultSchemaUtils.SPACE_INDENT + "list:"); printSchemaAsADM(node.innerListNode, admTypeString); admTypeString.append('\n'); } else { for (int i = 0; i < node.innerFields.size(); i++) { RecordSchemaNode r = node.innerFields.get(i); 
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  public static FlatSchemaNode computeFlatType(ISchemaNodeType type1, ISchemaNodeType type2, IHeterogeneousTypeComputer typeComputer) { if (type1 == type2) <|startfocus|> return getFlatNode(type1); <|endfocus|> FlatSchemaNodeType thisType = (FlatSchemaNodeType) type1; FlatSchemaNodeType otherType = (FlatSchemaNodeType) type2; FlatSchemaNodeType newType = (FlatSchemaNodeType) typeComputer.computePrimitiveType(thisType, otherType); return getFlatNode(newType); 
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|>  * * @param message * @param nodeId */ public synchronized void registerSchemaLocation(SchemaRegisterMessage message, String nodeId) { List<SchemaDirectoryeRecord> direcotryRecords = schemaLocations.get(message.getSchemaId()); if (direcotryRecords == null) { direcotryRecords = new LinkedList<>(); schemaLocations.put(message.getSchemaId(), direcotryRecords); } direcotryRecords.add(new SchemaDirectoryeRecord(message, nodeId)); notifyAll(); } /** * Map the schemaId with jobId. <|startfocus|> * <|endfocus|> * @param jobId * @param schemaId */ public synchronized void setJobSchemaId(long jobId, long schemaId) { jobSchemaIdMap.put(jobId, schemaId); notifyAll(); } /** * get all schemas from all registered partitions. * * @param jobId * @return * @throws InterruptedException */ public List<ISchemaNode> getSchemas(long jobId) throws InterruptedException { long schemaId = jobSchemaIdMap.get(jobId); List<ISchemaNode> schemas = jobSchemas.get(schemaId);
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  for (Pair<OrderOperator.IOrder, Mutable<ILogicalExpression>> p : op.getOrderExpressions()) { String fst; if (op.getTopK() != -1) { buffer.append("(topK: " + op.getTopK() + ") "); } switch (p.first.getKind()) { case ASC: { fst = "ASC"; break; } case DESC: { fst = "DESC"; break; } default: { fst = p.first.getExpressionRef().toString(); <|startfocus|> } <|endfocus|> } buffer.append("(" + fst + ", " + p.second.getValue().accept(exprVisitor, indent) + ") "); } return buffer.toString(); } catch (IOException e) { throw new AlgebricksException(e); } } @Override public String visitAssignOperator(AssignOperator op, Integer indent) throws AlgebricksException { try { StringBuilder buffer = new StringBuilder(); addIndent(buffer, indent).append("assign ").append(str(op.getVariables())).append(" <- ");
<|startcomment|> MAJOR SonarQube violation: Constructor has 8 parameters, which is greater than 7 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00107 <|endcomment|>  public AsterixExternalScalarFunctionInfo(String namespace, AsterixFunction asterixFunction, IAType returnType, String body, String language, List<IAType> argumentTypes,String initParas, IResultTypeComputer rtc) { <|startfocus|> super(namespace, asterixFunction, FunctionKind.SCALAR, argumentTypes, returnType, rtc, body, language, initParas); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Reduce this switch case number of lines from 81 to at most 20, for example by extracting code into methods. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1151 <|endcomment|>  leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<ILogicalOperator>(deleteOp)); break; } case CONNECT_FEED: { InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false); insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions); insertOp.getInputs().add(new MutableObject<ILogicalOperator>(assign)); leafOperator = new SinkOperator(); <|startfocus|> leafOperator.getInputs().add(new MutableObject<ILogicalOperator>(insertOp)); <|endfocus|> break; } case SUBSCRIBE_FEED: { // if the feed is a change feed (i.e, performs different operations), we need to project op variable CompiledSubscribeFeedStatement sfs = (CompiledSubscribeFeedStatement) stmt; InsertDeleteUpsertOperator feedModificationOp; AssignOperator metaAndKeysAssign = null; List<LogicalVariable> metaAndKeysVars = null; List<Mutable<ILogicalExpression>> metaAndKeysExprs = null; List<Mutable<ILogicalExpression>> metaExpSingletonList = null; boolean isChangeFeed = FeedMetadataUtil.isChangeFeed(metadataProvider, sfs.getDataverseName(), sfs.getFeedName());
<|startcomment|> MAJOR SonarQube violation: The Cyclomatic Complexity of this method "merge" is 21 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity <|endcomment|>  private String toOutput(String signature) { if (signature.indexOf(OPEN_ANGULAR) == 0) { // a final StringBuilder aString = new StringBuilder(); aString.append(signature.substring(0, signature.indexOf(CLOSE_ANGULAR) + 1)); aString.append('\n'); aString.append(signature.substring(signature.indexOf(CLOSE_ANGULAR) + 1)); return aString.toString(); } else { return signature; } } <|startfocus|> private void merge(BufferedWriter writer, String signature, Pair<String, String> baseBlocks, String[] extensions) <|endfocus|> throws IOException, MojoExecutionException { String errorMessage = "Merged base node doesn't conform to expected mergable node structure"; int block1Open = baseBlocks.first.indexOf(OPEN_BRACE); int block1Close = baseBlocks.first.lastIndexOf(CLOSE_BRACE); // first block writer.write(OPEN_BRACE); if (extensions[0] != null) { writer.write(extensions[0]); } writer.write(baseBlocks.first.substring(block1Open + 1, block1Close)); if (extensions[1] != null) { writer.write(extensions[1]); }
<|startcomment|> Can we do non-* static includes? <|endcomment|>  import javax.servlet.ServletContext; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.json.JSONArray; import org.json.JSONObject; import org.apache.asterix.result.ResultReader; import org.apache.hyracks.api.client.IHyracksClientConnection; import org.apache.hyracks.api.dataset.IHyracksDataset; import org.apache.hyracks.api.dataset.ResultSetId; import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.client.dataset.HyracksDataset; <|startfocus|> import static org.apache.asterix.api.http.servlet.ServletConstants.*; <|endfocus|> public class QueryStatusAPIServlet extends HttpServlet { private static final long serialVersionUID = 1L; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType("text/html"); response.setCharacterEncoding("utf-8"); String strHandle = request.getParameter("handle"); PrintWriter out = response.getWriter(); ServletContext context = getServletContext(); IHyracksClientConnection hcc; IHyracksDataset hds; try { synchronized (context) { hcc = (IHyracksClientConnection) context.getAttribute(HYRACKS_CONNECTION_ATTR); 
<|startcomment|> synchronize close() as well and set out to null after closing? <|endcomment|> <|startfocus|> public void close() { <|endfocus|> if (out != null) { out.flush(); out.close(); }
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  nullPrinter = npf.createPrinter(); AbstractPrinterWithSchemaFactory fpf = (AbstractPrinterWithSchemaFactory) AqlCleanJSONWithSchemaPrinterFactoryProvider .getPrinterFactory(unionType.getActualType(), schemaId, typeComputer); fieldPrinter = fpf.createPrinter(); } @Override public void print(byte[] b, int s, int l, PrintStream ps) throws HyracksDataException { fieldPrinter.init(); if (b[s] == ATypeTag.NULL.serialize()) nullPrinter.print(b, s, l, ps); else <|startfocus|> fieldPrinter.print(b, s, l, ps); <|endfocus|> } };
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|>  public static final FlatSchemaNode NULL_NODE = new FlatSchemaNode(FlatSchemaNodeType.NULL); public static final FlatSchemaNode ANY_NODE = new FlatSchemaNode(FlatSchemaNodeType.ANY); /** * Create a primitive node of @param * * @param type */ public FlatSchemaNode(ISchemaNodeType type) { this.type = type; } @Override public String toString() { return type.toString(); } /** * Return a node of a given type <|startfocus|> * <|endfocus|> * @param type * @return */ public static FlatSchemaNode getFlatNode(ISchemaNodeType type) { FlatSchemaNodeType flatType = (FlatSchemaNodeType) type; switch (flatType) { case STRING: return STRING_NODE; case BOOLEAN: return BOOLEAN_NODE; case DOUBLE: return DOUBLE_NODE; case INT64: return LONG_NODE; case NULL: return NULL_NODE; case ANY: return ANY_NODE; default: break; } return ANY_NODE; } /** * Get the required type of two different primitive types
<|startcomment|> MAJOR SonarQube violation: trailing WS is not allowed Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3Aasterixdb_trailingws <|endcomment|> import org.apache.asterix.schema.node.IHeterogeneousTypeComputer; import org.apache.asterix.schema.node.ListSchemaNode; import org.apache.asterix.schema.node.RecordSchemaNode; import org.apache.asterix.schema.node.type.NestedSchemaNodeType; /** * Object pool for SchemaNode. */ public class NodesObjectPool { private Queue<RecordSchemaNode> recordPool = new LinkedList<>(); private Queue<ListSchemaNode> listPool = new LinkedList<>(); private final IHeterogeneousTypeComputer typeComputer; /** * Creates NodeObjectPool. <|startfocus|> * <|endfocus|> * @param typeComputer */ public NodesObjectPool(IHeterogeneousTypeComputer typeComputer) { this.typeComputer = typeComputer; } /** * Put back the object to reused. * * @param nestedNode */ public void recycle(AbstractNestedSchemaNode nestedNode) { if (nestedNode.getType().equals(NestedSchemaNodeType.LIST)) { listPool.add((ListSchemaNode) nestedNode); } else { recordPool.add((RecordSchemaNode) nestedNode); } } /** * Get a SchemaNode of type Record. * * @return
<|startcomment|> MAJOR SonarQube violation: Split this 140 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|> <|startfocus|> public LocalResource createLocalResource(long resourceId, String resourceName, int partition, int storageVersion, String resourcePath) { return new LocalResource(resourceId, resourceName, partition, resourcePath, LocalResource.TransientResource, storageVersion, null); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "arg". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|>  u.setExpr(u.getExpr().accept(this, u)); return u; } @Override public Expression visit(FieldAccessor fa, ILangExpression arg) throws AsterixException { fa.setExpr(fa.getExpr().accept(this, fa)); return fa; } @Override public Expression visit(IndexAccessor ia, ILangExpression arg) throws AsterixException { ia.setExpr(ia.getExpr().accept(this, ia)); if (ia.getIndexExpr() != null) { <|startfocus|> ia.setIndexExpr(ia.getIndexExpr()); <|endfocus|> } return ia; } @Override public Expression visit(IndependentSubquery independentSubquery, ILangExpression arg) throws AsterixException { independentSubquery.setExpr(independentSubquery.getExpr().accept(this, arg)); return independentSubquery; } } 
<|startcomment|> MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "s". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 <|endcomment|>  public static long getByteValue(String s) { try { // step1. strip all commas from the given number and // convert each character to a corresponding lowercase. s = s.replaceAll(",", "").toLowerCase(); <|startfocus|> // Default type StorageUtil.StorageUnit unitType = StorageUnit.BYTE; <|endfocus|> // Check the suffix switch (s.substring(s.length() - 2)) { case "kb": unitType = StorageUnit.KILOBYTE; break; case "mb": unitType = StorageUnit.MEGABYTE; break; case "gb": unitType = StorageUnit.GIGABYTE; break; case "tb": unitType = StorageUnit.TERABYTE; break; case "pb": unitType = StorageUnit.PETABYTE; break; default: // Other suffixes will be treated as byte. break; } // Strip all unit suffixes. s = s.replaceAll("[^\\.0123456789]", ""); // Return the byte value for the given numbers. return (long) getSizeInBytes(Double.parseDouble(s), unitType);
<|startcomment|> MAJOR SonarQube violation: Rename "partitioningKeys" which hides the field declared at line 52. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck <|endcomment|>  AqlMetadataProvider aqlMetadataProvider, IDataSource<AqlSourceId> dataSource, List<LogicalVariable> scanVariables, List<LogicalVariable> projectVariables, boolean projectPushed, List<LogicalVariable> minFilterVars, List<LogicalVariable> maxFilterVars, IOperatorSchema opSchema, IVariableTypeEnvironment typeEnv, JobGenContext context, JobSpecification jobSpec, Object implConfig) throws AlgebricksException { // This is a load into dataset operation LoadableDataSource alds = (LoadableDataSource) dataSource; <|startfocus|> List<List<String>> partitioningKeys = alds.getPartitioningKeys(); boolean isPKAutoGenerated = ((InternalDatasetDetails) alds.getTargetDataset().getDatasetDetails()).isAutogenerated(); <|endfocus|> ARecordType itemType = (ARecordType) alds.getLoadedType(); int pkIndex = 0; IAdapterFactory adapterFactory = aqlMetadataProvider.getConfiguredAdapterFactory(alds.getTargetDataset(), alds.getAdapter(), alds.getAdapterProperties(), itemType, isPKAutoGenerated, partitioningKeys, null); RecordDescriptor rDesc = JobGenHelper.mkRecordDescriptor(typeEnv, opSchema, context); return aqlMetadataProvider.buildLoadableDatasetScan(jobSpec, alds, adapterFactory, rDesc, isPKAutoGenerated, partitioningKeys, itemType, pkIndex); } } 
<|startcomment|> MAJOR SonarQube violation: Method has 12 parameters, which is greater than 7 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00107 <|endcomment|>  metaAndKeysAssign = new AssignOperator(metaAndKeysVars, metaAndKeysExprs); metaAndKeysAssign.getInputs().add(project.getInputs().get(0)); project.getInputs().set(0, new MutableObject<>(metaAndKeysAssign)); } feedModificationOp.setAdditionalFilteringExpressions(additionalFilteringExpressions); SinkOperator leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<>(feedModificationOp)); return leafOperator; } <|startfocus|> private ILogicalOperator translateUpsert(Query expr, DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, <|endfocus|> List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign, List<String> additionalFilteringField, LogicalVariable unnestVar, ProjectOperator project, ArrayList<Mutable<ILogicalExpression>> exprs, LogicalVariable resVar, AssignOperator additionalFilteringAssign) throws AlgebricksException { if (!targetDatasource.getDataset().allow(project,Dataset.UPSERT)) { throw new AlgebricksException(targetDatasource.getDataset().getDatasetName() + ": upsert into dataset is not supported on Datasets with Meta records"); } if (targetDatasource.getDataset().hasMetaPart()) { InsertDeleteUpsertOperator feedModificationOp;
<|startcomment|> MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "s". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 <|endcomment|>  public static String escapeHTML(String s) { for (Character c : HTML_ENTITIES.keySet()) { if (s.indexOf(c) >= 0) { s = s.replace(c.toString(), HTML_ENTITIES.get(c)); } } <|startfocus|> return s; <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 <|endcomment|>  IAType fieldType = null; ARecordType subType = KeyFieldTypeUtils.chooseSource(keySourceIndicators, keyIndex, aRecordType, metaRecordType); boolean isOpen = subType.isOpen(); int i = 0; if (fieldExpr.first.size() > 1 && !isOpen) { for (; i < fieldExpr.first.size() - 1;) { subType = (ARecordType) subType.getFieldType(fieldExpr.first.get(i)); i++; <|startfocus|> if (subType.isOpen()) { isOpen = true; break; } ; <|endfocus|> } } if (fieldExpr.second == null) { fieldType = subType.getSubFieldType(fieldExpr.first.subList(i, fieldExpr.first.size())); } else { if (!stmtCreateIndex.isEnforced()) { throw new AlgebricksException("Cannot create typed index on \"" + fieldExpr.first + "\" field without enforcing it's type"); } if (!isOpen) { throw new AlgebricksException("Typed index on \"" + fieldExpr.first
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  * @return * @throws AsterixException */ protected Triple<FeedConnectionRequest, Boolean, List<IFeedJoint>> getFeedConnectionRequest(String dataverse, Feed feed, String dataset, FeedPolicyEntity feedPolicy, MetadataTransactionContext mdTxnCtx) throws AsterixException { IFeedJoint sourceFeedJoint = null; FeedConnectionRequest request = null; List<String> functionsToApply = new ArrayList<String>(); boolean needIntakeJob = false; List<IFeedJoint> jointsToRegister = new ArrayList<IFeedJoint>(); FeedConnectionId connectionId = new FeedConnectionId(feed.getFeedId(), dataset); <|startfocus|> FeedRuntimeType connectionLocation = null; <|endfocus|> FeedJointKey feedJointKey = getFeedJointKey(feed, mdTxnCtx); EntityId entityId = new EntityId(Feed.EXTENSION_NAME, dataverse, feed.getFeedName()); FeedEventsListener listener = (FeedEventsListener) ActiveJobNotificationHandler.INSTANCE.getActiveEntityListener(entityId); if (listener == null) { throw new AsterixException("Feed Listener is not registered"); } boolean isFeedJointAvailable = listener.isFeedJointAvailable(feedJointKey); if (!isFeedJointAvailable) { sourceFeedJoint = listener.getAvailableFeedJoint(feedJointKey);
<|startcomment|> MAJOR SonarQube violation: Split this 128 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  pb.directory(new File(pregelixHome)); pb.redirectErrorStream(true); MetadataManager.INSTANCE.commitTransaction(mdTxnCtx); bActiveTxn = false; // Executes the Pregelix command. int resultState = executeExternalShellProgram(pb); // Checks the return state of the external Pregelix command. if (resultState != 0) { throw new AlgebricksException( "Something went wrong executing your Pregelix Job. Perhaps the Pregelix cluster needs to be restarted. " + "Check the following things: Are the datatypes of Asterix and Pregelix matching? " <|startfocus|> + "Is the server configuration correct (node names, buffer sizes, framesize)? Check the logfiles for more details."); <|endfocus|> } } catch (Exception e) { if (bActiveTxn) { abort(e, e, mdTxnCtx); } throw e; } finally { MetadataLockManager.INSTANCE.insertDeleteUpsertEnd(dataverseNameTo, datasetNameTo, readDataverses, readDatasets); } } // Prepares to run a program on external runtime. protected void prepareRunExternalRuntime(AqlMetadataProvider metadataProvider, IHyracksClientConnection hcc,
<|startcomment|> MAJOR SonarQube violation: Method has 11 parameters, which is greater than 7 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00107 <|endcomment|>  project.getInputs().set(0, new MutableObject<>(metaAndKeysAssign)); } feedModificationOp.setAdditionalFilteringExpressions(additionalFilteringExpressions); SinkOperator leafOperator = new SinkOperator(); leafOperator.getInputs().add(new MutableObject<>(feedModificationOp)); return leafOperator; } private ILogicalOperator translateUpsert(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading, List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign, <|startfocus|> List<String> additionalFilteringField) throws AlgebricksException { if (targetDatasource.getDataset().hasMetaPart()) { <|endfocus|> throw new AlgebricksException(targetDatasource.getDataset().getDatasetName() + ": upsert into dataset is not supported on Datasets with Meta records"); } InsertDeleteUpsertOperator upsertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading, InsertDeleteUpsertOperator.Kind.UPSERT, false); upsertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions); upsertOp.getInputs().add(new MutableObject<>(assign)); // Create and add a new variable used for representing the original record ARecordType recordType = (ARecordType) targetDatasource.getItemType();
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|> <|startfocus|> public final static List<IAlgebraicRewriteRule> buildAccessMethodRuleCollection() { List<IAlgebraicRewriteRule> accessMethod = new LinkedList<IAlgebraicRewriteRule>(); <|endfocus|> accessMethod.add(new IntroduceSelectAccessMethodRule()); accessMethod.add(new IntroduceJoinAccessMethodRule()); accessMethod.add(new IntroduceLSMComponentFilterRule()); accessMethod.add(new IntroduceSecondaryIndexInsertDeleteRule()); accessMethod.add(new RemoveUnusedOneToOneEquiJoinRule()); accessMethod.add(new PushSimilarityFunctionsBelowJoin()); accessMethod.add(new RemoveUnusedAssignAndAggregateRule()); return accessMethod;
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  } } else { parentFieldNames.add(fieldName); } return (parentFieldNames); } optFuncExpr.setSourceVar(funcVarIndex, ((AssignOperator) op).getVariables().get(assignVarIndex)); //no nested assign, we are at the lowest level. if (isByName) { if (nestedAccessFieldName != null) { return nestedAccessFieldName; } return new ArrayList<String>(Arrays.asList(fieldName)); } <|startfocus|> return new ArrayList<String>(Arrays.asList(recordType.getFieldNames()[fieldIndex])); <|endfocus|> } if (!funcIDSetThatRetainFieldName.contains(funcIdent)) { return null; } // We use a part of the field in edit distance computation if (optFuncExpr.getFuncExpr().getFunctionIdentifier() == AsterixBuiltinFunctions.EDIT_DISTANCE_CHECK) { optFuncExpr.setPartialField(true); } // We expect the function's argument to be a variable, otherwise we // cannot apply an index. ILogicalExpression argExpr = funcExpr.getArguments().get(0).getValue(); if (argExpr.getExpressionTag() != LogicalExpressionTag.VARIABLE) {
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  PlanTranslationUtil.prepareVarAndExpression(additionalFilteringField, resVar, additionalFilteringVars, additionalFilteringAssignExpressions, additionalFilteringExpressions, context); additionalFilteringAssign = new AssignOperator(additionalFilteringVars, additionalFilteringAssignExpressions); additionalFilteringAssign.getInputs().add(new MutableObject<ILogicalOperator>(project)); assign.getInputs().add(new MutableObject<ILogicalOperator>(additionalFilteringAssign)); } else { assign.getInputs().add(new MutableObject<ILogicalOperator>(project)); } <|startfocus|> Mutable<ILogicalExpression> varRef = new MutableObject<ILogicalExpression>( new VariableReferenceExpression(resVar)); ILogicalOperator leafOperator = null; <|endfocus|> switch (stmt.getKind()) { case INSERT: { if (targetDatasource.getDataset().hasMetaPart()) { throw new AlgebricksException(targetDatasource.getDataset().getDatasetName() + ": insert into dataset is not supported on Datasets with Meta records"); } InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false); insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions); insertOp.getInputs().add(new MutableObject<ILogicalOperator>(assign));
<|startcomment|> BLOCKER SonarQube violation: NullPointerException might be thrown as 'currExpr' is nullable here Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2259 <|endcomment|>  BroadcastExpressionAnnotation bcast = new BroadcastExpressionAnnotation(); bcast.setObject(BroadcastSide.RIGHT); c.getAnnotations().put(BroadcastExpressionAnnotation.BROADCAST_ANNOTATION_KEY, bcast); } } } else { AbstractFunctionCallExpression f = createFunctionCallExpressionForBuiltinOperator(ops.get(i)); if (i == 0) { f.getArguments().add(new MutableObject<ILogicalExpression>(e)); currExpr = f; } else { <|startfocus|> ((AbstractFunctionCallExpression) currExpr).getArguments() .add(new MutableObject<ILogicalExpression>(e)); f.getArguments().add(new MutableObject<ILogicalExpression>(currExpr)); <|endfocus|> currExpr = f; } } } else { // don't forget the last expression... ((AbstractFunctionCallExpression) currExpr).getArguments() .add(new MutableObject<ILogicalExpression>(e)); if (i == 1 && op.isBroadcastOperand(i)) { BroadcastExpressionAnnotation bcast = new BroadcastExpressionAnnotation(); bcast.setObject(BroadcastSide.RIGHT); ((AbstractFunctionCallExpression) currExpr).getAnnotations() .put(BroadcastExpressionAnnotation.BROADCAST_ANNOTATION_KEY, bcast); } } } 
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  case PLUS: { fid = AlgebricksBuiltinFunctions.NUMERIC_ADD; break; } case MINUS: { fid = AsterixBuiltinFunctions.NUMERIC_SUBTRACT; break; } case MUL: { fid = AsterixBuiltinFunctions.NUMERIC_MULTIPLY; break; } case DIV: { fid = AsterixBuiltinFunctions.NUMERIC_DIVIDE; break; } case MOD: { fid = AsterixBuiltinFunctions.NUMERIC_MOD; break; } case IDIV: { fid = AsterixBuiltinFunctions.NUMERIC_IDIV; break; } case CARET: { fid = AsterixBuiltinFunctions.CARET; break; <|startfocus|> } case AND: { <|endfocus|> fid = AlgebricksBuiltinFunctions.AND; break; } case OR: { fid = AlgebricksBuiltinFunctions.OR; break; } case FUZZY_EQ: { fid = AsterixBuiltinFunctions.FUZZY_EQ; break; } default: { throw new NotImplementedException("Operator " + t + " is not yet implemented"); } } return new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(fid)); } private static boolean hasOnlyChild(ILogicalOperator parent, Mutable<ILogicalOperator> childCandidate) {
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  protected ILogicalExpression makeUnnestExpression(ILogicalExpression expr) { List<Mutable<ILogicalExpression>> argRefs = new ArrayList<>(); argRefs.add(new MutableObject<ILogicalExpression>(expr)); switch (expr.getExpressionTag()) { case CONSTANT: case VARIABLE: { return new UnnestingFunctionCallExpression( FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), argRefs); } case FUNCTION_CALL: { AbstractFunctionCallExpression fce = (AbstractFunctionCallExpression) expr; <|startfocus|> if (fce.getKind() == FunctionKind.UNNEST) { return expr; } else { return new UnnestingFunctionCallExpression( FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), argRefs); } } default: { <|endfocus|> return expr; } }
<|startcomment|> CRITICAL SonarQube violation: Refactor this code to not throw exceptions in finally blocks. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1163 <|endcomment|>  LOGGER.warn("Failure while operating a feed source", e); throw new HyracksDataException(e); } try { tupleForwarder.close(); } catch (Throwable th) { hde = ExternalDataExceptionUtils.suppressIntoHyracksDataException(hde, th); } try { recordReader.close(); } catch (Throwable th) { LOGGER.warn("Failure during while operating a feed sourcec", th); hde = ExternalDataExceptionUtils.suppressIntoHyracksDataException(hde, th); } finally { closeSignal(); if (hde != null) { throw hde; } <|startfocus|> } <|endfocus|> } private void parseAndForward(IRawRecord<? extends T> record) throws IOException { synchronized (dataParser) { try { dataParser.parse(record, tb.getDataOutput()); } catch (Exception e) { LOGGER.warn(ExternalDataConstants.ERROR_PARSE_RECORD, e); feedLogManager.logRecord(record.toString(), ExternalDataConstants.ERROR_PARSE_RECORD); // continue the outer loop return; } tb.addFieldEndOffset(); addMetaPart(tb, record); addPrimaryKeys(tb, record); tupleForwarder.addTuple(tb); } } 
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  private static final Map<IFunctionInfo, IFunctionInfo> aggregateToLocalAggregate = new HashMap<IFunctionInfo, IFunctionInfo>(); private static final Map<IFunctionInfo, IFunctionInfo> aggregateToIntermediateAggregate = new HashMap<IFunctionInfo, IFunctionInfo>(); private static final Map<IFunctionInfo, IFunctionInfo> aggregateToGlobalAggregate = new HashMap<IFunctionInfo, IFunctionInfo>(); private static final Map<IFunctionInfo, IFunctionInfo> aggregateToSerializableAggregate = new HashMap<IFunctionInfo, IFunctionInfo>(); private final static Map<IFunctionInfo, Boolean> builtinUnnestingFunctions = new HashMap<IFunctionInfo, Boolean>(); private final static Map<IFunctionInfo, IFunctionInfo> scalarToAggregateFunctionMap = new HashMap<IFunctionInfo, IFunctionInfo>(); private static final Map<IFunctionInfo, SpatialFilterKind> spatialFilterFunctions = new HashMap<IFunctionInfo, SpatialFilterKind>(); <|startfocus|> public final static FunctionIdentifier TYPE_OF = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "type-of", 1); public final static FunctionIdentifier GET_HANDLE = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, <|endfocus|> "get-handle", 2); public final static FunctionIdentifier GET_DATA = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "get-data", 2); 
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  this.hostIPAddressFirstOctet = replicationProperties.getReplicaIPAddress(nodeId).substring(0, 3); this.logManager = logManager; replicationJobsQ = new LinkedBlockingQueue<IReplicationJob>(); replicaEventsQ = new LinkedBlockingQueue<ReplicaEvent>(); terminateJobsReplication = new AtomicBoolean(false); jobsReplicationSuspended = new AtomicBoolean(true); replicationSuspended = new AtomicBoolean(true); <|startfocus|> replicas = new HashMap<String, Replica>(); jobCommitAcks = new ConcurrentHashMap<Integer, Set<String>>(); replicationJobsPendingAcks = new ConcurrentHashMap<Integer, ILogRecord>(); shuttingDownReplicaIds = new HashSet<String>(); <|endfocus|> dataBuffer = ByteBuffer.allocate(INITIAL_BUFFER_SIZE); //Used as async listeners from replicas replicationListenerThreads = Executors.newCachedThreadPool(); replicationJobsProcessor = new ReplicationJobsProccessor(); replicationMonitor = new ReplicasEventsMonitor(); Map<String, ClusterPartition[]> nodePartitions = ((IAsterixPropertiesProvider) asterixAppRuntimeContextProvider .getAppContext()).getMetadataProperties().getNodePartitions(); //add list of replicas from configurations (To be read from another source e.g. Zookeeper) Set<Replica> replicaNodes = replicationProperties.getRemoteReplicas(nodeId);
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  private void checkReplicaState(String replicaId, boolean async, boolean suspendReplication) { Replica replica = replicas.get(replicaId); ReplicaStateChecker connector = new ReplicaStateChecker(replica, replicationProperties.getReplicationTimeOut(), this, replicationProperties, suspendReplication); Future<? extends Object> ft = asterixAppRuntimeContextProvider.getThreadExecutor().submit(connector); if (!async) { //wait until task is done while (!ft.isDone()) { try { Thread.sleep(1000); } catch (InterruptedException e) { <|startfocus|> e.printStackTrace(); <|endfocus|> } } }
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  String responseLine = ""; while (true) { responseLine = incomingResponse.readLine(); if (responseLine == null) { break; } //read ACK for job commit log String replicaId = ReplicationProtocol.getNodeIdFromLogAckMessage(responseLine); int jobId = ReplicationProtocol.getJobIdFromLogAckMessage(responseLine); addAckToJob(jobId, replicaId); } <|startfocus|> } catch (AsynchronousCloseException e1) { LOGGER.log(Level.INFO, "Replication listener stopped for remote replica: " + replicaId); } catch (IOException e2) { reportFailedReplica(replicaId); <|endfocus|> }
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|> import org.apache.hyracks.algebricks.core.algebra.expressions.IMissableTypeComputer; import org.apache.hyracks.algebricks.core.algebra.metadata.IMetadataProvider; import org.apache.hyracks.algebricks.core.algebra.properties.TypePropagationPolicy; public class PropagatingTypeEnvironment extends AbstractTypeEnvironment { private final TypePropagationPolicy policy; private final IMissableTypeComputer nullableTypeComputer; private final ITypeEnvPointer[] envPointers; private final List<LogicalVariable> nonNullVariables = new ArrayList<LogicalVariable>(); <|startfocus|> private final List<List<LogicalVariable>> correlatedNullableVariableLists = new ArrayList<List<LogicalVariable>>(); <|endfocus|> public PropagatingTypeEnvironment(IExpressionTypeComputer expressionTypeComputer, IMissableTypeComputer nullableTypeComputer, IMetadataProvider<?, ?> metadataProvider, TypePropagationPolicy policy, ITypeEnvPointer[] envPointers) { super(expressionTypeComputer, metadataProvider); this.nullableTypeComputer = nullableTypeComputer; this.policy = policy; this.envPointers = envPointers; } @Override public Object getVarType(LogicalVariable var) throws AlgebricksException { return getVarTypeFullList(var, nonNullVariables, correlatedNullableVariableLists); } public List<LogicalVariable> getNonNullVariables() { return nonNullVariables; } 
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  private boolean evaluatePredicate(int tIx1, int tIx2) { if (reverseOutputOrder) { //Role Reversal Optimization is triggered return ((predEvaluator == null) || predEvaluator.evaluate(accessorBuild, tIx2, accessorProbe, tIx1)); } else { <|startfocus|> return ((predEvaluator == null) || predEvaluator.evaluate(accessorProbe, tIx1, accessorBuild, tIx2)); <|endfocus|> }
<|startcomment|> MAJOR SonarQube violation: '<' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  SequentialFixpointRuleController seqCtrlNoDfs = new SequentialFixpointRuleController(false); SequentialFixpointRuleController seqCtrlFullDfs = new SequentialFixpointRuleController(true); SequentialOnceRuleController seqOnceCtrl = new SequentialOnceRuleController(true); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildInitialTranslationRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildTypeInferenceRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildAutogenerateIDRuleCollection())); <|startfocus|> defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection())); <|endfocus|> defaultLogicalRewrites .add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildCondPushDownAndJoinInferenceRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildLoadFieldsRuleCollection())); // fj defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildFuzzyJoinRuleCollection())); // defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection())); defaultLogicalRewrites .add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildCondPushDownAndJoinInferenceRuleCollection()));
<|startcomment|> MAJOR SonarQube violation: '<' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  conf.out().println(); printPlanPrefix(conf, "Expression tree"); q.accept(astPrintVisitorFactory.createLangVisitor(conf.out()), 0); printPlanPostfix(conf); } IQueryRewriter rw = rewriterFactory.createQueryRewriter(); rw.rewrite(declaredFunctions, q, metadataProvider, new LangRewritingContext(q.getVarCounter())); return new Pair<>(q, q.getVarCounter()); } public JobSpecification compileQuery(List<FunctionDecl> declaredFunctions, <|startfocus|> AqlMetadataProvider queryMetadataProvider, Query rwQ, int varCounter, String outputDatasetName, <|endfocus|> SessionConfig conf, ICompiledDmlStatement statement) throws AlgebricksException, JSONException, RemoteException, ACIDException { if (!conf.is(SessionConfig.FORMAT_ONLY_PHYSICAL_OPS) && conf.is(SessionConfig.OOB_REWRITTEN_EXPR_TREE)) { conf.out().println(); printPlanPrefix(conf, "Rewritten expression tree"); if (rwQ != null) { rwQ.accept(astPrintVisitorFactory.createLangVisitor(conf.out()), 0); } printPlanPostfix(conf); } org.apache.asterix.common.transactions.JobId asterixJobId = JobIdFactory.generateJobId(); queryMetadataProvider.setJobId(asterixJobId);
<|startcomment|> spaces? <|endcomment|>  public Void visit(Projection projection, Integer step) throws AsterixException { <|startfocus|> if(projection.star()){ <|endfocus|> out.print(" * "); return null; } projection.getExpression().accept(this, step); String name = projection.getName(); if (name != null) { out.print(" as " + name); } return null;
<|startcomment|> ws <|endcomment|>  */ public interface IExtension { enum ExtensionKind { /** * Extends Query translator */ STATEMENT_EXECUTOR, /** * Extends Metadata */ METADATA, /** * Extends Language Syntax and Algebric Operations */ LANG } /** * @return Unique Id for the extension (used for lookup operations) */ ExtensionId getId(); /** * Configures the extension with configuration parameters. * This method is called on system boot * * @param property */ <|startfocus|> void configure(List<Property> property); <|endfocus|> /** * @return The extension point implemented by this extension */ ExtensionKind getExtensionKind(); } 
<|startcomment|> code tells. <|endcomment|>  // The only issue was that it has exceeded the budget slightly. // Now, since a partition is spilled to the disk, we check the frame usage again. if (!table.isUsedNumFramesExceedBudget()) { // If the table conforms to the budget, we can stop here. // If not, we continue to spill another partitions. result = InsertResultType.SUCCESS; } } else { <|startfocus|> // FAIL case - try to insert again <|endfocus|> result = table.insert(accessor, i); } } while (result != InsertResultType.SUCCESS); } } } private void flushPartitionToRun(int partition, RunFileWriter writer) throws HyracksDataException { try { spilledNumTuples[partition] += table.flushFrames(partition, writer, AggregateType.PARTIAL); table.clear(partition); } catch (Exception ex) { writer.fail(); throw new HyracksDataException(ex); } } public void flushSpilledPartitions() throws HyracksDataException { for (int i = 0; i < runWriters.length; ++i) {
<|startcomment|> CRITICAL SonarQube violation: Make "strLowerCaseTokenCmp" transient or serializable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1948 <|endcomment|>  // To conduct a full-text search, we convert all strings to the lower case. // In addition, since each token does not include the length information (2 // bytes) in the beginning, // We need to have a different binary comparator that is different from a standard string comparator. // i.e. A token comparator that receives the length of a token as a parameter. private final IBinaryComparator strLowerCaseTokenCmp = AqlBinaryComparatorFactoryProvider.UTF8STRING_LOWERCASE_TOKEN_POINTABLE_INSTANCE .createBinaryComparator(); <|startfocus|> private IBinaryTokenizer tokenizerForLeftArray = null; private IBinaryTokenizer tokenizerForRightArray = null; <|endfocus|> // Case insensitive hash for full-text search private IBinaryHashFunction hashFunc = null; // keyEntry used in the hash-set private BinaryEntry keyEntry = null; // Parameter: number of bucket, frame size, hashFunction, Comparator, byte // array that contains the key private BinaryHashSet rightHashSet = null; // Checks whether the query array has been changed private byte[] previousQueryArray = null; private int previousQueryArrayLength = 0; 
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  IBinaryTokenizer queryTokenizer = searchPred.getQueryTokenizer(); // Is this query a full-text query? // Then, the last argument is conjuctive or disjunctive search option, not a query text. // Thus, we need to remove the last argument. boolean isFullTextSearchQuery = searchPred.getIsFullTextSearchQuery(); int queryFieldIndexesLength = queryFieldIndexes.length; <|startfocus|> // if (isFullTextSearchQuery && queryFieldIndexesLength > FTContainsParams.getNumParams()) { // queryFieldIndexesLength = queryFieldIndexesLength - FTContainsParams.getNumParams(); // } <|endfocus|> // Get the type of query tokenizer. TokenizerType queryTokenizerType = queryTokenizer.getTokenizerType(); for (int i = 0; i < queryFieldIndexesLength; i++) { queryTokenAppender.reset(queryTokenFrame, true); queryTokenizer.reset(queryTuple.getFieldData(queryFieldIndexes[i]), queryTuple.getFieldStart(queryFieldIndexes[i]), queryTuple.getFieldLength(queryFieldIndexes[i])); int tokenCountInOneField = 0; while (queryTokenizer.hasNext()) { queryTokenizer.next(); queryTokenBuilder.reset(); try { tokenCountInOneField++;
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  response.sendError(HttpServletResponse.SC_NOT_FOUND); }catch(IllegalStateException | IOException e){ LOG.error(e); } return; } // Multiple MIME type support for (Map.Entry<String, String> entry : fileMimePair.entrySet()) { OutputStream out = null; if (resourcePath.endsWith(entry.getKey())) { response.setContentType(entry.getValue()); try { out = response.getOutputStream(); IOUtils.copy(is, out); } catch(IOException e){ LOG.info(e); <|startfocus|> } finally{ <|endfocus|> if (out != null) { IOUtils.closeQuietly(out); } IOUtils.closeQuietly(is); } return; } } try{ response.sendError(HttpServletResponse.SC_BAD_REQUEST); }catch(IllegalStateException | IOException e){ LOG.error(e); } } } @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setCharacterEncoding("utf-8"); response.setContentType("application/json");
<|startcomment|> MAJOR SonarQube violation: Rename "jsonAPIServer" which hides the field declared at line 81. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck <|endcomment|>  queryWebServer = new Server(externalProperties.getQueryWebInterfacePort()); ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); context.setContextPath("/"); IHyracksClientConnection hcc = getNewHyracksClientConnection(); context.setAttribute(HYRACKS_CONNECTION_ATTR, hcc); queryWebServer.setHandler(context); context.addServlet(new ServletHolder(new QueryWebInterfaceServlet()), "/*"); } protected Server setupJSONAPIServer(AsterixExternalProperties externalProperties) throws Exception { <|startfocus|> Server jsonAPIServer = new Server(externalProperties.getAPIServerPort()); <|endfocus|> ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS); context.setContextPath("/"); IHyracksClientConnection hcc = getNewHyracksClientConnection(); context.setAttribute(HYRACKS_CONNECTION_ATTR, hcc); context.setAttribute(ASTERIX_BUILD_PROP_ATTR, AsterixAppContextInfo.getInstance()); jsonAPIServer.setHandler(context); // AQL rest APIs. addServlet(context, Servlets.AQL_QUERY); addServlet(context, Servlets.AQL_UPDATE); addServlet(context, Servlets.AQL_DDL); addServlet(context, Servlets.AQL); // SQL++ rest APIs. addServlet(context, Servlets.SQLPP_QUERY); addServlet(context, Servlets.SQLPP_UPDATE);
<|startcomment|> revert static final -> final static <|endcomment|>  public static final FunctionIdentifier EDIT_DISTANCE_CHECK = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "edit-distance-check", 3); public static final FunctionIdentifier EDIT_DISTANCE_LIST_IS_FILTERABLE = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "edit-distance-list-is-filterable", 2); public static final FunctionIdentifier EDIT_DISTANCE_STRING_IS_FILTERABLE = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "edit-distance-string-is-filterable", 4); <|startfocus|> public static final FunctionIdentifier EDIT_DISTANCE_CONTAINS = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "edit-distance-contains", 3); <|endfocus|> // tokenizers: public static final FunctionIdentifier WORD_TOKENS = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "word-tokens", 1); public static final FunctionIdentifier HASHED_WORD_TOKENS = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "hashed-word-tokens", 1); public static final FunctionIdentifier COUNTHASHED_WORD_TOKENS = new FunctionIdentifier( FunctionConstants.ASTERIX_NS, "counthashed-word-tokens", 1); public static final FunctionIdentifier GRAM_TOKENS = new FunctionIdentifier(FunctionConstants.ASTERIX_NS, "gram-tokens", 3);
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  Pair<Query, Integer> reWrittenQuery = apiFramework.reWriteQuery(declaredFunctions, metadataProvider, query, sessionConfig); // Query Compilation (happens under the same ongoing metadata transaction) JobSpecification spec = apiFramework.compileQuery(declaredFunctions, metadataProvider, reWrittenQuery.first, reWrittenQuery.second, stmt == null ? null : stmt.getDatasetName(), sessionConfig, stmt); return spec; } <|startfocus|> protected void handleCreateFeedStatement(AqlMetadataProvider metadataProvider, Statement stmt, IHyracksClientConnection hcc) throws Exception { <|endfocus|> CreateFeedStatement cfs = (CreateFeedStatement) stmt; String dataverseName = getActiveDataverse(cfs.getDataverseName()); String feedName = cfs.getFeedName().getValue(); MetadataTransactionContext mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); metadataProvider.setMetadataTxnContext(mdTxnCtx); MetadataLockManager.INSTANCE.createFeedBegin(dataverseName, dataverseName + "." + feedName); Feed feed = null; try { feed = MetadataManager.INSTANCE.getFeed(metadataProvider.getMetadataTxnContext(), dataverseName, feedName); if (feed != null) { if (cfs.getIfNotExists()) { MetadataManager.INSTANCE.commitTransaction(mdTxnCtx);
<|startcomment|> MAJOR SonarQube violation: Split this 137 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  IAType keyType = recType.getSubFieldType(partitioningKey); typeTraits[i] = AqlTypeTraitProvider.INSTANCE.getTypeTrait(keyType); ++i; } ARecordType metaItemType = DatasetUtils.getMetaType(this, dataset); IBinaryComparatorFactory[] primaryComparatorFactories = DatasetUtils.computeKeysBinaryComparatorFactories( dataset, recType, metaItemType, context.getBinaryComparatorFactoryProvider()); IAsterixApplicationContextInfo appContext = (IAsterixApplicationContextInfo) context.getAppContext(); <|startfocus|> Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitProviderAndPartitionConstraintsForDataset( <|endfocus|> dataverseName, datasetName, indexName, temp); int[] btreeFields = new int[primaryComparatorFactories.length]; for (int k = 0; k < btreeFields.length; k++) { btreeFields[k] = k + numSecondaryKeys; } ITypeTraits[] filterTypeTraits = DatasetUtils.computeFilterTypeTraits(dataset, recType); IBinaryComparatorFactory[] filterCmpFactories = DatasetUtils.computeFilterBinaryComparatorFactories(dataset, recType, context.getBinaryComparatorFactoryProvider()); int[] filterFields = null; int[] rtreeFields = null; if (filterTypeTraits != null) { filterFields = new int[1];
<|startcomment|> CRITICAL SonarQube violation: Make "tupleTranslatorProvider" transient or serializable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1948 <|endcomment|> import org.apache.hyracks.storage.am.lsm.common.api.ILSMIndexAccessor; import org.apache.hyracks.storage.am.lsm.common.impls.AbstractLSMIndex; public class MetadataNode implements IMetadataNode { private static final long serialVersionUID = 1L; private static final DatasetId METADATA_DATASET_ID = new DatasetId(MetadataPrimaryIndexes.PROPERTIES_METADATA.getDatasetId()); // shared between core and extension private IDatasetLifecycleManager datasetLifecycleManager; private ITransactionSubsystem transactionSubsystem; private int metadataStoragePartition; // core only <|startfocus|> private MetadataTupleTranslatorProvider tupleTranslatorProvider; <|endfocus|> // extension only private Map<ExtensionMetadataDatasetId, ExtensionMetadataDataset<?>> extensionDatasets; public static final MetadataNode INSTANCE = new MetadataNode(); private MetadataNode() { super(); } public void initialize(IAsterixAppRuntimeContext runtimeContext, MetadataTupleTranslatorProvider tupleTranslatorProvider, List<IMetadataExtension> metadataExtensions) { this.tupleTranslatorProvider = tupleTranslatorProvider; this.transactionSubsystem = runtimeContext.getTransactionSubsystem(); this.datasetLifecycleManager = runtimeContext.getDatasetLifecycleManager(); this.metadataStoragePartition = ((IAsterixPropertiesProvider) runtimeContext).getMetadataProperties() .getMetadataPartition().getPartitionId();
<|startcomment|> CRITICAL SonarQube violation: Make "aInt64" transient or serializable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1948 <|endcomment|>  /** * Translates a Node metadata entity to an ITupleReference and vice versa. */ public class NodeTupleTranslator extends AbstractTupleTranslator<Node> { // Field indexes of serialized Node in a tuple. // First key field. public static final int NODE_NODENAME_TUPLE_FIELD_INDEX = 0; // Payload field containing serialized Node. public static final int NODE_PAYLOAD_TUPLE_FIELD_INDEX = 1; private AMutableInt64 aInt64 = new AMutableInt64(-1); @SuppressWarnings("unchecked") <|startfocus|> private ISerializerDeserializer<AInt64> int64Serde = AqlSerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT64); <|endfocus|> // @SuppressWarnings("unchecked") // private ISerializerDeserializer<ARecord> recordSerDes = // NonTaggedSerializerDeserializerProvider.INSTANCE // .getSerializerDeserializer(recordType); protected NodeTupleTranslator(boolean getTuple) { super(getTuple, MetadataPrimaryIndexes.NODE_DATASET.getFieldCount()); } @Override public Node getMetadataEntityFromTuple(ITupleReference frameTuple) throws IOException { throw new NotImplementedException(); // TODO: Implement this. // try { // byte[] serRecord =
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "previousChar". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  } builder.finish(); } public void initCap(UTF8StringBuilder builder, GrowableArray out) throws IOException { initCap(this, builder, out); } public static void initCap(UTF8StringPointable src, UTF8StringBuilder builder, GrowableArray out) throws IOException { final int srcUtfLen = src.getUTF8Length(); final int srcStart = src.getMetaDataLength(); builder.reset(out, srcUtfLen); boolean toUpperCase = true; int byteIndex = 0; <|startfocus|> char previousChar = ' '; <|endfocus|> while (byteIndex < srcUtfLen) { char originalChar = src.charAt(srcStart + byteIndex); boolean isLetter = Character.isLetter(originalChar); // Make the first character into upper case while the later ones into lower case. char resultChar = toUpperCase && isLetter ? Character.toUpperCase(originalChar) : (isLetter ? Character .toLowerCase(originalChar) : originalChar); builder.appendChar(resultChar); byteIndex += src.charSize(srcStart + byteIndex); // Whether the next letter needs to switch to the upper case.
<|startcomment|> MAJOR SonarQube violation: Make this anonymous inner class a lambda Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1604 <|endcomment|>  public class StringTrimDescriptor extends AbstractScalarFunctionDynamicDescriptor { private static final long serialVersionUID = 1L; public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { @Override public IFunctionDescriptor createFunctionDescriptor() { return new StringTrimDescriptor(); } }; @Override public FunctionIdentifier getIdentifier() { return AsterixBuiltinFunctions.STRING_TRIM; } @Override public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) throws AlgebricksException { <|startfocus|> return new IScalarEvaluatorFactory() { <|endfocus|> @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws AlgebricksException { return new AbstractUnaryStringStringEval(ctx, args[0], StringTrimDescriptor.this.getIdentifier()) { private StringTrimer stringTrimer = new StringTrimer(resultBuilder, resultArray, " "); @Override protected void process(UTF8StringPointable srcPtr, IPointable resultStrPtr) throws AlgebricksException { stringTrimer.trim(srcPtr, resultStrPtr, true, true); } }; } }; } } 
<|startcomment|> Can we just let this throw IOException? Seems cleaner ... <|endcomment|> <|startfocus|> public static void readRecords(String fileName, List<int[]> records, List<Integer> rids) { <|endfocus|> try (LittleEndianIntInputStream in = new LittleEndianIntInputStream(new BufferedInputStream(new FileInputStream(fileName)))) { while (true) { int rid = 0; try { rid = in.readInt(); } catch (IOException e) { // FILE_EXPECTED reach of EOF break; } rids.add(rid); int[] record; int size = in.readInt(); record = new int[size]; for (int j = 0; j < size; j++) { int token = in.readInt(); record[j] = token; } records.add(record); } } catch (IOException e) { throw new RuntimeException(e); }
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  public IPhysicalPropertiesVector computePropertiesVector(List<LogicalVariable> scanVariables) { IPhysicalPropertiesVector propsVector = null; IPartitioningProperty pp; List<ILocalStructuralProperty> propsLocal; int n; switch (ds.getDatasourceType()) { case AqlDataSourceType.LOADABLE: case AqlDataSourceType.EXTERNAL_DATASET: pp = new RandomPartitioningProperty(domain); propsLocal = new ArrayList<ILocalStructuralProperty>(); ds.computeLocalStructuralProperties(propsLocal, scanVariables); <|startfocus|> propsVector = new StructuralPropertiesVector(pp, propsLocal); <|endfocus|> break; case AqlDataSourceType.FEED: n = scanVariables.size(); if (n < 2) { pp = new RandomPartitioningProperty(domain); } else { Set<LogicalVariable> pvars = new ListSet<LogicalVariable>(); pvars.addAll(ds.getPrimaryKeyVariables(scanVariables)); pp = new UnorderedPartitionedProperty(pvars, domain); } propsLocal = new ArrayList<ILocalStructuralProperty>(); propsVector = new StructuralPropertiesVector(pp, propsLocal); break; case AqlDataSourceType.INTERNAL_DATASET: n = scanVariables.size(); Set<LogicalVariable> pvars = new ListSet<LogicalVariable>(); if (n < 2) {
<|startcomment|> MAJOR SonarQube violation: Return an empty array instead of null. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1168 <|endcomment|>  * if it does not correspond to the set of registered Node Controllers. */ public synchronized String[] getIODevices(String nodeId) { Map<String, String> ncConfig = activeNcConfiguration.get(nodeId); if (ncConfig == null) { if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.warning("Configuration parameters for nodeId " + nodeId + " not found. The node has not joined yet or has left."); } <|startfocus|> return null; <|endfocus|> } return ncConfig.get(IO_DEVICES).split(","); } public ClusterState getState() { return state; } public Cluster getCluster() { return cluster; } public synchronized Node getAvailableSubstitutionNode() { List<Node> subNodes = cluster.getSubstituteNodes() == null ? null : cluster.getSubstituteNodes().getNode(); return subNodes == null || subNodes.isEmpty() ? null : subNodes.get(0); } public synchronized Set<String> getParticipantNodes() { Set<String> participantNodes = new HashSet<>();
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  } public ClusterState getState() { return state; } public Cluster getCluster() { return cluster; } public synchronized Node getAvailableSubstitutionNode() { List<Node> subNodes = cluster.getSubstituteNodes() == null ? null : cluster.getSubstituteNodes().getNode(); return subNodes == null || subNodes.isEmpty() ? null : subNodes.get(0); } public synchronized Set<String> getParticipantNodes() { <|startfocus|> Set<String> participantNodes = new HashSet<String>(); <|endfocus|> for (String pNode : activeNcConfiguration.keySet()) { participantNodes.add(pNode); } return participantNodes; } public synchronized AlgebricksAbsolutePartitionConstraint getClusterLocations() { if (clusterPartitionConstraint == null) { resetClusterPartitionConstraint(); } return clusterPartitionConstraint; } private synchronized void resetClusterPartitionConstraint() { ArrayList<String> clusterActiveLocations = new ArrayList<>(); for (ClusterPartition p : clusterPartitions.values()) { if (p.isActive()) { clusterActiveLocations.add(p.getActiveNodeId()); } }
<|startcomment|> MAJOR SonarQube violation: Remove this silly call to "Math.ceil" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2185 <|endcomment|>  public static int getExpectedByteSizeOfHashTable(int tableSize, int frameSize) { <|startfocus|> int numberOfHeaderFrame = (int) Math.ceil(tableSize * 2 / frameSize); int numberOfContentFrame = (int) Math .ceil((getNumberOfEntryInSlot() * 2 * getUnitSize() * tableSize) / frameSize); <|endfocus|> return (numberOfHeaderFrame + numberOfContentFrame) * frameSize;
<|startcomment|> CRITICAL SonarQube violation: Add a "try/catch" block for "sendError". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1989 <|endcomment|>  json.put("ncs", getClusterStateJSON(request, "").getJSONArray("ncs")); } else { String[] parts = request.getPathInfo().replaceAll("/+", "/").split("/"); json = processNode(request, hcc, parts); } response.setStatus(HttpServletResponse.SC_OK); response.setContentType("application/json"); response.setCharacterEncoding("utf-8"); responseWriter.write(json.toString(4)); <|startfocus|> } catch (IllegalArgumentException e) { response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage()); <|endfocus|> } catch (Exception e) { ResultUtil.apiErrorHandler(responseWriter, e); response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); } responseWriter.flush(); } private JSONObject processNode(HttpServletRequest request, IHyracksClientConnection hcc, String[] parts) throws Exception { if (parts.length < 2 || parts.length > 3 || !"".equals(parts[0])) { throw new IllegalArgumentException(); } String node = parts[1]; if (parts.length == 2) {
<|startcomment|> 1. static final 2. can we write -1 as 0xFFFFFFFF, such that you can use arrays.fill(...) instead of ByteBuffer.writeInt(...), which is more convenient and more efficient? <|endcomment|>  * [capacity of the slot], [# of occupied elements], {[frameIndex], [tupleIndex]}+; * <fIndex, tIndex> forms a tuple pointer */ public class SerializableHashTable implements ISerializableTable { // unit size: int private static final int INT_SIZE = 4; // Initial entry slot size private static final int INIT_ENTRY_SIZE = 4; <|startfocus|> private static double garbageCollectionThreshold = 0.10; private static int INVALID_VALUE = -1; <|endfocus|> // Header frame array private IntSerDeBuffer[] headers; // Content frame list private List<IntSerDeBuffer> contents = new ArrayList<>(); private List<Integer> currentOffsetInEachFrameList = new ArrayList<>(); private final IHyracksFrameMgrContext ctx; private final int frameCapacity; private int currentLargestFrameNumber = 0; private int tupleCount = 0; // The number of total frames that are allocated to the headers and contents private int totalFrameCount = 0; private TuplePointer tempTuplePointer = new TuplePointer();
<|startcomment|> MAJOR SonarQube violation: Replace the type specification in this constructor call with the diamond operator ("<>"). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2293 <|endcomment|>  public ActiveLifecycleEventSubscriber() { <|startfocus|> this.inbox = new LinkedBlockingQueue<ActiveLifecycleEvent>(); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  if (pushSubplanAsAggIntoGby(opRef, nspOp, v, nspListifyVarsCount, nspWithAgg, nspAggVarToPlanIndex, context)) { change = true; } else { nspListifyVarsCount.put(v, m + 1); } } } if (!change) { // Collect aggregate variables for pushing aggregates into the subplan (if possible). collectAggregateVars(nspListifyVarsCount, nspWithAgg, nspAggVarToPlanIndex, (AbstractOperatorWithNestedPlans) op1); } break; <|startfocus|> } case GROUP: { <|endfocus|> // Collect aggregate variables for pushing aggregates into the nested subplan // of the group by operator (if possible). collectAggregateVars(nspListifyVarsCount, nspWithAgg, nspAggVarToPlanIndex, (AbstractOperatorWithNestedPlans) op1); break; } default: { for (LogicalVariable v : used) { Integer m = nspListifyVarsCount.get(v); if (m != null) { nspListifyVarsCount.put(v, m + 1); } } } } return change; } 
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; public void dumpState(String stateDumpId) throws Exception; public void shutdown() throws Exception; public void sendApplicationMessageToNC(byte[] data, DeploymentId deploymentId, String nodeId) throws Exception; <|startfocus|> public void takeThreadDump() throws Exception; <|endfocus|> } 
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "B". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  public List<ExtensionMetadataDataset> getExtensionIndexes() { try { <|startfocus|> ExtensionMetadataDataset A = BADMetadataIndexes.CHANNEL_DATASET; ExtensionMetadataDataset B = BADMetadataIndexes.BROKER_DATASET; <|endfocus|> return Arrays.asList(BADMetadataIndexes.CHANNEL_DATASET, BADMetadataIndexes.BROKER_DATASET); } catch (Throwable th) { th.printStackTrace(); throw th; }
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  buffer.append(", meta: "); pprintExprList(op.getAdditionalNonFilteringExpressions(), indent); } buffer.append(" partitioned by "); pprintExprList(op.getPrimaryKeyExpressions(), indent); if (op.getOperation() == Kind.UPSERT) { buffer.append( <|startfocus|> " out: ([record-before-upsert:" + op.getBeforeOpRecordVar() + ((op.getBeforeOpAdditionalNonFilteringVars() != null) ? (", additional-before-upsert: " + op.getBeforeOpAdditionalNonFilteringVars()) : "") <|endfocus|> + "]) "); } if (op.isBulkload()) { buffer.append(" [bulkload]"); } return null; } @Override public Void visitIndexInsertDeleteUpsertOperator(IndexInsertDeleteUpsertOperator op, Integer indent) throws AlgebricksException { String header = getIndexOpString(op.getOperation()); addIndent(indent).append(header).append(op.getIndexName()).append(" on ") .append(str(op.getDataSourceIndex().getDataSource())).append(" from "); if (op.getOperation() == Kind.UPSERT) { buffer.append(" replace:");
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  JobSpecificationActivityClusterGraphGeneratorFactory jsacggf = new JobSpecificationActivityClusterGraphGeneratorFactory( jobSpec); return startJob(deploymentId, jsacggf, jobFlags); } @Override public JobId startJob(DeploymentId deploymentId, IActivityClusterGraphGeneratorFactory acggf, EnumSet<JobFlag> jobFlags) throws Exception { return hci.startJob(deploymentId, JavaSerializationUtils.serialize(acggf), jobFlags); } @Override public JobInfo getJobInfo(JobId jobId) throws Exception { return hci.getJobInfo(jobId); } @Override <|startfocus|> public void stopCluster(boolean terminateNCService) throws Exception{ <|endfocus|> hci.stopCluster(terminateNCService); } @Override public String getNodeDetailsJSON(String nodeId, boolean includeStats, boolean includeConfig) throws Exception { return hci.getNodeDetailsJSON(nodeId, includeStats, includeConfig); } @Override public String getThreadDump(String node) throws Exception { return hci.getThreadDump(node); } } 
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  Long.toString(highKey)); } @Override public IAction buildIOWaitAction() throws IOException { SequentialActionList ioAction = new SequentialActionList(); ioAction.add(new SleepAction(10000)); ioAction.add(new RunRESTIOWaitAction(httpClient, restHost, restPort)); ioAction.add(new SleepAction(10000)); return ioAction; } @Override public IAction buildCompactAction() throws IOException { <|startfocus|> return (new RunAQLFileAction(httpClient, restHost, restPort, localExperimentRoot.resolve(LSMExperimentConstants.AQL_DIR).resolve("8_compact.aql"))); <|endfocus|> } } } 
<|startcomment|> MAJOR SonarQube violation: Use isEmpty() to check whether the collection is empty or not. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1155 <|endcomment|>  + dataverseName + "." + signature.getName() + "!"); } Function function = lookupUserDefinedFunctionDecl(metadataProvider.getMetadataTxnContext(), signature); if (function == null) { FunctionSignature normalizedSignature = functionNormalizer == null ? signature : functionNormalizer.normalizeBuiltinFunctionSignature(signature); if (AsterixBuiltinFunctions.isBuiltinCompilerFunction(normalizedSignature, includePrivateFunctions)) { continue; } StringBuilder messageBuilder = new StringBuilder(); <|startfocus|> if (functionDecls.size() > 0) { <|endfocus|> messageBuilder.append("function " + functionDecls.get(functionDecls.size() - 1).getSignature() + " depends upon function " + signature + " which is undefined"); } else { messageBuilder.append("function " + signature + " is undefined "); } throw new AsterixException(messageBuilder.toString()); } if (function.getLanguage().equalsIgnoreCase(Function.LANGUAGE_AQL)) { FunctionDecl functionDecl = functionParser.getFunctionDecl(function); if (functionDecl != null) { if (functionDecls.contains(functionDecl)) { throw new AsterixException(
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  DeploymentId deploymentId = null; boolean hasDeployed = dis.readBoolean(); if (hasDeployed) { deploymentId = DeploymentId.create(dis); } // read plan bytes int planBytesSize = dis.readInt(); byte[] planBytes = null; if (planBytesSize >= 0) { planBytes = new byte[planBytesSize]; dis.read(planBytes, 0, planBytesSize); } return new StartJobFunction(deploymentId, jobId, planBytes); } <|startfocus|> public static void serialize(OutputStream out, Object object) throws Exception { <|endfocus|> StartJobFunction fn = (StartJobFunction) object; DataOutputStream dos = new DataOutputStream(out); //write jobId and deploymentId fn.jobId.writeFields(dos); dos.writeBoolean(fn.deploymentId == null ? false : true); if (fn.deploymentId != null) { fn.deploymentId.writeFields(dos); } //write plan bytes dos.writeInt(fn.planBytes == null ? -1 : fn.planBytes.length); if (fn.planBytes != null) { dos.write(fn.planBytes, 0, fn.planBytes.length); } } }
<|startcomment|> MAJOR SonarQube violation: Rename this field "INVALID_VALUE" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 <|endcomment|>  * . * An entry slot in the content frame is as follows. * [capacity of the slot], [# of occupied elements], {[frameIndex], [tupleIndex]}+; * <fIndex, tIndex> forms a tuple pointer */ public class SerializableHashTable implements ISerializableTable { protected static final int INT_SIZE = 4; // Initial entry slot size protected static final int INIT_ENTRY_SIZE = 4; // Header frame array <|startfocus|> protected IntSerDeBuffer[] headers; <|endfocus|> // Content frame list protected List<IntSerDeBuffer> contents = new ArrayList<>(); protected List<Integer> currentOffsetInEachFrameList = new ArrayList<>(); protected final IHyracksFrameMgrContext ctx; protected final int frameCapacity; protected int currentLargestFrameNumber = 0; protected int tupleCount = 0; // The number of total frames that are allocated to the headers and contents protected int totalFrameCount = 0; protected TuplePointer tempTuplePointer = new TuplePointer(); public SerializableHashTable(int tableSize, final IHyracksFrameMgrContext ctx) throws HyracksDataException {
<|startcomment|> MAJOR SonarQube violation: The return type of this method should be an interface such as "List" rather than the implementation "ArrayList". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 <|endcomment|>  return IndexingConstants.getRIDSize(dsd.getProperties().get(IndexingConstants.KEY_INPUT_FORMAT)); } public static IBinaryComparatorFactory[] getComparatorFactories(Dataset dataset) { ExternalDatasetDetails dsd = ((ExternalDatasetDetails) dataset.getDatasetDetails()); return IndexingConstants.getComparatorFactories(dsd.getProperties().get(IndexingConstants.KEY_INPUT_FORMAT)); } public static IBinaryComparatorFactory[] getBuddyBtreeComparatorFactories() { return IndexingConstants.getBuddyBtreeComparatorFactories(); } <|startfocus|> public static ArrayList<ExternalFile> getSnapshotFromExternalFileSystem(Dataset dataset) throws AlgebricksException { ArrayList<ExternalFile> files = new ArrayList<>(); <|endfocus|> ExternalDatasetDetails datasetDetails = (ExternalDatasetDetails) dataset.getDatasetDetails(); try { // Create the file system object FileSystem fs = getFileSystemObject(datasetDetails.getProperties()); // Get paths of dataset String path = datasetDetails.getProperties().get(ExternalDataConstants.KEY_PATH); String[] paths = path.split(","); // Add fileStatuses to files for (String aPath : paths) { FileStatus[] fileStatuses = fs.listStatus(new Path(aPath));
<|startcomment|> MAJOR SonarQube violation: Add a private constructor to hide the implicit public one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1118 <|endcomment|>  */ package org.apache.asterix.lang.common.util; import org.apache.asterix.common.utils.JobSpecificationUtils; import org.apache.asterix.metadata.declared.AqlMetadataProvider; import org.apache.asterix.metadata.entities.Dataverse; import org.apache.hyracks.algebricks.common.constraints.AlgebricksPartitionConstraint; import org.apache.hyracks.algebricks.common.constraints.AlgebricksPartitionConstraintHelper; import org.apache.hyracks.algebricks.common.utils.Pair; import org.apache.hyracks.api.job.JobSpecification; import org.apache.hyracks.dataflow.std.file.FileRemoveOperatorDescriptor; import org.apache.hyracks.dataflow.std.file.IFileSplitProvider; <|startfocus|> public class DataverseOperations { <|endfocus|> public static JobSpecification createDropDataverseJobSpec(Dataverse dataverse, AqlMetadataProvider metadata) { JobSpecification jobSpec = JobSpecificationUtils.createJobSpecification(); Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = metadata .splitProviderAndPartitionConstraintsForDataverse(dataverse.getDataverseName()); FileRemoveOperatorDescriptor frod = new FileRemoveOperatorDescriptor(jobSpec, splitsAndConstraint.first, false); AlgebricksPartitionConstraintHelper.setPartitionConstraintInJobSpec(jobSpec, frod, splitsAndConstraint.second); jobSpec.addRoot(frod); return jobSpec; } } 
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "ds". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|>  file.getFileName(), file.getLastModefiedTime(), appendedFile.getSize(), ExternalFilePendingOp.PENDING_NO_OP)); } } } } for (ExternalFile file : addedFiles) { files.add(file); } Collections.sort(files); return buildFilesIndexReplicationJobSpec(ds, files, metadataProvider, false); } <|startfocus|> public static JobSpecification buildIndexUpdateOp(Dataset ds, Index index, List<ExternalFile> metadataFiles, List<ExternalFile> deletedFiles, List<ExternalFile> addedFiles, List<ExternalFile> appendedFiles, AqlMetadataProvider metadataProvider) throws AsterixException, AlgebricksException { <|endfocus|> // Create files list ArrayList<ExternalFile> files = new ArrayList<>(); for (ExternalFile metadataFile : metadataFiles) { if (metadataFile.getPendingOp() != ExternalFilePendingOp.PENDING_APPEND_OP) { files.add(metadataFile); } else { metadataFile.setPendingOp(ExternalFilePendingOp.PENDING_NO_OP); files.add(metadataFile); } } // add new files for (ExternalFile file : addedFiles) { files.add(file); } // add appended files
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "storageProperties". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  AlgebricksMetaOperatorDescriptor selectOp = null; if (anySecondaryKeyIsNullable || isEnforcingKeyTypes) { selectOp = createFilterNullsSelectOp(spec, numNestedSecondaryKeFieldsConsideringPointMBR, secondaryRecDescConsideringPointMBR); } // Sort by secondary keys. ExternalSortOperatorDescriptor sortOp = createSortOp(spec, new IBinaryComparatorFactory[] { AqlMetadataProvider.proposeLinearizer(keyType, secondaryComparatorFactories.length) }, isPointMBR ? secondaryRecDescForPointMBR : secondaryRecDesc); <|startfocus|> AsterixStorageProperties storageProperties = propertiesProvider.getStorageProperties(); <|endfocus|> IBinaryComparatorFactory[] btreeCompFactories = getComparatorFactoriesForDeletedKeyBTree(); IIndexDataflowHelperFactory idff = new LSMRTreeWithAntiMatterTuplesDataflowHelperFactory( valueProviderFactories, RTreePolicyType.RTREE, btreeCompFactories, new AsterixVirtualBufferCacheProvider(dataset.getDatasetId()), mergePolicyFactory, mergePolicyFactoryProperties, new SecondaryIndexOperationTrackerProvider(dataset.getDatasetId()), AsterixRuntimeComponentsProvider.RUNTIME_PROVIDER, LSMRTreeIOOperationCallbackFactory.INSTANCE, AqlMetadataProvider.proposeLinearizer(keyType, secondaryComparatorFactories.length), rtreeFields, filterTypeTraits, filterCmpFactories, secondaryFilterFields, !temp, isPointMBR);; // Create secondary RTree bulk load op.
<|startcomment|> MAJOR SonarQube violation: Rename "itemTypeName" which hides the field declared at line 71. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck <|endcomment|>  } @Override public byte getCategory() { return Category.DDL; } @Override public void handle(IStatementExecutor executor, AqlMetadataProvider metadataProvider, IHyracksClientConnection hcc) throws Exception { MutableObject<ProgressState> progress = new MutableObject<>(ProgressState.NO_PROGRESS); String dvName = executor.getActiveDataverseName(dataverse); String dsName = name.getValue(); String itemTypeDataverseName = itemTypeDataverse.getValue(); String itemTypeName = this.itemTypeName.getValue(); String metaItemTypeDataverseName = getMetaItemTypeDataverse().getValue(); <|startfocus|> String metaItemTypeName = getMetaItemTypeName().getValue(); <|endfocus|> Identifier ngNameId = nodegroupName; String nodegroupName = getNodeGroupName(ngNameId, this, dvName); String compactionPolicy = getCompactionPolicy(); Map<String, String> compactionPolicyProperties = this.compactionPolicyProperties; boolean defaultCompactionPolicy = compactionPolicy == null; boolean temp = getDatasetDetailsDecl().isTemp(); MetadataTransactionContext mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); boolean bActiveTxn = true; metadataProvider.setMetadataTxnContext(mdTxnCtx); 
<|startcomment|> MAJOR SonarQube violation: The Cyclomatic Complexity of this method "validateKeyFields" is 56 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity <|endcomment|>  * a map of key fields that will be validated * @param keyFieldTypes * a map of key types (if provided) that will be validated * @param indexType * the type of the index that its key fields is being validated * @throws AsterixException * (if the validation failed), IOException */ public static void validateKeyFields(ARecordType recType, ARecordType metaRecType, List<List<String>> keyFieldNames, List<Integer> keySourceIndicators, List<IAType> keyFieldTypes, IndexType indexType) <|startfocus|> throws AsterixException { <|endfocus|> List<IAType> fieldTypes = KeyFieldTypeUtils.getKeyTypes(recType, metaRecType, keyFieldNames, keySourceIndicators); int pos = 0; boolean openFieldCompositeIdx = false; for (IAType fieldType : fieldTypes) { List<String> fieldName = keyFieldNames.get(pos); if (fieldType == null) { fieldType = keyFieldTypes.get(pos); if (keyFieldTypes.get(pos) == BuiltinType.AMISSING) {
<|startcomment|> MAJOR SonarQube violation: Iterate over the "entrySet" instead of the "keySet". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2864 <|endcomment|>  throw new IllegalStateException(); } } catch (AsterixException e) { throw new AlgebricksException(e); } } private static void secondPass(MetadataTransactionContext mdTxnCtx, Map<TypeSignature, IAType> typeMap, Map<String, Map<ARecordType, List<Integer>>> incompleteFieldTypes, Map<TypeSignature, List<AbstractCollectionType>> incompleteItemTypes, Map<TypeSignature, List<TypeSignature>> incompleteTopLevelTypeReferences, String typeDataverse) throws AlgebricksException { // solve remaining top level references <|startfocus|> for (TypeSignature typeSignature : incompleteTopLevelTypeReferences.keySet()) { <|endfocus|> IAType t; Datatype dt = MetadataManager.INSTANCE.getDatatype(mdTxnCtx, typeSignature.getNamespace(), typeSignature.getName()); if (dt == null) { throw new AlgebricksException("Could not resolve type " + typeSignature); } else { t = dt.getDatatype(); } for (TypeSignature sign : incompleteTopLevelTypeReferences.get(typeSignature)) { typeMap.put(sign, t); } } // solve remaining field type references for (String trefName : incompleteFieldTypes.keySet()) { IAType t;
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  /** * expend the executing activities further to the downstream */ if (outputConnectors != null && outputConnectors.size() > 0) { for (IConnectorDescriptor conn : outputConnectors) { if (conn != null) { childQueue.add(parent.getConnectorActivityMap().get(conn.getConnectorId())); } } } } } @Override public void deinitialize() throws HyracksDataException { <|startfocus|> // No op here since the deinitialize() of each individual wrapped operator // has been run in this.initialize(); <|endfocus|> } @Override public int getInputArity() { return inputArity; } @Override public void setOutputFrameWriter(int clusterOutputIndex, IFrameWriter writer, RecordDescriptor recordDesc) throws HyracksDataException { /** * set the right output frame writer */ Pair<ActivityId, Integer> activityIdOutputIndex = parent.getActivityIdOutputIndex(clusterOutputIndex); IOperatorNodePushable opPushable = operatorNodePushables.get(activityIdOutputIndex.getLeft()); opPushable.setOutputFrameWriter(activityIdOutputIndex.getRight(), writer, recordDesc); } @Override
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "change". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  if (plan.getRoots().size() > 1) { // not a single subplan List<Mutable<ILogicalOperator>> subInpList = subplan.getInputs(); subInpList.clear(); subInpList.add(new MutableObject<ILogicalOperator>(new EmptyTupleSourceOperator())); return subplan; } return plan.getRoots().get(0).getValue(); } public static boolean setOperatorMode(AbstractLogicalOperator op, IOptimizationContext context) throws AlgebricksException { AbstractLogicalOperator.ExecutionMode oldMode = op.getExecutionMode(); <|startfocus|> boolean change = false; <|endfocus|> switch (op.getOperatorTag()) { case DATASOURCESCAN: { op.setExecutionMode(AbstractLogicalOperator.ExecutionMode.PARTITIONED); AbstractLogicalOperator currentOp = op; while (currentOp.getInputs().size() == 1) { AbstractLogicalOperator child = (AbstractLogicalOperator) currentOp.getInputs().get(0).getValue(); // Empty tuple source is a special case that can be partitioned in the same way as the data scan. if (child.getOperatorTag() != LogicalOperatorTag.EMPTYTUPLESOURCE) { break; } child.setExecutionMode(AbstractLogicalOperator.ExecutionMode.PARTITIONED);
<|startcomment|> MAJOR SonarQube violation: '!=' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  out.print(skip(step) + "connect " + FEED); out.print(generateFullName(connectFeedStmt.getDataverseName(), new Identifier(connectFeedStmt.getFeedName()))); out.print(" to " + datasetSymbol + generateFullName(connectFeedStmt.getDataverseName(), connectFeedStmt.getDatasetName())); if (connectFeedStmt.getPolicy() != null) { out.print(" using policy " + revertStringToQuoted(connectFeedStmt.getPolicy())); } <|startfocus|> if(connectFeedStmt.getAppliedFunctions()!=null){ <|endfocus|> out.print(" apply function " + connectFeedStmt.getAppliedFunctions()); } out.println(SEMICOLON); return null;
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|> <|startfocus|> public void dropFeedConnection(String dataverseName, String feedName, String datasetName){ FeedConnection feedConnection = new FeedConnection(dataverseName,feedName,datasetName, null, null, null); <|endfocus|> droppedCache.addFeedConnectionIfNotExists(feedConnection); logAndApply((new MetadataLogicalOperation(feedConnection, false)));
<|startcomment|> MAJOR SonarQube violation: Split this 126 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|> import java.io.IOException; import java.util.HashMap; import java.util.Map; /** * Created by Xikui on 6/28/16. */ public class XMLFileParserFactory implements IRecordDataParserFactory<char[]> { private ARecordType recordType; private String XML_Template; private Map<String, String> configuration; @Override public IRecordDataParser<char[]> createRecordParser(IHyracksTaskContext ctx) throws HyracksDataException { <|startfocus|> return new XMLFileParser(recordType, new ADMDataParser(recordType, ExternalDataUtils.getDataSourceType(configuration).equals(IExternalDataSourceFactory.DataSourceType.STREAM))); <|endfocus|> } @Override public void configure(Map<String, String> configuration) { this.configuration = configuration; } @Override public void setRecordType(ARecordType recordType) { this.recordType = recordType; } @Override public Class<?> getRecordClass() { return char[].class; } @Override public void setMetaType(ARecordType metaType) { } } 
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  private IOperatorDelegate delegate; public DelegateOperator(IOperatorDelegate delegate) { super(); if (delegate == null) { throw new IllegalArgumentException("delegate cannot be null!"); } this.delegate = delegate; setExecutionMode(delegate.getExecutionMode()); } @Override public void recomputeSchema() throws AlgebricksException { schema = new ArrayList<LogicalVariable>(inputs.get(0).getValue().getSchema()); delegate.setSchema(schema); } @Override <|startfocus|> public boolean acceptExpressionTransform(ILogicalExpressionReferenceTransform transform) throws AlgebricksException { <|endfocus|> return delegate.acceptExpressionTransform(transform); } @Override public <R, T> R accept(ILogicalOperatorVisitor<R, T> visitor, T arg) throws AlgebricksException { return visitor.visitDelegateOperator(this, arg); } @Override public boolean isMap() { return this.delegate.isMap(); } @Override public VariablePropagationPolicy getVariablePropagationPolicy() { return VariablePropagationPolicy.ALL; } @Override public IVariableTypeEnvironment computeOutputTypeEnvironment(ITypingContext ctx) throws AlgebricksException { return this.createPropagatingAllInputsTypeEnvironment(ctx); } @Override
<|startcomment|> MAJOR SonarQube violation: Remove this unused "ARGS" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|>  public static final DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss"); public static final String NC_JAVA_OPTS = "nc.java.opts"; public static final String CC_JAVA_OPTS = "cc.java.opts"; private static final String IP_LOCATION = "IP_LOCATION"; <|startfocus|> private static final String CLUSTER_ENV = "ENV"; private static final String SCRIPT = "SCRIPT"; private static final String ARGS = "ARGS"; private static final String EXECUTE_SCRIPT = "events/execute.sh"; <|endfocus|> public static Cluster getCluster(String clusterConfigurationPath) throws JAXBException { File file = new File(clusterConfigurationPath); JAXBContext ctx = JAXBContext.newInstance(Cluster.class); Unmarshaller unmarshaller = ctx.createUnmarshaller(); Cluster cluster = (Cluster) unmarshaller.unmarshal(file); return cluster; } public static long parseTimeInterval(ValueType v, String unit) throws IllegalArgumentException { int val = 0; switch (v.getType()) { case ABS: val = Integer.parseInt(v.getAbsoluteValue()); break; case RANDOM_MIN_MAX:
<|startcomment|> Why this [&& optFuncExpr.getFieldType(j) != null] needs to be augmented? <|endcomment|>  if (!accessMethod.exprIsOptimizable(index, optFuncExpr)) { exprsAndVarIter.remove(); continue; } boolean typeMatch = true; //Prune indexes based on field types List<IAType> matchedTypes = new ArrayList<>(); //retrieve types of expressions joined/selected with an indexed field for (int j = 0; j < optFuncExpr.getNumLogicalVars(); j++) { <|startfocus|> if (j != exprAndVarIdx.second && optFuncExpr.getFieldType(j) != null) { <|endfocus|> matchedTypes.add(optFuncExpr.getFieldType(j)); } } if (matchedTypes.size() < 2 && optFuncExpr.getNumLogicalVars() == 1) { matchedTypes .add((IAType) AqlExpressionTypeComputer.INSTANCE.getType(optFuncExpr.getConstantExpr(0), context.getMetadataProvider(), typeEnvironment)); } //infer type of logicalExpr based on index keyType matchedTypes.add((IAType) AqlExpressionTypeComputer.INSTANCE.getType( optFuncExpr.getLogicalExpr(exprAndVarIdx.second), null, new IVariableTypeEnvironment() { @Override
<|startcomment|> I think this kind of format changes that are not caused by your changes are not necessary. <|endcomment|>  LinkedList<LocalOrderProperty> oList = new LinkedList<>(); for (ILocalStructuralProperty prop : localProperties) { switch (prop.getPropertyType()) { case LOCAL_ORDER_PROPERTY: { oList.add((LocalOrderProperty) prop); break; } case LOCAL_GROUPING_PROPERTY: { LocalGroupingProperty g = (LocalGroupingProperty) prop; <|startfocus|> Collection<LogicalVariable> vars = (g.getPreferredOrderEnforcer() != null) ? g.getPreferredOrderEnforcer() : g.getColumnSet(); <|endfocus|> List<OrderColumn> orderColumns = new ArrayList<>(); for (LogicalVariable v : vars) { OrderColumn oc = new OrderColumn(v, OrderKind.ASC); orderColumns.add(oc); } LocalOrderProperty lop = new LocalOrderProperty(orderColumns); oList.add(lop); break; } default: { throw new IllegalStateException(); } } } if (!oList.isEmpty()) { topOp = enforceOrderProperties(oList, topOp, nestedPlan, context); } op.getInputs().set(i, topOp);
<|startcomment|> The reason of this change - not using FuzzyUtils.getSimThreshold()? <|endcomment|>  return false; } // // -- - FIRE - -- // AqlMetadataProvider metadataProvider = ((AqlMetadataProvider) context.getMetadataProvider()); FunctionIdentifier funcId = FuzzyUtils.getTokenizer(leftType.getTypeTag()); String tokenizer; if (funcId == null) { tokenizer = ""; } else { tokenizer = funcId.getName(); } String simFunction = FuzzyUtils.getSimFunction(simFuncExpr.getFunctionIdentifier()); float simThreshold; <|startfocus|> ConstantExpression constExpr = (ConstantExpression) inputExp2; <|endfocus|> AsterixConstantValue constVal = (AsterixConstantValue) constExpr.getValue(); if (constVal.getObject().getType().equals(BuiltinType.AFLOAT)) { simThreshold = ((AFloat) constVal.getObject()).getFloatValue(); } else { simThreshold = FuzzyUtils.getSimThreshold(metadataProvider); } // finalize AQL+ query String prepareJoin; switch (joinOp.getJoinKind()) { case INNER: { prepareJoin = "join" + AQLPLUS; break; } case LEFT_OUTER: { prepareJoin = "loj" + AQLPLUS; break; } default: {
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  .getSerializerDeserializer(BuiltinType.ADOUBLE); @SuppressWarnings("unchecked") private ISerializerDeserializer<AInt64> longSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.AINT64); @SuppressWarnings("unchecked") private ISerializerDeserializer<ANull> nullSerde = AqlSerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(BuiltinType.ANULL); public AbstractAvgAggregateFunction(IScalarEvaluatorFactory[] args, IHyracksTaskContext context) throws HyracksDataException { <|startfocus|> try { eval = args[0].createScalarEvaluator(context); } catch (org.apache.hyracks.api.exceptions.HyracksDataException e) { e.printStackTrace(); } <|endfocus|> recType = new ARecordType(null, new String[] { "sum", "count" }, new IAType[] { BuiltinType.ADOUBLE, BuiltinType.AINT64 }, false); recordEval = new ClosedRecordConstructorEval(recType, new IScalarEvaluator[] { evalSum, evalCount }); } @Override public void init() throws HyracksDataException { aggType = ATypeTag.SYSTEM_NULL; sum = 0.0; count = 0; } @Override public abstract void step(IFrameTupleReference tuple) throws HyracksDataException; @Override
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  if (leftTypeTag != rightTypeTag) { // If types are numeric compare their real values instead if (ATypeHierarchy.isSameTypeDomain(leftTypeTag, rightTypeTag, false) && ATypeHierarchy.getTypeDomain(leftTypeTag) == Domain.NUMERIC) { double leftVal = ATypeHierarchy.getDoubleValue(leftPointable.getByteArray(), leftPointable.getStartOffset()); double rightVal = ATypeHierarchy.getDoubleValue(rightPointable.getByteArray(), rightPointable.getStartOffset()); <|startfocus|> return (leftVal == rightVal); <|endfocus|> } else { return false; } } Pair<IVisitablePointable, Boolean> arg = new Pair<IVisitablePointable, Boolean>(rightPointable, Boolean.FALSE); // Assess the nested equality leftPointable.accept(equalityVisitor, arg); return arg.second; } } 
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  operandsFloating[i] = operandsInteger[i]; break; } case INT64: { currentType = typeInt64; operandsInteger[i] = AInt64SerializerDeserializer.getLong(bytes, offset + 1); operandsFloating[i] = operandsInteger[i]; break; } case FLOAT: { currentType = typeFloat; operandsFloating[i] = AFloatSerializerDeserializer.getFloat(bytes, offset + 1); break; <|startfocus|> } case DOUBLE: { <|endfocus|> currentType = typeDouble; operandsFloating[i] = ADoubleSerializerDeserializer.getDouble(bytes, offset + 1); break; } case DATE: case TIME: case DATETIME: case DURATION: case YEARMONTHDURATION: case DAYTIMEDURATION: evaluateTemporalArthmeticOperation(typeTag); result.set(resultStorage); return; default: { throw new RuntimeTypeException(getIdentifier(), i, bytes[offset], ATypeTag.SERIALIZED_INT8_TYPE_TAG, ATypeTag.SERIALIZED_INT16_TYPE_TAG, ATypeTag.SERIALIZED_INT32_TYPE_TAG, ATypeTag.SERIALIZED_INT64_TYPE_TAG,
<|startcomment|> MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  aPoint[1].setValue(x + xInc, y + yInc); aRectangle.setValue(aPoint[0], aPoint[1]); rectangleSerde.serialize(aRectangle, out); } else { if(tag0 != ATypeTag.SERIALIZED_POINT_TYPE_TAG) { throw new RuntimeTypeException(getIdentifier(), 0, tag0, ATypeTag.SERIALIZED_POINT_TYPE_TAG); } if(tag1 != ATypeTag.SERIALIZED_POINT_TYPE_TAG) { <|startfocus|> throw new RuntimeTypeException(getIdentifier(), 1, tag1, <|endfocus|> ATypeTag.SERIALIZED_POINT_TYPE_TAG); } if(tag2 != ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG) { throw new RuntimeTypeException(getIdentifier(), 2, tag2, ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG); } if(tag3 != ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG) { throw new RuntimeTypeException(getIdentifier(), 3, tag3, ATypeTag.SERIALIZED_DOUBLE_TYPE_TAG); } } result.set(resultStorage); } catch (IOException e1) { throw new HyracksDataException(e1); } } }; } };
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  } @Override public abstract void step(IFrameTupleReference tuple) throws HyracksDataException; @Override public abstract void finish(IPointable result) throws HyracksDataException; @Override public abstract void finishPartial(IPointable result) throws HyracksDataException; protected abstract void processNull(); protected void processDataValues(IFrameTupleReference tuple) throws HyracksDataException { if (skipStep()) { return; } <|startfocus|> try { eval.evaluate(tuple, inputVal); } catch (org.apache.hyracks.api.exceptions.HyracksDataException e) { e.printStackTrace(); } <|endfocus|> byte[] data = inputVal.getByteArray(); int offset = inputVal.getStartOffset(); ATypeTag typeTag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(data[offset]); if (typeTag == ATypeTag.MISSING || typeTag == ATypeTag.NULL) { processNull(); return; } else if (aggType == ATypeTag.SYSTEM_NULL) { aggType = typeTag; } else if (typeTag != ATypeTag.SYSTEM_NULL && !ATypeHierarchy.isCompatible(typeTag, aggType)) { throw new RuntimeTypeException(AsterixBuiltinFunctions.AVG, data[offset], aggType.serialize());
<|startcomment|> MAJOR SonarQube violation: Method has 11 parameters, which is greater than 7 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00107 <|endcomment|>  } return false; } private void addPrimaryKey(List<LogicalVariable> scanVariables, DataSource dataSource, IOptimizationContext context) { List<LogicalVariable> primaryKey = dataSource.getPrimaryKeyVariables(scanVariables); List<LogicalVariable> tail = new ArrayList<LogicalVariable>(); tail.addAll(scanVariables); FunctionalDependency pk = new FunctionalDependency(primaryKey, tail); context.addPrimaryKey(pk); } private FeedDataSource createFeedDataSource(DataSourceId aqlId, String targetDataset, String sourceFeedName, <|startfocus|> String subscriptionLocation, AqlMetadataProvider metadataProvider, FeedPolicyEntity feedPolicy, <|endfocus|> String outputType, String locations, LogicalVariable recordVar, IOptimizationContext context, List<LogicalVariable> pkVars) throws AlgebricksException { if (!aqlId.getDataverseName().equals(metadataProvider.getDefaultDataverse() == null ? null : metadataProvider.getDefaultDataverse().getDataverseName())) { return null; } Dataset dataset = metadataProvider.findDataset(aqlId.getDataverseName(), targetDataset); ARecordType feedOutputType = (ARecordType) metadataProvider.findType(aqlId.getDataverseName(), outputType); Feed sourceFeed = metadataProvider.findFeed(aqlId.getDataverseName(), sourceFeedName);
<|startcomment|> MAJOR SonarQube violation: Add a private constructor to hide the implicit public one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1118 <|endcomment|>  * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.asterix.runtime.exceptions; import org.apache.asterix.om.types.EnumDeserializer; <|startfocus|> public class ExceptionUtil { <|endfocus|> static String toExpectedTypeString(byte... expectedTypeTags) { StringBuilder expectedTypes = new StringBuilder(); int numCandidateTypes = expectedTypeTags.length; for (int index = 0; index < numCandidateTypes; ++index) { if (index > 0) { if (index == numCandidateTypes - 1) { expectedTypes.append(" or "); } else { expectedTypes.append(", "); } } expectedTypes.append(EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(expectedTypeTags[index])); } return expectedTypes.toString(); } 
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  ccs.getWorkQueue().schedule(new UnregisterNodeWork(ccs, unf.getNodeId())); return; } case NODE_HEARTBEAT: { CCNCFunctions.NodeHeartbeatFunction nhf = (CCNCFunctions.NodeHeartbeatFunction) fn; ccs.getWorkQueue().schedule(new NodeHeartbeatWork(ccs, nhf.getNodeId(), nhf.getHeartbeatData())); return; } case NOTIFY_JOBLET_CLEANUP: { CCNCFunctions.NotifyJobletCleanupFunction njcf = (CCNCFunctions.NotifyJobletCleanupFunction) fn; ccs.getWorkQueue().schedule(new JobletCleanupNotificationWork(ccs, njcf.getJobId(), njcf.getNodeId())); <|startfocus|> return; } case NOTIFY_DEPLOY_BINARY: { <|endfocus|> CCNCFunctions.NotifyDeployBinaryFunction ndbf = (CCNCFunctions.NotifyDeployBinaryFunction) fn; ccs.getWorkQueue().schedule(new NotifyDeployBinaryWork(ccs, ndbf.getDeploymentId(), ndbf.getNodeId(), ndbf.getDeploymentStatus())); return; } case REPORT_PROFILE: { CCNCFunctions.ReportProfileFunction rpf = (CCNCFunctions.ReportProfileFunction) fn; ccs.getWorkQueue().schedule(new ReportProfilesWork(ccs, rpf.getProfiles())); return; } case NOTIFY_TASK_COMPLETE: {
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  public void deliverIncomingMessage(IIPCHandle handle, long mid, long rmid, Object payload, Exception exception) { HyracksClientInterfaceFunctions.Function fn = (HyracksClientInterfaceFunctions.Function) payload; switch (fn.getFunctionId()) { case GET_CLUSTER_CONTROLLER_INFO: { try { handle.send(mid, ccs.getClusterControllerInfo(), null); } catch (IPCException e) { e.printStackTrace(); } <|startfocus|> return; } case CREATE_JOB: <|endfocus|> break; case GET_JOB_STATUS: { HyracksClientInterfaceFunctions.GetJobStatusFunction gjsf = (HyracksClientInterfaceFunctions.GetJobStatusFunction) fn; ccs.getWorkQueue().schedule(new GetJobStatusWork(ccs, gjsf.getJobId(), new IPCResponder<JobStatus>(handle, mid))); return; } case GET_JOB_INFO: { HyracksClientInterfaceFunctions.GetJobInfoFunction gjsf = (HyracksClientInterfaceFunctions.GetJobInfoFunction) fn; ccs.getWorkQueue().schedule(new GetJobInfoWork(ccs, gjsf.getJobId(), new IPCResponder<JobInfo>(handle, mid))); return; } case START_JOB: { HyracksClientInterfaceFunctions.StartJobFunction sjf =
<|startcomment|> constant for this? <|endcomment|>  return true; } ATypeTag leftTypeTag = PointableHelper.getTypeTag(leftPointable); ATypeTag rightTypeTag = PointableHelper.getTypeTag(rightPointable); if (leftTypeTag != rightTypeTag) { // If types are numeric compare their real values instead if (ATypeHierarchy.isSameTypeDomain(leftTypeTag, rightTypeTag, false) && ATypeHierarchy.getTypeDomain(leftTypeTag) == Domain.NUMERIC) { double leftVal = ATypeHierarchy.getDoubleValue("deep-equal", 0, leftPointable.getByteArray(), leftPointable.getStartOffset()); <|startfocus|> double rightVal = ATypeHierarchy.getDoubleValue("deep-equal", 1, rightPointable.getByteArray(), <|endfocus|> rightPointable.getStartOffset()); return Math.abs(leftVal - rightVal) < 1E-10; } else { return false; } } Pair<IVisitablePointable, Boolean> arg = new Pair<IVisitablePointable, Boolean>(rightPointable, Boolean.FALSE); // Assess the nested equality leftPointable.accept(equalityVisitor, arg); return arg.second; } } 
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|> <|startfocus|> public int getPageSizeWithHeader(){ <|endfocus|> return vbc.getPageSizeWithHeader();
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "requiredSize". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|> <|startfocus|> public int selectVictimPartition(int failedToInsertPartition, int requiredSize) { <|endfocus|> // To avoid flush a half-full frame, it's better to spill itself. if (bufferManager.getNumTuples(failedToInsertPartition) > 0) { // Temp: to be deleted // System.out.println( // "PreferToSpillFullyOccupiedFramePolicy::selectVictimPartition failedToInsertPartition " // + failedToInsertPartition); return failedToInsertPartition; } // If we couldn't find an already spilled partition, or it is too small to flush that one, // try to flush an in memory partition. int partitionToSpill = findSpilledPartitionWithMaxMemoryUsage(); // Temp: to be deleted // System.out.println("partitionToSpill " + partitionToSpill); int maxToSpillPartSize = 0; if (partitionToSpill < 0 || (maxToSpillPartSize = bufferManager.getPhysicalSize(partitionToSpill)) <= minFrameSize) { int partitionInMem = findInMemPartitionWithMaxMemoryUsage(); if (partitionInMem >= 0 && bufferManager.getPhysicalSize(partitionInMem) > maxToSpillPartSize) { partitionToSpill = partitionInMem; } }
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  return count; } @Override public int getNumPartitions() { return bufferManager.getNumPartitions(); } @Override public int findVictimPartition(IFrameTupleAccessor accessor, int tIndex) throws HyracksDataException { int entryInHashTable = tpc.partition(accessor, tIndex, tableSize); int partition = getPartition(entryInHashTable); // Temp: to be deleted // System.out.println("HashSpillableTableFactory::findVictimPartition h " + entryInHashTable // + " partition " + partition); <|startfocus|> int tupleSize = accessor.getTupleLength(tIndex); return spillPolicy.selectVictimPartition(partition, tupleSize); <|endfocus|> } }; } /** * Calculate the number of partitions for Data table. The formula is from Shapiro's paper - * http://cs.stanford.edu/people/chrismre/cs345/rl/shapiro.pdf. Check the page 249 for more details. * If the required number of frames is greater than the number of available frames, we make sure that * at least two partitions will be created. Also, if the number of partitions is greater than the memory budget,
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  join(accessorProbe, i, writer); } } public void closeJoin(IFrameWriter writer) throws HyracksDataException { appender.write(writer, true); int nFrames = buffers.size(); // Frames assigned to the data table will be released here. for (int i = 0; i < nFrames; i++) { bufferManager.releaseFrame(buffers.get(i)); } buffers.clear(); // Frames assigned to the hash table will be released here. table.close(); <|startfocus|> // Temp: // ctx.deallocateFrames(nFrames); <|endfocus|> LOGGER.fine("InMemoryHashJoin has finished using " + nFrames + " frames for Thread ID " + Thread.currentThread().getId() + "."); } private boolean evaluatePredicate(int tIx1, int tIx2) { if (reverseOutputOrder) { //Role Reversal Optimization is triggered return (predEvaluator == null) || predEvaluator.evaluate(accessorBuild, tIx2, accessorProbe, tIx1); } else { return (predEvaluator == null) || predEvaluator.evaluate(accessorProbe, tIx1, accessorBuild, tIx2); } } 
<|startcomment|> remove the feedJob variable? move the declaration of ingestionLocations down to the assignment statement? <|endcomment|>  } // jobEventListenerFactory jobSpec.setJobletEventListenerFactory(new MultiTransactionJobletEventListenerFactory(jobIds, true)); // useConnectorSchedulingPolicy jobSpec.setUseConnectorPolicyForScheduling(jobsList.get(0).isUseConnectorPolicyForScheduling()); // connectorAssignmentPolicy jobSpec.setConnectorPolicyAssignmentPolicy(jobsList.get(0).getConnectorPolicyAssignmentPolicy()); return jobSpec; } <|startfocus|> public static JobSpecification buildStartFeedJob(AqlMetadataProvider metadataProvider, Feed feed, List<FeedConnection> feedConnections) throws Exception { JobSpecification feedJob; String[] ingestionLocations; <|endfocus|> FeedPolicyAccessor fpa = new FeedPolicyAccessor(new HashMap<>()); // TODO: Change the default Datasource to use all possible partitions Pair<JobSpecification, IAdapterFactory> intakeInfo = buildFeedIntakeJobSpec(feed, metadataProvider, fpa); //TODO: Add feed policy accessor List<JobSpecification> jobsList = new ArrayList<>(); // Construct the ingestion Job JobSpecification intakeJob = intakeInfo.getLeft(); IAdapterFactory ingestionAdaptorFactory = intakeInfo.getRight(); ingestionLocations = ingestionAdaptorFactory.getPartitionConstraint().getLocations(); // Add connection job for (FeedConnection feedConnection : feedConnections) {
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  } dslc.open(true); dslc.touch(); if (!iInfo.isOpen()) { ILSMOperationTracker opTracker = iInfo.getIndex().getOperationTracker(); synchronized (opTracker) { iInfo.getIndex().activate(); } iInfo.setOpen(true); } iInfo.touch(); } private boolean evictCandidateDataset() throws HyracksDataException { /** * We will take a dataset that has no active transactions, it is open (a dataset consuming memory), * that is not being used (refcount == 0) and has been least recently used, excluding metadata datasets. * The sort order defined for DatasetInfo maintains this. See DatasetInfo.compareTo(). */ <|startfocus|> List<DatasetLifecycle> datasetLifecyclesList = new ArrayList<>(datasetLifecycles.values()); Collections.sort(datasetLifecyclesList); for (DatasetLifecycle dslc : datasetLifecyclesList) { PrimaryIndexOperationTracker opTracker = dslc.getOpTracker(); <|endfocus|> if (opTracker != null && opTracker.getNumActiveOperations() == 0 && dslc.getDatasetInfo().getReferenceCount() == 0 && dslc.getDatasetInfo().isOpen()
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  tempKeyTxnId.setTxnId(jobId, logRecord.getDatasetId(), logRecord.getPKHashValue(), logRecord.getPKValue(), logRecord.getPKValueSize()); if (jobEntityWinners.containsEntityCommitForTxnId(LSN, tempKeyTxnId)) { foundWinner = true; } } if (foundWinner) { resourceId = logRecord.getResourceId(); System.err.println("resource id found = " + resourceId); localResource = resourcesMap.get(resourceId); <|startfocus|> System.err.println("resource found = " + localResource); <|endfocus|> /******************************************************************* * [Notice] * -> Issue * Delete index may cause a problem during redo. * The index operation to be redone couldn't be redone because the corresponding index * may not exist in NC due to the possible index drop DDL operation. * -> Approach * Avoid the problem during redo. * More specifically, the problem will be detected when the localResource of * the corresponding index is retrieved, which will end up with 'null'.
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  } } private static final long serialVersionUID = 1L; protected FileSplit[] splits; public FileSplit[] getSplits() { return splits; } public void setSplits(FileSplit[] splits) { this.splits = splits; } public AbstractFileWriteOperatorDescriptor(IOperatorDescriptorRegistry spec, FileSplit[] splits) { super(spec, 1, 0); this.splits = splits; } protected abstract IRecordWriter createRecordWriter(IOManager ioManager, FileSplit fileSplit, int index) <|startfocus|> throws Exception; <|endfocus|> @Override public IOperatorNodePushable createPushRuntime(IHyracksTaskContext ctx, IRecordDescriptorProvider recordDescProvider, int partition, int nPartitions) { return new DeserializedOperatorNodePushable(ctx, new FileWriteOperator((IOManager) ctx.getIOManager(), partition), recordDescProvider.getInputRecordDescriptor(getActivityId(), 0)); } } 
<|startcomment|> Indentation? <|endcomment|>  private int index; private IRecordWriter writer; FileWriteOperator(IOManager ioManager, int index) { this.ioManager = ioManager; this.index = index; } @Override public void setDataWriter(int index, IOpenableDataWriter<Object[]> writer) { throw new IllegalArgumentException(); } @Override public void open() throws HyracksDataException { FileSplit split = splits[index]; writer = createRecordWriter(ioManager, split, index); } @Override public void close() throws HyracksDataException { <|startfocus|> writer.close(); <|endfocus|> } @Override public void fail() throws HyracksDataException { } @Override public void writeData(Object[] data) throws HyracksDataException { writer.write(data); } @Override public void flush() throws HyracksDataException { // This is a kind of a sink operator and hence, flush() is a no op } } private static final long serialVersionUID = 1L; protected FileSplit[] splits; public FileSplit[] getSplits() { return splits; } 
<|startcomment|> single line <|endcomment|>  IFileSplitProvider custSplitsProvider = new ConstantFileSplitProvider(custSplits); RecordDescriptor custDesc = new RecordDescriptor(new ISerializerDeserializer[] { new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer() }); <|startfocus|> FileSplit[] ordersSplits = new FileSplit[] { new FileSplit(NC2_ID, "data/tpch0.001/orders.tbl") }; <|endfocus|> IFileSplitProvider ordersSplitsProvider = new ConstantFileSplitProvider(ordersSplits); RecordDescriptor ordersDesc = new RecordDescriptor(new ISerializerDeserializer[] { new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer() }); RecordDescriptor custOrderJoinDesc = new RecordDescriptor(new ISerializerDeserializer[] { new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(),
<|startcomment|> BLOCKER SonarQube violation: NullPointerException might be thrown as 'bloomFilterFile' is nullable here Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2259 <|endcomment|>  } else if (fileName.endsWith(BLOOM_FILTER_STRING)) { bloomFilterFile = new File(dir.getPath() + File.separator + fileName); } else { throw new HyracksDataException("unrecognized file found = " + fileName); } } <|startfocus|> FileReference rTreeFileRef = ioManager.absToFileRef(rTreeFile.getAbsolutePath()); FileReference bTreeFileRef = ioManager.absToFileRef(bTreeFile.getAbsolutePath()); FileReference bloomFilterFileRef = ioManager.absToFileRef(bloomFilterFile.getAbsolutePath()); <|endfocus|> return new LSMComponentFileReferences(rTreeFileRef, bTreeFileRef, bloomFilterFileRef); } } 
<|startcomment|> s/ManagedFileSplit/FileSplit/ <|endcomment|>  spec.addRoot(algebricksOp); AlgebricksHyracksIntegrationUtil.runJob(spec); StringBuilder buf = new StringBuilder(); readFileToString(outFile, buf); Assert.assertEquals("403", buf.toString()); outFile.delete(); } @Test public void scanMicroSortGbySelectWrite() throws Exception { JobSpecification spec = new JobSpecification(FRAME_SIZE); // the scanner ManagedFileSplit[] fileSplits = new ManagedFileSplit[1]; fileSplits[0] = new ManagedFileSplit(AlgebricksHyracksIntegrationUtil.NC1_ID, <|startfocus|> "data/tpch0.001/customer.tbl"); <|endfocus|> IFileSplitProvider splitProvider = new ConstantFileSplitProvider(fileSplits); RecordDescriptor scannerDesc = new RecordDescriptor(new ISerializerDeserializer[] { IntegerSerializerDeserializer.INSTANCE, new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), IntegerSerializerDeserializer.INSTANCE, new UTF8StringSerializerDeserializer(), FloatSerializerDeserializer.INSTANCE, new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer() }); IValueParserFactory[] valueParsers = new IValueParserFactory[] { IntegerParserFactory.INSTANCE, UTF8StringParserFactory.INSTANCE, UTF8StringParserFactory.INSTANCE, IntegerParserFactory.INSTANCE,
<|startcomment|> s/ManagedFileSplit/FileSplit/ <|endcomment|>  IConnectorDescriptor conn4 = new OneToOneConnectorDescriptor(spec); spec.connect(conn4, sorter2, 0, group2, 0); IConnectorDescriptor conn5 = new MToNBroadcastConnectorDescriptor(spec); spec.connect(conn5, group2, 0, printer, 0); spec.addRoot(printer); runTest(spec); } @Test public void countOfCountsMultiNC() throws Exception { JobSpecification spec = new JobSpecification(); <|startfocus|> ManagedFileSplit[] splits = new ManagedFileSplit[] { new ManagedFileSplit(NC2_ID, "data/words.txt") }; <|endfocus|> IFileSplitProvider splitProvider = new ConstantFileSplitProvider(splits); RecordDescriptor desc = new RecordDescriptor( new ISerializerDeserializer[] { new UTF8StringSerializerDeserializer() }); FileScanOperatorDescriptor csvScanner = new FileScanOperatorDescriptor( spec, splitProvider, new DelimitedDataTupleParserFactory(new IValueParserFactory[] { UTF8StringParserFactory.INSTANCE }, ','), desc); PartitionConstraintHelper.addAbsoluteLocationConstraint(spec, csvScanner, NC2_ID); InMemorySortOperatorDescriptor sorter = new InMemorySortOperatorDescriptor(spec, new int[] { 0 },
<|startcomment|> s/ManagedFileSplit/FileSplit/ <|endcomment|>  IConnectorDescriptor custJoinConn = new OneToOneConnectorDescriptor(spec); spec.connect(custJoinConn, custScanner, 0, join, 1); IConnectorDescriptor joinPrinterConn = new OneToOneConnectorDescriptor(spec); spec.connect(joinPrinterConn, join, 0, printer, 0); spec.addRoot(printer); runTest(spec); } @Test public void customerOrderCIDInMemoryHashLeftOuterJoin() throws Exception { JobSpecification spec = new JobSpecification(); <|startfocus|> ManagedFileSplit[] custSplits = new ManagedFileSplit[] { new ManagedFileSplit(NC1_ID, "data" + File.separator <|endfocus|> + "tpch0.001" + File.separator + "customer.tbl") }; IFileSplitProvider custSplitsProvider = new ConstantFileSplitProvider(custSplits); RecordDescriptor custDesc = new RecordDescriptor(new ISerializerDeserializer[] { new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer() }); 
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  public ISerializerDeserializer getSerializerDeserializer(Object typeInfo) { IAType aqlType = (IAType) typeInfo; if (aqlType == null) { return null; } switch (aqlType.getTypeTag()) { case ANY: case UNION: { // we could do smth better for nullable fields return AObjectSerializerDeserializer.INSTANCE; <|startfocus|> } default: { <|endfocus|> return addTag(getNonTaggedSerializerDeserializer(aqlType), aqlType.getTypeTag()); } }
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  } case INT64: { return AInt64SerializerDeserializer.INSTANCE; } case LINE: { return ALineSerializerDeserializer.INSTANCE; } case MISSING: return AMissingSerializerDeserializer.INSTANCE; case NULL: { return ANullSerializerDeserializer.INSTANCE; } case STRING: { return AStringSerializerDeserializer.INSTANCE; } case BINARY: { return ABinarySerializerDeserializer.INSTANCE; } case TIME: { return ATimeSerializerDeserializer.INSTANCE; } case DURATION: { return ADurationSerializerDeserializer.INSTANCE; } case YEARMONTHDURATION: { return AYearMonthDurationSerializerDeserializer.INSTANCE; <|startfocus|> } case DAYTIMEDURATION: { <|endfocus|> return ADayTimeDurationSerializerDeserializer.INSTANCE; } case INTERVAL: { return AIntervalSerializerDeserializer.INSTANCE; } case ORDEREDLIST: { return new AOrderedListSerializerDeserializer((AOrderedListType) aqlType); } case POINT: { return APointSerializerDeserializer.INSTANCE; } case POINT3D: { return APoint3DSerializerDeserializer.INSTANCE; } case RECTANGLE: { return ARectangleSerializerDeserializer.INSTANCE; } case POLYGON: { return APolygonSerializerDeserializer.INSTANCE; } case RECORD: { return new ARecordSerializerDeserializer((ARecordType) aqlType); } case UNORDEREDLIST: {
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  return anyBinaryComparatorFactory(ascending); } case NULL: case MISSING: return new IBinaryComparatorFactory() { private static final long serialVersionUID = 1L; @Override public IBinaryComparator createBinaryComparator() { return new IBinaryComparator() { @Override public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) { return 0; } }; } }; case BOOLEAN: { return addOffset(BooleanBinaryComparatorFactory.INSTANCE, ascending); <|startfocus|> } case INT8: { <|endfocus|> return addOffset(BYTE_POINTABLE_INSTANCE, ascending); } case INT16: { return addOffset(SHORT_POINTABLE_INSTANCE, ascending); } case DATE: case TIME: case YEARMONTHDURATION: case INT32: { return addOffset(INTEGER_POINTABLE_INSTANCE, ascending); } case DATETIME: case DAYTIMEDURATION: case INT64: { return addOffset(LONG_POINTABLE_INSTANCE, ascending); } case FLOAT: { return addOffset(FLOAT_POINTABLE_INSTANCE, ascending); } case DOUBLE: { return addOffset(DOUBLE_POINTABLE_INSTANCE, ascending); }
<|startcomment|> MAJOR SonarQube violation: Split this 123 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|> import org.apache.hyracks.storage.am.lsm.invertedindex.tokenizers.UTF8WordTokenFactory; public class BinaryTokenizerFactoryProvider implements IBinaryTokenizerFactoryProvider { public static final BinaryTokenizerFactoryProvider INSTANCE = new BinaryTokenizerFactoryProvider(); private static final IBinaryTokenizerFactory aqlStringTokenizer = new DelimitedUTF8StringBinaryTokenizerFactory( true, true, new UTF8WordTokenFactory(ATypeTag.SERIALIZED_STRING_TYPE_TAG, ATypeTag.SERIALIZED_INT32_TYPE_TAG)); <|startfocus|> private static final IBinaryTokenizerFactory aqlHashingStringTokenizer = new DelimitedUTF8StringBinaryTokenizerFactory( true, true, <|endfocus|> new HashedUTF8WordTokenFactory(ATypeTag.SERIALIZED_INT32_TYPE_TAG, ATypeTag.SERIALIZED_INT32_TYPE_TAG)); private static final IBinaryTokenizerFactory orderedListTokenizer = new AOrderedListBinaryTokenizerFactory( new AListElementTokenFactory()); private static final IBinaryTokenizerFactory unorderedListTokenizer = new AUnorderedListBinaryTokenizerFactory( new AListElementTokenFactory()); @Override public IBinaryTokenizerFactory getWordTokenizerFactory(ATypeTag typeTag, boolean hashedTokens) { switch (typeTag) { case STRING: { if (hashedTokens) { return aqlHashingStringTokenizer; } else { return aqlStringTokenizer; } } case ORDEREDLIST: {
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  return new AWrappedAscNormalizedKeyComputerFactory(new DoubleNormalizedKeyComputerFactory()); } case STRING: { return new AWrappedAscNormalizedKeyComputerFactory(new UTF8StringNormalizedKeyComputerFactory()); } case BINARY: { return new AWrappedAscNormalizedKeyComputerFactory(new ByteArrayNormalizedKeyComputerFactory()); } default: { return null; } } } else { switch (aqlType.getTypeTag()) { case DATE: case TIME: case YEARMONTHDURATION: case INT32: { return new AWrappedDescNormalizedKeyComputerFactory(new IntegerNormalizedKeyComputerFactory()); <|startfocus|> } <|endfocus|> case DATETIME: case DAYTIMEDURATION: case INT64: { return new AWrappedDescNormalizedKeyComputerFactory(new Integer64NormalizedKeyComputerFactory()); } case FLOAT: { return new AWrappedDescNormalizedKeyComputerFactory(new FloatNormalizedKeyComputerFactory()); } case DOUBLE: { return new AWrappedDescNormalizedKeyComputerFactory(new DoubleNormalizedKeyComputerFactory()); } case STRING: { return new AWrappedDescNormalizedKeyComputerFactory(new UTF8StringNormalizedKeyComputerFactory()); } case BINARY: { return new AWrappedDescNormalizedKeyComputerFactory(new ByteArrayNormalizedKeyComputerFactory()); } default: {
<|startcomment|> MAJOR SonarQube violation: The type of the "jobFlags" object should be an interface such as "Set" rather than the implementation "EnumSet". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 <|endcomment|> <|startfocus|> public StartJobFunction(byte[] acggfBytes, EnumSet<JobFlag> jobFlags, JobId jobId) { <|endfocus|> this.acggfBytes = acggfBytes; this.jobFlags = jobFlags; this.deploymentId = null; this.jobId = jobId;
<|startcomment|> MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "subTreeOpRef". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 <|endcomment|>  do { // Skip select operator. if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) { subTreeOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue(); } // Check primary-index pattern. if (subTreeOp.getOperatorTag() != LogicalOperatorTag.ASSIGN && subTreeOp.getOperatorTag() != LogicalOperatorTag.UNNEST) { // Pattern may still match if we are looking for primary index matches as well. return initializeDataSource(subTreeOpRef); } // Match (assign | unnest)+. <|startfocus|> while (subTreeOp.getOperatorTag() == LogicalOperatorTag.ASSIGN || subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST) { <|endfocus|> if (!OperatorPropertiesUtil.isMovable(subTreeOp)) { return false; } else { assignsAndUnnestsRefs.add(subTreeOpRef); assignsAndUnnests.add(subTreeOp); } subTreeOpRef = subTreeOp.getInputs().get(0); subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue(); } } while (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT);
<|startcomment|> MAJOR SonarQube violation: Remove this unused "ERR_MSG" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|>  */ package org.apache.asterix.om.typecomputer.impl; import org.apache.asterix.om.exceptions.UnsupportedTypeException; import org.apache.asterix.om.typecomputer.base.AbstractResultTypeComputer; import org.apache.asterix.om.types.ATypeTag; import org.apache.asterix.om.types.AUnionType; import org.apache.asterix.om.types.IAType; import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException; import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression; public class MinMaxAggTypeComputer extends AbstractResultTypeComputer { <|startfocus|> private static final String ERR_MSG = "Aggregator is not implemented for "; <|endfocus|> public static final MinMaxAggTypeComputer INSTANCE = new MinMaxAggTypeComputer(); private MinMaxAggTypeComputer() { } @Override protected void checkArgType(String funcName, int argIndex, IAType type) throws AlgebricksException { ATypeTag tag = type.getTypeTag(); switch (tag) { case DOUBLE: case FLOAT: case INT64: case INT32: case INT16: case INT8: case STRING: case DATE: case TIME: case DATETIME: case YEARMONTHDURATION: case DAYTIMEDURATION: case ANY: return; default:
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  fta.reset(frame); int tupleIndex = (int) (th.getParams()[0]); try { logExceptionCausingTuple(tupleIndex, th); } catch (Exception ex) { ex.addSuppressed(th); if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.warning("Unable to log exception causing tuple due to..." + ex.getMessage()); } } // TODO: Improve removeBadTuple. Right now, it creates lots of objects return FeedFrameUtil.removeBadTuple(ctx, tupleIndex, fta); } else { return null; } } catch (Exception exception) { <|startfocus|> exception.printStackTrace(); <|endfocus|> if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.warning("Unable to handle exception " + exception.getMessage()); } return null; }
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  public void run() { Map<JobId, ActivityClusterGraph> acgMap = ncs.getActivityClusterGraphMap(); ActivityClusterGraph acg = acgMap.get(jobId); if (acg == null) { throw new RuntimeException("Trying to destroy a job that was never distributed!"); } <|startfocus|> acgMap.remove(jobId); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Split this 142 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  ActiveRuntimeId runtimeId; FeedRuntimeType subscribableRuntimeType = ((EndFeedMessage) message).getSourceRuntimeType(); if (endFeedMessage.isCompleteDisconnection()) { // subscribableRuntimeType represents the location at which the feed connection receives // data FeedRuntimeType runtimeType; switch (subscribableRuntimeType) { case INTAKE: runtimeType = FeedRuntimeType.COLLECT; break; case COMPUTE: runtimeType = FeedRuntimeType.COMPUTE_COLLECT; break; default: <|startfocus|> throw new RuntimeDataException(ErrorCode.ERROR_OPERATORS_FEED_MESSAGE_OPERATOR_NODE_PUSHABLE_INVALID_SUBSCRIBABLE_RUNTIME, <|endfocus|> subscribableRuntimeType); } runtimeId = new ActiveRuntimeId(endFeedMessage.getSourceFeedId(), runtimeType.toString(), partition); CollectionRuntime feedRuntime = (CollectionRuntime) feedManager.getRuntime(runtimeId); if (feedRuntime != null) { feedRuntime.getSourceRuntime().unsubscribe(feedRuntime); } if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Complete Unsubscription of " + endFeedMessage.getFeedConnectionId()); } } else { // subscribaleRuntimeType represents the location for data hand-off in presence of // subscribers switch (subscribableRuntimeType) {
<|startcomment|> MAJOR SonarQube violation: Split this 122 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  private long getDeadReplicasMinFirstLSN(Set<String> deadReplicaIds) { final IReplicaResourcesManager remoteResourcesManager = txnSubsystem.getAsterixAppRuntimeContextProvider() .getAppContext().getReplicaResourcesManager(); final IAsterixPropertiesProvider propertiesProvider = (IAsterixPropertiesProvider) txnSubsystem .getAsterixAppRuntimeContextProvider().getAppContext(); final AsterixMetadataProperties metadataProperties = propertiesProvider.getMetadataProperties(); <|startfocus|> final PersistentLocalResourceRepository localResourceRepository = (PersistentLocalResourceRepository) txnSubsystem .getAsterixAppRuntimeContextProvider().getLocalResourceRepository(); <|endfocus|> // Get partitions of the dead replicas that are not active on this node final Set<Integer> deadReplicasPartitions = new HashSet<>(); for (String deadReplicaId : deadReplicaIds) { final ClusterPartition[] nodePartitons = metadataProperties.getNodePartitions().get(deadReplicaId); for (ClusterPartition partition : nodePartitons) { if (!localResourceRepository.getActivePartitions().contains(partition.getPartitionId())) { deadReplicasPartitions.add(partition.getPartitionId()); } } } return remoteResourcesManager.getPartitionsMinLSN(deadReplicasPartitions);
<|startcomment|> MAJOR SonarQube violation: Split this 142 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  return firstLSNs[readIndex]; } public synchronized boolean hasPendingFlush() { for (int i = 0; i < flushRequested.length; i++) { if (flushRequested[i]) { return true; } } return false; } /** * @param component * @param componentFilePath <|startfocus|> * @return The LSN byte offset in the LSM disk component if the index is valid, otherwise {@link IMetadataPageManager#INVALID_LSN_OFFSET}. <|endfocus|> * @throws HyracksDataException */ public abstract long getComponentFileLSNOffset(ILSMComponent component, String componentFilePath) throws HyracksDataException; } 
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  } throw e; } } freePageManager.open(fileId); setRootAndMetadataPages(appendOnly); if (!appendOnly) { initEmptyTree(); freePageManager.close(); } else { this.appendOnly = true; initCachedMetadataPage(); } bufferCache.closeFile(fileId); } private void initEmptyTree() throws HyracksDataException { ITreeIndexFrame frame = leafFrameFactory.createFrame(); ITreeIndexMetaDataFrame metaFrame = freePageManager.getMetaDataFrameFactory().createFrame(); freePageManager.init(metaFrame, rootPage); <|startfocus|> ICachedPage rootNode = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, rootPage), true); <|endfocus|> rootNode.acquireWriteLatch(); try { frame.setPage(rootNode); frame.initBuffer((byte) 0); } finally { rootNode.releaseWriteLatch(true); bufferCache.unpin(rootNode); } } private void setRootAndMetadataPages(boolean appendOnly) throws HyracksDataException { if (!appendOnly) { // regular or empty tree rootPage = 1; bulkloadLeafStart = 2; } else {
<|startcomment|> CRITICAL SonarQube violation: Either re-interrupt this method or rethrow the "InterruptedException". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2142 <|endcomment|>  public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { evalValue.evaluate(tuple, result); evalTime.evaluate(tuple, argTime); final byte[] bytes = argTime.getByteArray(); final int offset = argTime.getStartOffset(); final long time = ATypeHierarchy.getLongValue(getIdentifier().getName(), 1, bytes, offset); try { Thread.sleep(time / 1000000, (int) (time % 1000000)); } catch (InterruptedException e) { <|startfocus|> throw new HyracksDataException(e); <|endfocus|> } } }; } };
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  maxLSN = Math.max(AbstractLSMIOOperationCallback.getTreeIndexLSN(invIndexComponent.getDeletedKeysBTree()), maxLSN); } return maxLSN; } @Override public long getComponentFileLSNOffset(ILSMComponent diskComponent, String diskComponentFilePath) throws HyracksDataException { if (diskComponentFilePath.endsWith(LSMInvertedIndexFileManager.DELETED_KEYS_BTREE_SUFFIX)) { LSMInvertedIndexDiskComponent invIndexComponent = (LSMInvertedIndexDiskComponent) diskComponent; <|startfocus|> IMetadataPageManager metadataPageManager = ((IMetadataPageManager) invIndexComponent.getDeletedKeysBTree() .getPageManager()); <|endfocus|> return metadataPageManager.getFileOffset(metadataPageManager.createMetadataFrame(), LSN_KEY); } return INVALID; } } 
<|startcomment|> "else" on the previous line? <|endcomment|>  if (contentFile == null) { String file; try { URI uri = new URI(url); file = ((uri.getHost() != null ? uri.getHost() : "") + uri.getPath()).replaceAll(BAD_CHARS, "_"); } catch (URISyntaxException e) { file = url.replaceAll(BAD_CHARS, "_"); } return (!fixupExtension || file.endsWith(".txt")) ? file : file + ".txt"; <|startfocus|> } else { <|endfocus|> return contentFile; }
<|startcomment|> MAJOR SonarQube violation: '!=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  return null; } @Override public Void visit(VariableExpr v, Void arg) throws AsterixException { // do nothing return null; } @Override public Void visit(WhereClause wc, Void arg) throws AsterixException { wc.getWhereExpr().accept(this, arg); return null; } @Override public Void visit(InsertStatement wc, Void arg) throws AsterixException { wc.getQuery().accept(this, arg); Expression returnExpression = wc.getReturnExpression(); <|startfocus|> if(returnExpression!=null){ <|endfocus|> returnExpression.accept(this, arg); } return null; } public Set<FunctionSignature> getCalls() { return calls; } @Override public Void visit(FunctionDecl fd, Void arg) throws AsterixException { return null; } } 
<|startcomment|> MAJOR SonarQube violation: Remove this unused "LOGGER" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|>  */ package org.apache.asterix.common.config; import java.util.Set; import java.util.logging.Logger; import java.util.stream.Collectors; import org.apache.asterix.common.replication.IReplicationStrategy; import org.apache.asterix.common.replication.Replica; import org.apache.asterix.event.schema.cluster.Cluster; import org.apache.asterix.event.schema.cluster.Node; import org.apache.hyracks.util.StorageUtil; import org.apache.hyracks.util.StorageUtil.StorageUnit; public class ReplicationProperties extends AbstractProperties { <|startfocus|> private static final Logger LOGGER = Logger.getLogger(ReplicationProperties.class.getName()); <|endfocus|> private static final int REPLICATION_DATAPORT_DEFAULT = 2000; private static final String REPLICATION_TIMEOUT_KEY = "replication.timeout"; private static final int REPLICATION_TIME_OUT_DEFAULT = 15; private static final String REPLICATION_MAX_REMOTE_RECOVERY_ATTEMPTS_KEY = "replication.max.remote.recovery.attempts"; private static final int MAX_REMOTE_RECOVERY_ATTEMPTS = 5; private static final String NODE_IP_ADDRESS_DEFAULT = "127.0.0.1"; private static final String REPLICATION_LOG_BATCH_SIZE_KEY = "replication.log.batchsize";
<|startcomment|> MAJOR SonarQube violation: Make second a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck <|endcomment|>  /** * Returns the capacity and the usedCount for the given slot in this table. */ public void getSlotInfo(int contentFrameIndex, int contentOffsetIndex, SlotInfoPair<Integer, Integer> slotInfo) { IntSerDeBuffer frame = contents.get(contentFrameIndex); int entryCapacity = frame.getInt(contentOffsetIndex); int entryUsedItems = frame.getInt(contentOffsetIndex + 1); slotInfo.reset(entryCapacity, entryUsedItems); } static class SlotInfoPair<T1, T2> { <|startfocus|> public T1 first; public T2 second; <|endfocus|> public SlotInfoPair(T1 first, T2 second) { this.first = first; this.second = second; } public void reset(T1 first, T2 second) { this.first = first; this.second = second; } } } 
<|startcomment|> Rename parameter to "topStatement" (or "topStmt") as well? <|endcomment|> <|startfocus|> private void setup(List<FunctionDecl> declaredFunctions, StatementWithReturn topExpr, MetadataProvider metadataProvider, LangRewritingContext context) { this.topStatement = topExpr; <|endfocus|> this.context = context; this.declaredFunctions = declaredFunctions; this.metadataProvider = metadataProvider;
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  public void startFailbackProcess() { int maxRecoveryAttempts = replicationProperties.getMaxRemoteRecoveryAttempts(); PersistentLocalResourceRepository resourceRepository = (PersistentLocalResourceRepository) runtimeContext .getLocalResourceRepository(); IDatasetLifecycleManager datasetLifeCycleManager = runtimeContext.getDatasetLifecycleManager(); <|startfocus|> System.out.println("Starting failback process..."); // failbackRecoveryReplicas = new HashMap<>(); <|endfocus|> while (true) { //start recovery steps try { if (maxRecoveryAttempts <= 0) { //to avoid infinite loop in case of unexpected behavior. throw new IllegalStateException("Failed to perform remote recovery."); } /*** Prepare for Recovery ***/ //1. check remote replicas states replicationManager.initializeReplicasState(); int activeReplicasCount = replicationManager.getActiveReplicasCount(); if (activeReplicasCount == 0) { throw new IllegalStateException("no ACTIVE remote replica(s) exists to perform remote recovery"); } //2. clean any memory data that could've existed from previous failed recovery attempt datasetLifeCycleManager.closeAllDatasets(); //3. remove any existing storage data and initialize storage metadata resourceRepository.deleteStorageData(true);
<|startcomment|> Replace "put" with "set"? "put" is deprecated (for JsonNode), <|endcomment|>  index = valueArray.size() - 1; } final Object value = valueArray.get(index); json.remove(key); json.putPOJO(key.replaceAll("s$",""), value); } } List<ObjectNode> gcs = new ArrayList<>(); for (int i = 0; i < gcNames.size(); i++) { ObjectNode gc = om.createObjectNode(); <|startfocus|> gc.put("name", gcNames.get(i)); gc.put("collection-time", ((ArrayNode)gcCollectionTimes.get(i)).get(index)); gc.put("collection-count", ((ArrayNode)gcCollectionCounts.get(i)).get(index)); <|endfocus|> gcs.add(gc); } json.putPOJO("gcs", gcs); return json; } private ObjectNode processNodeConfig(IHyracksClientConnection hcc, String node) throws Exception { ObjectMapper om = new ObjectMapper(); String config = hcc.getNodeDetailsJSON(node, false, true); if (config == null) { throw new IllegalArgumentException(); } return (ObjectNode) om.readTree(config); } 
<|startcomment|> fix ws? <|endcomment|>  String out = IOUtils.toString(resultStream); ObjectMapper om = new ObjectMapper(); om.setConfig(om.getDeserializationConfig() .with(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)); JsonNode result; try { result = om.readValue(out, ObjectNode.class).get("results"); } catch( JsonMappingException e){ result = om.createArrayNode(); } for (int i=0;i<result.size();i++) { JsonNode json = result.get(i); <|startfocus|> if(json != null) { <|endfocus|> String dvName = json.get("DataverseName").asText(); if (!dvName.equals("Metadata") && !dvName.equals("Default")) { toBeDropped.add(dvName); } } } if (!toBeDropped.isEmpty()) { badtestcases.add(testCase); LOGGER.warning( "Last test left some garbage. Dropping dataverses: " + StringUtils.join(toBeDropped, ',')); StringBuilder dropStatement = new StringBuilder(); for (String dv : toBeDropped) { dropStatement.append("drop dataverse "); dropStatement.append(dv);
<|startcomment|> Replace "put" with "set"? "put" is deprecated (for JsonNode), <|endcomment|>  } List<IConnectorDescriptor> outputs = activityOutputMap.get(an.getActivityId()); if (outputs != null) { ArrayNode jOutputs = om.createArrayNode(); for (int i = 0; i < outputs.size(); ++i) { ObjectNode jOutput = om.createObjectNode(); jOutput.put("output-port", i); jOutput.put("connector-id", outputs.get(i).getConnectorId().toString()); jOutputs.add(jOutput); } <|startfocus|> jan.put("outputs", jOutputs); <|endfocus|> } Set<ActivityId> blockers = getBlocked2BlockerMap().get(an.getActivityId()); if (blockers != null) { ArrayNode jDeps = om.createArrayNode(); for (ActivityId blocker : blockers) { jDeps.add(blocker.toString()); } jan.put("depends-on", jDeps); } jans.add(jan); } jac.put("activities", jans); return jac;
<|startcomment|> MAJOR SonarQube violation: Remove this unused "DEBUG" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|>  */ public class ReplicationManager implements IReplicationManager { private static final Logger LOGGER = Logger.getLogger(ReplicationManager.class.getName()); private static final int INITIAL_REPLICATION_FACTOR = 1; private static final int MAX_JOB_COMMIT_ACK_WAIT = 10000; private final String nodeId; private ExecutorService replicationListenerThreads; private final Map<Integer, Set<String>> jobCommitAcks; private final Map<Integer, ILogRecord> replicationJobsPendingAcks; private ByteBuffer dataBuffer; <|startfocus|> private static final boolean DEBUG = false; <|endfocus|> private final LinkedBlockingQueue<IReplicationJob> replicationJobsQ; private final LinkedBlockingQueue<ReplicaEvent> replicaEventsQ; private int replicationFactor = 1; private final ReplicaResourcesManager replicaResourcesManager; private final ILogManager logManager; private final IAppRuntimeContextProvider asterixAppRuntimeContextProvider; private final ReplicationProperties replicationProperties; private final Map<String, Replica> replicas; private final Map<String, Set<Integer>> replica2PartitionsMap; private final AtomicBoolean replicationSuspended; private AtomicBoolean terminateJobsReplication; private AtomicBoolean jobsReplicationSuspended; private static final int INITIAL_BUFFER_SIZE = StorageUtil.getSizeInBytes(4, StorageUnit.KILOBYTE);
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  if (isExcluded(depProject.getArtifact())) { getLog().debug("skipping " + depProject + " [excluded]"); } else if (depLocation == null) { getLog().debug("skipping " + depProject + " [not included in dependency sets]"); <|startfocus|> // } else if (!depProject.getPackaging().equals("jar")) { // getLog().info("skipping non-jar packaging (" + depProject.getPackaging() + ") for " + depProject); <|endfocus|> } else { addDependencyToLicenseMap(depProject, dep.getValue(), depLocation); } } } private void addDependencyToLicenseMap(MavenProject depProject, List<Pair<String, String>> depLicenses, String depLocation) { final String depGav = toGav(depProject); getLog().debug("adding " + depGav + ", location: " + depLocation); if (depLicenses.size() > 1) { Collections.sort(depLicenses, (o1, o2) -> { final LicenseSpec l1 = urlToLicenseMap.get(o1.getLeft());
<|startcomment|> MAJOR SonarQube violation: Make INSTANCE a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck <|endcomment|>  * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.job.resource; import org.apache.hyracks.api.job.IComputationResource; public class DefaultJobResourceController implements IJobResourceController { <|startfocus|> public static DefaultJobResourceController INSTANCE = new DefaultJobResourceController(); <|endfocus|> private DefaultJobResourceController() { } @Override public boolean allocate(IComputationResource inputComputationResource) { return true; } @Override public void release(IComputationResource inputComputationResource) { } } 
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  private void executeJob(JobRun run) { IResultCallback<JobId> callback = run.getCallback(); try { <|startfocus|> //run.setStatus(JobStatus.INITIALIZED, null); <|endfocus|> run.setStartTime(System.currentTimeMillis()); JobId jobId = run.getJobId(); activeRunMap.put(jobId, run); CCApplicationContext appCtx = ccs.getApplicationContext(); IActivityClusterGraphGeneratorFactory acggf = run.getActivityClusterGraphFactory(); appCtx.notifyJobCreation(jobId, acggf); run.setStatus(JobStatus.RUNNING, null); try { run.getExecutor().startJob(); } catch (Exception e) { ccs.getWorkQueue().schedule( new JobCleanupWork(ccs, run.getJobId(), JobStatus.FAILURE, Collections.singletonList(e))); } callback.setValue(jobId); } catch (Exception e) { callback.setException(e); }
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  // Query language ILangCompilationProvider compilationProvider = "AQL".equals(request.getParameter("query-language")) ? aqlCompilationProvider : sqlppCompilationProvider; IParserFactory parserFactory = compilationProvider.getParserFactory(); // Output format. OutputFormat format; boolean csv_and_header = false; String output = request.getParameter("output-format"); try { format = OutputFormat.valueOf(output); } catch (IllegalArgumentException e) { <|startfocus|> LOGGER.info(output + ": unsupported output-format, using " + OutputFormat.CLEAN_JSON + " instead"); <|endfocus|> // Default output format format = OutputFormat.CLEAN_JSON; } String query = request.getParameter("query"); String wrapperArray = request.getParameter("wrapper-array"); String printExprParam = request.getParameter("print-expr-tree"); String printRewrittenExprParam = request.getParameter("print-rewritten-expr-tree"); String printLogicalPlanParam = request.getParameter("print-logical-plan"); String printOptimizedLogicalPlanParam = request.getParameter("print-optimized-logical-plan"); String printJob = request.getParameter("print-job"); String executeQuery = request.getParameter("execute-query");
<|startcomment|> CRITICAL SonarQube violation: Make this member "protected". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2386 <|endcomment|>  public static final String FILTER_LEVEL = "filter-level"; } public static class GeoConstants { private static final double[][] US = new double[][] { { -124.848974, 24.396308 }, { -66.885444, 49.384358 } }; private static final double[][] EU = new double[][] { { -29.7, 36.7 }, { 79.2, 72.0 } }; <|startfocus|> public static Map<String, double[][]> boundingBoxes = initializeBoundingBoxes(); } <|endfocus|> private static Map<String, double[][]> initializeBoundingBoxes() { Map<String, double[][]> boundingBoxes = new HashMap<String, double[][]>(); boundingBoxes.put(ConfigurationConstants.LOCATION_US, GeoConstants.US); boundingBoxes.put(ConfigurationConstants.LOCATION_EU, GeoConstants.EU); return boundingBoxes; } /** * Gets more than one bounding box from a sequences of coordinates * (following Twitter formats) + predefined location names, as US and EU.
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  Set<TaskId> cluster = taskClusterMap.get(e.getKey()); for (Pair<TaskId, ConnectorDescriptorId> p : e.getValue()) { IConnectorPolicy cPolicy = connectorPolicies.get(p.getRight()); if (cPolicy.requiresProducerConsumerCoscheduling()) { cluster.add(p.getLeft()); } } } /* <|startfocus|> * taskClusterMap contains for every TID x, x -> { coscheduled consumer TIDs U x } * We compute the transitive closure of this relation to find the largest set of * tasks that need to be co-scheduled <|endfocus|> */ int counter = 0; TaskId[] ordinalList = new TaskId[taskClusterMap.size()]; Map<TaskId, Integer> ordinalMap = new HashMap<TaskId, Integer>(); for (TaskId tid : taskClusterMap.keySet()) { ordinalList[counter] = tid; ordinalMap.put(tid, counter); ++counter; } int n = ordinalList.length; BitSet[] paths = new BitSet[n]; for (Map.Entry<TaskId, Set<TaskId>> e : taskClusterMap.entrySet()) {
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  } if (targetNodes != null && !targetNodes.isEmpty()) { INodeManager nodeManager = ccs.getNodeManager(); Set<String> toDelete = new HashSet<>(); for (String n : targetNodes) { NodeControllerState ncs = nodeManager.getNodeControllerState(n); try { if (ncs == null) { toDelete.add(n); } else { ncs.getNodeController().cleanUpJoblet(jobId, status); } } catch (Exception e) { <|startfocus|> e.printStackTrace(); <|endfocus|> } } targetNodes.removeAll(toDelete); run.getCleanupPendingNodeIds().removeAll(toDelete); if (run.getCleanupPendingNodeIds().isEmpty()) { completeJob(run); } } else { completeJob(run); }
<|startcomment|> currentPK -> currentPKs <|endcomment|>  // leftInputPKs extract all the PKs derived from the downstream of the left branch. List<LogicalVariable> leftInputPKs = findPrimaryKeysInSubplan(liveVars, context); liveVars.clear(); VariableUtilities.getLiveVariables(rightInputOp, liveVars); // rightInputPKs extract all the PKs derived from the downstream of the right branch. List<LogicalVariable> rightInputPKs = findPrimaryKeysInSubplan(liveVars, context); <|startfocus|> Collection<LogicalVariable> currentPK = new HashSet<>(); currentPK.addAll(leftInputPKs); currentPK.addAll(rightInputPKs); <|endfocus|> // If PKs derived from the both branches are SAME as a previous fuzzyjoin, we treat this ~= as a select. for (int i = 0; i < previousPK.size(); i++) { if (previousPK.get(i).containsAll(currentPK) && currentPK.containsAll(previousPK.get(i))) { return false; } } //Suppose we want to query on the same table on the different fields, i.e. A.a1 ~= B.b1 AND A.a2 ~= B.b2
<|startcomment|> I think this should be a CompilationException and it needs to have an error code, too. <|endcomment|>  translator.addVariableToMetaScope(new VarIdentifier("$$RIGHTPK_" + i + "_" + j), rightInputVarCopy); } copyVisitor.updatePrimaryKeys(context); copyVisitor.reset(); } counter.set(context.getVarCounter()); AQLPlusParser parser = new AQLPlusParser(new StringReader(aqlPlus)); parser.initScope(); parser.setVarCounter(counter); List<Clause> clauses; try { clauses = parser.Clauses(); } catch (ParseException e) { <|startfocus|> throw new AlgebricksException(e); <|endfocus|> } // Step 4. The essential substitution with translator. ILogicalPlan plan; try { plan = translator.translate(clauses); } catch (AsterixException e) { throw new AlgebricksException(e); } context.setVarCounter(counter.get()); return plan.getRoots().get(0).getValue(); } // Since the generatePrefixFuzzyJoinSubplan generates the prefix-based join operators for the partial simJoin // of expRef, we need to add the full condition expRef\getItemExprRef into the top-level operator of the plan.
<|startcomment|> MAJOR SonarQube violation: Split this 127 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  IApplicationContextInfo appContext = (IApplicationContextInfo) context.getAppContext(); Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitAndConstraints(dataverseName, datasetName, indexName, temp); // prepare callback JobId jobId = ((JobEventListenerFactory) spec.getJobletEventListenerFactory()).getJobId(); int datasetId = dataset.getDatasetId(); IModificationOperationCallbackFactory modificationCallbackFactory = temp ? new TempDatasetSecondaryIndexModificationOperationCallbackFactory(jobId, datasetId, <|startfocus|> modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE) <|endfocus|> : new SecondaryIndexModificationOperationCallbackFactory(jobId, datasetId, modificationCallbackPrimaryKeyFields, getStorageComponentProvider().transactionSubsystemProvider(), indexOp, ResourceType.LSM_BTREE, dataset.hasMetaPart()); Pair<ILSMMergePolicyFactory, Map<String, String>> compactionInfo = DatasetUtils .getMergePolicyFactory(dataset, mdTxnCtx); IIndexDataflowHelperFactory idfh = getStorageComponentProvider().indexDataflowHelperFactory(this, dataset, secondaryIndex, itemType, metaType, compactionInfo.first, compactionInfo.second); IOperatorDescriptor op; if (bulkload) { long numElementsHint = getCardinalityPerPartitionHint(dataset);
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|> <|startfocus|> public void setFeedLogManager(FeedLogManager feedLogManager) { <|endfocus|>
<|startcomment|> Change this line to: defaultLogicalRewrites.add(new Pair<>(seqFirstCheckCtrlFullDfs, RuleCollections.buildFuzzyJoinRuleCollection())); <|endcomment|>  defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildTypeInferenceRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildAutogenerateIDRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection())); defaultLogicalRewrites .add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildCondPushDownAndJoinInferenceRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildLoadFieldsRuleCollection())); <|startfocus|> defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildFuzzyJoinRuleCollection())); <|endfocus|> defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildNormalizationRuleCollection())); defaultLogicalRewrites .add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildCondPushDownAndJoinInferenceRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqCtrlFullDfs, RuleCollections.buildLoadFieldsRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildDataExchangeRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqCtrlNoDfs, RuleCollections.buildConsolidationRuleCollection())); defaultLogicalRewrites.add(new Pair<>(seqOnceCtrl, RuleCollections.buildFulltextContainsRuleCollection()));
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|> <|startfocus|> private Mutable<ILogicalExpression> getSimilarityExpression(Mutable<ILogicalExpression> expRef) { ILogicalExpression exp = expRef.getValue(); <|endfocus|> if (exp.getExpressionTag() == LogicalExpressionTag.FUNCTION_CALL) { AbstractFunctionCallExpression funcExpr = (AbstractFunctionCallExpression) exp; if (funcExpr.getFunctionIdentifier().equals(AsterixBuiltinFunctions.GET_ITEM)) { return expRef; } if (funcExpr.getFunctionIdentifier().equals(AlgebricksBuiltinFunctions.AND)) { for (Mutable<ILogicalExpression> arg : funcExpr.getArguments()) { Mutable<ILogicalExpression> expRefRet = getSimilarityExpression(arg); if (expRefRet != null) { return expRefRet; } } } } return null;
<|startcomment|> MAJOR SonarQube violation: The type of the "RecordIDFields" object should be an interface such as "List" rather than the implementation "ArrayList". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 <|endcomment|>  private static ITypeTraits fileNumberTypeTraits; private static ITypeTraits recordOffsetTypeTraits; private static ITypeTraits rowNumberTypeTraits; //IScalarEvaluatorFactories private static final IScalarEvaluatorFactory fileNumberEvalFactory; private static final IScalarEvaluatorFactory recordOffsetEvalFactory; private static final IScalarEvaluatorFactory rowNumberEvalFactory; public static final int FILE_NUMBER_FIELD_INDEX = 0; public static final int RECORD_OFFSET_FIELD_INDEX = 1; public static final int ROW_NUMBER_FIELD_INDEX = 2; <|startfocus|> public static final ArrayList<List<String>> RecordIDFields = new ArrayList<>(); <|endfocus|> static { fileNumberSerializerDeserializer = SerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(FILE_NUMBER_FIELD_TYPE); recordOffsetSerializerDeserializer = SerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(RECORD_OFFSET_FIELD_TYPE); rowNumberSerializerDeserializer = SerializerDeserializerProvider.INSTANCE .getSerializerDeserializer(ROW_NUMBER_FIELD_TYPE); fileNumberTypeTraits = TypeTraitProvider.INSTANCE.getTypeTrait(FILE_NUMBER_FIELD_TYPE); recordOffsetTypeTraits = TypeTraitProvider.INSTANCE.getTypeTrait(RECORD_OFFSET_FIELD_TYPE); rowNumberTypeTraits = TypeTraitProvider.INSTANCE.getTypeTrait(ROW_NUMBER_FIELD_TYPE); fileNumberEvalFactory = new TupleFieldEvaluatorFactory(1);
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "filterFields". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  IApplicationContextInfo appContext = (IApplicationContextInfo) context.getAppContext(); Pair<IFileSplitProvider, AlgebricksPartitionConstraint> splitsAndConstraint = splitAndConstraints(dataverseName, datasetName, indexName, temp); int[] btreeFields = new int[primaryComparatorFactories.length]; for (int k = 0; k < btreeFields.length; k++) { btreeFields[k] = k + numSecondaryKeys; } ITypeTraits[] filterTypeTraits = DatasetUtils.computeFilterTypeTraits(dataset, recType); <|startfocus|> int[] filterFields = null; int[] rtreeFields = null; <|endfocus|> if (filterTypeTraits != null) { filterFields = new int[1]; filterFields[0] = numSecondaryKeys + numPrimaryKeys; rtreeFields = new int[numSecondaryKeys + numPrimaryKeys]; for (int k = 0; k < rtreeFields.length; k++) { rtreeFields[k] = k; } } // prepare callback JobId jobId = ((JobEventListenerFactory) spec.getJobletEventListenerFactory()).getJobId(); int datasetId = dataset.getDatasetId(); IModificationOperationCallbackFactory modificationCallbackFactory = temp
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  public static boolean isValidIndexName(String datasetName, String indexName) { <|startfocus|> return (!datasetName.concat(IndexingConstants.EXTERNAL_FILE_INDEX_NAME_SUFFIX).equals(indexName)); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  asterixPropertiesProvider, metadataProvider, recType, metaType, enforcedType, enforcedMetaType); break; } case SINGLE_PARTITION_WORD_INVIX: case SINGLE_PARTITION_NGRAM_INVIX: case LENGTH_PARTITIONED_WORD_INVIX: case LENGTH_PARTITIONED_NGRAM_INVIX: { indexOperationsHelper = new SecondaryInvertedIndexOperationsHelper(dataset, index, physOptConf, asterixPropertiesProvider, metadataProvider, recType, metaType, enforcedType, enforcedMetaType); break; } default: { throw new CompilationException(ErrorCode.COMPILATION_UNKNOWN_INDEX_TYPE, index.getIndexType()); <|startfocus|> } <|endfocus|> } indexOperationsHelper.init(); return indexOperationsHelper; } public abstract JobSpecification buildCreationJobSpec() throws AsterixException, AlgebricksException; public abstract JobSpecification buildLoadingJobSpec() throws AsterixException, AlgebricksException; public abstract JobSpecification buildCompactJobSpec() throws AsterixException, AlgebricksException; protected void init() throws AsterixException, AlgebricksException { payloadSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(itemType); metaSerde = metaType == null ? null : SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(metaType); Pair<IFileSplitProvider, AlgebricksPartitionConstraint> secondarySplitsAndConstraint = metadataProvider
<|startcomment|> father op -> parent operator the below opRef -> the following opRef <|endcomment|>  // Steps 1-2. Generate the prefix-based fuzzy jon template. String aqlPlus = generateAqlTemplate(metadataProvider, joinOp, simFuncExpr, leftInputPKs, leftType, rightInputPKs, thresholdConstantExpr); // Steps 3-4. Generate the prefix-based fuzzy join subplan. ILogicalOperator outputOp = generatePrefixFuzzyJoinSubplan(context, metadataProvider, aqlPlus, leftInputOp, leftInputPKs, leftInputVar, rightInputOp, rightInputPKs, rightInputVar); <|startfocus|> // Step 5. Bind the plan to the father op referred by the below opRef. <|endfocus|> SelectOperator extraSelect; if (getItemExprRef != exprRef) { // more than one join condition getItemExprRef.setValue(ConstantExpression.TRUE); switch (joinOp.getJoinKind()) { case INNER: { extraSelect = new SelectOperator(exprRef, false, null); extraSelect.getInputs().add(new MutableObject<>(outputOp)); outputOp = extraSelect; break; } case LEFT_OUTER: { LeftOuterJoinOperator topJoin = (LeftOuterJoinOperator) outputOp; setConditionForLeftOuterJoin(topJoin, exprRef); break; } default: {
<|startcomment|> This interface is also a little confusing. We add a JobRun to the queue, but we remove by giving resources back. It seems the ResouceManager should be the one that manages the returning of resources. Or maybe we just need a different name for this method? <|endcomment|>  void add(JobRun run) throws HyracksException; /** * Remove a list of jobs from the job queque, when more computation resource becomes available. * * @param maxResource, * the current maximum computation resource of the cluster. * @param availableResource, * the latest available computation resource of the cluster. * @return a list of jobs whose resource requirements can all be met at the same time. */ <|startfocus|> List<JobRun> remove(IReadOnlyComputationResource maxResource, IComputationResource availableResource); <|endfocus|> /** * @return all pending jobs in the queue. */ Collection<JobRun> jobs(); } 
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|> <|startfocus|> public void setId(String s) { <|endfocus|>
<|startcomment|> would this be more readable with one per line? e.g. private static final List<String> recordReaderNames = Collections.unmodifiableList(Arrays.asList( ExternalDataConstants.READER_TWITTER_PULL, ExternalDataConstants.READER_TWITTER_PUSH, ExternalDataConstants.READER_PUSH_TWITTER, ExternalDataConstants.READER_TWITTER_PUSH, ExternalDataConstants.READER_PUSH_TWITTER, ExternalDataConstants.READER_PULL_TWITTER, ExternalDataConstants.READER_USER_STREAM_TWITTER, ExternalDataConstants.READER_PULL_TWITTER, ExternalDataConstants.READER_USER_STREAM_TWITTER )); <|endcomment|>  private static final String DEFAULT_INTERVAL = "10"; // 10 seconds private static final int INTAKE_CARDINALITY = 1; // degree of parallelism at intake stage private Map<String, String> configuration; private transient AlgebricksAbsolutePartitionConstraint clusterLocations; <|startfocus|> private static final List<String> recordReaderNames = Collections .unmodifiableList(Arrays.asList(ExternalDataConstants.READER_TWITTER_PULL, ExternalDataConstants.READER_TWITTER_PUSH, ExternalDataConstants.READER_PUSH_TWITTER, ExternalDataConstants.READER_PULL_TWITTER, ExternalDataConstants.READER_USER_STREAM_TWITTER)); <|endfocus|> @Override public List<String> getRecordReaderNames() { return recordReaderNames; } @Override public DataSourceType getDataSourceType() { return DataSourceType.RECORDS; } @Override public AlgebricksAbsolutePartitionConstraint getPartitionConstraint() throws AlgebricksException { clusterLocations = IExternalDataSourceFactory.getPartitionConstraints(clusterLocations, INTAKE_CARDINALITY); return clusterLocations; } @Override public void configure(Map<String, String> configuration) throws AsterixException { this.configuration = configuration; TwitterUtil.initializeConfigurationWithAuthInfo(configuration); if (!validateConfiguration(configuration)) { StringBuilder builder = new StringBuilder();
<|startcomment|> format? <|endcomment|>  public ExternalDatasetIndexesAbortOperatorDescriptor(IOperatorDescriptorRegistry spec, <|startfocus|> IIndexDataflowHelperFactory filesIndexDataflowHelperFactory, IndexInfoOperatorDescriptor fileIndexesInfo, List<IIndexDataflowHelperFactory> treeIndexesDataflowHelperFactories, List<IndexInfoOperatorDescriptor> treeIndexesInfos) { super(spec, filesIndexDataflowHelperFactory, fileIndexesInfo, treeIndexesDataflowHelperFactories, treeIndexesInfos); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Split this 149 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public DdlApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, <|startfocus|> ILangCompilationProvider compilationProvider, IStatementExecutorFactory statementExecutorFactory, IComponentProvider componentProvider) { <|endfocus|> super(ctx, paths, compilationProvider, statementExecutorFactory, componentProvider);
<|startcomment|> inline? import of IStatementExecutor.ResultDelivery would increase brevity... <|endcomment|>  ctx.put(HYRACKS_DATASET_ATTR, hds); } } } IParser parser = compilationProvider.getParserFactory().createParser(param.statement); List<Statement> statements = parser.parse(); MetadataManager.INSTANCE.init(); IStatementExecutor translator = statementExecutorFactory.create(statements, sessionConfig, compilationProvider); execStart = System.nanoTime(); translator.compileAndExecute(hcc, hds, delivery, stats); execEnd = System.nanoTime(); <|startfocus|> final boolean asyncDelivery = IStatementExecutor.ResultDelivery.ASYNC == delivery; printStatus(resultWriter, asyncDelivery ? ResultStatus.STARTED : ResultStatus.SUCCESS); <|endfocus|> } catch (AsterixException | TokenMgrError | org.apache.asterix.aqlplus.parser.TokenMgrError pe) { GlobalConfig.ASTERIX_LOGGER.log(Level.SEVERE, pe.getMessage(), pe); printError(resultWriter, pe); printStatus(resultWriter, ResultStatus.FATAL); status = HttpResponseStatus.BAD_REQUEST; } catch (Exception e) { GlobalConfig.ASTERIX_LOGGER.log(Level.SEVERE, e.getMessage(), e); printError(resultWriter, e); printStatus(resultWriter, ResultStatus.FATAL); status = HttpResponseStatus.INTERNAL_SERVER_ERROR; } finally {
<|startcomment|> runtimeComponentProvider --> storageManager <|endcomment|>  private final boolean isPrimary; /** the name of the index that is being operated upon **/ private final String indexName; public LSMTreeInsertDeleteOperatorDescriptor(IOperatorDescriptorRegistry spec, RecordDescriptor recDesc, <|startfocus|> IStorageManager runtimeComponentProvider, IIndexLifecycleManagerProvider lifecycleManagerProvider, <|endfocus|> IFileSplitProvider fileSplitProvider, ITypeTraits[] typeTraits, IBinaryComparatorFactory[] comparatorFactories, int[] bloomFilterKeyFields, int[] fieldPermutation, IndexOperation op, IIndexDataflowHelperFactory dataflowHelperFactory, ITupleFilterFactory tupleFilterFactory, boolean isPrimary, String indexName, IMissingWriterFactory nullWriterFactory, IModificationOperationCallbackFactory modificationOpCallbackProvider, ISearchOperationCallbackFactory searchOpCallbackProvider, IPageManagerFactory pageManagerFactory) { super(spec, recDesc, runtimeComponentProvider, lifecycleManagerProvider, fileSplitProvider, typeTraits, comparatorFactories, bloomFilterKeyFields, fieldPermutation, op, dataflowHelperFactory, tupleFilterFactory, nullWriterFactory, modificationOpCallbackProvider, searchOpCallbackProvider, pageManagerFactory); this.isPrimary = isPrimary; this.indexName = indexName;
<|startcomment|> root? <|endcomment|> import org.apache.hyracks.storage.common.file.IResourceIdFactory; /** * Provides storage components during hyracks tasks execution */ public interface IStorageManager extends Serializable { /** * @param ctx * hyracks task context * @return the disk {@link org.apache.hyracks.storage.common.buffercache.IBufferCache} */ IBufferCache getBufferCache(IHyracksTaskContext ctx); /** * @param ctx * the task context <|startfocus|> * @return the root {@link org.apache.hyracks.storage.common.file.IFileMapProvider} <|endfocus|> */ IFileMapProvider getFileMapProvider(IHyracksTaskContext ctx); /** * @param ctx * the task context * @return the root {@link org.apache.hyracks.storage.common.file.ILocalResourceRepository} */ ILocalResourceRepository getLocalResourceRepository(IHyracksTaskContext ctx); /** * @param ctx * the task context * @return the root {@link org.apache.hyracks.storage.common.file.IResourceIdFactory} */ IResourceIdFactory getResourceIdFactory(IHyracksTaskContext ctx); } 
<|startcomment|> MAJOR SonarQube violation: Split this 125 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  Index fileIndex = MetadataManager.INSTANCE.getIndex(metadataProvider.getMetadataTxnContext(), dataset.getDataverseName(), dataset.getDatasetName(), fileIndexName); IIndexDataflowHelperFactory dataflowHelperFactory = dataset.getIndexDataflowHelperFactory(metadataProvider, fileIndex, null, null, compactionInfo.first, compactionInfo.second); IndexDropOperatorDescriptor btreeDrop = new IndexDropOperatorDescriptor(spec, metadataProvider.getStorageComponentProvider().getStorageManager(), <|startfocus|> metadataProvider.getStorageComponentProvider().getIndexLifecycleManagerProvider(), splitsAndConstraint.first, dataflowHelperFactory, metadataProvider.getStorageComponentProvider().getMetadataPageManagerFactory()); <|endfocus|> AlgebricksPartitionConstraintHelper.setPartitionConstraintInJobSpec(spec, btreeDrop, splitsAndConstraint.second); spec.addRoot(btreeDrop); return spec; } public static JobSpecification buildFilesIndexUpdateOp(Dataset ds, List<ExternalFile> metadataFiles, List<ExternalFile> addedFiles, List<ExternalFile> appendedFiles, MetadataProvider metadataProvider) throws AlgebricksException { ArrayList<ExternalFile> files = new ArrayList<>(); for (ExternalFile file : metadataFiles) { if (file.getPendingOp() == ExternalFilePendingOp.DROP_OP) { files.add(file);
<|startcomment|> AbstractDiskComponent -> ILSMDiskComponent <|endcomment|>  ILSMComponent c = immutableComponents.get(i); long componentSize = ((AbstractDiskComponent) c).getComponentSize(); if (componentSize > maxMergableComponentSize) { startIndex = i; totalSize = 0; continue; } totalSize += componentSize; boolean isLastComponent = i + 1 == minNumComponents ? true : false; if (totalSize > maxMergableComponentSize || (isLastComponent && i - startIndex >= maxToleranceComponentCount)) { for (ILSMIndex lsmIndex : indexes) { <|startfocus|> List<AbstractDiskComponent> reversedImmutableComponents = <|endfocus|> new ArrayList<>(lsmIndex.getImmutableComponents()); // Reverse the components order so that we look at components from oldest to newest. Collections.reverse(reversedImmutableComponents); List<AbstractDiskComponent> mergableComponents = new ArrayList<>(); for (int j = startIndex + 1; j <= i; j++) { mergableComponents.add(reversedImmutableComponents.get(j)); } // Reverse the components order back to its original order Collections.reverse(mergableComponents); ILSMIndexAccessor accessor =
<|startcomment|> IDiskComponentFactory -> ILSMDiskComponentFactory "LSM" is used all over the places, thus we'd better be consistent. At the moment we remove all in-place stuff, we can remove the "LSM" prefix but it's OK to keep it. <|endcomment|>  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.storage.am.lsm.btree.impls; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.storage.am.bloomfilter.impls.BloomFilterFactory; import org.apache.hyracks.storage.am.btree.impls.BTree; import org.apache.hyracks.storage.am.lsm.common.api.ILSMComponentFilterFactory; <|startfocus|> import org.apache.hyracks.storage.am.lsm.common.api.IDiskComponentFactory; <|endfocus|> import org.apache.hyracks.storage.am.lsm.common.impls.LSMComponentFileReferences; import org.apache.hyracks.storage.am.lsm.common.impls.TreeIndexFactory; public class LSMBTreeDiskComponentFactory implements IDiskComponentFactory { private final TreeIndexFactory<BTree> btreeFactory; private final BloomFilterFactory bloomFilterFactory; private final ILSMComponentFilterFactory filterFactory; public LSMBTreeDiskComponentFactory(TreeIndexFactory<BTree> btreeFactory, BloomFilterFactory bloomFilterFactory, ILSMComponentFilterFactory filterFactory) { this.btreeFactory = btreeFactory; this.bloomFilterFactory = bloomFilterFactory; this.filterFactory = filterFactory; } @Override public LSMBTreeDiskComponent createComponent(LSMComponentFileReferences cfr) throws HyracksDataException {
<|startcomment|> MAJOR SonarQube violation: Split this 122 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  private boolean notified = false; private final ILSMIOOperationCallback wrappedCallback; public BlockingIOOperationCallbackWrapper(ILSMIOOperationCallback callback) { this.wrappedCallback = callback; } public synchronized void waitForIO() throws InterruptedException { if (!notified) { wait(); } notified = false; } @Override public void beforeOperation(LSMOperationType opType) throws HyracksDataException { wrappedCallback.beforeOperation(opType); } @Override <|startfocus|> public void afterOperation(LSMOperationType opType, List<ILSMComponent> oldComponents, ILSMDiskComponent newComponent) throws HyracksDataException { <|endfocus|> wrappedCallback.afterOperation(opType, oldComponents, newComponent); } @Override public synchronized void afterFinalize(LSMOperationType opType, ILSMDiskComponent newComponent) throws HyracksDataException { wrappedCallback.afterFinalize(opType, newComponent); notifyAll(); notified = true; } @Override public void setNumOfMutableComponents(int count) { wrappedCallback.setNumOfMutableComponents(count); } } 
<|startcomment|> "lists" -> "sequences" to be consistent with the parameter type? <|endcomment|>  // for ASCII letter count filtering private final int[] letterCounts = new int[128]; // for string edit-distance calculation private final UTF8StringCharByCharIterator leftIt = new UTF8StringCharByCharIterator(); private final UTF8StringCharByCharIterator rightIt = new UTF8StringCharByCharIterator(); public SimilarityMetricEditDistance() { cols = 100; // arbitrary default value matrix = new int[rows][cols]; } /** <|startfocus|> * Gets the edit distance value for the given two lists using a Dynamic Programming approach. <|endfocus|> * If a positive simThresh value is provided, this method only calculates 2 * (simThresh + 1) cells per row, * not entire cells as an optimization. Refer to https://en.wikipedia.org/wiki/WagnerFischer_algorithm * for more details. Also, as one more optimization, during the calculation steps, if this method finds out * that the final edit distance value cannot be less than simThresh, this method stops the calculation * and immediately returns -1.
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "coredumpdir". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  nodeStores.append(nodeIdDevice[i] + File.separator + storeDir + ","); } //remove last comma nodeStores.deleteCharAt(nodeStores.length() - 1); stores.add(new Store(asterixInstanceName + "_" + node.getId(), nodeStores.toString())); } configuration.setStore(stores); List<Coredump> coredump = new ArrayList<Coredump>(); String coredumpdir = null; List<TransactionLogDir> txnLogDirs = new ArrayList<TransactionLogDir>(); <|startfocus|> String txnLogDir = null; <|endfocus|> for (Node node : cluster.getNode()) { coredumpdir = node.getLogDir() == null ? cluster.getLogDir() : node.getLogDir(); coredump.add(new Coredump(asterixInstanceName + "_" + node.getId(), coredumpdir + File.separator + asterixInstanceName + "_" + node.getId())); txnLogDir = node.getTxnLogDir() == null ? cluster.getTxnLogDir() : node.getTxnLogDir(); txnLogDirs.add(new TransactionLogDir(asterixInstanceName + "_" + node.getId(), txnLogDir)); } configuration.setCoredump(coredump);
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|> <|startfocus|> public void notify(ActiveEvent event) { <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: The Cyclomatic Complexity of this method "createServlet" is 21 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity <|endcomment|>  protected IServlet createServlet(HttpServer server, Lets key, String... paths) { switch (key) { <|startfocus|> case AQL: <|endfocus|> return new FullApiServlet(server.ctx(), paths, ccExtensionManager.getAqlCompilationProvider(), getStatementExecutorFactory(), componentProvider); case AQL_QUERY: return new QueryApiServlet(server.ctx(), paths, ccExtensionManager.getAqlCompilationProvider(), getStatementExecutorFactory(), componentProvider); case AQL_UPDATE: return new UpdateApiServlet(server.ctx(), paths, ccExtensionManager.getAqlCompilationProvider(), getStatementExecutorFactory(), componentProvider); case AQL_DDL: return new DdlApiServlet(server.ctx(), paths, ccExtensionManager.getAqlCompilationProvider(), getStatementExecutorFactory(), componentProvider); case SQLPP: return new FullApiServlet(server.ctx(), paths, ccExtensionManager.getSqlppCompilationProvider(), getStatementExecutorFactory(), componentProvider); case SQLPP_QUERY: return new QueryApiServlet(server.ctx(), paths, ccExtensionManager.getSqlppCompilationProvider(), getStatementExecutorFactory(), componentProvider); case SQLPP_UPDATE: return new UpdateApiServlet(server.ctx(), paths, ccExtensionManager.getSqlppCompilationProvider(),
<|startcomment|> MAJOR SonarQube violation: Split this 130 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  ncConfig.resultTTL, ncConfig.resultSweepThreshold); datasetNetworkManager = new DatasetNetworkManager(ncConfig.resultListenAddress, ncConfig.resultListenPort, datasetPartitionManager, ncConfig.netThreadCount, ncConfig.netBufferCount, ncConfig.resultPublicAddress, ncConfig.resultPublicPort, FullFrameChannelInterfaceFactory.INSTANCE); if (ncConfig.messagingListenAddress != null && appCtx.getMessagingChannelInterfaceFactory() != null) { <|startfocus|> messagingNetManager = new MessagingNetworkManager(this, ncConfig.messagingListenAddress, ncConfig.messagingListenPort, ncConfig.netThreadCount, ncConfig.messagingPublicAddress, ncConfig.messagingPublicPort, appCtx.getMessagingChannelInterfaceFactory()); <|endfocus|> } } @Override public void start() throws Exception { LOGGER.log(Level.INFO, "Starting NodeControllerService"); ipc.start(); netManager.start(); startApplication(); init(); datasetNetworkManager.start(); if (messagingNetManager != null) { messagingNetManager.start(); } IIPCHandle ccIPCHandle = ipc.getHandle(new InetSocketAddress(ncConfig.clusterAddress, ncConfig.clusterPort), ncConfig.clusterConnectRetries); this.ccs = new ClusterControllerRemoteProxy(ccIPCHandle);
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  offset++; } else if (serString[offset] == '-') { offset++; positive = false; limit = Integer.MIN_VALUE; } int end = startOffset + len; for (; offset < end; offset++) { if (serString[offset] >= '0' && serString[offset] <= '9') { value *= 10; <|startfocus|> int digit = (serString[offset] - '0'); if (value < limit + digit) { <|endfocus|> throw new InvalidDataFormatException(getIdentifier(), ATypeTag.SERIALIZED_INT32_TYPE_TAG); } value -= digit; } else if (serString[offset] == 'i' && serString[offset + 1] == '3' && serString[offset + 2] == '2' && offset + 3 == end) { break; } else { throw new InvalidDataFormatException(getIdentifier(), ATypeTag.SERIALIZED_INT32_TYPE_TAG); } } if (value > 0) {
<|startcomment|> MAJOR SonarQube violation: Rename "hcc" which hides the field declared at line 102. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck <|endcomment|>  addServlet(jsonAPIServer, Servlets.DIAGNOSTICS); return jsonAPIServer; } protected void addServlet(HttpServer server, String path) { server.addServlet(createServlet(server, path, path)); } protected HttpServer setupQueryWebServer(ExternalProperties externalProperties) throws Exception { HttpServer queryWebServer = new HttpServer(webManager.getBosses(), webManager.getWorkers(), externalProperties.getQueryWebInterfacePort()); IHyracksClientConnection hcc = getNewHyracksClientConnection(); queryWebServer.setAttribute(HYRACKS_CONNECTION_ATTR, hcc); <|startfocus|> queryWebServer.addServlet(new QueryWebInterfaceServlet(queryWebServer.ctx(), new String[] { "/*" }, appCtx.getPropertiesProvider())); <|endfocus|> return queryWebServer; } protected HttpServer setupFeedServer(ExternalProperties externalProperties) throws Exception { HttpServer feedServer = new HttpServer(webManager.getBosses(), webManager.getWorkers(), externalProperties.getFeedServerPort()); feedServer.setAttribute(HYRACKS_CONNECTION_ATTR, getNewHyracksClientConnection()); feedServer.addServlet(new FeedServlet(feedServer.ctx(), new String[] { "/" })); return feedServer; } 
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public void start() throws Exception { LOGGER.log(Level.INFO, "Starting ClusterControllerService: " + this); serverCtx = new ServerContext(ServerContext.ServerType.CLUSTER_CONTROLLER, new File(ccConfig.rootDir)); IIPCI ccIPCI = new ClusterControllerIPCI(this); clusterIPC = new IPCSystem(new InetSocketAddress(ccConfig.clusterListenPort), ccIPCI, new CCNCFunctions.SerializerDeserializer()); IIPCI ciIPCI = new ClientInterfaceIPCI(this); <|startfocus|> clientIPC = new IPCSystem(new InetSocketAddress(ccConfig.clientListenAddress, ccConfig.clientListenPort), ciIPCI, new JavaSerializationBasedPayloadSerializerDeserializer()); <|endfocus|> webServer = new WebServer(this); clusterIPC.start(); clientIPC.start(); webServer.setPort(ccConfig.consoleListenPort); webServer.start(); info = new ClusterControllerInfo(ccConfig.clientListenAddress, ccConfig.clientListenPort, webServer.getListeningPort()); timer.schedule(sweeper, 0, ccConfig.heartbeatPeriod); jobLog.open(); startApplication(); datasetDirectoryService.init(executor); workQueue.start(); connectNCs(); LOGGER.log(Level.INFO, "Started ClusterControllerService"); notifyApplication(); } private void startApplication() throws Exception {
<|startcomment|> BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 <|endcomment|>  } } private void propagateInputFields(int idx) throws IOException { frameTuple.reset(tupleAccessor, idx); for (int i = 0; i < frameTuple.getFieldCount(); i++) { tb.getDataOutput().write(frameTuple.getFieldData(i), frameTuple.getFieldStart(i), frameTuple.getFieldLength(i)); tb.addFieldEndOffset(); } } @Override public void close() throws HyracksDataException { try { appender.write(writer, true); } catch (Throwable t) { writer.fail(); <|startfocus|> throw t; <|endfocus|> } finally { writer.close(); } } @Override public void flush() throws HyracksDataException { appender.flush(writer); } } 
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  out.write(jsonResponse.toString()); } catch (Exception e) { LOGGER.log(Level.SEVERE, "Failure handling a request", e); out.println(e.getMessage()); e.printStackTrace(out); } } private JsonNode parseHandle(ObjectMapper om, String strHandle) throws IOException { try { JsonNode handleObj = om.readTree(strHandle); return handleObj.get("handle"); } catch (JsonProcessingException e) { LOGGER.log(Level.WARNING, "Invalid handle: \"" + strHandle + "\""); return null; <|startfocus|> } <|endfocus|> } } 
<|startcomment|> MAJOR SonarQube violation: The Cyclomatic Complexity of this method "description" is 37 which is greater than 20 authorized. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AMethodCyclomaticComplexity <|endcomment|>  public String description() { <|startfocus|> switch (this) { <|endfocus|> case CLUSTER_LISTEN_ADDRESS: return "IP Address to bind cluster listener"; case PUBLIC_ADDRESS: return "Default public address that other processes should use to contact this NC. All services " + "will advertise this address unless a service-specific public address is supplied. "; case NCSERVICE_ADDRESS: return "Address the CC should use to contact the NCService associated with this NC"; case NCSERVICE_PORT: return "Port the CC should use to contact the NCService associated with this NC"; case CLUSTER_ADDRESS: return "Cluster Controller address (required unless specified in config file)"; case CLUSTER_PORT: return "Cluster Controller port"; case CLUSTER_LISTEN_PORT: return "IP port to bind cluster listener"; case CLUSTER_PUBLIC_ADDRESS: return "Public IP Address to announce cluster listener"; case CLUSTER_PUBLIC_PORT: return "Public IP port to announce cluster listener"; case NODE_ID:
<|startcomment|> line too long? <|endcomment|>  nc1.start(); NCConfig ncConfig2 = new NCConfig(NC2_ID); ncConfig2.clusterAddress = "localhost"; ncConfig2.clusterPort = 39001; ncConfig2.clusterListenAddress = "127.0.0.1"; ncConfig2.dataListenAddress = "127.0.0.1"; ncConfig2.resultListenAddress = "127.0.0.1"; <|startfocus|> ncConfig2.iodevices = new String [] { System.getProperty("user.dir") + File.separator + "target" + File.separator + "data" + File.separator + "device1" }; <|endfocus|> NodeControllerService nc2Base = new NodeControllerService(ncConfig2); nc2 = Mockito.spy(nc2Base); nc2.start(); hcc = new HyracksConnection(ccConfig.clientListenAddress, ccConfig.clientListenPort); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Starting CC in " + ccRoot.getAbsolutePath()); } } @Test public void DistributedTest() throws Exception { JobSpecification spec1 = UnionTest.createUnionJobSpec(); JobSpecification spec2 = HeapSortMergeTest.createSortMergeJobSpec(); //distribute both jobs
<|startcomment|> why protected? <|endcomment|> import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAccessor; import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAppender; import org.apache.hyracks.dataflow.common.comm.util.FrameUtils; public class PartitionDataWriter implements IFrameWriter { protected final int consumerPartitionCount; protected final IFrameWriter[] pWriters; protected final boolean[] isOpen; protected final FrameTupleAppender[] appenders; protected final FrameTupleAccessor tupleAccessor; protected final ITuplePartitionComputer tpc; protected final IHyracksTaskContext ctx; <|startfocus|> protected boolean[] allocatedFrames; <|endfocus|> public PartitionDataWriter(IHyracksTaskContext ctx, int consumerPartitionCount, IPartitionWriterFactory pwFactory, RecordDescriptor recordDescriptor, ITuplePartitionComputer tpc) throws HyracksDataException { this.consumerPartitionCount = consumerPartitionCount; pWriters = new IFrameWriter[consumerPartitionCount]; isOpen = new boolean[consumerPartitionCount]; allocatedFrames = new boolean[consumerPartitionCount]; appenders = new FrameTupleAppender[consumerPartitionCount]; tupleAccessor = new FrameTupleAccessor(recordDescriptor); this.tpc = tpc; this.ctx = ctx; initializeAppenders(pwFactory); } 
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.control.cc.web.util; import com.fasterxml.jackson.databind.node.ObjectNode; public interface IJSONOutputFunction { <|startfocus|> public ObjectNode invoke(String host, String prefix, String[] arguments) throws Exception; <|endfocus|> } 
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  this.resultSetPartitionId = resultSetPartitionId; this.asyncMode = asyncMode; this.ioManager = ioManager; this.fileFactory = fileFactory; this.frameSize = frameSize; eos = new AtomicBoolean(false); failed = new AtomicBoolean(false); localPageList = new ArrayList<Page>(); fileRef = null; writeFileHandle = null; System.err.println("XXX created " + toString()); } public synchronized void open() { <|startfocus|> System.err.println("XXX open " + toString()); <|endfocus|> size = 0; persistentSize = 0; } public synchronized void close() { System.err.println("XXX close " + toString()); eos.set(true); closeWriteFileHandle(); notifyAll(); } public synchronized void closeAndDelete() { System.err.println("XXX closeAndDelete " + toString()); // Deleting a job is equivalent to aborting the job for all practical purposes, so the same action, needs // to be taken when there are more requests to these result states. failed.set(true); closeWriteFileHandle();
<|startcomment|> Can we implement ProgressPartitionDataWriter as a separate IFrameWriter, rather than an inherited class from PartitionDataWriter. It looks very few things are common between them.. <|endcomment|> import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAccessor; import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAppender; import org.apache.hyracks.dataflow.common.comm.util.FrameUtils; public class PartitionDataWriter implements IFrameWriter { protected final int consumerPartitionCount; protected final IFrameWriter[] pWriters; protected final boolean[] isOpen; protected final FrameTupleAppender[] appenders; protected final FrameTupleAccessor tupleAccessor; protected final ITuplePartitionComputer tpc; protected final IHyracksTaskContext ctx; protected boolean[] allocatedFrames; protected boolean failed = false; public PartitionDataWriter(IHyracksTaskContext ctx, int consumerPartitionCount, IPartitionWriterFactory pwFactory, <|startfocus|> RecordDescriptor recordDescriptor, ITuplePartitionComputer tpc) throws HyracksDataException { <|endfocus|> this.consumerPartitionCount = consumerPartitionCount; pWriters = new IFrameWriter[consumerPartitionCount]; isOpen = new boolean[consumerPartitionCount]; allocatedFrames = new boolean[consumerPartitionCount]; appenders = new FrameTupleAppender[consumerPartitionCount]; tupleAccessor = new FrameTupleAccessor(recordDescriptor); this.tpc = tpc; this.ctx = ctx; initializeAppenders(pwFactory); } protected void initializeAppenders(IPartitionWriterFactory pwFactory) throws HyracksDataException {
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  return new IOManager(devices, Executors.newCachedThreadPool()); } public static void compareWithResult(File expectedFile, File actualFile) throws Exception { BufferedReader readerExpected = new BufferedReader(new FileReader(expectedFile)); BufferedReader readerActual = new BufferedReader(new FileReader(actualFile)); String lineExpected, lineActual; int num = 1; try { while ((lineExpected = readerExpected.readLine()) != null) { lineActual = readerActual.readLine(); <|startfocus|> // Assert.assertEquals(lineExpected, lineActual); <|endfocus|> if (lineActual == null) { throw new Exception("Actual result changed at line " + num + ":\n< " + lineExpected + "\n> "); } if (!equalStrings(lineExpected, lineActual)) { throw new Exception( "Result for changed at line " + num + ":\n< " + lineExpected + "\n> " + lineActual); } ++num; } lineActual = readerActual.readLine(); if (lineActual != null) {
<|startcomment|> MAJOR SonarQube violation: Reduce this anonymous class number of lines from 61 to at most 20, or make it a named class. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1188 <|endcomment|>  public void writeTo(final IFrameWriter writer) { <|startfocus|> Runnable dataPusher = new Runnable() { <|endfocus|> @Override public void run() { try { synchronized (MaterializingPipelinedPartition.this) { while (readHandle == null && !eos && !failed) { MaterializingPipelinedPartition.this.wait(); } } writer.open(); try { long offset = 0; ByteBuffer buffer = ctx.allocateFrame(); boolean done = false; while (!done) { boolean flush; boolean fail; synchronized (MaterializingPipelinedPartition.this) { while (offset >= size && !eos && !failed) { MaterializingPipelinedPartition.this.wait(); } flush = flushRequest; flushRequest = false; // Clear the flush flag. fail = failed; done = eos && offset >= size; } if (fail) { writer.fail(); break; } if (!done) { buffer.clear(); long readLen = ioManager.syncRead(readHandle, offset, buffer);
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  } public synchronized void open() { if (DEBUG) System.err.println("XXX RState open " + toString()); size = 0; persistentSize = 0; } public synchronized void close() { if (DEBUG) System.err.println("XXX RState close " + toString()); eos.set(true); closeWriteFileHandle(); notifyAll(); } public synchronized void closeAndDelete() { <|startfocus|> if (DEBUG) System.err.println("XXX RState closeAndDelete " + toString()); <|endfocus|> // Deleting a job is equivalent to aborting the job for all practical purposes, so the same action, needs // to be taken when there are more requests to these result states. failed.set(true); closeWriteFileHandle(); if (fileRef != null) { fileRef.delete(); } } private void closeWriteFileHandle() { if (writeFileHandle != null) { try { ioManager.close(writeFileHandle); } catch (IOException e) { // Since file handle could not be closed, just ignore. } writeFileHandle = null; }
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  if (DEBUG) System.err.println("XXX Writer open " + toString()); try { datasetPartitionWriter = dpm.createDatasetPartitionWriter(ctx, rsId, ordered, asyncMode, partition, nPartitions); datasetPartitionWriter.open(); resultSerializer.init(); } catch (HyracksException e) { throw HyracksDataException.create(e); } } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { <|startfocus|> if (DEBUG) System.err.println("XXX Writer nextFrame " + toString()); <|endfocus|> frameTupleAccessor.reset(buffer); for (int tIndex = 0; tIndex < frameTupleAccessor.getTupleCount(); tIndex++) { resultSerializer.appendTuple(frameTupleAccessor, tIndex); if (!frameOutputStream.appendTuple()) { frameOutputStream.flush(datasetPartitionWriter); resultSerializer.appendTuple(frameTupleAccessor, tIndex); frameOutputStream.appendTuple(); } } } @Override public void fail() throws HyracksDataException { if (DEBUG) System.err.println("XXX Writer fail " + toString()); failed = true; datasetPartitionWriter.fail(); } @Override
<|startcomment|> Keep the DatasetId? <|endcomment|>  protected final ITypeTraits[] typeTraits; // Comparator factories for key fields of btree tuple. Created in c'tor. protected final IBinaryComparatorFactory[] bcfs; // Hash function factories for key fields of btree tuple. Created in c'tor. protected final IBinaryHashFunctionFactory[] bhffs; protected FileReference file; // Identifier of file BufferCache backing this metadata btree index. protected int fileId; // Resource id of this index for use in transactions. protected long resourceId; // datasetId <|startfocus|> private final int datasetId; <|endfocus|> // Flag of primary index protected final boolean isPrimaryIndex; // PrimaryKeyField indexes used for secondary index operations protected final int[] primaryKeyIndexes; public MetadataIndex(MetadataIndexImmutableProperties indexImmutableProperties, int numFields, IAType[] keyTypes, List<List<String>> keyNames, int numSecondaryIndexKeys, ARecordType payloadType, boolean isPrimaryIndex, int[] primaryKeyIndexes) { // Sanity checks. if (keyTypes.length != keyNames.size()) { throw new AssertionError("Unequal number of key names and key types"); }
<|startcomment|> Keep the enum? <|endcomment|>  Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, tuple)); } @Override public void found(ITupleReference before, ITupleReference after) throws HyracksDataException { if (isFoundNull) { Assert.assertEquals(null, before); } else { Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, before)); } Assert.assertEquals(0, cmp.compare(AbstractModificationOperationCallbackTest.this.tuple, after)); } <|startfocus|> @Override public void setOp(byte op) throws HyracksDataException { // not needed for test case } <|endfocus|> } } 
<|startcomment|> CRITICAL SonarQube violation: Either log or rethrow this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1166 <|endcomment|>  public String toString() { try { ObjectMapper om = new ObjectMapper(); ObjectNode on = om.createObjectNode(); on.put("host", host); on.put("path", path); on.put("statement", JSONUtil.escape(new StringBuilder(), statement).toString()); on.put("pretty", pretty); on.put("mode", mode); on.put("clientContextID", clientContextID); <|startfocus|> return om.writer((new MinimalPrettyPrinter())).writeValueAsString(on); } catch (JsonProcessingException e) { <|endfocus|> return e.getMessage(); }
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|> <|startfocus|> public Date() { <|endfocus|>
<|startcomment|> Would it work to use Java's Collections.singletonList here? <|endcomment|>  } public static JobSpecification buildDropIndexJobSpec(Index index, MetadataProvider metadataProvider, Dataset dataset) throws AlgebricksException { ARecordType recordType = (ARecordType) metadataProvider.findType(dataset.getItemTypeDataverseName(), dataset.getItemTypeName()); ARecordType metaType = DatasetUtil.getMetaType(metadataProvider, dataset); ARecordType enforcedType = null; ARecordType enforcedMetaType = null; if (index.isEnforcingKeyFileds()) { Pair<ARecordType, ARecordType> enforcedTypes = <|startfocus|> TypeUtil.createEnforcedType(recordType, metaType, Lists.newArrayList(index)); <|endfocus|> enforcedType = enforcedTypes.first; enforcedMetaType = enforcedTypes.second; } SecondaryIndexOperationsHelper secondaryIndexHelper = SecondaryIndexOperationsHelper.createIndexOperationsHelper(dataset, index, metadataProvider, physicalOptimizationConfig, recordType, metaType, enforcedType, enforcedMetaType); return secondaryIndexHelper.buildDropJobSpec(); } public static JobSpecification buildSecondaryIndexCreationJobSpec(Dataset dataset, Index index, ARecordType recType, ARecordType metaType, ARecordType enforcedType, ARecordType enforcedMetaType, MetadataProvider metadataProvider) throws AlgebricksException { SecondaryIndexOperationsHelper secondaryIndexHelper =
<|startcomment|> MAJOR SonarQube violation: Make this final field static too. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1170 <|endcomment|> import org.apache.hyracks.algebricks.common.constraints.AlgebricksAbsolutePartitionConstraint; import org.apache.hyracks.algebricks.common.utils.Pair; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.exceptions.HyracksDataException; public class SocketServerInputStreamFactory implements IInputStreamFactory { private static final long serialVersionUID = 1L; <|startfocus|> private final String IP_ADDRESS_REGEX = "^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}:[0-9]{1,5}"; <|endfocus|> private List<Pair<String, Integer>> sockets; private Mode mode = Mode.IP; public static enum Mode { NC, IP } @Override public void configure(Map<String, String> configuration) throws AsterixException { try { sockets = new ArrayList<Pair<String, Integer>>(); String modeValue = configuration.get(ExternalDataConstants.KEY_MODE); if (modeValue != null) { mode = Mode.valueOf(modeValue.trim().toUpperCase()); } String socketsValue = configuration.get(ExternalDataConstants.KEY_SOCKETS); if (socketsValue == null
<|startcomment|> MAJOR SonarQube violation: The type of the "cursorsOrderedByTokens" object should be an interface such as "List" rather than the implementation "ArrayList". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1319 <|endcomment|>  public PartitionedOnDiskInvertedIndexAccessor(OnDiskInvertedIndex index) throws HyracksDataException { super(index, new PartitionedTOccurrenceSearcher(ctx, index)); } } @Override public IIndexAccessor createAccessor(IModificationOperationCallback modificationCallback, ISearchOperationCallback searchCallback) throws HyracksDataException { return new PartitionedOnDiskInvertedIndexAccessor(this); } @Override public boolean openInvertedListPartitionCursors(IInvertedIndexSearcher searcher, IIndexOperationContext ictx, short numTokensLowerBound, short numTokensUpperBound, InvertedListPartitions invListPartitions, <|startfocus|> ArrayList<IInvertedListCursor> cursorsOrderedByTokens) throws HyracksDataException { <|endfocus|> PartitionedTOccurrenceSearcher partSearcher = (PartitionedTOccurrenceSearcher) searcher; OnDiskInvertedIndexOpContext ctx = (OnDiskInvertedIndexOpContext) ictx; ITupleReference lowSearchKey = null; ITupleReference highSearchKey = null; partSearcher.setNumTokensBoundsInSearchKeys(numTokensLowerBound, numTokensUpperBound); if (numTokensLowerBound < 0) { ctx.btreePred.setLowKeyComparator(ctx.prefixSearchCmp); lowSearchKey = partSearcher.getPrefixSearchKey(); } else { ctx.btreePred.setLowKeyComparator(ctx.searchCmp); lowSearchKey = partSearcher.getFullLowSearchKey(); } if (numTokensUpperBound < 0) {
<|startcomment|> RemoteException will be wrapped by MetadataException? It's in the method signature. How about: catch(HyracksDataException | IOException e) <|endcomment|>  try { ITupleReference searchKey = createTuple(dataverse, feedName); FeedTupleTranslator tupleReaderWriter = tupleTranslatorProvider.getFeedTupleTranslator(false); List<Feed> results = new ArrayList<>(); IValueExtractor<Feed> valueExtractor = new MetadataEntityValueExtractor<>(tupleReaderWriter); searchIndex(jobId, MetadataPrimaryIndexes.FEED_DATASET, searchKey, valueExtractor, results); if (!results.isEmpty()) { return results.get(0); } return null; <|startfocus|> } catch (Exception e) { <|endfocus|> throw new MetadataException(e); } } @Override public void dropFeed(JobId jobId, String dataverse, String feedName) throws MetadataException, RemoteException { try { ITupleReference searchKey = createTuple(dataverse, feedName); // Searches the index for the tuple to be deleted. Acquires an S // lock on the 'nodegroup' dataset. ITupleReference tuple = getTupleToBeDeleted(jobId, MetadataPrimaryIndexes.FEED_DATASET, searchKey); deleteTupleFromIndex(jobId, MetadataPrimaryIndexes.FEED_DATASET, tuple); // TODO: Change this to be a BTree specific exception, e.g., // BTreeKeyDoesNotExistException.
<|startcomment|> no remote exception thrown? <|endcomment|>  throws MetadataException, RemoteException { confirmDatatypeIsUnusedByDatatypes(jobId, dataverseName, datatypeName); confirmDatatypeIsUnusedByDatasets(jobId, dataverseName, datatypeName); } private void confirmDatatypeIsUnusedByDatasets(JobId jobId, String dataverseName, String datatypeName) <|startfocus|> throws MetadataException { <|endfocus|> //If any dataset uses this type, throw an error List<Dataset> datasets = getAllDatasets(jobId); for (Dataset set : datasets) { if (set.getItemTypeName().equals(datatypeName) && set.getItemTypeDataverseName().equals(dataverseName)) { throw new MetadataException("Cannot drop type " + dataverseName + "." + datatypeName + " being used by dataset " + set.getDataverseName() + "." + set.getDatasetName()); } } } private void confirmDatatypeIsUnusedByDatatypes(JobId jobId, String dataverseName, String datatypeName) throws MetadataException, RemoteException { //If any datatype uses this type, throw an error //TODO: Currently this loads all types into memory. This will need to be fixed for large numbers of types
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|>  newBuffer = bufferManager.acquireFrame(frameSize); if (newBuffer != null) { return newBuffer; } } // At this point, we have no way to get a frame. throw new HyracksDataException( "Can't allocate one more frame. Assign more memory to InMemoryHashJoin."); } @Override public void close() throws HyracksDataException { ctx.setStateObject(state); } @Override <|startfocus|> public void doFail() throws HyracksDataException { <|endfocus|> } }; return op;
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|>  tb.addField(accessor, tIndex, f); } FrameUtils.appendToWriter(outputWriter, outputAppender, tb.getFieldEndOffsets(), tb.getByteArray(), 0, tb.getSize()); } } @Override public void close() throws HyracksDataException { outputAppender.write(outputWriter, true); } public void setInputIdx(int inputIdx) { this.inputIdx = inputIdx; } public ArrayTupleBuilder getGroupByTupleBuilder() { return gbyTb; } @Override <|startfocus|> public void doFail() throws HyracksDataException { <|endfocus|> } @Override public void doFlush() throws HyracksDataException { outputAppender.flush(outputWriter); } } } 
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  : predEvaluatorFactory.createPredicateEvaluator()); IOperatorNodePushable op = new AbstractUnaryInputSinkOperatorNodePushable() { private HashBuildTaskState state; @Override public void open() throws HyracksDataException { ITuplePartitionComputer hpc0 = new FieldHashPartitionComputerFactory(keys0, hashFunctionFactories) .createPartitioner(); ITuplePartitionComputer hpc1 = new FieldHashPartitionComputerFactory(keys1, hashFunctionFactories) .createPartitioner(); state = new HashBuildTaskState(ctx.getJobletContext().getJobId(), new TaskId(getActivityId(), partition)); <|startfocus|> ISerializableTable table = new SerializableHashTable(tableSize, ctx); <|endfocus|> state.joiner = new InMemoryHashJoin(ctx, tableSize, new FrameTupleAccessor(rd0), hpc0, new FrameTupleAccessor(rd1), hpc1, new FrameTuplePairComparator(keys0, keys1, comparators), isLeftOuter, nullWriters1, table, predEvaluator); } @Override public void nextFrame(ByteBuffer buffer) throws HyracksDataException { ByteBuffer copyBuffer = ctx.allocateFrame(buffer.capacity()); FrameUtils.copyAndFlip(buffer, copyBuffer); state.joiner.build(copyBuffer); } @Override
<|startcomment|> MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 <|endcomment|>  opDesc, feedPolicyEntity.getProperties(), FeedRuntimeType.STORE, false, operandId); opId = metaOp.getOperatorId(); opDesc.setOperatorId(opId); } else { if (opDesc instanceof AlgebricksMetaOperatorDescriptor) { AlgebricksMetaOperatorDescriptor algOp = (AlgebricksMetaOperatorDescriptor) opDesc; for (IPushRuntimeFactory runtimeFactory : algOp.getPipeline().getRuntimeFactories()) { if (runtimeFactory instanceof StreamSelectRuntimeFactory) { ((StreamSelectRuntimeFactory) runtimeFactory).retainMissing(true, 0); } } } <|startfocus|> opId = jobSpec.createOperatorDescriptorId(opDesc); <|endfocus|> } operatorIdMapping.put(oldId, opId); } // copy connectors connectorIdMapping.clear(); for (Entry<ConnectorDescriptorId, IConnectorDescriptor> entry : subJob.getConnectorMap().entrySet()) { IConnectorDescriptor connDesc = entry.getValue(); ConnectorDescriptorId newConnId; if (entry.getKey().getId() == 0) { continue; } if (connDesc instanceof MToNPartitioningConnectorDescriptor) { MToNPartitioningConnectorDescriptor m2nConn = (MToNPartitioningConnectorDescriptor) connDesc;
<|startcomment|> MAJOR SonarQube violation: Refactor this code to not nest more than 4 if/for/while/switch/try statements. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS134 <|endcomment|>  opId = metaOp.getOperatorId(); opDesc.setOperatorId(opId); } else { if (opDesc instanceof AlgebricksMetaOperatorDescriptor) { AlgebricksMetaOperatorDescriptor algOp = (AlgebricksMetaOperatorDescriptor) opDesc; for (IPushRuntimeFactory runtimeFactory : algOp.getPipeline().getRuntimeFactories()) { if (runtimeFactory instanceof StreamSelectRuntimeFactory) { ((StreamSelectRuntimeFactory) runtimeFactory).retainMissing(true, 0); } } } <|startfocus|> opId = jobSpec.createOperatorDescriptorId(opDesc); <|endfocus|> } operatorIdMapping.put(oldId, opId); } // copy connectors connectorIdMapping.clear(); for (Entry<ConnectorDescriptorId, IConnectorDescriptor> entry : subJob.getConnectorMap().entrySet()) { IConnectorDescriptor connDesc = entry.getValue(); ConnectorDescriptorId newConnId; if (entry.getKey().getId() == 0) { continue; } if (connDesc instanceof MToNPartitioningConnectorDescriptor) { MToNPartitioningConnectorDescriptor m2nConn = (MToNPartitioningConnectorDescriptor) connDesc; connDesc = new MToNPartitioningWithMessageConnectorDescriptor(jobSpec, m2nConn.getTuplePartitionComputerFactory());
<|startcomment|> should we make this the last parameter to align with all of the other servlets? <|endcomment|>  case Servlets.CONNECTOR: return new ConnectorApiServlet(ctx, paths, appCtx); case Servlets.SHUTDOWN: return new ShutdownApiServlet(ctx, paths); case Servlets.VERSION: return new VersionApiServlet(ctx, paths); case Servlets.CLUSTER_STATE: return new ClusterApiServlet(ctx, paths); case Servlets.CLUSTER_STATE_NODE_DETAIL: return new NodeControllerDetailsApiServlet(ctx, paths); case Servlets.CLUSTER_STATE_CC_DETAIL: return new ClusterControllerDetailsApiServlet(ctx, paths); case Servlets.DIAGNOSTICS: <|startfocus|> return new DiagnosticsApiServlet(appCtx, ctx, paths); <|endfocus|> default: throw new IllegalStateException(String.valueOf(key)); }
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  LOGGER.info("Ignoring disk-order scan since it's not supported."); } } catch (ClassCastException e) { // Ignore exception because IIndexAccessor sometimes isn't // an ITreeIndexAccessor, e.g., for the LSMBTree. if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info("Ignoring disk-order scan since it's not supported."); } } } @SuppressWarnings("unchecked") <|startfocus|> public Pair<ITupleReference,ITupleReference> insertIntTuples(IIndexTestContext ctx, int numTuples, boolean filtered, Random rnd) throws Exception { <|endfocus|> int fieldCount = ctx.getFieldCount(); int numKeyFields = ctx.getKeyFieldCount(); int[] fieldValues = new int[ctx.getFieldCount()]; // Scale range of values according to number of keys. // For example, for 2 keys we want the square root of numTuples, for 3 // keys the cube root of numTuples, etc. int maxValue = (int) Math.ceil(Math.pow(numTuples, 1.0 / numKeyFields)); MutablePair<ITupleReference,ITupleReference> minMax = null;
<|startcomment|> BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 <|endcomment|>  th.addSuppressed(failFailure); } throw HyracksDataException.create(closeException); } finally { if (index != null) { // If index was opened! try { indexHelper.close(); } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } if (!failed) { try { writer.fail(); } catch (Throwable failFailure) { closeException.addSuppressed(failFailure); } } } finally { <|startfocus|> try { writer.close(); } catch (Throwable th) { if (closeException == null) { closeException = th; } else { closeException.addSuppressed(th); } } <|endfocus|> } } } if (closeException != null) { // NOSONAR false positive throw HyracksDataException.create(closeException); } } @Override protected void doFlush() throws HyracksDataException { writer.flush(); } @Override public void doFail() throws HyracksDataException {
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  if (plot) { PlanPlotter.printOptimizedLogicalPlan(plan); } if (conf.is(SessionConfig.OOB_OPTIMIZED_LOGICAL_PLAN)) { if (conf.is(SessionConfig.FORMAT_ONLY_PHYSICAL_OPS)) { // For Optimizer tests. StringBuilder buffer = new StringBuilder(); PlanPrettyPrinter.printPhysicalOps(plan, buffer, 0); conf.out().print(buffer); } else { printPlanPrefix(conf, "Optimized logical plan"); <|startfocus|> if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { StringBuilder buffer = new StringBuilder(); PlanPrettyPrinter.printPlan(plan, buffer, pvisitor, 0); conf.out().print(buffer); <|endfocus|> } printPlanPostfix(conf); } } } if (!conf.isGenerateJobSpec()) { return null; } builder.setBinaryBooleanInspectorFactory(format.getBinaryBooleanInspectorFactory()); builder.setBinaryIntegerInspectorFactory(format.getBinaryIntegerInspectorFactory()); builder.setComparatorFactoryProvider(format.getBinaryComparatorFactoryProvider()); builder.setExpressionRuntimeProvider( new LogicalExpressionJobGenToExpressionRuntimeProviderAdapter(QueryLogicalExpressionJobGen.INSTANCE));
<|startcomment|> MAJOR SonarQube violation: Merge this if statement with the enclosing one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1066 <|endcomment|>  public boolean handleException(Throwable th) { if (in == null) { return false; } <|startfocus|> if (th instanceof IOException) { if (th instanceof RuntimeDataException && ((RuntimeDataException) th).getErrorCode() == ErrorCode.RECORD_READER_MALFORMED_INPUT_STREAM) { <|endfocus|> if (currentFile != null) { try { logManager.logRecord(currentFile.getAbsolutePath(), "Corrupted input file"); } catch (IOException e) { LOGGER.warn("Filed to write to feed log file", e); } LOGGER.warn("Corrupted input file: " + currentFile.getAbsolutePath()); } try { advance(); return true; } catch (Exception e) { LOGGER.warn("An exception was thrown while trying to skip a file", e); } } } LOGGER.warn("Failed to recover from failure", th); return false;
<|startcomment|> MAJOR SonarQube violation: Extract this nested code block into a method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1199 <|endcomment|>  tail.add(v); FunctionalDependency pk = new FunctionalDependency(keys, tail); context.addPrimaryKey(pk); } } exprRef.setValue(new VariableReferenceExpression(v)); return true; } else { boolean pushed = false; for (Mutable<ILogicalExpression> argRef : f.getArguments()) { if (pushFieldLoads(argRef, topOp, context)) { pushed = true; } } return pushed; } } case CONSTANT: <|startfocus|> case VARIABLE: case RUNTIME_CONTEXT_VAR: { <|endfocus|> return false; } default: { assert false; throw new IllegalArgumentException(); } } } private static void pushFieldAssign(AssignOperator a2, AbstractLogicalOperator topOp, IOptimizationContext context) throws AlgebricksException { if (topOp.getInputs().size() == 1 && !topOp.hasNestedPlans()) { Mutable<ILogicalOperator> topChild = topOp.getInputs().get(0); // plugAccessAboveOp(a2, topChild, context); List<Mutable<ILogicalOperator>> a2InptList = a2.getInputs(); a2InptList.clear();
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  | ((long) (data[start + 4] & 0xff) << 24) | ((long) (data[start + 5] & 0xff) << 16) | ((long) (data[start + 6] & 0xff) << 8) | ((long) (data[start + 7] & 0xff))); break; default: <|startfocus|> throw new IOException("Can't convert integer types. The source type should be one of TINYINT/16/32/64."); <|endfocus|> } // Boundary check switch (targetType) { case TINYINT: if (num > Byte.MAX_VALUE || num < Byte.MIN_VALUE) { throw new IOException("Source value " + num + " is out of range that TINYINT can hold - TINYINT.MAX_VALUE:" + Byte.MAX_VALUE + ", TINYINT.MIN_VALUE:" + Byte.MIN_VALUE); } break; case SMALLINT: if (num > Short.MAX_VALUE || num < Short.MIN_VALUE) { throw new IOException("Source value " + num
<|startcomment|> MAJOR SonarQube violation: Split this 127 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  IIOManager ioManager = serviceCtx.getIoManager(); FileReference file = ioManager.resolve(resource.getPath()); return LSMBTreeUtil.createExternalBTreeWithBuddy(ioManager, file, appCtx.getBufferCache(), appCtx.getFileMapManager(), typeTraits, btreeCmpFactories, appCtx.getBloomFilterFalsePositiveRate(), mergePolicyFactory.createMergePolicy(mergePolicyProperties, appCtx.getDatasetLifecycleManager()), opTrackerProvider.getOperationTracker(serviceCtx), appCtx.getLSMIOScheduler(), <|startfocus|> ioOpCallbackFactory.createIoOpCallback(), buddyBtreeFields, -1, true, metadataPageManagerFactory, partition()); <|endfocus|> } } 
<|startcomment|> MAJOR SonarQube violation: Split this 125 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  protected final IHyracksTaskContext ctx; protected final float fillFactor; protected final boolean verifyInput; protected final long numElementsHint; protected final boolean checkIfEmptyIndex; protected final IIndexDataflowHelper indexHelper; protected final RecordDescriptor recDesc; protected final PermutingFrameTupleReference tuple = new PermutingFrameTupleReference(); protected FrameTupleAccessor accessor; protected IIndex index; protected IIndexBulkLoader bulkLoader; <|startfocus|> public IndexBulkLoadOperatorNodePushable(IIndexDataflowHelperFactory indexDataflowHelperFactory, IHyracksTaskContext ctx, int partition, int[] fieldPermutation, float fillFactor, boolean verifyInput, long numElementsHint, boolean checkIfEmptyIndex, RecordDescriptor recDesc) throws HyracksDataException { <|endfocus|> this.ctx = ctx; this.indexHelper = indexDataflowHelperFactory.create(ctx, partition); this.fillFactor = fillFactor; this.verifyInput = verifyInput; this.numElementsHint = numElementsHint; this.checkIfEmptyIndex = checkIfEmptyIndex; this.recDesc = recDesc; tuple.setFieldPermutation(fieldPermutation); } @Override public void open() throws HyracksDataException { accessor = new FrameTupleAccessor(recDesc); indexHelper.open(); index = indexHelper.getIndexInstance();
<|startcomment|> MAJOR SonarQube violation: Split this 130 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public IScalarEvaluatorFactory createEvaluatorFactory(IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() { private static final long serialVersionUID = 1L; private byte[] result; @Override public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException { <|startfocus|> return new AbstractUnaryStringStringEval(ctx, args[0], GetRuntimeContextVariableDescriptor.this.getIdentifier()) { <|endfocus|> @Override protected void process(UTF8StringPointable inputString, IPointable resultPointable) throws IOException { result = ctx.getRuntimeContextVariable(inputString.getByteArray(), inputString.getStartOffset(), inputString.getLength()); } @Override void writeResult(IPointable resultPointable) throws IOException { resultPointable.set(result, 0, result.length - 1); } }; } };
<|startcomment|> I searched in the codebase, but couldn't find callers of the first two methods? <|endcomment|>  import org.apache.hyracks.api.application.INCServiceContext; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.api.io.FileReference; import org.apache.hyracks.api.io.FileSplit; import org.apache.hyracks.dataflow.std.file.IFileSplitProvider; public interface IVirtualBufferCacheProvider extends Serializable { <|startfocus|> List<IVirtualBufferCache> getVirtualBufferCaches(IHyracksTaskContext ctx, IFileSplitProvider fileSplitProvider) throws HyracksDataException; List<IVirtualBufferCache> getVirtualBufferCaches(INCServiceContext ctx, FileSplit fileSplit) throws HyracksDataException; <|endfocus|> List<IVirtualBufferCache> getVirtualBufferCaches(INCServiceContext ctx, FileReference fileRef) throws HyracksDataException; } 
<|startcomment|> MAJOR SonarQube violation: '>' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  Boolean matchFlag = true; int matchOptNum = 0; // Here StreamRecordReaderProvider will try its best to find the most suitable // record reader by matching options. However, if there is a option key error, // it will be ignored and a potential wrong record reader with less required options // will be returned. for (String configKey : configPair.getLeft()) { <|startfocus|> if (configKey.length()>0 && !configuration.containsKey(configKey)) { <|endfocus|> matchFlag = false; break; } if (configKey.length() > 0) { matchOptNum++; } } if (matchFlag && matchOptNum >= maxOptNum) { clazz = configPair.getRight(); maxOptNum = matchOptNum; } } if (clazz != null) { return clazz; } else { throw new AsterixException(ErrorCode.PROVIDER_STREAM_RECORD_READER_WRONG_CONFIGURATION, format); } } public static Class getRecordReaderClazz(Map<String, String> configuration) throws AsterixException { String format = configuration.get(ExternalDataConstants.KEY_FORMAT); 
<|startcomment|> 1. What is the advantage of doing ClassName(message) -vs- ClassName: message like the JDK does? 2. Either way I'd guard this in a msg == null ? "" : ... since NullPointerException(null) isn't very friendly. <|endcomment|>  pw.print("\t\""); pw.print(AbstractQueryApiServlet.ResultFields.ERRORS.str()); pw.print("\": [{ \n"); printField(pw, QueryServiceServlet.ErrorField.CODE.str(), "1"); String msg = rootCause.getMessage(); if (!(rootCause instanceof AlgebricksException || rootCause instanceof HyracksException || rootCause instanceof TokenMgrError || rootCause instanceof org.apache.asterix.aqlplus.parser.TokenMgrError)) { <|startfocus|> msg = rootCause.getClass().getSimpleName() + "(" + msg + ")"; <|endfocus|> } printField(pw, QueryServiceServlet.ErrorField.MSG.str(), JSONUtil.escape(msg), addStack);
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  try { nodes = metadataProvider.findNodes(nodeGroupName); MetadataManager.INSTANCE.commitTransaction(mdTxnCtx); } catch (Exception e) { abort(e, e, mdTxnCtx); throw e; } finally { metadataProvider.getLocks().unlock(); metadataProvider.getLocks().reset(); } return nodes; } // Creates a node group for the rebalance target dataset. private static void createNodeGroup(String ngName, Set<String> ncNames, MetadataProvider metadataProvider) throws Exception { <|startfocus|> MetadataTransactionContext mdTxnCtx = MetadataManager.INSTANCE.beginTransaction(); metadataProvider.setMetadataTxnContext(mdTxnCtx); <|endfocus|> MetadataLockManager.INSTANCE.acquireNodeGroupWriteLock(metadataProvider.getLocks(), ngName); try { NodeGroup ng = MetadataManager.INSTANCE.getNodegroup(mdTxnCtx, ngName); if (ng == null) { MetadataManager.INSTANCE.addNodegroup(mdTxnCtx, new NodeGroup(ngName, new ArrayList<>(ncNames))); } MetadataManager.INSTANCE.commitTransaction(mdTxnCtx); } catch (Exception e) { abort(e, e, mdTxnCtx); throw e; } finally { metadataProvider.getLocks().unlock();
<|startcomment|> Why HTML and not JSON? <|endcomment|>  protected void post(IServletRequest request, IServletResponse response) { PrintWriter out = response.writer(); ObjectMapper om = new ObjectMapper(); ObjectNode jsonResponse = om.createObjectNode(); try { // Sets the content type. <|startfocus|> HttpUtil.setContentType(response, HttpUtil.ContentType.TEXT_HTML, HttpUtil.Encoding.UTF8); <|endfocus|> // Gets dataverse, dataset, and target nodes for rebalance. String dataverseName = request.getParameter("dataverseName"); String datasetName = request.getParameter("datasetName"); String nodes = request.getParameter("nodes"); if (dataverseName == null || datasetName == null || nodes == null) { sendResponse(out, jsonResponse, response, HttpResponseStatus.BAD_REQUEST, "dataverseName, datasetName, or nodes is not given"); return; } String nodesString = StringUtils.strip(nodes, "\"'").trim(); String[] targetNodes = nodesString.split(","); if ("".equals(nodesString)) { sendResponse(out, jsonResponse, response, HttpResponseStatus.BAD_REQUEST, "target nodes should not be empty"); return; } 
<|startcomment|> MAJOR SonarQube violation: Remove this use of "Thread.sleep()". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2925 <|endcomment|>  // get all components List<ILSMMemoryComponent> memComponents = lsmBtree.getMemoryComponents(); List<ILSMDiskComponent> diskComponents = lsmBtree.getDiskComponents(); Assert.assertEquals(9, diskComponents.size()); Assert.assertTrue(memComponents.get(lsmBtree.getCurrentMemoryComponentIndex()).isModified()); Searcher firstSearcher = new Searcher(nc, ctx, dataset, storageManager, lsmBtree, TOTAL_NUM_OF_RECORDS); // wait till firstSearcher enter the components <|startfocus|> while (!firstSearcher.entered()) { Thread.sleep(1); } <|endfocus|> // now that we enetered, we will rollback ILSMIndexAccessor lsmAccessor = lsmBtree.createAccessor(NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); // rollback a memory component lsmAccessor.rollback(c -> (c instanceof ILSMMemoryComponent && !((ILSMMemoryComponent) c).isModified()) || c instanceof ILSMDiskComponent); // now that the rollback has completed, we will unblock the search lsmBtree.addSearchCallback(sem -> sem.release()); lsmBtree.allowSearch(1); Assert.assertTrue(firstSearcher.result()); // search now and ensure
<|startcomment|> What does "Eager" mean here? <|endcomment|>  List<String> nodeControllers = new ArrayList<>(); for (Set<String> ncCollection : nodeControllersCollection) { nodeControllers.addAll(ncCollection); } return nodeControllers; } public static Map<InetAddress, Set<String>> getNodeControllerMap(ICcApplicationContext appCtx) throws HyracksDataException { Map<InetAddress, Set<String>> map = new HashMap<>(); appCtx.getServiceContext().getCCContext().getIPAddressNodeMap(map); return map; } <|startfocus|> public static Map<InetAddress, Set<String>> getEagerNodeControllerMap(ICcApplicationContext appCtx) { <|endfocus|> ClusterControllerService ccs = (ClusterControllerService) appCtx.getServiceContext().getControllerService(); INodeManager nodeManager = ccs.getNodeManager(); return nodeManager.getIpAddressNodeNameMap(); } public static JobSpecification createJobSpecification(ICcApplicationContext appCtx) { CompilerProperties compilerProperties = appCtx.getCompilerProperties(); int frameSize = compilerProperties.getFrameSize(); return new JobSpecification(frameSize); } } 
<|startcomment|> MAJOR SonarQube violation: Split this 139 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  runner += tuple.getFieldLength(i); } // write value fields for (int i = inputKeyFieldCount; i < inputTotalFieldCount; i++) { System.arraycopy(tuple.getFieldData(i), tuple.getFieldStart(i), targetBuf, runner, tuple.getFieldLength(i)); runner += tuple.getFieldLength(i); } //set antimatter bit if necessary <|startfocus|> //this is used when we flush an in-memory rtree into disk, and insert anti-matter tuples from in-memory buddy btree into disk rtree <|endfocus|> if (antimatterAware) { if (tuple instanceof ILSMTreeTupleReference && ((ILSMTreeTupleReference) tuple).isAntimatter()) { setAntimatterBit(targetBuf, targetOff); } } //this is used during creating secondary index operation, where we explicitly insert some antimatter tuple if (isDelete) { setAntimatterBit(targetBuf, targetOff); } return runner - targetOff;
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "searchCallback". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|>  public RTreeAccessor(RTree rtree, IModificationOperationCallback modificationCallback, ISearchOperationCallback searchCallback, int[] logTupleFields) { this.rtree = rtree; <|startfocus|> this.ctx = rtree.createOpContext(modificationCallback, logTupleFields); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Remove this use of "Thread.sleep()". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2925 <|endcomment|>  ILSMIndexAccessor mergeAccessor = lsmBtree.createAccessor(NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); // select the components to merge... the last three List<ILSMDiskComponent> mergedComponents = new ArrayList<>(); long lsn = AbstractLSMIOOperationCallback.getTreeIndexLSN(diskComponents.get(0).getMetadata()); for (int i = 0; i < 3; i++) { mergedComponents.add(diskComponents.get(i)); } mergeAccessor.scheduleMerge(lsmBtree.getIOOperationCallback(), mergedComponents); <|startfocus|> while (merger.mergeCount() != 1) { Thread.sleep(5); } <|endfocus|> // now that we enetered, we will rollback ILSMIndexAccessor lsmAccessor = lsmBtree.createAccessor(NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); lsmAccessor.rollback(c -> { try { return (c instanceof ILSMMemoryComponent && ((ILSMMemoryComponent) c).isModified()) || (c instanceof ILSMDiskComponent && AbstractLSMIOOperationCallback .getTreeIndexLSN(((ILSMDiskComponent) c).getMetadata()) >= lsn); } catch (HyracksDataException e) { e.printStackTrace(); return false; } });
<|startcomment|> MAJOR SonarQube violation: Remove this use of "Thread.sleep()". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2925 <|endcomment|>  List<ILSMDiskComponent> diskComponents = lsmBtree.getDiskComponents(); Assert.assertEquals(9, diskComponents.size()); Assert.assertTrue(memComponents.get(lsmBtree.getCurrentMemoryComponentIndex()).isModified()); searchAndAssertCount(nc, ctx, dataset, storageManager, TOTAL_NUM_OF_RECORDS); // disable flushes lsmBtree.getFlushCallbacks().clear(); Flusher firstFlusher = new Flusher(lsmBtree); dsLifecycleMgr.flushDataset(dataset.getDatasetId(), true); <|startfocus|> while (firstFlusher.flushCount() != 1) { Thread.sleep(5); } <|endfocus|> // now that we enetered, we will rollback ILSMIndexAccessor lsmAccessor = lsmBtree.createAccessor(NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); // rollback a memory component lsmAccessor.rollback(memoryComponentsPredicate); // now that the rollback has completed, we will search searchAndAssertCount(nc, ctx, dataset, storageManager, TOTAL_NUM_OF_RECORDS - RECORDS_PER_COMPONENT); //unblock the flush int cancelledFlushes = TestLsmBtreeIoOpCallbackFactory.INSTANCE.getCancelledFlushes(); int expectedCancelledFlushes = cancelledFlushes + 1; lsmBtree.allowFlush(1); while (cancelledFlushes < expectedCancelledFlushes) { Thread.sleep(5);
<|startcomment|> Move the if branch to be CASE in side the next switch(opType)? <|endcomment|>  // to is still busy flushing its data to disk. Thus, the notification that was issued upon scheduling the flush // is not enough. opTracker.notifyAll(); break; default: break; } } else { switch (c.getState()) { case INACTIVE: lsmIndex.addInactiveDiskComponent((AbstractLSMDiskComponent) c); break; default: break; } <|startfocus|> if (opType == LSMOperationType.ROLLBACK) { lsmIndex.getDiskComponents().remove(c); } <|endfocus|> } i++; } ctx.setAccessingComponents(false); // Then, perform any action that is needed to be taken based on the operation type. if (!failedOperation) { switch (opType) { case FLUSH: // newComponent is null if the flush op. was not performed. if (newComponent != null) { lsmIndex.addDiskComponent(newComponent); if (replicationEnabled) { componentsToBeReplicated.clear(); componentsToBeReplicated.add(newComponent);
<|startcomment|> BLOCKER SonarQube violation: Catch Exception instead of Throwable. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1181 <|endcomment|>  } abstract protected RunFileWriter getRunFileWriter() throws HyracksDataException; abstract protected IFrameWriter getFlushableFrameWriter(RunFileWriter writer) throws HyracksDataException; protected void flushFramesToRun() throws HyracksDataException { getSorter().sort(); RunFileWriter runWriter = getRunFileWriter(); IFrameWriter flushWriter = getFlushableFrameWriter(runWriter); flushWriter.open(); try { getSorter().flush(flushWriter); <|startfocus|> } catch (Throwable th) { try { flushWriter.fail(); } catch (Throwable secondFailure) { th.addSuppressed(secondFailure); } throw th; <|endfocus|> } finally { flushWriter.close(); } generatedRunFileReaders.add(runWriter.createDeleteOnCloseReader()); getSorter().reset(); } @Override public void fail() throws HyracksDataException { } @Override public List<GeneratedRunFileReader> getRuns() { return generatedRunFileReaders; } } 
<|startcomment|> MAJOR SonarQube violation: Move this method into "RTreeAccessor". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3398 <|endcomment|>  keySerdes, strBuilder, cmp); } } else { node.releaseReadLatch(); bufferCache.unpin(node); } } catch (Exception e) { node.releaseReadLatch(); bufferCache.unpin(node); e.printStackTrace(); } } private RTreeOpContext createOpContext(IModificationOperationCallback modificationCallback) { return new RTreeOpContext((IRTreeLeafFrame) leafFrameFactory.createFrame(), (IRTreeInteriorFrame) interiorFrameFactory.createFrame(), freePageManager, cmpFactories, modificationCallback); } <|startfocus|> <|endfocus|> private ICachedPage findLeaf(RTreeOpContext ctx) throws HyracksDataException { int pageId = rootPage; boolean writeLatched = false; boolean readLatched = false; boolean succeeded = false; ICachedPage node = null; boolean isLeaf = false; long pageLsn = 0, parentLsn = 0; try { while (true) { if (!writeLatched) { node = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, pageId), false); ctx.interiorFrame.setPage(node); isLeaf = ctx.interiorFrame.isLeaf(); if (isLeaf) { node.acquireWriteLatch();
<|startcomment|> MAJOR SonarQube violation: Extract this nested try block into a separate method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1141 <|endcomment|>  } if (flush) { writer.flush(); } } } catch (Exception e) { writer.fail(); throw e; } finally { try { if (readHandle != null) { ioManager.close(readHandle); // close is idempotent. } } finally { writer.close(); } } } catch (Exception e) { LOGGER.log(Level.SEVERE, e.getMessage(), e); } } <|startfocus|> }; pushDataThread = new Thread(dataPusher); executor.execute(pushDataThread); <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "registry". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|> <|startfocus|> public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { <|endfocus|> return new AsterixVirtualBufferCacheProvider(json.get("datasetId").asInt());
<|startcomment|> MAJOR SonarQube violation: Remove this unused method parameter "registry". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1172 <|endcomment|> import org.apache.hyracks.api.io.IPersistedResourceRegistry; import org.apache.hyracks.storage.am.lsm.common.api.ILSMIOOperationScheduler; import org.apache.hyracks.storage.am.lsm.common.api.ILSMIOOperationSchedulerProvider; public enum SynchronousSchedulerProvider implements ILSMIOOperationSchedulerProvider { INSTANCE { private static final long serialVersionUID = 1L; @Override public JsonNode toJson(IPersistedResourceRegistry registry) throws HyracksDataException { return registry.getClassIdentifier(getClass(), serialVersionUID); } }; <|startfocus|> public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) { <|endfocus|> return INSTANCE; } @Override public ILSMIOOperationScheduler getIoScheduler(INCServiceContext ctx) { return SynchronousScheduler.INSTANCE; } } 
<|startcomment|> BLOCKER SonarQube violation: Change this condition so that it does not always evaluate to "false" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2583 <|endcomment|>  jobs.add(IndexUtil.buildDropIndexJobSpec(index, metadataProvider, dataset, true)); } // Files should always be cleaned up even if the rebalance is interrupted. InterruptedException interruptedException = null; for (JobSpecification jobSpec : jobs) { boolean dropped = false; do { try { JobUtils.runJob(hcc, jobSpec, true); dropped = true; } catch (InterruptedException e) { interruptedException = e; } } while (!dropped); } if (interruptedException != null) { throw interruptedException; } } // Acquires a read lock for the dataverse and a write lock for the dataset, in order to populate the dataset. <|startfocus|> private static void writeLockDataset(LockList locks, Dataset dataset) throws AsterixException { <|endfocus|> MetadataLockManager.INSTANCE.acquireDataverseReadLock(locks, dataset.getDataverseName()); MetadataLockManager.INSTANCE.acquireDatasetWriteLock(locks, dataset.getDataverseName() + "." + dataset.getDatasetName()); } // Creates and loads all secondary indexes for the rebalance target dataset.
<|startcomment|> MAJOR SonarQube violation: Extract this nested try block into a separate method. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1141 <|endcomment|>  ILSMIndexAccessor indexAccessor = index.createAccessor(NoOpOperationCallback.INSTANCE, NoOpOperationCallback.INSTANCE); if (logRecord.getNewOp() == IndexOperation.INSERT.ordinal()) { indexAccessor.forceInsert(logRecord.getNewValue()); } else if (logRecord.getNewOp() == IndexOperation.DELETE.ordinal()) { <|startfocus|> indexAccessor.forceDelete(logRecord.getNewValue()); <|endfocus|> } else { throw new IllegalStateException("Unsupported OperationType: " + logRecord.getNewOp()); } } catch (Exception e) { throw new IllegalStateException("Failed to redo", e); }
<|startcomment|> MAJOR SonarQube violation: Split this 142 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public ITupleReference getFilterMaxTuple() { <|startfocus|> ILSMComponentFilter filter = operationalComponents.get(outputElement == null ? 0 : outputElement.cursorIndex).getLSMComponentFilter(); <|endfocus|> return filter == null ? null : filter.getMaxTuple();
<|startcomment|> MAJOR SonarQube violation: Split this 137 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|> import org.kohsuke.args4j.Argument; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.OptionDef; import org.kohsuke.args4j.spi.OptionHandler; import org.kohsuke.args4j.spi.Parameters; import org.kohsuke.args4j.spi.Setter; public class SocketTweetGeneratorConfig { <|startfocus|> @Option(name = "-p", aliases = "--handle-range-start", usage = "Starting handle number for the set of data generators (default = 0)") <|endfocus|> private int partitionRangeStart = 0; public int getPartitionRangeStart() { return partitionRangeStart; } @Option(name = "-d", aliases = { "--datagen-duration" }, usage = "Duration in seconds to run data generation") private int duration = -1; public int getDataGenDuration() { return duration; } @Option(name = "-qd", aliases = { "--querygen-duration" }, usage = "Duration in seconds to run query generation") private int queryDuration = -1; 
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "doesSIdxSearchGenerateNoFalsePositiveResults". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  analysisCtx, context, indexOnlyPlanInfo); isIndexOnlyPlan = indexOnlyPlanInfo.first; secondaryKeyFieldUsedAfterSelectOp = indexOnlyPlanInfo.second; requireVerificationAfterSIdxSearch = indexOnlyPlanInfo.third; doesSIdxSearchGenerateNoFalsePositiveResults = indexOnlyPlanInfo.fourth; doesSIdxSearchCoverAllPredicates = indexOnlyPlanInfo.fifth; } else { // An index on an external dataset can't be optimized for the index-only plan. isIndexOnlyPlan = false; <|startfocus|> doesSIdxSearchGenerateNoFalsePositiveResults = false; <|endfocus|> } } analysisCtx.setIndexOnlyPlanInfo(indexOnlyPlanInfo); // R-Tree specific: if the verification after a SIdx search is required, then // there are false positives from a secondary index search. if (requireVerificationAfterSIdxSearch) { doesSIdxSearchGenerateNoFalsePositiveResults = false; } ILogicalOperator primaryIndexUnnestOp = createSecondaryToPrimaryPlan(afterSelectRefs, selectRef, selectOp.getCondition(), subTree.getAssignsAndUnnestsRefs(), subTree, null, chosenIndex, analysisCtx, AccessMethodUtils.retainInputs(subTree.getDataSourceVariables(), subTree.getDataSourceRef().getValue(), afterSelectRefs),
<|startcomment|> MAJOR SonarQube violation: Introduce a new variable instead of reusing the parameter "originalEvaluatorClassName". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1226 <|endcomment|>  * @param action, * a user definition action for the generated byte code. * @throws IOException * @throws ClassNotFoundException */ private static void generateEvaluatorClassBinary(String originalEvaluatorClassName, String suffixForGeneratedClass, int evalCounter, List<Pair<String, String>> nameMappings, ClassLoader classLoader, ClassByteCodeAction action) throws IOException, ClassNotFoundException { // Convert class names. <|startfocus|> originalEvaluatorClassName = CodeGenHelper.toInternalClassName(originalEvaluatorClassName); if (originalEvaluatorClassName.equals(OBJECT_CLASS_NAME)) { <|endfocus|> return; } String targetEvaluatorClassName = CodeGenHelper.generateClassName(originalEvaluatorClassName, EVALUATOR + suffixForGeneratedClass, evalCounter); // Generates code for super classes except java.lang.Object. Class<?> evaluatorClass = classLoader.loadClass(CodeGenHelper.toJdkStandardName(originalEvaluatorClassName)); generateEvaluatorClassBinary(evaluatorClass.getSuperclass().getName(), suffixForGeneratedClass, evalCounter, nameMappings, classLoader, action); // Adds name mapping. nameMappings.add(Pair.of(originalEvaluatorClassName, targetEvaluatorClassName)); nameMappings.add(Pair.of(CodeGenHelper.toJdkStandardName(originalEvaluatorClassName),
<|startcomment|> MAJOR SonarQube violation: Make second a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.hyracks.algebricks.common.utils; public class Quadruple<T1, T2, T3, T4> { <|startfocus|> public T1 first; public T2 second; public T3 third; public T4 fourth; <|endfocus|> public Quadruple(T1 first, T2 second, T3 third, T4 fourth) { this.first = first; this.second = second; this.third = third; this.fourth = fourth; } @Override public String toString() { return first + "," + second + ", " + third + ", " + fourth; } @Override public int hashCode() {
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|>  new FrameTuplePairComparator(keys0, keys1, comparators), isLeftOuter, nullWriters1, table, predEvaluator, null); bufferForPartitions = new IFrame[state.nPartitions]; state.fWriters = new RunFileWriter[state.nPartitions]; for (int i = 0; i < state.nPartitions; i++) { bufferForPartitions[i] = new VSizeFrame(ctx); } ftappender.reset(inBuffer, true); } @Override <|startfocus|> public void fail(HyracksDataException cause) throws HyracksDataException { <|endfocus|> } private void closeWriter(int i) throws HyracksDataException { RunFileWriter writer = state.fWriters[i]; if (writer != null) { writer.close(); } } private void write(int i, ByteBuffer head) throws HyracksDataException { RunFileWriter writer = state.fWriters[i]; if (writer == null) { FileReference file = ctx.getJobletContext() .createManagedWorkspaceFile(BuildAndPartitionActivityNode.class.getSimpleName()); writer = new RunFileWriter(file, ctx.getIoManager()); writer.open();
<|startcomment|> MAJOR SonarQube violation: Remove this useless assignment to local variable "searchNotNecessaryFromNow". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1854 <|endcomment|>  } return dataset; } public static INodeDomain findNodeDomain(MetadataTransactionContext mdTxnCtx, String nodeGroupName) throws AlgebricksException { NodeGroup nodeGroup = MetadataManager.INSTANCE.getNodegroup(mdTxnCtx, nodeGroupName); List<String> partitions = new ArrayList<>(); for (String location : nodeGroup.getNodeNames()) { int numPartitions = ClusterStateManager.INSTANCE.getNodePartitionsCount(location); for (int i = 0; i < numPartitions; i++) { partitions.add(location); } } return new DefaultNodeGroupDomain(partitions); } <|startfocus|> <|endfocus|> public static Feed findFeed(MetadataTransactionContext mdTxnCtx, String dataverse, String feedName) throws AlgebricksException { try { return MetadataManager.INSTANCE.getFeed(mdTxnCtx, dataverse, feedName); } catch (MetadataException e) { throw new AlgebricksException(e); } } public static FeedPolicyEntity findFeedPolicy(MetadataTransactionContext mdTxnCtx, String dataverse, String policyName) throws AlgebricksException { try { return MetadataManager.INSTANCE.getFeedPolicy(mdTxnCtx, dataverse, policyName); } catch (MetadataException e) { throw new AlgebricksException(e); } }
<|startcomment|> same <|endcomment|>  super(spec, 0, 1); } @Override public IOperatorNodePushable createPushRuntime(final IHyracksTaskContext ctx, IRecordDescriptorProvider recordDescProvider, int partition, int nPartitions) throws HyracksDataException { return new AbstractUnaryOutputSourceOperatorNodePushable() { @Override public void initialize() throws HyracksDataException { try { writer.open(); while (true) { synchronized (this) { wait(); } } } catch (Exception e) { <|startfocus|> writer.fail(HyracksDataException.create(e)); <|endfocus|> } finally { writer.close(); } } }; } } class SleepOperatorDescriptor extends AbstractSingleActivityOperatorDescriptor { private static final long serialVersionUID = 1L; public SleepOperatorDescriptor(JobSpecification spec) { super(spec, 1, 1); } @Override public IOperatorNodePushable createPushRuntime(final IHyracksTaskContext ctx, IRecordDescriptorProvider recordDescProvider, int partition, int nPartitions) throws HyracksDataException { return new AbstractUnaryInputUnaryOutputOperatorNodePushable() { @Override public void open() throws HyracksDataException { writer.open(); } @Override
<|startcomment|> MAJOR SonarQube violation: '=' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  throws AlgebricksException { AlgebricksAppendable plan = addIndent(indent).append("\"operator\":\""+opSignature + "\""); if(op.getVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\":["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); <|startfocus|> buffer.append("\""+str(v)+"\""); first=false; <|endfocus|> } buffer.append("]"); } buffer.append(",\n"); addIndent(indent).append("\"expressions\":\""+op.getExpressionRef().getValue().accept(exprVisitor, indent).replace('"',' ')+"\""); appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(),indent); return null; } @Override public Void visitDataScanOperator(DataSourceScanOperator op, Integer indent) throws AlgebricksException { AlgebricksAppendable plan = addIndent(indent).append( "\"operator\":\"data-scan\""); if(op.getProjectVariables().size() > 0) {
<|startcomment|> MAJOR SonarQube violation: '+' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  addIndent(0).append(",\n"); addIndent(indent).append("\"variables\":["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); if(op.getDataSource()!=null){ addIndent(0).append(",\n"); <|startfocus|> addIndent(indent).append("\"data-source\":\""+op.getDataSource()+"\""); <|endfocus|> } } appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(),indent); return null; } private Void appendFilterInformation(AlgebricksAppendable plan, List<LogicalVariable> minFilterVars, List<LogicalVariable> maxFilterVars, Integer indent) throws AlgebricksException { if (minFilterVars != null || maxFilterVars != null) { plan.append(",\n"); addIndent(indent); plan.append("\"with-filter-on\":{"); } if (minFilterVars != null) { buffer.append("\n");
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  addIndent(indent).append("\"operator\":\"exchange\""); return null; } @Override public Void visitScriptOperator(ScriptOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"script\""); if(op.getInputVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"in\":["); boolean first = true; <|startfocus|> for (LogicalVariable v : op.getInputVariables()){ if(!first) <|endfocus|> buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } if(op.getOutputVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"out\":["); boolean first = true; for (LogicalVariable v : op.getOutputVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } return null; } 
<|startcomment|> MAJOR SonarQube violation: '+' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  return null; } @Override public Void visitInsertDeleteUpsertOperator(InsertDeleteUpsertOperator op, Integer indent) throws AlgebricksException { String header = "\"operator\":\""+getIndexOpString(op.getOperation())+"\",\n"; addIndent(indent).append(header); addIndent(indent).append(str("\"data-source\":\""+op.getDataSource()+"\",\n")); addIndent(indent).append("\"from-record\":\"") <|startfocus|> .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent)+"\""); <|endfocus|> if (op.getAdditionalNonFilteringExpressions() != null) { buffer.append(",\n\"meta\":\""); pprintExprList(op.getAdditionalNonFilteringExpressions(), 0); buffer.append("\""); } buffer.append(",\n"); addIndent(indent).append("\"partitioned-by\":{"); pprintExprList(op.getPrimaryKeyExpressions(), 0); buffer.append("}"); if (op.getOperation() == Kind.UPSERT) { addIndent(indent).append(",\n\"out\":{\n");
<|startcomment|> MAJOR SonarQube violation: '+' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  if (fst) { fst = false; } else { buffer.append(","); } if (ve.first != null) { buffer.append("{\"variable\":\""+ve.first.toString().replace('"',' ') + "\"," +"\"expression\":\"" + ve.second.toString().replace('"',' ')+"\"}"); } else { <|startfocus|> buffer.append("{\"expression\":\""+ve.second.getValue().accept(exprVisitor, indent).replace('"',' ')+"\"}"); <|endfocus|> } } buffer.append("]"); } } 
<|startcomment|> CRITICAL SonarQube violation: Make this "public static planFormat" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 <|endcomment|> import org.apache.hyracks.http.server.utils.HttpUtil.Encoding; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.*; import java.util.List; import java.util.concurrent.ConcurrentMap; import java.util.logging.Level; import java.util.logging.Logger; import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_CONNECTION_ATTR; import static org.apache.asterix.api.http.servlet.ServletConstants.HYRACKS_DATASET_ATTR; public class ApiServlet extends AbstractServlet { <|startfocus|> public static PlanFormat planFormat; public static PlanFormat opPlanFormat; <|endfocus|> private static final Logger LOGGER = Logger.getLogger(ApiServlet.class.getName()); public static final String HTML_STATEMENT_SEPARATOR = "<!-- BEGIN -->"; private final ICcApplicationContext appCtx; private final ILangCompilationProvider aqlCompilationProvider; private final ILangCompilationProvider sqlppCompilationProvider; private final IStatementExecutorFactory statementExectorFactory; private final IStorageComponentProvider componentProvider; public ApiServlet(ConcurrentMap<String, Object> ctx, String[] paths, ICcApplicationContext appCtx, ILangCompilationProvider aqlCompilationProvider, ILangCompilationProvider sqlppCompilationProvider, IStatementExecutorFactory statementExecutorFactory, IStorageComponentProvider componentProvider) { super(ctx, paths);
<|startcomment|> MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  if(op.getVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\" :["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } <|startfocus|> if(op.getExpressions().size()>0) { addIndent(0).append(",\n"); pprintExprList(op.getExpressions(), indent); <|endfocus|> } return null; } @Override public Void visitEmptyTupleSourceOperator(EmptyTupleSourceOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"empty-tuple-source\""); return null; } @Override public Void visitGroupByOperator(GroupByOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"group-by\"" ); if(op.isGroupAll()) { buffer.append(",\n");
<|startcomment|> MAJOR SonarQube violation: '+' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  buffer.append(",\n"); if (op.getTopK() != -1) { addIndent(indent).append("\"topK\":\"" + op.getTopK() + "\",\n"); } String fst = getOrderString(p.first); addIndent(indent).append("\"first\":" + fst + ",\n"); <|startfocus|> addIndent(indent).append("\"second\":\""+p.second.getValue().accept(exprVisitor, indent).replace('"',' ') + "\""); <|endfocus|> } return null; } private String getOrderString(OrderOperator.IOrder first) { switch (first.getKind()) { case ASC: return "\"ASC\""; case DESC: return "\"DESC\""; default: return first.getExpressionRef().toString(); } } @Override public Void visitAssignOperator(AssignOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"assign\""); if(op.getVariables().size() > 0) { addIndent(0).append(",\n");
<|startcomment|> MAJOR SonarQube violation: '+' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  addIndent(indent).append("\"partitioned-by\":{"); pprintExprList(op.getKeyExpressions(), indent); addIndent(indent).append("}"); return null; } @Override public Void visitSelectOperator(SelectOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"select\",\n"); <|startfocus|> addIndent(indent).append("\"expressions\":\""+op.getCondition().getValue().accept(exprVisitor, indent).replace('"',' ')+"\""); <|endfocus|> return null; } @Override public Void visitProjectOperator(ProjectOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"project\""); if(op.getVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\":["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } return null; }
<|startcomment|> MAJOR SonarQube violation: Use isEmpty() to check whether the collection is empty or not. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1155 <|endcomment|>  if (j > 0) { buffer.append(", "); } buffer.append("\""+str(op.getInputVariables(i).get(j))+"\""); } buffer.append(']'); } buffer.append("]"); return null; } @Override public Void visitUnnestOperator(UnnestOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"unnest\""); <|startfocus|> if(op.getVariables().size() > 0) { <|endfocus|> addIndent(0).append(",\n"); addIndent(indent).append("\"variables\" :["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } if (op.getPositionalVariable() != null) { buffer.append(",\n"); addIndent(indent).append("\"position\":\"" + op.getPositionalVariable()+"\""); } buffer.append(",\n");
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  boolean first = true; for (LogicalVariable v : op.getProjectVariables()){ if(!first) buffer.append(","); buffer.append("\""+str(v)+"\""); first=false; } buffer.append("]"); } if(op.getVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\":["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); <|startfocus|> buffer.append("\""+str(v)+"\""); first=false; <|endfocus|> } buffer.append("]"); if(op.getDataSource()!=null){ addIndent(0).append(",\n"); addIndent(indent).append("\"data-source\":\""+op.getDataSource()+"\""); } } appendFilterInformation(plan, op.getMinFilterVars(), op.getMaxFilterVars(),indent); return null; } private Void appendFilterInformation(AlgebricksAppendable plan, List<LogicalVariable> minFilterVars,
<|startcomment|> MAJOR SonarQube violation: '+' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  pprintExprList(op.getPrimaryKeyExpressions(), 0); buffer.append("}"); if (op.getOperation() == Kind.UPSERT) { addIndent(indent).append(",\n\"out\":{\n"); addIndent(indent).append("\"record-before-upsert\":\"" + op.getBeforeOpRecordVar()+"\""); if((op.getBeforeOpAdditionalNonFilteringVars() != null)){ buffer.append(",\n"); <|startfocus|> addIndent(indent).append("\"additional-before-upsert\":\"" + op.getBeforeOpAdditionalNonFilteringVars()+"\""); <|endfocus|> } addIndent(indent).append("}"); } if (op.isBulkload()) { buffer.append(",\n"); addIndent(indent).append("\"bulkload\":\"true\""); } return null; } @Override public Void visitIndexInsertDeleteUpsertOperator(IndexInsertDeleteUpsertOperator op, Integer indent) throws AlgebricksException { String header = getIndexOpString(op.getOperation()); addIndent(indent).append("\"operator\":\""+header+"\",\n");
<|startcomment|> MAJOR SonarQube violation: '+' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  } public static void printOperatorJson(AbstractLogicalOperator op, LogicalOperatorPrettyPrintVisitorJson pvisitor, int indent) throws AlgebricksException { final AlgebricksAppendable out = pvisitor.get(); pad(out, indent); // append(out,"{\"Operator\":\""); appendln(out,"{"); op.accept(pvisitor, indent+1); indent++; appendln(out,","); pad(out, indent); if(op.getOperatorID()==0){ op.setOperatorID(operatorID); operatorID++; } <|startfocus|> append(out,"\"operator-id\":"+op.getOperatorID()); <|endfocus|> IPhysicalOperator pOp = op.getPhysicalOperator(); if(pOp!=null){ appendln(out,","); pad(out, indent); String pOperator = "\"physical-operator\":\"" + pOp.toString() + "\""; append(out,pOperator); } appendln(out,","); pad(out,indent); append(out,"\"execution-mode\":\"" + op.getExecutionMode()+'"'); if (op.getInputs().size()>0) { appendln(out,","); pad(out,indent); appendln(out, "\"inputs\":[");
<|startcomment|> MAJOR SonarQube violation: Split this 148 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  queryJobSpec = null; dmlJobs = null; if (queryText == null) { return; } int ch; StringBuilder builder = new StringBuilder(); while ((ch = queryText.read()) != -1) { builder.append((char) ch); } IParser parser = parserFactory.createParser(builder.toString()); List<Statement> statements = parser.parse(); MetadataManager.INSTANCE.init(); <|startfocus|> SessionConfig conf = new SessionConfig(OutputFormat.ADM, optimize, true, generateBinaryRuntime,PlanFormat.CLEAN_JSON,PlanFormat.CLEAN_JSON); <|endfocus|> conf.setOOBData(false, printRewrittenExpressions, printLogicalPlan, printOptimizedPlan, printJob); if (printPhysicalOpsOnly) { conf.set(SessionConfig.FORMAT_ONLY_PHYSICAL_OPS, true); } SessionOutput output = new SessionOutput(conf, writer); IStatementExecutor translator = statementExecutorFactory.create(appCtx, statements, output, compilationProvider, storageComponentProvider); translator.compileAndExecute(hcc, null, QueryTranslator.ResultDelivery.IMMEDIATE, null, new IStatementExecutor.Stats()); writer.flush(); } public void execute() throws Exception { if (dmlJobs != null) {
<|startcomment|> MAJOR SonarQube violation: '+' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  return null; } @Override public Void visitUnnestOperator(UnnestOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"unnest\""); if(op.getVariables().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\" :["); boolean first = true; for (LogicalVariable v : op.getVariables()){ if(!first) buffer.append(","); <|startfocus|> buffer.append("\""+str(v)+"\""); first=false; <|endfocus|> } buffer.append("]"); } if (op.getPositionalVariable() != null) { buffer.append(",\n"); addIndent(indent).append("\"position\":\"" + op.getPositionalVariable()+"\""); } buffer.append(",\n"); addIndent(indent).append("\"expressions\":\""+op.getExpressionRef().getValue().accept(exprVisitor, indent).replace('"',' ')+"\""); return null; } @Override public Void visitLeftOuterUnnestOperator(LeftOuterUnnestOperator op, Integer indent) throws AlgebricksException {
<|startcomment|> MAJOR SonarQube violation: Make this "nodeId" field final. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1165 <|endcomment|>  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.api.exceptions; import java.io.IOException; import java.io.Serializable; import org.apache.hyracks.api.util.ErrorMessageUtil; public class HyracksException extends IOException { private static final long serialVersionUID = 1L; public static final int UNKNOWN = 0; private final String component; private final int errorCode; private final Serializable[] params; <|startfocus|> protected String nodeId; <|endfocus|> private transient volatile String msgCache; public static HyracksException create(Throwable cause) { if (cause instanceof HyracksException) { return (HyracksException) cause; } return new HyracksException(cause); } public static HyracksException create(int code, Serializable... params) { return new HyracksException(ErrorCode.HYRACKS, code, ErrorCode.getErrorMessage(code), params); } public static HyracksException create(int code, Throwable cause, Serializable... params) { return new HyracksException(ErrorCode.HYRACKS, code, ErrorCode.getErrorMessage(code), cause, params); } 
<|startcomment|> CRITICAL SonarQube violation: Make the enclosing method "static" or remove this set. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2696 <|endcomment|>  printPlanPrefix(conf, "Logical plan"); if (rwQ != null || (statement != null && statement.getKind() == Kind.LOAD)) { StringBuilder buffer = new StringBuilder(); PlanPrettyPrinter.printPlan(plan, buffer, pvisitor, 0); conf.out().print(buffer); } printPlanPostfix(conf); } //print the plot for the logical plan AsterixExternalProperties xProps = AsterixAppContextInfo.getInstance().getExternalProperties(); Boolean plot = xProps.getIsPlottingEnabled(); if (plot) { PlanPlotter.printLogicalPlan(plan); } <|startfocus|> AsterixCompilerProperties compilerProperties = AsterixAppContextInfo.getInstance().getCompilerProperties(); <|endfocus|> int frameSize = compilerProperties.getFrameSize(); int sortFrameLimit = (int) (compilerProperties.getSortMemorySize() / frameSize); int groupFrameLimit = (int) (compilerProperties.getGroupMemorySize() / frameSize); int joinFrameLimit = (int) (compilerProperties.getJoinMemorySize() / frameSize); OptimizationConfUtil.getPhysicalOptimizationConfig().setFrameSize(frameSize); OptimizationConfUtil.getPhysicalOptimizationConfig().setMaxFramesExternalSort(sortFrameLimit);
<|startcomment|> MAJOR SonarQube violation: Use isEmpty() to check whether the collection is empty or not. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1155 <|endcomment|>  addIndent(indent).append("\"operator\":\"write\""); if (op.getExpressions().size() > 0) { addIndent(0).append(",\n"); pprintExprList(op.getExpressions(), indent); } return null; } @Override public Void visitDistributeResultOperator(DistributeResultOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"distribute-result\""); <|startfocus|> if (op.getExpressions().size() > 0) { <|endfocus|> addIndent(0).append(",\n"); pprintExprList(op.getExpressions(), indent); } return null; } @Override public Void visitWriteResultOperator(WriteResultOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"load\",\n"); addIndent(indent).append(str(op.getDataSource())).append("\"from\":") .append(op.getPayloadExpression().getValue().accept(exprVisitor, indent) + ",\n"); addIndent(indent).append("\"partitioned-by\":{"); pprintExprList(op.getKeyExpressions(), indent); addIndent(indent).append("}");
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  case UPSERT: return "upsert-into"; } return null; } @Override public Void visitTokenizeOperator(TokenizeOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"tokenize\""); if (op.getTokenizeVars().size() > 0) { addIndent(0).append(",\n"); addIndent(indent).append("\"variables\" :["); boolean first = true; for (LogicalVariable v : op.getTokenizeVars()) { if (!first) <|startfocus|> buffer.append(","); <|endfocus|> buffer.append("\"" + str(v) + "\""); first = false; } buffer.append("]"); } if (op.getSecondaryKeyExpressions().size() > 0) { addIndent(0).append(",\n"); pprintExprList(op.getSecondaryKeyExpressions(), indent); } return null; } @Override public Void visitSinkOperator(SinkOperator op, Integer indent) throws AlgebricksException { addIndent(indent).append("\"operator\":\"sink\""); return null; } 
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  argEvaluator.evaluate(tuple, argPointable); inputPointable.set(argPointable); cast(result); } protected void cast(IPointable result) throws HyracksDataException { inputPointable.accept(castVisitor, arg); result.set(resultPointable); } // Allocates the result pointable. private final IVisitablePointable allocatePointable(IAType typeForPointable, IAType typeForOtherSide) { <|startfocus|> // Temp: System.out.println("CastTypeEvaluator::allocatePointable\ntypeForPointable\n" + typeForPointable + "\ntypeForOtherSide\n" + typeForOtherSide); <|endfocus|> if (!typeForPointable.equals(BuiltinType.ANY)) { return allocator.allocateFieldValue(typeForPointable); } return allocatePointableForAny(typeForOtherSide); } // Allocates an input or result pointable if the input or required type is ANY. private IVisitablePointable allocatePointableForAny(IAType type) { ATypeTag tag = type.getTypeTag(); // Temp: System.out.println("CastTypeEvaluator::allocatePointableForAny\ntype\n" + type + " tag " + tag); switch (tag) { case OBJECT: return allocator.allocateFieldValue(DefaultOpenFieldType.NESTED_OPEN_RECORD_TYPE); case ARRAY:
<|startcomment|> MAJOR SonarQube violation: Move the "Logical plan" string literal on the left side of this string comparison. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1132 <|endcomment|>  private void printPlanPrefix(SessionOutput output, String planName) { if (output.config().is(SessionConfig.FORMAT_HTML)) { output.out().println("<h4>" + planName + ":</h4>"); if (planName.equalsIgnoreCase("Logical plan")) { output.out().println("<pre class = query-plan>"); } else if (planName.equalsIgnoreCase("Optimized logical plan")) { output.out().println("<pre class = query-optimized-plan>"); } else { <|startfocus|> output.out().println("<pre>"); <|endfocus|> } } else { output.out().println("----------" + planName + ":"); } 
<|startcomment|> CRITICAL SonarQube violation: Make the enclosing method "static" or remove this set. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2696 <|endcomment|>  String printRewrittenExprParam = request.getParameter("print-rewritten-expr-tree"); String printLogicalPlanParam = request.getParameter("print-logical-plan"); String printOptimizedLogicalPlanParam = request.getParameter("print-optimized-logical-plan"); String printJob = request.getParameter("print-job"); String executeQuery = request.getParameter("execute-query"); try { <|startfocus|> HttpUtil.setContentType(response, HttpUtil.ContentType.TEXT_HTML, HttpUtil.Encoding.UTF8); <|endfocus|> } catch (IOException e) { LOGGER.log(Level.WARNING, "Failure setting content type", e); response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR); return; } try { IHyracksClientConnection hcc = (IHyracksClientConnection) ctx.get(HYRACKS_CONNECTION_ATTR); IHyracksDataset hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); if (hds == null) { synchronized (ctx) { hds = (IHyracksDataset) ctx.get(HYRACKS_DATASET_ATTR); if (hds == null) { hds = new HyracksDataset(hcc, ResultReader.FRAME_SIZE, ResultReader.NUM_READERS); ctx.put(HYRACKS_DATASET_ATTR, hds); } } }
<|startcomment|> MAJOR SonarQube violation: Missing curly brace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00121 <|endcomment|>  public boolean flipUpdated() { if (updateAware) { final byte mask = (byte) (1 << 6); if ((buf[tupleStartOff] & mask) == 0) { buf[tupleStartOff] |= mask; return true; } else { buf[tupleStartOff] &= ~mask; return false; } } else <|startfocus|> return false; <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Move the "Logical plan" string literal on the left side of this string comparison. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1132 <|endcomment|>  if (q == null) { return null; } if (!conf.is(SessionConfig.FORMAT_ONLY_PHYSICAL_OPS) && conf.is(SessionConfig.OOB_EXPR_TREE)) { conf.out().println(); printPlanPrefix(conf, "Expression tree"); q.accept(astPrintVisitorFactory.createLangVisitor(conf.out()), 0); printPlanPostfix(conf); } IQueryRewriter rw = rewriterFactory.createQueryRewriter(); rw.rewrite(declaredFunctions, q, metadataProvider, new LangRewritingContext(q.getVarCounter())); <|startfocus|> return new Pair<>(q, q.getVarCounter()); <|endfocus|> } public JobSpecification compileQuery(IClusterInfoCollector clusterInfoCollector, MetadataProvider metadataProvider, Query rwQ, int varCounter, String outputDatasetName, SessionConfig conf, ICompiledDmlStatement statement) throws AlgebricksException, RemoteException, ACIDException { if (!conf.is(SessionConfig.FORMAT_ONLY_PHYSICAL_OPS) && conf.is(SessionConfig.OOB_REWRITTEN_EXPR_TREE)) { conf.out().println(); printPlanPrefix(conf, "Rewritten expression tree"); if (rwQ != null) { rwQ.accept(astPrintVisitorFactory.createLangVisitor(conf.out()), 0); } printPlanPostfix(conf);
<|startcomment|> set to -1 if framesLimit is -1 <|endcomment|>  int framesLimit) throws HyracksDataException { this.groupFields = groupFields; this.comparators = comparators; if (framesLimit > 0 && framesLimit <= 2) { throw HyracksDataException.create(ErrorCode.ILLEGAL_MEMORY_BUDGET, "GROUP BY", Long.toString(((long) (framesLimit)) * ctx.getInitialFrameSize()), Long.toString(2L * ctx.getInitialFrameSize())); } <|startfocus|> this.memoryLimit = ((long) (framesLimit - 2)) * ctx.getInitialFrameSize(); // Deducts input/output frames. <|endfocus|> this.aggregator = aggregatorFactory.createAggregator(ctx, inRecordDesc, outRecordDesc, groupFields, groupFields, writer, this.memoryLimit); this.aggregateState = aggregator.createAggregateStates(); copyFrame = new VSizeFrame(ctx); inFrameAccessor = new FrameTupleAccessor(inRecordDesc); copyFrameAccessor = new FrameTupleAccessor(inRecordDesc); copyFrameAccessor.reset(copyFrame.getBuffer()); VSizeFrame outFrame = new VSizeFrame(ctx); FrameTupleAppender appender = new FrameTupleAppender(); appender.reset(outFrame, true); appenderWrapper = new FrameTupleAppenderWrapper(appender, writer); 
<|startcomment|> MAJOR SonarQube violation: Rename "hcc" which hides the field declared at line 109. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AHiddenFieldCheck <|endcomment|>  return new FullApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(AQL), getStatementExecutorFactory(), componentProvider); case Servlets.AQL_QUERY: return new QueryApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(AQL), getStatementExecutorFactory(), componentProvider); case Servlets.AQL_UPDATE: return new UpdateApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(AQL), getStatementExecutorFactory(), componentProvider); case Servlets.AQL_DDL: <|startfocus|> return new DdlApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(AQL), <|endfocus|> getStatementExecutorFactory(), componentProvider); case Servlets.SQLPP: return new FullApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(SQLPP), getStatementExecutorFactory(), componentProvider); case Servlets.SQLPP_QUERY: return new QueryApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(SQLPP), getStatementExecutorFactory(), componentProvider); case Servlets.SQLPP_UPDATE: return new UpdateApiServlet(ctx, paths, appCtx, ccExtensionManager.getCompilationProvider(SQLPP), getStatementExecutorFactory(), componentProvider); case Servlets.SQLPP_DDL:
<|startcomment|> MAJOR SonarQube violation: "dataStartOff" is the name of a field in "TypeAwareTupleReference". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2387 <|endcomment|>  private final int inputKeyFieldCount; //double field count for mbr secondary key of an input tuple private final int inputTotalFieldCount; //total field count (key + value fields) of an input tuple. private final int storedKeyFieldCount; //double field count to be stored for the mbr secondary key private final int nullFlagsBytes; private final int[] decodedFieldSlots; private byte[] buf; private int tupleStartOff; private int dataStartOff; private final boolean antimatterAware; <|startfocus|> private VarLenIntDecoder encDec = VarLenIntEncoderDecoder.createDecoder(); <|endfocus|> public LSMRTreeTupleReferenceForPointMBR(ITypeTraits[] typeTraits, int keyFieldCount, int valueFieldCount, boolean antimatterAware) { super(typeTraits); this.inputKeyFieldCount = keyFieldCount; this.inputTotalFieldCount = keyFieldCount + valueFieldCount; this.storedKeyFieldCount = keyFieldCount / 2; this.nullFlagsBytes = getNullFlagsBytes(); decodedFieldSlots = new int[inputTotalFieldCount]; this.antimatterAware = antimatterAware; } @Override public void resetByTupleOffset(byte[] buf, int tupleStartOff) {
<|startcomment|> If we use these strings to trigger a specific behavior, we should have then as string constants or as enums. <|endcomment|>  private void printPlanPrefix(SessionOutput output, String planName) { if (output.config().is(SessionConfig.FORMAT_HTML)) { output.out().println("<h4>" + planName + ":</h4>"); <|startfocus|> String lplan = "Logical plan"; String oplan = "Optimized logical plan"; <|endfocus|> if (lplan.equalsIgnoreCase(planName)) { output.out().println("<pre class = query-plan>"); } else if (oplan.equalsIgnoreCase(planName)) { output.out().println("<pre class = query-optimized-plan>"); } else { output.out().println("<pre>"); } } else { output.out().println("----------" + planName + ":"); } 
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|>  private final IIndexBulkLoader bulkLoader; public LSMIndexBulkLoader(IIndexBulkLoader bulkLoader) { this.bulkLoader = bulkLoader; } @Override public ITupleReference delete(ITupleReference tuple) throws HyracksDataException { ILSMTreeTupleWriter tupleWriter = (ILSMTreeTupleWriter) ((AbstractTreeIndexBulkLoader) bulkLoader).getLeafFrame().getTupleWriter(); tupleWriter.setAntimatter(true); try { bulkLoader.add(tuple); } finally { tupleWriter.setAntimatter(false); } return tuple; } @Override <|startfocus|> public void cleanupArtifacts() throws HyracksDataException { <|endfocus|> } @Override public ITupleReference add(ITupleReference tuple) throws HyracksDataException { bulkLoader.add(tuple); return tuple; } @Override public void end() throws HyracksDataException { bulkLoader.end(); } @Override public void abort() throws HyracksDataException { bulkLoader.abort(); } } 
<|startcomment|> CRITICAL SonarQube violation: Make this "public static TRACE_LOG_LEVEL" field final Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1444 <|endcomment|>  * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.util.trace; import java.util.logging.Level; import java.util.logging.Logger; /** * https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit */ public class ExecutionTrace { public static Logger TRACE_LOG = Logger.getLogger(ExecutionTrace.class.getName()); public static Level TRACE_LOG_LEVEL = Level.INFO; <|startfocus|> public static ExecutionTrace INSTANCE = new ExecutionTrace(); <|endfocus|> protected final int pid = 1; public enum Phase { // Duration Events B, // begin E, // end // Complete Events X, // Instant Events I, // Counter Events C, // Async Events b, // nestable start n, // nestable instant e, // nestable end // Flow Events s, // start t, // step f, // end // Object Events N, // created O, // snapshot D // destroyed
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  return ioOp.isFinished(); } @Override public List<ILSMIOOperation> getDependingOps() { return ioOp.getDependingOps(); } } class ComparableTracedIOOperation extends TracedIOOperation implements Comparable<ILSMIOOperation> { protected ComparableTracedIOOperation(ILSMIOOperation ioOp, Tracer trace) { super(ioOp, trace); System.err.println("COMPARE ComparableTracedIOOperation"); } @Override public int compareTo(ILSMIOOperation other) { <|startfocus|> System.err.println("COMPARE compareTo " + other.getClass().getSimpleName()); if (other instanceof ComparableTracedIOOperation) { other = ((ComparableTracedIOOperation) other).getIoOp(); return ((Comparable) this.ioOp).compareTo(other); <|endfocus|> } throw new IllegalArgumentException("Comparing ioOps of type " + this.ioOp.getClass().getSimpleName() + " and " + other.getClass().getSimpleName()); } } 
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  final long tid = tracer.durationB(getDevice().toString(), cat, null); try { return ioOp.call(); } finally { tracer.durationE(tid, "{\"optional\":\"value\"}"); } } @Override public ILSMIndexAccessor getAccessor() { return ioOp.getAccessor(); } } class ComparableTracedIOOperation extends TracedIOOperation implements Comparable<ILSMIOOperation> { protected ComparableTracedIOOperation(ILSMIOOperation ioOp, Tracer trace) { super(ioOp, trace); <|startfocus|> System.err.println("COMPARE ComparableTracedIOOperation"); <|endfocus|> } @Override public int compareTo(ILSMIOOperation other) { System.err.println("COMPARE compareTo " + other.getClass().getSimpleName()); if (other instanceof ComparableTracedIOOperation) { other = ((ComparableTracedIOOperation) other).getIoOp(); return ((Comparable) this.ioOp).compareTo(other); } throw new IllegalArgumentException("Comparing ioOps of type " + this.ioOp.getClass().getSimpleName() + " and " + other.getClass().getSimpleName()); } } 
<|startcomment|> How come the constant folding rule did not take care of is_missing() already? it is supposed to rewrite f(g(CONST_X) into CONST_Y. So why is this not happening for not(is_missing(const))? If it did happen then we would not need to modify the constant folding rule at all. <|endcomment|>  return new Pair<>(false, expr); } @Override public Pair<Boolean, ILogicalExpression> visitScalarFunctionCallExpression(ScalarFunctionCallExpression expr, Void arg) throws AlgebricksException { boolean changed = changeRec(expr, arg); if (!checkArgs(expr) || !expr.isFunctional()) { return new Pair<>(changed, expr); } <|startfocus|> //IS_MISSING is always false for constant args if (expr.getFunctionIdentifier().equals(BuiltinFunctions.IS_MISSING)) { return new Pair<>(true, new ConstantExpression(new AsterixConstantValue(ABoolean.FALSE))); } <|endfocus|> // Skip Constant Folding for the record-related functions. if (FUNC_ID_SET_THAT_SHOULD_NOT_BE_APPLIED.contains(expr.getFunctionIdentifier())) { return new Pair<>(false, null); } //Current List SerDe assumes a strongly typed list, so we do not constant fold the list constructors if they are not strongly typed if (expr.getFunctionIdentifier().equals(BuiltinFunctions.UNORDERED_LIST_CONSTRUCTOR) || expr.getFunctionIdentifier().equals(BuiltinFunctions.ORDERED_LIST_CONSTRUCTOR)) {
<|startcomment|> MAJOR SonarQube violation: '||' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  public class STIsCollectionDescriptor extends AbstractSTSingleGeometryDescriptor { private static final long serialVersionUID = 1L; public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { @Override public IFunctionDescriptor createFunctionDescriptor() { return new STIsCollectionDescriptor(); } }; @Override protected Object evaluateOGCGeometry(OGCGeometry geometry) throws HyracksDataException { String type = geometry.geometryType(); <|startfocus|> return "GeometryCollection".equals(type)||"MultiLineString".equals(type)||"MultiPoint".equals(type)||"MultiPolygon".equals(type); <|endfocus|> } @Override public FunctionIdentifier getIdentifier() { return BuiltinFunctions.ST_IS_COLLECTION; } } 
<|startcomment|> MAJOR SonarQube violation: Replace the synchronized class "Stack" by an unsynchronized one such as "Deque". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1149 <|endcomment|>  public LogicalOperatorPrettyPrintVisitorJson() { super(); } public LogicalOperatorPrettyPrintVisitorJson(AlgebricksAppendable buffer, ILogicalExpressionVisitor<String, Integer> exprVisitor) { super(buffer, exprVisitor); } public LogicalOperatorPrettyPrintVisitorJson(AlgebricksAppendable buffer) { super(buffer); } public LogicalOperatorPrettyPrintVisitorJson(Appendable app) { super(app); } IdCounter idCounter = new IdCounter(); public class IdCounter { private int id; <|startfocus|> private Stack<Integer> prefix; <|endfocus|> public IdCounter() { prefix = new Stack<Integer>(); prefix.push(1); this.id = 0; } public void previousPrefix() { this.id = prefix.pop(); } public void nextPrefix() { prefix.push(this.id); this.id = 0; } public String printOperatorId(AbstractLogicalOperator op) { String stringPrefix = ""; Object[] values = this.prefix.toArray(); for (Object val : values) { stringPrefix = (stringPrefix.isEmpty()) ? val.toString() : stringPrefix + "." + val.toString(); }
<|startcomment|> code format <|endcomment|>  public IScalarEvaluator createScalarEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException { return new IScalarEvaluator() { private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage(); private final DataOutput out = resultStorage.getDataOutput(); private final IPointable argPtr0 = new VoidPointable(); private final IPointable argPtr1 = new VoidPointable(); private final IScalarEvaluator eval0 = args[0].createScalarEvaluator(ctx); private final IScalarEvaluator eval1 = args[1].createScalarEvaluator(ctx); <|startfocus|> @Override @SuppressWarnings("unchecked") <|endfocus|> public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException { resultStorage.reset(); eval0.evaluate(tuple, argPtr0); eval1.evaluate(tuple, argPtr1); try { byte[] bytes0 = argPtr0.getByteArray(); int offset0 = argPtr0.getStartOffset(); int len0 = argPtr0.getLength(); byte[] bytes1 = argPtr1.getByteArray(); int offset1 = argPtr1.getStartOffset(); int len1 = argPtr1.getLength(); 
<|startcomment|> fix import * <|endcomment|> import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier; import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator; import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory; import org.apache.hyracks.api.context.IHyracksTaskContext; import org.apache.hyracks.api.dataflow.value.ISerializerDeserializer; import org.apache.hyracks.api.exceptions.HyracksDataException; import org.apache.hyracks.data.std.api.IPointable; import org.apache.hyracks.data.std.primitive.VoidPointable; import org.apache.hyracks.data.std.util.ArrayBackedValueStorage; import org.apache.hyracks.dataflow.common.data.accessors.IFrameTupleReference; <|startfocus|> import java.io.*; <|endfocus|> import java.util.ArrayList; import java.util.List; public class STPolygonizeDescriptor extends AbstractScalarFunctionDynamicDescriptor { public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() { @Override public IFunctionDescriptor createFunctionDescriptor() { return new STPolygonizeDescriptor(); } }; private static final long serialVersionUID = 1L; @Override public FunctionIdentifier getIdentifier() { return BuiltinFunctions.ST_POLYGONIZE; } @Override public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) { return new IScalarEvaluatorFactory() {
<|startcomment|> MAJOR SonarQube violation: Rename this field "INSTANCE" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 <|endcomment|>  * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ package org.apache.hyracks.util.trace; import java.util.HashMap; import java.util.Map; public class TraceCategoryRegistry { <|startfocus|> public static TraceCategoryRegistry INSTANCE = new TraceCategoryRegistry(); <|endfocus|> static final int NO_CATEGORIES = 64; private Map<String, Long> categories = new HashMap<>(); private int bitPos = 0; public long register(String name) { if (categories.containsKey(name)) { throw new IllegalStateException("Category " + name + " already exsits"); } if (bitPos > NO_CATEGORIES - 1) { throw new IllegalStateException("Cannot add category " + name); } final long categoryCode = 1L << bitPos++; categories.put(name, categoryCode); return categoryCode; } 
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|>  public interface IHyracksClientInterface { public ClusterControllerInfo getClusterControllerInfo() throws Exception; public JobStatus getJobStatus(JobId jobId) throws Exception; public JobId startJob(byte[] acggfBytes, EnumSet<JobFlag> jobFlags) throws Exception; public JobId startJob(JobId jobId, Map<byte[], byte[]> jobParameters) throws Exception; public void cancelJob(JobId jobId) throws Exception; public JobId distributeJob(byte[] acggfBytes) throws Exception; <|startfocus|> public JobId destroyJob(JobId jobId) throws Exception; <|endfocus|> public NetworkAddress getDatasetDirectoryServiceInfo() throws Exception; public void waitForCompletion(JobId jobId) throws Exception; public Map<String, NodeControllerInfo> getNodeControllersInfo() throws Exception; public ClusterTopology getClusterTopology() throws Exception; public void deployBinary(List<URL> binaryURLs, DeploymentId deploymentId) throws Exception; public void unDeployBinary(DeploymentId deploymentId) throws Exception; public JobId startJob(DeploymentId deploymentId, byte[] acggfBytes, EnumSet<JobFlag> jobFlags) throws Exception; public JobInfo getJobInfo(JobId jobId) throws Exception; 
<|startcomment|> CRITICAL SonarQube violation: Define and throw a dedicated exception instead of using a generic one. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00112 <|endcomment|> import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.api.job.JobStatus; import org.apache.hyracks.api.job.PreDistributedId; import org.apache.hyracks.api.partitions.PartitionId; import org.apache.hyracks.control.common.job.TaskAttemptDescriptor; public interface INodeController { public void startTasks(DeploymentId deploymentId, JobId jobId, byte[] planBytes, List<TaskAttemptDescriptor> taskDescriptors, Map<ConnectorDescriptorId, IConnectorPolicy> connectorPolicies, <|startfocus|> Set<JobFlag> flags, Map<byte[], byte[]> jobParameters, PreDistributedId preDistributedId) throws Exception; <|endfocus|> public void abortTasks(JobId jobId, List<TaskAttemptId> tasks) throws Exception; public void cleanUpJoblet(JobId jobId, JobStatus status) throws Exception; public void reportPartitionAvailability(PartitionId pid, NetworkAddress networkAddress) throws Exception; public void deployBinary(DeploymentId deploymentId, List<URL> url) throws Exception; public void undeployBinary(DeploymentId deploymentId) throws Exception; public void distributeJob(PreDistributedId preDistributedId, byte[] planBytes) throws Exception; public void destroyJob(PreDistributedId preDistributedId) throws Exception; 
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|>  return getDatasetLifecycle(datasetID).getVirtualBufferCaches(); } @Override public List<IVirtualBufferCache> getVirtualBufferCaches(int datasetID, int ioDeviceNum) { DatasetVirtualBufferCaches dvbcs = getVirtualBufferCaches(datasetID); return dvbcs.getVirtualBufferCaches(this, ioDeviceNum); } private void removeDatasetFromCache(int datasetID) throws HyracksDataException { deallocateDatasetMemory(datasetID); datasetLifecycles.remove(datasetID); } @Override public PrimaryIndexOperationTracker getOperationTracker(int datasetID) { <|startfocus|> return datasetLifecycles.get(datasetID).getOpTracker(); <|endfocus|> } private void validateDatasetLifecycleManagerState() throws HyracksDataException { if (stopped) { throw new HyracksDataException(DatasetLifecycleManager.class.getSimpleName() + " was stopped."); } } @Override public synchronized void start() { used = 0; } @Override public synchronized void flushAllDatasets() throws HyracksDataException { for (DatasetLifecycle dslc : datasetLifecycles.values()) { flushDatasetOpenIndexes(dslc.getDatasetInfo(), false); } } @Override public synchronized void flushDataset(int datasetId, boolean asyncFlush) throws HyracksDataException {
<|startcomment|> MAJOR SonarQube violation: Remove this unused "detectTemporal" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|> import org.apache.hyracks.data.std.api.IMutableValueStorage; import com.fasterxml.jackson.core.JsonFactory; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonToken; /** * JSON format parser using Jakson parser. */ public class JSONDataParser extends AbstractNestedDataParser<ADMToken> implements IStreamDataParser, IRecordDataParser<char[]> { protected final ParserContext parserContext; protected final JsonFactory jsonFactory; protected final ARecordType rootType; protected final GeometryCoParser geometryCoParser; <|startfocus|> private final boolean detectGeoJson; private final boolean detectTemporal; <|endfocus|> protected JsonParser jsonParser; public JSONDataParser(ARecordType recordType, JsonFactory jsonFactory) { this(recordType, jsonFactory, false, null, false); } /** * Constructor that can tell the parser to detect potential ADM formats (e.g point, datetime) * and convert them accordingly. This can be slightly expensive and they are turned-off by default. * * @param recordType * defined type. * @param jsonFactory * Jackson JSON parser factory. * @param detectGeoJSON
<|startcomment|> MAJOR SonarQube violation: Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1186 <|endcomment|> <|startfocus|> public FullTextContainsExpressionVisitor() { <|endfocus|>
<|startcomment|> I think an aggregate operator can only have one input. <|endcomment|>  return false; } // find its primary index and replace datascan boolean transformed = replaceDatascan(localAggregateOperator,scanAndAssignOpRef, context); if (transformed) { OperatorPropertiesUtil.typeOpRec(opRef, context); // TODO(ali): check this } return transformed; } private Pair<Mutable<ILogicalOperator>,Mutable<ILogicalOperator>> findScanAndAssignOperator( ILogicalOperator localAggregateOperator, IMetadataProvider metadataProvider) throws AlgebricksException { <|startfocus|> // TODO(ali): can it happen that an aggregate operator has more than one input? <|endfocus|> Mutable<ILogicalOperator> scanOpRef = localAggregateOperator.getInputs().get(0); Mutable<ILogicalOperator> assignOpRef = null; // assign operator may or may not exist if (scanOpRef.getValue().getOperatorTag() == LogicalOperatorTag.ASSIGN) { AssignOperator assignOperator = (AssignOperator) scanOpRef.getValue(); assignOpRef = new MutableObject<>(assignOperator); scanOpRef = scanOpRef.getValue().getInputs().get(0); } // next operator must be datascan or unnest map using the dataset if (scanOpRef.getValue().getOperatorTag() != LogicalOperatorTag.DATASOURCESCAN &&
<|startcomment|> you already have optionExpr at this point. Why fetch it again from arguments. You could use ConstantExpressionUtil.getStringConstant(optionExpr) instead of getStringArgument(). btw, you could combine it with the previous line (240-243). If it returns null (i.e. was not a STRING) then throw TYPE_UNSUPPORTED exception. <|endcomment|>  ILogicalExpression optionExpr = openRecConsExpr.getArguments().get(i).getValue(); ILogicalExpression optionExprVal = openRecConsExpr.getArguments().get(i + 1).getValue(); if (optionExpr.getExpressionTag() != LogicalExpressionTag.CONSTANT) { throw CompilationException.create(ErrorCode.TYPE_UNSUPPORTED, functionName, optionExpr.getExpressionTag()); } <|startfocus|> String option = ConstantExpressionUtil.getStringArgument(openRecConsExpr, i).toLowerCase(); <|endfocus|> if (!FullTextContainsDescriptor.getParamTypeMap().containsKey(option)) { throw CompilationException.create(ErrorCode.TYPE_UNSUPPORTED, functionName, option); } boolean typeError = false; String optionTypeStringVal = null; // If the option value is a constant, then we can check here. if (optionExprVal.getExpressionTag() == LogicalExpressionTag.CONSTANT) { switch (FullTextContainsDescriptor.getParamTypeMap().get(option)) { case STRING: optionTypeStringVal = ConstantExpressionUtil.getStringArgument(openRecConsExpr, i + 1) .toLowerCase(); if (optionTypeStringVal == null) { typeError = true; } break;
<|startcomment|> MAJOR SonarQube violation: Split this 121 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  * @param adapter * Adapter to be inserted * @throws AlgebricksException * for example, if the adapter already exists. * @throws RemoteException */ void addAdapter(JobId jobId, DatasourceAdapter adapter) throws AlgebricksException, RemoteException; /** * @param jobId * @param compactionPolicy * @throws AlgebricksException * @throws RemoteException */ <|startfocus|> void addCompactionPolicy(JobId jobId, CompactionPolicy compactionPolicy) throws AlgebricksException, RemoteException; <|endfocus|> /** * @param jobId * @param dataverse * @param policy * @return * @throws AlgebricksException * @throws RemoteException */ CompactionPolicy getCompactionPolicy(JobId jobId, String dataverse, String policy) throws AlgebricksException, RemoteException; /** * @param jobId * @throws AlgebricksException * @throws RemoteException */ void initializeDatasetIdFactory(JobId jobId) throws AlgebricksException, RemoteException; /** * @return * @throws AlgebricksException * @throws RemoteException */ int getMostRecentDatasetId() throws AlgebricksException, RemoteException;
<|startcomment|> MAJOR SonarQube violation: 'if' is not followed by whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  ILSMIndex lsmIndex = info.getIndex(); List<ILSMDiskComponent> immutableComponents = new ArrayList<>(lsmIndex.getDiskComponents()); if (isMergeOngoing(immutableComponents)) { continue; } List<ILSMDiskComponent> mergableComponents = new ArrayList<>(); for (ILSMDiskComponent component : immutableComponents) { ILSMComponentId id = component.getId(); IdCompareResult cmp = targetId.compareTo(id); if(cmp == IdCompareResult.INCLUDE) { mergableComponents.add(component); <|startfocus|> }else if(cmp == IdCompareResult.GREATER_THAN) { <|endfocus|> //disk components are ordered from latest (with largest IDs) to oldest (with smallest IDs) // if targetId>component.Id, we can safely skip the rest disk components in the list break; } } ILSMIndexAccessor accessor = lsmIndex.createAccessor(NoOpIndexAccessParameters.INSTANCE); accessor.scheduleMerge(lsmIndex.getIOOperationCallback(), mergableComponents); } } private int getIndexPartition(ILSMIndex index, Set<IndexInfo> indexInfos) { for (IndexInfo info : indexInfos) { if (info.getIndex() == index) { return info.getPartition(); } }
<|startcomment|> txn? <|endcomment|>  String recoveryDirPath = getRecoveryDirPath(); Path JobRecoveryFolder = Paths.get(recoveryDirPath + File.separator + jobId); if (!Files.exists(JobRecoveryFolder)) { Files.createDirectories(JobRecoveryFolder); } File jobRecoveryFile = new File(JobRecoveryFolder.toString() + File.separator + fileName); if (!jobRecoveryFile.exists()) { jobRecoveryFile.createNewFile(); } else { throw new IOException("File: " + fileName + " for job id(" + jobId + ") already exists"); } <|startfocus|> <|endfocus|> return jobRecoveryFile; } @Override public void deleteRecoveryTemporaryFiles() { String recoveryDirPath = getRecoveryDirPath(); Path recoveryFolderPath = Paths.get(recoveryDirPath); FileUtils.deleteQuietly(recoveryFolderPath.toFile()); } private String getRecoveryDirPath() { String logDir = logMgr.getLogManagerProperties().getLogDir(); if (!logDir.endsWith(File.separator)) { logDir += File.separator; } return logDir + RECOVERY_FILES_DIR_NAME; } private void freeJobsCachedEntities(int requestingJobId) throws IOException {
<|startcomment|> This seems a little out of place ... <|endcomment|>  public void notifyUpdateCommitted(long resourceId) { try { opTrackers.get(resourceId).completeOperation(null, LSMOperationType.MODIFICATION, null, callbacks.get(resourceId)); } catch (HyracksDataException e) { <|startfocus|> throw new IllegalStateException(e); <|endfocus|> }
<|startcomment|> Should we set logFile to null here or do we still need it? <|endcomment|> <|startfocus|> public void close() { <|endfocus|> try { if (logFile != null) { logFile.close(); } } catch (IOException e) { throw new ACIDException(e); }
<|startcomment|> CRITICAL SonarQube violation: Use a logger to log this exception. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1148 <|endcomment|>  this.replicationProperties = replicationProperties; this.replicaResourcesManager = (ReplicaResourcesManager) remoteResoucesManager; this.asterixAppRuntimeContextProvider = asterixAppRuntimeContextProvider; this.hostIPAddressFirstOctet = replicationProperties.getReplicaIPAddress(nodeId).substring(0, 3); this.logManager = logManager; replicationJobsQ = new LinkedBlockingQueue<IReplicationJob>(); replicaEventsQ = new LinkedBlockingQueue<ReplicaEvent>(); terminateJobsReplication = new AtomicBoolean(false); jobsReplicationSuspended = new AtomicBoolean(true); replicationSuspended = new AtomicBoolean(true); <|startfocus|> replicas = new HashMap<String, Replica>(); jobCommitAcks = new ConcurrentHashMap<Integer, Set<String>>(); replicationJobsPendingAcks = new ConcurrentHashMap<Integer, ILogRecord>(); shuttingDownReplicaIds = new HashSet<String>(); <|endfocus|> dataBuffer = ByteBuffer.allocate(INITIAL_BUFFER_SIZE); //Used as async listeners from replicas replicationListenerThreads = Executors.newCachedThreadPool(); replicationJobsProcessor = new ReplicationJobsProccessor(); replicationMonitor = new ReplicasEventsMonitor(); Map<String, ClusterPartition[]> nodePartitions = ((IAsterixPropertiesProvider) asterixAppRuntimeContextProvider .getAppContext()).getMetadataProperties().getNodePartitions();
<|startcomment|> MAJOR SonarQube violation: Replace this usage of System.out or System.err by a logger. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS106 <|endcomment|>  } } } return replicaNodesSockets; } /** * Establishes a connection with a remote replica. * * @param replicaId * The replica to connect to. * @return The socket of the remote replica * @throws IOException */ private SocketChannel getReplicaSocket(String replicaId) throws IOException { Replica replica = replicationProperties.getReplicaById(replicaId); SocketChannel sc = SocketChannel.open(); sc.configureBlocking(true); <|startfocus|> InetSocketAddress address = replica.getAddress(replicationProperties); sc.connect(new InetSocketAddress(address.getHostString(), address.getPort())); <|endfocus|> return sc; } @Override public Set<String> getDeadReplicasIds() { Set<String> replicasIds = new HashSet<>(); for (Replica replica : replicas.values()) { if (replica.getState() == ReplicaState.DEAD) { replicasIds.add(replica.getNode().getId()); } } return replicasIds; } @Override public Set<String> getActiveReplicasIds() { Set<String> replicasIds = new HashSet<>();
<|startcomment|> MAJOR SonarQube violation: '{' is not preceded with whitespace. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=checkstyle%3AWhitespace_Around <|endcomment|>  try { messageBroker.sendApplicationMessageToNC(response, nodeState.getKey()); } catch (Exception e) { throw HyracksDataException.create(e); } } } else if(failedNodes.size() > 0){ List<INCLifecycleTask> tasks = buildFailbackStartupSequence(); RegistrationTasksResponseMessage response = new RegistrationTasksResponseMessage(nodeId,tasks); try{ messageBroker.sendApplicationMessageToNC(response,msg.getNodeId()); } catch (Exception e){ throw HyracksDataException.create(e); } } <|startfocus|> else{ startupQueue.put(nodeId,state); } <|endfocus|> } private List<INCLifecycleTask> buildFailbackStartupSequence() { final List<INCLifecycleTask> tasks = new ArrayList<>(); tasks.add(new StartFailbackTask()); tasks.add(new ReportLocalCountersTask()); tasks.add(new StartLifecycleComponentsTask()); return tasks; } private List<INCLifecycleTask> buildStartupSequence(String nodeId) { final List<INCLifecycleTask> tasks = new ArrayList<>(); tasks.add(new StartReplicationServiceTask()); final boolean isMetadataNode = nodeId.equals(currentMetadataNode); if (isMetadataNode) {
<|startcomment|> BLOCKER SonarQube violation: Close this "SocketChannel". Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2095 <|endcomment|>  if (LOGGER.isLoggable(Level.WARNING)) { LOGGER.log(Level.WARNING, "Could not get replica socket", e); } reportFailedReplica(replica.getId()); } } } return replicaNodesSockets; } /** * Establishes a connection with a remote replica. * * @param replicaId * The replica to connect to. * @return The socket of the remote replica * @throws IOException */ private SocketChannel getReplicaSocket(String replicaId) throws IOException { <|startfocus|> Replica replica = replicationProperties.getReplicaById(replicaId); <|endfocus|> SocketChannel sc = SocketChannel.open(); sc.configureBlocking(true); InetSocketAddress address = replica.getAddress(replicationProperties); sc.connect(new InetSocketAddress(address.getHostString(), address.getPort())); return sc; } @Override public Set<String> getDeadReplicasIds() { Set<String> replicasIds = new HashSet<>(); for (Replica replica : replicas.values()) { if (replica.getState() == ReplicaState.DEAD) { replicasIds.add(replica.getNode().getId()); } }
<|startcomment|> MAJOR SonarQube violation: Split this 127 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  if (ClusterProperties.INSTANCE.isReplicationEnabled()) { String nodeId = ncApplicationContext.getNodeId(); replicaResourcesManager = new ReplicaResourcesManager(localResourceRepository, metadataProperties); replicationManager = new ReplicationManager(nodeId, replicationProperties, replicaResourcesManager, txnSubsystem.getLogManager(), asterixAppRuntimeContextProvider); //pass replication manager to replication required object //LogManager to replicate logs txnSubsystem.getLogManager().setReplicationManager(replicationManager); //PersistentLocalResourceRepository to replicate metadata files and delete backups on drop index localResourceRepository.setReplicationManager(replicationManager); <|startfocus|> /** <|endfocus|> * add the partitions that will be replicated in this node as inactive partitions */ //get nodes which replicate to this node Set<String> replicationClients = replicationProperties.getNodeReplicationClients(nodeId); //remove the node itself replicationClients.remove(nodeId); for (String clientId : replicationClients) { //get the partitions of each client ClusterPartition[] clientPartitions = metadataProperties.getNodePartitions().get(clientId); for (ClusterPartition partition : clientPartitions) { localResourceRepository.addInactivePartition(partition.getPartitionId()); } } 
<|startcomment|> MAJOR SonarQube violation: Make ncs a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck <|endcomment|> import org.apache.hyracks.control.nc.NodeControllerService; import org.kohsuke.args4j.CmdLineException; public class AsterixHyracksIntegrationUtil { static class LoggerHolder { static final Logger LOGGER = Logger.getLogger(AsterixHyracksIntegrationUtil.class.getName()); private LoggerHolder() { } } public static final int DEFAULT_HYRACKS_CC_CLIENT_PORT = 1098; public static final int DEFAULT_HYRACKS_CC_CLUSTER_PORT = 1099; <|startfocus|> public ClusterControllerService cc; public NodeControllerService[] ncs = new NodeControllerService[2]; public IHyracksClientConnection hcc; protected boolean gracefulShutdown = true; <|endfocus|> private static final String DEFAULT_STORAGE_PATH = joinPath("target", "io", "dir"); public static final String DEFAULT_CONF_FILE = (joinPath("asterixdb", "asterix-app", "src", "test", "resources", "cc.conf")); private static String storagePath = DEFAULT_STORAGE_PATH; private ConfigManager configManager; private List<String> nodeNames; List<Pair<IOption, Object>> opts = new ArrayList<>(); public void init(boolean deleteOldInstanceData, String confFile) throws Exception {
<|startcomment|> MAJOR SonarQube violation: Remove this unused "sc" private field. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1068 <|endcomment|> import org.apache.asterix.common.replication.IPartitionReplica; import org.apache.asterix.common.storage.ReplicaIdentifier; import org.apache.hyracks.util.JSONUtil; import org.apache.hyracks.util.annotations.ThreadSafe; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; @ThreadSafe public class PartitionReplica implements IPartitionReplica { private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); private final ReplicaIdentifier id; <|startfocus|> private SocketChannel sc; <|endfocus|> private PartitionReplicaStatus status = DISCONNECTED; public PartitionReplica(ReplicaIdentifier id) { this.id = id; } @Override public synchronized PartitionReplicaStatus getStatus() { return status; } @Override public ReplicaIdentifier getIdentifier() { return id; } public synchronized void sync() { if (status == IN_SYNC || status == CATCHING_UP) { return; } } public JsonNode asJson() { ObjectNode json = OBJECT_MAPPER.createObjectNode(); json.put("id", id.toString());
<|startcomment|> MAJOR SonarQube violation: Split this 155 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  public void run() { Thread.currentThread().setName("Replication Channel Thread"); String nodeIP = replicationProperties.getReplicaIPAddress(localNodeID); int dataPort = replicationProperties.getDataReplicationPort(localNodeID); try { serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(true); <|startfocus|> InetSocketAddress replicationChannelAddress = new InetSocketAddress(InetAddress.getByName(nodeIP), dataPort); <|endfocus|> serverSocketChannel.socket().bind(replicationChannelAddress); lsmComponentLSNMappingService.start(); replicationNotifier.start(); LOGGER.log(Level.INFO, "opened Replication Channel @ IP Address: " + nodeIP + ":" + dataPort); //start accepting replication requests while (true) { socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(true); //start a new thread to handle the request replicationThreads.execute(new ReplicationThread(socketChannel)); } } catch (IOException e) { throw new IllegalStateException( "Could not open replication channel @ IP Address: " + nodeIP + ":" + dataPort, e); }
<|startcomment|> MAJOR SonarQube violation: Split this 129 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  private final String id; private final ILogManager logManager; private final ILockManager lockManager; private final ITransactionManager transactionManager; private final IRecoveryManager recoveryManager; private final IAppRuntimeContextProvider asterixAppRuntimeContextProvider; private final TransactionProperties txnProperties; private final ICheckpointManager checkpointManager; //for profiling purpose private long profilerEntityCommitLogCount = 0; private EntityCommitProfiler ecp; public TransactionSubsystem(INCServiceContext serviceCtx, String id, <|startfocus|> IAppRuntimeContextProvider asterixAppRuntimeContextProvider, TransactionProperties txnProperties) <|endfocus|> throws ACIDException { this.asterixAppRuntimeContextProvider = asterixAppRuntimeContextProvider; this.id = id; this.txnProperties = txnProperties; this.transactionManager = new TransactionManager(this); this.lockManager = new ConcurrentLockManager(txnProperties.getLockManagerShrinkTimer()); ReplicationProperties repProperties = asterixAppRuntimeContextProvider.getAppContext().getReplicationProperties(); final boolean replicationEnabled = repProperties.isReplicationEnabled(); final CheckpointProperties checkpointProperties = new CheckpointProperties(txnProperties, id); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.log(Level.INFO, "Checkpoint Properties: " + checkpointProperties); }
<|startcomment|> MAJOR SonarQube violation: Split this 249 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  LOGGER.warning("Could not find node " + nodeId + " in cluster configurations"); } return Collections.emptySet(); } //find nodes to the right of this node while (remoteReplicas.size() != numberOfRemoteReplicas) { String replica = repProp.getNodeIds().get(++nodeIndex % repProp.getNodeIds().size()); <|startfocus|> remoteReplicas.add(new Replica(replica, configManager.getNodeEffectiveConfig(replica).getString(NCConfig.Option.REPLICATION_LISTEN_ADDRESS), configManager.getNodeEffectiveConfig(replica).getInt(NCConfig.Option.REPLICATION_LISTEN_PORT))); <|endfocus|> } return remoteReplicas;
<|startcomment|> CRITICAL SonarQube violation: A "Set<Replica>" cannot contain a "String" Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS2175 <|endcomment|>  Map<String, Integer> candidatesScore = new HashMap<>(); //2. identify which nodes has backup per lost node data for (Replica node : replicas) { Set<Replica> locations = replicationStrategy.getRemoteReplicasAndSelf(node.getId()); //since the local node just started, remove it from candidates locations.remove(new Replica(localNodeId, "", -1)); //remove any dead replicas Set<String> deadReplicas = replicationManager.getDeadReplicasIds(); for (String deadReplica : deadReplicas) { <|startfocus|> locations.remove(deadReplica); <|endfocus|> } //no active replicas to recover from if (locations.isEmpty()) { throw new IllegalStateException("Could not find any ACTIVE replica to recover " + node + " data."); } for (Replica locationRep : locations) { String location = locationRep.getId(); if (candidatesScore.containsKey(location)) { candidatesScore.put(location, candidatesScore.get(location) + 1); } else { candidatesScore.put(location, 1); } }
<|startcomment|> MAJOR SonarQube violation: Make cc a static final constant or non-public and provide accessors if needed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AClassVariableVisibilityCheck <|endcomment|>  public static final int DEFAULT_HYRACKS_CC_CLIENT_PORT = 1098; public static final int DEFAULT_HYRACKS_CC_CLUSTER_PORT = 1099; public static final String DEFAULT_CONF_FILE = joinPath("asterixdb", "asterix-app", "src", "test", "resources", "cc.conf"); private static final String DEFAULT_STORAGE_PATH = joinPath("target", "io", "dir"); private static String storagePath = DEFAULT_STORAGE_PATH; <|startfocus|> public ClusterControllerService cc; public NodeControllerService[] ncs = new NodeControllerService[2]; public IHyracksClientConnection hcc; <|endfocus|> protected boolean gracefulShutdown = true; List<Pair<IOption, Object>> opts = new ArrayList<>(); private ConfigManager configManager; private List<String> nodeNames; public static void setStoragePath(String path) { storagePath = path; } public static void restoreDefaultStoragePath() { storagePath = DEFAULT_STORAGE_PATH; } /** * main method to run a simple 2 node cluster in-process * suggested VM arguments: <code>-enableassertions -Xmx2048m -Dfile.encoding=UTF-8</code> *
<|startcomment|> remove if no longer applicable <|endcomment|>  if (!only.isEmpty()) { boolean toRun = true; //TestHelper.isInPrefixList(only, queryFileShort); if (!toRun) { logger.info("SKIP TEST: \"" + queryFile.getPath() + "\" \"only.txt\" not empty and not in \"only.txt\"."); } Assume.assumeTrue(toRun); } <|startfocus|> boolean skipped = true; //TestHelper.isInPrefixList(ignore, queryFileShort); <|endfocus|> if (skipped) { logger.info("SKIP TEST: \"" + queryFile.getPath() + "\" in \"ignore.txt\"."); } Assume.assumeTrue(!skipped); logger.info("RUN TEST: \"" + queryFile.getPath() + "\""); parserTestExecutor.testSQLPPParser(queryFile, actualFile, expectedFile); } catch (Exception e) { if (!(e instanceof AssumptionViolatedException)) { final String msg = "Test \"" + queryFile.getPath() + "\" FAILED!"; logger.severe(msg); throw new Exception(msg, e); } else { throw e; } } } } 
<|startcomment|> MAJOR SonarQube violation: Reduce the number of conditional operators (5) used in the expression (maximum allowed 3). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS1067 <|endcomment|>  public boolean equals(Object object) { if (this == object) { return true; } if (!(object instanceof InsertStatement)) { return false; } InsertStatement target = (InsertStatement) object; return Objects.equals(datasetName, target.datasetName) && Objects.equals(dataverseName, target.dataverseName) <|startfocus|> && Objects.equals(query, target.query) && Objects.equals(var, target.var) && Objects.equals(returnExpression, target.returnExpression) && varCounter == target.varCounter; <|endfocus|>
<|startcomment|> MAJOR SonarQube violation: Split this 124 characters long line (which is greater than 120 authorized). Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS00103 <|endcomment|>  * under the License. */ package org.apache.asterix.common.replication; import java.util.HashMap; import java.util.Map; import org.apache.asterix.common.config.ReplicationProperties; import org.apache.asterix.common.exceptions.ErrorCode; import org.apache.asterix.common.exceptions.RuntimeDataException; import org.apache.hyracks.api.config.IConfigManager; import org.apache.hyracks.api.exceptions.HyracksDataException; public class ReplicationStrategyFactory { <|startfocus|> private static final Map<String, Class<? extends IReplicationStrategy>> BUILT_IN_REPLICATION_STRATEGY = new HashMap<>(); <|endfocus|> static { BUILT_IN_REPLICATION_STRATEGY.put("no_replication", NoReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("chained_declustering", ChainedDeclusteringReplicationStrategy.class); BUILT_IN_REPLICATION_STRATEGY.put("metadata_only", MetadataOnlyReplicationStrategy.class); } private ReplicationStrategyFactory() { throw new AssertionError(); } public static IReplicationStrategy create(String name, ReplicationProperties repProp, IConfigManager ncConfig) throws HyracksDataException { String strategyName = name.toLowerCase(); if (!BUILT_IN_REPLICATION_STRATEGY.containsKey(strategyName)) { throw new RuntimeDataException(ErrorCode.UNSUPPORTED_REPLICATION_STRATEGY, String.format(
<|startcomment|> MAJOR SonarQube violation: Remove those useless parentheses. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AUselessParenthesesCheck <|endcomment|>  /** * A task to initialize the checkpoints for all indexes in a partition with the replica's current LSN */ public class CheckpointPartitionIndexesTask implements IReplicaTask { private final int partition; public CheckpointPartitionIndexesTask(int partition) { this.partition = partition; } @Override public void perform(INcApplicationContext appCtx, IReplicationThread worker) throws HyracksDataException { final IIndexCheckpointManagerProvider indexCheckpointManagerProvider = appCtx.getIndexCheckpointManagerProvider(); PersistentLocalResourceRepository resRepo = <|startfocus|> ((PersistentLocalResourceRepository) appCtx.getLocalResourceRepository()); <|endfocus|> final Collection<LocalResource> partitionResources = resRepo.getPartitionResources(partition).values(); final long currentLSN = appCtx.getTransactionSubsystem().getLogManager().getAppendLSN(); for (LocalResource ls : partitionResources) { final IIndexCheckpointManager indexCheckpointManager = indexCheckpointManagerProvider.get(DatasetResourceReference.of(ls)); indexCheckpointManager.delete(); indexCheckpointManager.init(currentLSN); } ReplicationProtocol.sendAck(worker.getChannel(), worker.getReusableBuffer()); } @Override public ReplicationProtocol.ReplicationRequestType getMessageType() { return ReplicationProtocol.ReplicationRequestType.CHECKPOINT_PARTITION; } 
<|startcomment|> We already have RecordUtil.FULLY_OPEN_RECORD_TYPE. Can we use it instead? <|endcomment|> import com.fasterxml.jackson.databind.node.ObjectNode; /** * ARecordType is read-only and shared by different partitions at runtime. * Note: to check whether a field name is defined in the closed part at runtime, * please use RuntimeRecordTypeInfo which separates the mutable states * from ARecordType and has to be one-per-partition. */ public class ARecordType extends AbstractComplexType { <|startfocus|> public static final ARecordType ANY_OBJECT_RECORD_TYPE = new ARecordType("AnyObject", new String[0], new IAType[0], true); <|endfocus|> private static final long serialVersionUID = 1L; private final String[] fieldNames; private final IAType[] fieldTypes; private final Map<String, Integer> fieldNameToIndexMap = new HashMap<>(); private final boolean isOpen; private final transient List<IRecordTypeAnnotation> annotations = new ArrayList<>(); // The following set of names do not belong to the closed part, // but are additional possible field names. For example, a field "foo" with type
<|startcomment|> MAJOR SonarQube violation: Rename this field "LOGGER" to match the regular expression '^[a-z][a-zA-Z0-9]*$'. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3AS3008 <|endcomment|> import org.apache.hyracks.api.job.JobId; import org.apache.hyracks.control.cc.ClusterControllerService; import org.apache.hyracks.control.cc.cluster.INodeManager; import org.apache.hyracks.control.cc.job.IJobManager; import org.apache.hyracks.control.cc.job.JobRun; import org.apache.hyracks.control.common.work.AbstractWork; import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class RemoveDeadNodesWork extends AbstractWork { <|startfocus|> private static Logger LOGGER = LogManager.getLogger(); <|endfocus|> private final ClusterControllerService ccs; public RemoveDeadNodesWork(ClusterControllerService ccs) { this.ccs = ccs; } @Override public void run() { try { INodeManager nodeManager = ccs.getNodeManager(); Pair<Collection<String>, Collection<JobId>> result = nodeManager.removeDeadNodes(); Collection<String> deadNodes = result.getLeft(); Collection<JobId> affectedJobIds = result.getRight(); int size = affectedJobIds.size(); if (size > 0) { if (LOGGER.isInfoEnabled()) {
<|startcomment|> The change looks generally good to me. But changing this to private and moving to getters and setters seems inconsistent with the rest of the class - and it creates some noise in the other files. <|endcomment|>  protected static final int SWITCH_COMPONENT_CYCLE = 100; protected final ILSMIndexOperationContext opCtx; protected final boolean returnDeletedTuples; protected PriorityQueueElement outputElement; protected final ArrayTupleBuilder[] switchComponentTupleBuilders; protected final boolean[] switchRequest; protected final PriorityQueueElement[] switchedElements; protected IIndexCursor[] rangeCursors; protected PriorityQueueElement[] pqes; protected PriorityQueue<PriorityQueueElement> outputPriorityQueue; protected PriorityQueueComparator pqCmp; protected MultiComparator cmp; protected boolean needPushElementIntoQueue; <|startfocus|> private boolean includeMutableComponent; <|endfocus|> protected ILSMHarness lsmHarness; protected boolean switchPossible = true; protected int hasNextCallCount = 0; protected List<ILSMComponent> operationalComponents; public LSMIndexSearchCursor(ILSMIndexOperationContext opCtx, boolean returnDeletedTuples) { this.opCtx = opCtx; this.returnDeletedTuples = returnDeletedTuples; outputElement = null; needPushElementIntoQueue = false; switchComponentTupleBuilders = new ArrayTupleBuilder[opCtx.getIndex().getNumberOfAllMemoryComponents()]; switchRequest = new boolean[switchComponentTupleBuilders.length]; switchedElements = new PriorityQueueElement[switchComponentTupleBuilders.length]; } public ILSMIndexOperationContext getOpCtx() {
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  return ctx.getInitialFrameSize(); } @Override public int getMemoryBudgetBytes() { return memBudget; } @Override public ByteBuffer allocateFrame(int frameSize) throws HyracksDataException { ByteBuffer buffer = findExistingFrame(frameSize); if (buffer != null) { // Temp : // System.out.println("DeallocatableFramePool::allocateFrame - an existing buffer found " // + ObjectUtils.identityToString(buffer) + " #frame " + buffers.size() + " allocated " + allocated); return buffer; } if (haveEnoughFreeSpace(frameSize)) { <|startfocus|> // Temp : // System.out.println("DeallocatableFramePool::allocateFrame - a new buffer will be created." + " allocated " // + allocated); <|endfocus|> return createNewFrame(frameSize); } // Temp : // System.out.println("DeallocatableFramePool::allocateFrame - merging?" + " allocated " + allocated); return mergeExistingFrames(frameSize); } private ByteBuffer mergeExistingFrames(int frameSize) throws HyracksDataException { int mergedSize = memBudget - allocated;
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  */ @Override public ByteBuffer getNextFrame() throws HyracksDataException { frameConsumed = true; return buffers.get(IO_BUFFER_IDX); } /** * Finishes reading the result and frees the buffer. */ @Override public void closeResultRead(boolean deallocateIOBufferNeeded) throws HyracksDataException { // Deallocates I/O buffer if requested. if (deallocateIOBufferNeeded) { <|startfocus|> // Temp : // System.out.println("InvertedIndexSearchResult::closeResultRead() calling deallocateIOBuffer()"); // <|endfocus|> deallocateIOBuffer(); } } /** * Deletes any associated file and deallocates all buffers. */ @Override public void close() throws HyracksDataException { deallocateIOBuffer(); } @Override public void reset() throws HyracksDataException { // Resets the I/O buffer. clearBuffer(ioBuffer); searchResultWriter = null; searchResultReader = null; isInReadMode = false; isWriteFinished = false; isInMemoryOpMode = false; isFileOpened = false; frameConsumed = false; currentWriterBufIdx = 0; currentReaderBufIdx = 0;
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  */ protected void deallocateBuffers() throws HyracksDataException { int toDeleteCount = buffers.size() - 1; int deletedCount = 0; for (ListIterator<ByteBuffer> iter = buffers.listIterator(buffers.size()); iter.hasPrevious();) { if (deletedCount >= toDeleteCount) { break; } ByteBuffer next = iter.previous(); bufferManager.releaseFrame(next); <|startfocus|> // Temp : // System.out.println("InvertedIndexSearchResult::deallocateBuffers() buffer - " // + ObjectUtils.identityToString(inMemoryBuffers.get(i))); <|endfocus|> iter.remove(); deletedCount++; } } public FixedSizeFrameTupleAccessor getAccessor() { return accessor; } public FixedSizeFrameTupleAppender getAppender() { return appender; } public FixedSizeTupleReference getTuple() { return tuple; } protected void clearBuffer(ByteBuffer bufferToClear) { Arrays.fill(bufferToClear.array(), (byte) 0); bufferToClear.clear(); } protected void resetAppenderLocation(int bufferIdx) { accessor.reset(buffers.get(bufferIdx));
<|startcomment|> MAJOR SonarQube violation: This block of commented-out lines of code should be removed. Read more: https://asterix-sonar.ics.uci.edu/coding_rules#rule_key=squid%3ACommentedOutCodeLine <|endcomment|>  // Temp : int countc = 0; while (invListTidx < invListTupleCount) { invListTuple = invListCursor.getTuple(); if (!newSearchResult.append(invListTuple, 1)) { // For a final result, needs to pause when a frame becomes full to let the caller // consume the frame. SearchResult.append() should only return false for this case. return false; } <|startfocus|> // Temp : countc++; // System.out.println("mergePrefixList (remaining from cursor) added - " + countc); // <|endfocus|> invListTidx++; if (invListCursor.hasNext()) { invListCursor.next(); } } // append remaining elements from previous result set // Temp : int countp = 0; while (resultTidx < prevResultFrameTupleCount) { resultTuple.reset(prevCurrentBuffer.array(), resultFrameTupleAcc.getTupleStartOffset(resultTidx)); count = getCount(resultTuple); if (!newSearchResult.append(resultTuple, count)) { // For a final result, needs to pause when a frame becomes full to let the caller
<|startcomment|> mention optional partition clause here <|endcomment|>  import java.util.List; import com.cloudera.impala.authorization.Privilege; import com.cloudera.impala.common.AnalysisException; import com.cloudera.impala.thrift.TShowFilesParams; import com.cloudera.impala.thrift.TPartitionKeyValue; import com.cloudera.impala.catalog.Table; import com.cloudera.impala.catalog.View; import com.cloudera.impala.thrift.TTableName; import com.google.common.base.Preconditions; import com.google.common.base.Joiner; import com.google.common.collect.Lists; /** * Representation of a SHOW FILES statement. * Acceptable syntax: * <|startfocus|> * SHOW FILES IN database.table <|endfocus|> * */ public class ShowFilesStmt extends StatementBase { private final TableName tableName_; private final PartitionSpec partitionSpec_; private String postAnalysisDb_; public ShowFilesStmt(TableName tableName, PartitionSpec partitionSpec) { this.tableName_ = tableName; this.partitionSpec_ = partitionSpec; } @Override public String toSql() { StringBuilder strBuilder = new StringBuilder(); strBuilder.append("SHOW FILES "); strBuilder.append(tableName_.toString());
<|startcomment|> Just use: Lists.newArrayList(partition); <|endcomment|>  resultSchema.addToColumns(new TColumn("path", Type.STRING.toThrift())); resultSchema.addToColumns(new TColumn("size", Type.STRING.toThrift())); resultSchema.addToColumns(new TColumn("partition", Type.STRING.toThrift())); List<HdfsPartition> partitions = null; if (partitionSpec == null) { partitions = partitions_; } else { // Get the HdfsPartition object for the given partition spec. HdfsPartition partition = getPartitionFromThriftPartitionSpec(partitionSpec); <|startfocus|> partitions = Lists.newArrayList(); partitions.add(partition); <|endfocus|> } for (HdfsPartition p: partitions) { for (FileDescriptor fd: p.getFileDescriptors()) { TResultRowBuilder rowBuilder = new TResultRowBuilder(); rowBuilder.add(p.getLocation() + "/" + fd.getFileName()); rowBuilder.add(PrintUtils.printBytes(fd.getFileLength())); rowBuilder.add(p.getPartitionName()); result.addToRows(rowBuilder.get()); } } return result; } } 
<|startcomment|> Why is it ok not to do replaceTableIfUnchanged() here? It seems like while the async load is running another DDL might have made a change that would then be overwritten by adding the loaded table here regardless of version changes. <|endcomment|>  if (tbl == null) return null; Db db = tbl.getDb(); if (!(tbl instanceof HdfsTable)) { // Currently, only an HdfsTable can be loaded incrementally. Everything else (e.g. // IncompleteTable) will trigger a full table reload. TableLoadingMgr.LoadRequest loadReq = tableLoadingMgr_.loadAsync(tblName); tbl = loadReq.get(); catalogLock_.writeLock().lock(); try { <|startfocus|> tbl.setCatalogVersion(incrementAndGetCatalogVersion()); db.addTable(tbl); return tbl; <|endfocus|> } finally { catalogLock_.writeLock().unlock(); } } // Incremental table metadata load. Preconditions.checkState(tbl instanceof HdfsTable); HdfsTable hdfsTable = (HdfsTable) tbl; MetaStoreClient msClient = getMetaStoreClient(); org.apache.hadoop.hive.metastore.api.Table msTbl = null; try { msTbl = msClient.getHiveClient().getTable(db.getName(), tblName.getTable_name()); } catch (Exception e) { throw new CatalogException("Error loading metadata for table: " +
<|startcomment|> needed? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.cloudera.impala.analysis; import java.util.ArrayList; import java.util.List; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import com.cloudera.impala.catalog.ColumnStats; import com.cloudera.impala.common.AnalysisException; import com.cloudera.impala.common.InternalException; import com.google.common.base.Preconditions; import com.google.common.collect.Lists; <|startfocus|> import com.google.common.collect.Sets; <|endfocus|> /** * Representation of a union with its list of operands, and optional order by and limit. * A union materializes its results, and its resultExprs are slotrefs into the * materialized tuple. * During analysis, the operands are normalized (separated into a single sequence of * DISTINCT followed by a single sequence of ALL operands) and unnested to the extent * possible. This also creates the AggregationInfo for DISTINCT operands. */ public class UnionStmt extends QueryStmt {
<|startcomment|> only used in a single place and private, just inline <|endcomment|>  /** * Private c'tor, used only for testing. */ private ColumnLineageGraph(String stmt, String user, long timestamp) { queryStr_ = stmt; user_ = user; timestamp_ = timestamp; } private void setVertices(Set<Vertex> vertices) { for (Vertex vertex: vertices) { vertices_.put(vertex.getLabel(), vertex); idToVertexMap_.put(vertex.getVertexId(), vertex); } } <|startfocus|> private void addMultiEdge(MultiEdge e) { edges_.add(e); } <|endfocus|> /** * Creates a new MultiEdge in the column lineage graph from the sets of 'sources' and * 'targets' labels (representing column names or result expr labels). The new * MultiEdge object is returned. */ private MultiEdge createMultiEdge(Set<String> targets, Set<String> sources, MultiEdge.EdgeType type) { Set<Vertex> targetVertices = Sets.newHashSet(); for (String target: targets) { targetVertices.add(createVertex(target)); } Set<Vertex> sourceVertices = Sets.newHashSet();
<|startcomment|> "size is nonsensical" would be more accurate :) simply "size must be > 0: " + len should be enough <|endcomment|>  if (type == PrimitiveType.VARCHAR) { name = "Varchar"; maxLen = ScalarType.MAX_VARCHAR_LENGTH; } else if (type == PrimitiveType.CHAR) { name = "Char"; maxLen = ScalarType.MAX_CHAR_LENGTH; } else { Preconditions.checkState(false); return; } int len = scalarType.getLength(); if (len <= 0) { <|startfocus|> throw new AnalysisException(name + " size must be > 0. Size is too small: " + len + "."); <|endfocus|> } if (scalarType.getLength() > maxLen) { throw new AnalysisException(name + " size must be <= " + maxLen + ". Size is too large: " + len + "."); } break; } case DECIMAL: { int precision = scalarType.decimalPrecision(); int scale = scalarType.decimalScale(); if (precision > ScalarType.MAX_PRECISION) { throw new AnalysisException( "Decimal precision must be <= " + ScalarType.MAX_PRECISION + "."); }
<|startcomment|> remove "in particular," <|endcomment|>  * - assign conjuncts that can be evaluated at that node and compute the stats * of that node (cardinality, etc.) * - apply combined expression substitution map of child plan nodes; if a plan node * re-maps its input, set a substitution map to be applied by parents */ public PlanNode createSingleNodePlan() throws ImpalaException { QueryStmt queryStmt = ctx_.getQueryStmt(); <|startfocus|> // Use the stmt's analyzer which is not necessarily the root analyzer, in particular, <|endfocus|> // to detect empty result sets. Analyzer analyzer = queryStmt.getAnalyzer(); analyzer.computeEquivClasses(); analyzer.getTimeline().markEvent("Equivalence classes computed"); // Mark slots referenced by output exprs as materialized, prior to generating the // plan tree. // We need to mark the result exprs of the topmost select block as materialized, so // that PlanNode.init() can compute the final mem layout of materialized tuples // (the byte size of tuples is needed for cost computations).
<|startcomment|> table - lower case except for names and methods. <|endcomment|>  // until no more progress is made -- either fully cached or out of cache memory if (!cacheDirs.isEmpty()) { catalog_.watchCacheDirs(cacheDirs, tableName.toThrift()); } } else { // Partition is not cached, just return. if (!partition.isMarkedCached()) return; HdfsCachingUtil.uncachePartition(partition); } try { applyAlterPartition(tableName, partition); } finally { partition.markDirty(); } } } /** <|startfocus|> * Recover partitions of specified Table. <|endfocus|> * Add partitions to metastore which exist in HDFS but not in metastore. */ private void alterTableRecoverPartitions(TableName tableName) throws ImpalaException { Table table = getExistingTable(tableName.getDb(), tableName.getTbl()); if (!(table instanceof HdfsTable)) { throw new CatalogException("Table " + table.getFullName() + " is not an HDFS table"); } HdfsTable hdfsTable = (HdfsTable)table; Set<List<String>> partitionsNotInHms = hdfsTable.getPathsWithoutPartitions(); 
<|startcomment|> ..because this one behaves differently (it needs to be a path of length 1) <|endcomment|>  if (rootDesc_ != null) return rootDesc_.getType(); if (rootTable_ != null) return rootTable_.getType(); return null; } public Table destTable() { if (rootTable_ != null && rootDesc_ == null && matches_.isEmpty()) { return rootTable_; } return null; } public Column destColumn() { if (rootTable_ == null) return null; return rootTable_.getColumn(rawPath_.get(rawPath_.size() - 1)); } <|startfocus|> <|endfocus|> public TupleDescriptor destTupleDesc() { if (rootDesc_ != null && matches_.isEmpty()) return rootDesc_; return null; } public List<String> getFullyQualifiedRawPath() { Preconditions.checkState(rootTable_ != null || rootDesc_ != null); List<String> result = Lists.newArrayListWithCapacity(rawPath_.size() + 2); if (rootDesc_ != null) { result.addAll(Lists.newArrayList(rootDesc_.getAlias().split("\\."))); } else { result.add(rootTable_.getDb().getName());
<|startcomment|> just migrateConjuncts() and use 'targetRef' instead of 'inlineViewRef'? <|endcomment|> <|startfocus|> public List<Expr> migrateConjunctsToInlineView(Analyzer analyzer, <|endfocus|> InlineViewRef inlineViewRef) { List<Expr> unassignedConjuncts = analyzer.getUnassignedConjuncts(inlineViewRef.getId().asList(), true); if (inlineViewRef.getViewStmt().hasLimit() || inlineViewRef.getViewStmt().hasOffset() || ((inlineViewRef.getViewStmt() instanceof SelectStmt) && ((SelectStmt) inlineViewRef.getViewStmt()).hasAnalyticInfo())) { return unassignedConjuncts; } List<Expr> preds = Lists.newArrayList(); for (Expr e: unassignedConjuncts) { if (analyzer.canEvalPredicate(inlineViewRef.getId().asList(), e)) { preds.add(e); } } unassignedConjuncts.removeAll(preds); // Generate predicates to enforce equivalences among slots of the inline view // tuple. These predicates are also migrated into the inline view. analyzer.createEquivConjuncts(inlineViewRef.getId(), preds); // create new predicates against the inline view's unresolved result exprs, not // the resolved result exprs, in order to avoid skipping scopes (and ignoring
<|startcomment|> describe which of these may be null <|endcomment|>  * descriptor acts as a placeholder for 'virtual' table references such as inline views, * and must not be materialized at runtime. */ public class TupleDescriptor { private final TupleId id_; private final String debugName_; // debug-only private final ArrayList<SlotDescriptor> slots_ = Lists.newArrayList(); // The tuple descriptor or catalog table/view that the path of this descriptor is // rooted at. A parent tuple descriptor is only set for child collection references. private TupleDescriptor parentDesc_; <|startfocus|> private Table parentTable_; <|endfocus|> // Path from parentDesc_ or parentTable_ to this tuple descriptor. // If empty, it implies that this tuple descriptor must belong to a // catalog table/view reference (and parentTable_ must be set). private List<Integer> path_ = Lists.newArrayList(); // Type of this tuple descriptor. Used for slot/table resolution in analysis. private StructType type_; // All legal aliases of this tuple. private String[] aliases_; 
<|startcomment|> Make this and the following two functions static. <|endcomment|>  } finally { msClient.release(); } if (!cacheIds.isEmpty()) { catalog_.watchCacheDirs(cacheIds, tableName.toThrift()); } } } /** * Generate list of HMS paritions from a set of lists of partition column values. * The list of column values must be valid and have the same order with partition * columns defined in the HDFS table. */ private List<Partition> partitionValuesToHmsPartitions( <|startfocus|> Set<List<String>> partitionsNotInHms, HdfsTable hdfsTable) throws ImpalaException { <|endfocus|> List<Partition> hmsPartitions = Lists.newArrayList(); TableName tableName = hdfsTable.getTableName(); org.apache.hadoop.hive.metastore.api.Table msTbl = getMetaStoreTable(tableName); for (List<String> list: partitionsNotInHms) { hmsPartitions.add(createHmsPartitionFromValues(list, msTbl, tableName, null)); } return hmsPartitions; } /** * Create a new HMS Partition. */ private Partition createHmsPartition(List<TPartitionKeyValue> partitionSpec,
<|startcomment|> use getExistingTable() instead of catalog_.getOrLoadTable() because it handles additional error cases <|endcomment|>  } catch (Exception e) { LOG.error("Unable to uncache table: " + table.getFullName(), e); } } if (table.getNumClusteringCols() > 0) { for (HdfsPartition partition: hdfsTable.getPartitions()) { if (partition.isMarkedCached()) { try { <|startfocus|> HdfsCachingUtil.uncachePartition(partition.getMetaStorePartition()); <|endfocus|> } catch (Exception e) { LOG.error("Unable to uncache partition: " + partition.getPartitionName(), e); } } } } } } else { resp.result.setVersion(catalog_.getCatalogVersion()); } } removedObject.setType(TCatalogObjectType.TABLE); removedObject.setTable(new TTable()); removedObject.getTable().setTbl_name(tableName.getTbl()); removedObject.getTable().setDb_name(tableName.getDb()); removedObject.setCatalog_version(resp.result.getVersion()); resp.result.setRemoved_catalog_object(removedObject); } private void dropFunction(TDropFunctionParams params, TDdlExecResponse resp) throws ImpalaException { ArrayList<Type> argTypes = Lists.newArrayList();
<|startcomment|> nit: can you write those as (other.X != null ) ? other.X.clone() : null; like you did eg in AggregateInfo? <|endcomment|>  protected LimitElement(LimitElement other) { <|startfocus|> limitExpr_ = (other.limitExpr_ == null) ? null : other.limitExpr_.clone(); offsetExpr_ = (other.offsetExpr_ == null) ? null : other.offsetExpr_.clone(); <|endfocus|> limit_ = other.limit_; offset_ = other.offset_; isAnalyzed_ = other.isAnalyzed_;
<|startcomment|> So, is it null if there are no hints? Please clarify. <|endcomment|>  private final static Logger LOG = LoggerFactory.getLogger(JoinNode.class); // Default per-host memory requirement used if no valid stats are available. // TODO: Come up with a more useful heuristic (e.g., based on scanned partitions). protected final static long DEFAULT_PER_HOST_MEM = 2L * 1024L * 1024L * 1024L; <|startfocus|> // tableRef corresponding to the left or right child of this join; only used for // getting the plan hints of this join, so it's irrelevant which child exactly protected final TableRef tblRef_; <|endfocus|> protected final JoinOperator joinOp_; protected DistributionMode distrMode_ = DistributionMode.NONE; // join conjuncts from the ON clause that aren't equi-join predicates protected List<Expr> otherJoinConjuncts_; enum DistributionMode { NONE("NONE"), BROADCAST("BROADCAST"), PARTITIONED("PARTITIONED"); private final String description_; private DistributionMode(String description) { description_ = description; } @Override public String toString() { return description_; } } 
<|startcomment|> Shouldn't the constructors be private? <|endcomment|>  private int numNodes_ = 1; // Used only to construct the initial MembershipSnapshot. <|startfocus|> <|endfocus|>
<|startcomment|> && !joinOp_.isOuterJoin() <|endcomment|>  otherJoinConjuncts, "NESTED LOOPS JOIN"); } @Override public void init(Analyzer analyzer) throws InternalException { super.init(analyzer); assignedConjuncts_ = analyzer.getAssignedConjuncts(); ExprSubstitutionMap combinedChildSmap = getCombinedChildSmap(); otherJoinConjuncts_ = Expr.substituteList(otherJoinConjuncts_, combinedChildSmap, analyzer, false); // Set the proper join operator based on whether predicates are assigned or not. <|startfocus|> if (conjuncts_.isEmpty() && otherJoinConjuncts_.isEmpty() && !joinOp_.isSemiJoin()) { <|endfocus|> joinOp_ = JoinOperator.CROSS_JOIN; } else if (joinOp_.isCrossJoin()) { // A cross join with predicates is an inner join. joinOp_ = JoinOperator.INNER_JOIN; } } @Override public void computeCosts(TQueryOptions queryOptions) { if (getChild(1).getCardinality() == -1 || getChild(1).getAvgRowSize() == -1 || numNodes_ == 0) { perHostMemCost_ = DEFAULT_PER_HOST_MEM; return; } perHostMemCost_ =
<|startcomment|> Only use a try/catch when you're actually handling the exception. This is not needed. <|endcomment|>  throw new AnalysisException( "aggregate function not allowed in WHERE clause"); } whereClause_.checkReturnsBool("WHERE clause", false); Expr e = whereClause_.findFirstOf(AnalyticExpr.class); if (e != null) { throw new AnalysisException( "WHERE clause must not contain analytic expressions: " + e.toSql()); } <|startfocus|> try { analyzer.registerConjuncts(whereClause_, false); } catch (AnalysisException ex) { throw ex; } <|endfocus|> } createSortInfo(analyzer); analyzeAggregation(analyzer); analyzeAnalytics(analyzer); if (evaluateOrderBy_) createSortTupleInfo(analyzer); // Remember the SQL string before inline-view expression substitution. sqlString_ = toSql(); resolveInlineViewRefs(analyzer); // If this block's select-project-join portion returns an empty result set and the // block has no aggregation, then mark this block as returning an empty result set. if (analyzer.hasEmptySpjResultSet() && aggInfo_ == null) { analyzer.setHasEmptyResultSet(); } ColumnLineageGraph graph = analyzer.getColumnLineageGraph();
<|startcomment|> add Preconditions.checkNotNull(type); <|endcomment|>  * parsing the Parquet schema, or if the Parquet types cannot be represented in Impala. */ private static List<ColumnDef> extractParquetSchema(HdfsUri location) throws AnalysisException { parquet.schema.MessageType parquetSchema = loadParquetSchema(location.getPath()); List<parquet.schema.Type> fields = parquetSchema.getFields(); List<ColumnDef> schema = new ArrayList<ColumnDef>(); for (parquet.schema.Type field: fields) { <|startfocus|> Type type = convertParquetType(field); <|endfocus|> String colName = field.getName(); schema.add(new ColumnDef(colName, new TypeDef(type), "inferred from:\n" + field.toString())); } return schema; } @Override public String toSql() { ArrayList<String> colsSql = Lists.newArrayList(); ArrayList<String> partitionColsSql = Lists.newArrayList(); HdfsCompression compression = HdfsCompression.fromFileName( schemaLocation_.toString()); String s = ToSqlUtils.getCreateTableSql(getDb(), getTbl() + " __LIKE_FILEFORMAT__ ", getComment(), colsSql, partitionColsSql,
<|startcomment|> why is this not needed? <|endcomment|>  } /** * Analyzes the subquery in a child analyzer. */ @Override public void analyze(Analyzer analyzer) throws AnalysisException { if (isAnalyzed_) return; super.analyze(analyzer); if (!(stmt_ instanceof SelectStmt)) { throw new AnalysisException("A subquery must contain a single select block: " + toSql()); } // The subquery is analyzed with its own analyzer. analyzer_ = new Analyzer(analyzer); analyzer_.setIsSubquery(); <|startfocus|> stmt_.analyze(analyzer_); <|endfocus|> // Set the subquery type based on the types of the exprs in the // result list of the associated SelectStmt. ArrayList<Expr> stmtResultExprs = stmt_.getResultExprs(); if (stmtResultExprs.size() == 1) { type_ = stmtResultExprs.get(0).getType(); Preconditions.checkState(!type_.isComplexType()); } else { type_ = createStructTypeFromExprList(); } // If the subquery returns many rows, set its type to ArrayType.
<|startcomment|> extra space before "<" <|endcomment|>  // FK/PK join (which doesn't alter the cardinality of the left-hand side) result = getChild(0).cardinality_; if (eqJoinConjuncts_.isEmpty()) { // No equi-join conjuncts. We estimate the cardinality as 10% of the multiplied // cardinalities from the left and right hand side. result = multiplyCardinalities(getChild(0).cardinality_, getChild(1).cardinality_); <|startfocus|> result = result < 0 ? -1 : Math.round(result * DEFAULT_JOIN_SELECTIVITY); <|endfocus|> } } else if (getChild(0).cardinality_ != -1 && getChild(1).cardinality_ != -1) { result = multiplyCardinalities(getChild(0).cardinality_, getChild(1).cardinality_); result = Math.round((double)result / (double) maxNumDistinct); } return result;
<|startcomment|> comment that this returns objects in sorted order? <|endcomment|>  * which denotes choice. Doing the work here saves loading tables or * databases from the metastore (which Hive would do if we passed the call * through to the metastore client). * * If matchPattern is null, all strings are considered to match. If it is the * empty string, no strings match. */ private <T extends CatalogObject> List<T> filterCatalogObjectsByPattern( Iterable<? extends T> candidates, String matchPattern) { <|startfocus|> List<T> filtered = Lists.newArrayList(); <|endfocus|> if (matchPattern == null) { filtered = Lists.newArrayList(candidates); } else { PatternMatcher matcher = PatternMatcher.createHivePatternMatcher(matchPattern); for (T candidate: candidates) { if (matcher.matches(candidate.getName())) filtered.add(candidate); } } Collections.sort(filtered, CATALOG_OBJECT_ORDER); return filtered; } /** * Returns the HdfsPartition object for the given dbName/tableName and partition spec. * This will trigger a metadata load if the table metadata is not yet cached.
<|startcomment|> single line <|endcomment|>  JniUtil.deserializeThrift(protocolFactory_, params, thriftGetTablesParams); // If the session was not set it indicates this is an internal Impala call. User user = params.isSetSession() ? new User(TSessionStateUtil.getEffectiveUser(params.getSession())) : ImpalaInternalAdminUser.getInstance(); List<Db> dbs = frontend_.getDbs(params.pattern, user); TGetDbsResult result = new TGetDbsResult(); <|startfocus|> List<TDatabase> tDbs = Lists.newArrayListWithCapacity(dbs.size()); for (Db db: dbs) { tDbs.add(db.toThrift()); } result.setDbs(tDbs); <|endfocus|> TSerializer serializer = new TSerializer(protocolFactory_); try { return serializer.serialize(result); } catch (TException e) { throw new InternalException(e.getMessage()); } } /** * Returns a list of data sources matching an optional pattern. * The argument is a serialized TGetDataSrcsResult object. * The return type is a serialised TGetDataSrcsResult object. * @see Frontend#getDataSrcs */
<|startcomment|> You probably want checkState() <|endcomment|>  public String getDb() { <|startfocus|> Preconditions.checkNotNull(isAnalyzed()); <|endfocus|> return tableName_.getDb();
<|startcomment|> the null case is now handled inside AvroSchemaUtils.getAvroSchema() <|endcomment|>  */ private void analyzeAvroSchema(Analyzer analyzer) throws AnalysisException { List<Map<String, String>> schemaSearchLocations = Lists.newArrayList(); schemaSearchLocations.add(tblProperties_); // Get schema string from search location String avroSchema = AvroSchemaUtils.getAvroSchema(schemaSearchLocations); // Convert potential null object to empty string avroSchema = Strings.nullToEmpty(avroSchema); String fullTblName = analyzer.getTargetDbName(tableName_) + "." + tableName_.getTbl(); if (avroSchema.isEmpty()) { <|startfocus|> throw new AnalysisException("Avro schema is null or empty: " + fullTblName); <|endfocus|> } // Check if the schema is valid and is supported by Impala try { AvroSchemaParser.parse(avroSchema); } catch (SchemaParseException e) { throw new AnalysisException(String.format( "Error parsing Avro schema for table '%s': %s", fullTblName, e.getMessage())); } } } 
<|startcomment|> remove newline <|endcomment|>  tblPropertyParams.setTarget(targetProperty_); tblPropertyParams.setProperties(tblProperties_); if (partitionSpec_ != null) { tblPropertyParams.setPartition_spec(partitionSpec_.toThrift()); } params.setSet_tbl_properties_params(tblPropertyParams); return params; } @Override public void analyze(Analyzer analyzer) throws AnalysisException { super.analyze(analyzer); // Check avro schema when it is set in avro.schema.url or avro.schema.literal. // This avoids potential metadata corruption (see IMPALA-2042). <|startfocus|> // If both properties are set then only check avro.schema.literal and avro.schema.url // is ignored. <|endfocus|> if (tblProperties_.containsKey( AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName()) || tblProperties_.containsKey( AvroSerdeUtils.AvroTableProperties.SCHEMA_URL.getPropName())) { analyzeAvroSchema(analyzer); } } /** * Check that avro schema provided in avro.schema.url or avro.schema.literal is valid Json and * contains only supported Impala types. If both properties are set, then schema in
<|startcomment|> Replace this two lines with: AnalysisError(String.format("select group_concact(%s '')", keyword), "aggregation without a FROM clause is not allowed"); and move it to L1790. You will also need to invert the two for loops (i.e. make the one of the keyword the external), so that you can also simplify tests in L1753-1756. <|endcomment|>  "AVG requires a numeric or timestamp parameter: avg(string_col)"); // aggregate requires table in the FROM clause AnalysisError("select count(*)", "aggregation without a FROM clause is not allowed"); AnalysisError("select min(1)", "aggregation without a FROM clause is not allowed"); AnalysisError("select group_concat('')", "aggregation without a FROM clause is not allowed"); <|startfocus|> AnalysisError("select group_concat(distinct '')", "aggregation without a FROM clause is not allowed"); <|endfocus|> // test group_concat using a column as the custom separator AnalyzesOk("select group_concat(string_col, string_col) from functional.alltypes"); // test group_concat without and with distinct // test all types as arguments for (Type type: typeToLiteralValue_.keySet()) { String[] keywords = new String[] {"distinct", ""}; String literal = typeToLiteralValue_.get(type); for (String keyword: keywords) { String query1 = String.format( "select group_concat(%s %s) from functional.alltypes", keyword, literal);
<|startcomment|> long line (we have a 90-char limit) <|endcomment|>  // Cached column families. Used primarily for speeding up row stats estimation // (see CDH-19292). private HColumnDescriptor[] columnFamilies_ = null; protected HBaseTable(TableId id, org.apache.hadoop.hive.metastore.api.Table msTbl, Db db, String name, String owner) { super(id, msTbl, db, name, owner); } // Connection instances are expensive to create. The HBase documentation recommends <|startfocus|> // one and then sharing it among threads. All operations on a connection are thread-safe. <|endfocus|> private static class ConnectionHolder { private static Connection connection_ = null; public static synchronized Connection getConnection(Configuration conf) throws IOException { if (connection_ == null || connection_.isClosed()) { connection_ = ConnectionFactory.createConnection(conf); } return connection_; } } // Table client objects are thread-unsafe and cheap to create. The HBase docs recommend // creating a new one for each task and then closing when done. public org.apache.hadoop.hbase.client.Table getHBaseTable() throws IOException {
<|startcomment|> Long line. <|endcomment|>  private boolean isSystemDb_ = false; <|startfocus|> public Db(String name, Catalog catalog, org.apache.hadoop.hive.metastore.api.Database msDb) { <|endfocus|> thriftDb_ = new TDatabase(name.toLowerCase()); parentCatalog_ = catalog; msDb_ = msDb; thriftDb_.setMetastore_db(msDb_); tableCache_ = new CatalogObjectCache<Table>(); functions_ = new HashMap<String, List<Function>>();
<|startcomment|> buildPrivilegeResult is not a class <|endcomment|>  } TColumnValue dbNameCol = new TColumnValue(); dbNameCol.setString_val(db.getName()); TColumnValue dbTypeCol = new TColumnValue(); dbTypeCol.setString_val(Objects.toString(location, "")); TColumnValue commentCol = new TColumnValue(); commentCol.setString_val(Objects.toString(comment, "")); descResult.results.add( new TResultRow(Lists.newArrayList(dbNameCol, dbTypeCol, commentCol))); return descResult; } /* <|startfocus|> * Helper class used to build privilege results. <|endfocus|> */ private static void buildPrivilegeResult( TDescribeDbResult descResult, List<PrivilegeGrantInfo> pgList) { for (PrivilegeGrantInfo pg: pgList) { TColumnValue privilege = new TColumnValue(); privilege.setString_val(pg.getPrivilege() + " " + pg.isGrantOption()); TColumnValue grantor = new TColumnValue(); grantor.setString_val(pg.getGrantor() + " " + pg.getGrantorType()); TColumnValue grantTime = new TColumnValue(); grantTime.setString_val(pg.getCreateTime() + ""); descResult.results.add(
<|startcomment|> point out why you're not getting this from the subplan, it's a bit subtle. <|endcomment|>  public void computeStats(Analyzer analyzer) { super.computeStats(analyzer); <|startfocus|> cardinality_ = 1; <|endfocus|> numNodes_ = containingSubplanNode_.getChild(0).getNumNodes();
<|startcomment|> purgePartition <|endcomment|>  public AlterTableDropPartitionStmt(TableName tableName, <|startfocus|> PartitionSpec partitionSpec, boolean ifExists, boolean purgeTable) { <|endfocus|> super(tableName); Preconditions.checkNotNull(partitionSpec); partitionSpec_ = partitionSpec; partitionSpec_.setTableName(tableName); ifExists_ = ifExists; this.purgeTable_ = purgeTable;
<|startcomment|> Single line with no {} <|endcomment|>  private static void buildPrivilegeResult( TDescribeResult descResult, Map<String, List<PrivilegeGrantInfo>> privilegeMap) { <|startfocus|> if (privilegeMap == null) { return; } <|endfocus|> for (Map.Entry<String, List<PrivilegeGrantInfo>> privilegeEntry : privilegeMap.entrySet()) { TColumnValue title = new TColumnValue(); title.setString_val("Privileges for " + privilegeEntry.getKey() + ": "); descResult.results.add( new TResultRow(Lists.newArrayList(title, EMPTY, EMPTY))); for (PrivilegeGrantInfo privilegeInfo: privilegeEntry.getValue()) { TColumnValue privilege = new TColumnValue(); privilege.setString_val( privilegeInfo.getPrivilege() + " " + privilegeInfo.isGrantOption()); TColumnValue grantor = new TColumnValue(); grantor.setString_val( privilegeInfo.getGrantor() + " " + privilegeInfo.getGrantorType()); TColumnValue grantTime = new TColumnValue(); grantTime.setString_val(privilegeInfo.getCreateTime() + ""); descResult.results.add( new TResultRow(Lists.newArrayList(privilege, grantor, grantTime))); } }
<|startcomment|> boolean isCacheable = false, for clarity? <|endcomment|>  params.setSet_cached_params(cachingParams); return params; } @Override public void analyze(Analyzer analyzer) throws AnalysisException { super.analyze(analyzer); cacheOp_.analyze(analyzer); Table table = getTargetTable(); Preconditions.checkNotNull(table); if (!(table instanceof HdfsTable)) { throw new AnalysisException("ALTER TABLE SET [CACHED|UNCACHED] must target an " + "HDFS table: " + table.getFullName()); } if (cacheOp_.shouldCache()) { boolean isCacheable; <|startfocus|> StringBuilder locationSb = new StringBuilder(); <|endfocus|> PartitionSpec partSpec = getPartitionSpec(); HdfsTable hdfsTable = (HdfsTable)table; if (partSpec != null) { HdfsPartition part = hdfsTable.getPartition(partSpec.getPartitionSpecKeyValues()); if (part == null) { throw new AnalysisException("Partition spec does not exist: " + partSpec.toSql()); } isCacheable = part.isCacheable(); locationSb.append(part.getLocation()); } else { isCacheable = hdfsTable.isCacheable(locationSb); }
<|startcomment|> There are a lot of unnecessary whitespace changes in this file. It would be better to avoid the additional code churn. <|endcomment|>  Object parseNode = ParsesOk(selectStmtSql); if (!(parseNode instanceof SelectStmt)) { fail(String.format("Statement parsed ok but it is not a select stmt: %s", selectStmtSql)); } SelectStmt selectStmt = (SelectStmt) parseNode; Expr firstExpr = selectStmt.getSelectList().getItems().get(0).getExpr(); // Check the class of the first select-list expression. assertTrue(String.format( <|startfocus|> "Expression is of class '%s'. Expected class '%s'", firstExpr.getClass().getSimpleName(), cl.getSimpleName()), <|endfocus|> firstExpr.getClass().equals(cl)); return parseNode;
<|startcomment|> remove this. <|endcomment|>  */ public CreateTableAsSelectStmt(CreateTableStmt createStmt, QueryStmt queryStmt) { Preconditions.checkNotNull(queryStmt); Preconditions.checkNotNull(createStmt); createStmt_ = createStmt; insertStmt_ = new InsertStmt(null, createStmt.getTblName(), false, null, null, queryStmt, null); } public QueryStmt getQueryStmt() { return insertStmt_.getQueryStmt(); } <|startfocus|> public InsertStmt getInsertStmt() { return insertStmt_; } <|endfocus|> public CreateTableStmt getCreateStmt() { return createStmt_; } @Override public String toSql() { return createStmt_.toSql() + " AS " + getQueryStmt().toSql(); } @Override public void analyze(Analyzer analyzer) throws AnalysisException { if (isAnalyzed()) return; super.analyze(analyzer); // The analysis for CTAS happens in two phases - the first phase happens before // the target table exists and we want to validate the CREATE statement and the // query portion of the insert statement. If this passes, analysis will be run
<|startcomment|> tableParamsAreValid() ? Also, does this need to be public? <|endcomment|> <|startfocus|> public static boolean validTable(Map<String, String> params) { <|endfocus|> return params.get(KEY_TABLE_NAME) != null && params.get(KEY_TABLE_NAME).length() > 0 && params.get(KEY_MASTER_ADDRESSES) != null && params.get(KEY_MASTER_ADDRESSES).length() > 0 && params.get(KEY_KEY_COLUMNS) != null && params.get(KEY_KEY_COLUMNS).length() > 0;
<|startcomment|> "loadDb" does not exist. Can you plz update this comment? <|endcomment|>  * * Tables are stored in a map from the table name to the table object. They may * be loaded 'eagerly' at construction or 'lazily' on first reference. * Tables are accessed via getTable which may trigger a metadata read in two cases: * * if the table has never been loaded * * if the table loading failed on the previous attempt */ public class Db implements CatalogObject { <|startfocus|> private static final Logger LOG = Logger.getLogger(Db.class); <|endfocus|> private final Catalog parentCatalog_; private final TDatabase thriftDb_; private long catalogVersion_ = Catalog.INITIAL_CATALOG_VERSION; // Table metadata cache. private final CatalogObjectCache<Table> tableCache_; // All of the registered user functions. The key is the user facing name (e.g. "myUdf"), // and the values are all the overloaded variants (e.g. myUdf(double), myUdf(string)) // This includes both UDFs and UDAs. Updates are made thread safe by synchronizing // on this map. private final HashMap<String, List<Function>> functions_;
<|startcomment|> single line <|endcomment|>  * The argument is a serialized TGetDbParams object. * The return type is a serialized TGetDbResult object. */ public byte[] getDbs(byte[] thriftGetTablesParams) throws ImpalaException, TException { TGetDbsParams params = new TGetDbsParams(); JniUtil.deserializeThrift(protocolFactory_, params, thriftGetTablesParams); List<Db> dbs = catalog_.getDbs(null); TGetDbsResult result = new TGetDbsResult(); List<TDatabase> tDbs = Lists.newArrayListWithCapacity(dbs.size()); <|startfocus|> for (Db db: dbs) { tDbs.add(db.toThrift()); } <|endfocus|> result.setDbs(tDbs); TSerializer serializer = new TSerializer(protocolFactory_); return serializer.serialize(result); } /** * Returns a list of table names matching an optional pattern. * The argument is a serialized TGetTablesParams object. * The return type is a serialized TGetTablesResult object. */ public byte[] getTableNames(byte[] thriftGetTablesParams) throws ImpalaException, TException { TGetTablesParams params = new TGetTablesParams();
<|startcomment|> <space>+ (and elsewhere) <|endcomment|>  String numericTypes[] = new String[] { "TINYINT", "SMALLINT", "INT", "BIGINT", "FLOAT", "DOUBLE", "DECIMAL"}; for (String numericType : numericTypes) { numericValues.add("cast(NULL as " + numericType + ")"); } for (String lhs : numericValues) { for (String rhs : numericValues) { AnalyzesOk("select * from functional.alltypes where " + lhs + " " <|startfocus|> + operator+ " " + rhs); <|endfocus|> } } // Operator can compare identical non-numeric types for (String operand : new String[] {"bool_col", "string_col", "timestamp_col", "NULL"}) { AnalyzesOk("select * from functional.alltypes where " + operand + " " + operator+ " " + operand); AnalyzesOk("select * from functional.alltypes where " + operand + " " + operator+ " NULL"); AnalyzesOk( "select * from functional.alltypes where NULL " + operator+ " " + operand); } 
<|startcomment|> .._DB_PARAM_... <|endcomment|>  new TSerializer(new TCompactProtocol.Factory()); private final Catalog parentCatalog_; private final TDatabase thriftDb_; private long catalogVersion_ = Catalog.INITIAL_CATALOG_VERSION; private static final String FUNCTION_INDEX_PREFIX = "impala_registered_function_"; // Hive metastore imposes a limit of 4000 bytes on the key and value strings // in DB parameters map. We need ensure that this limit isn't crossed // while serializing functions to the metastore. <|startfocus|> private static final int HIVE_METASTORE_PARAM_LIMIT_BYTES = 4000; <|endfocus|> // Table metadata cache. private final CatalogObjectCache<Table> tableCache_; // All of the registered user functions. The key is the user facing name (e.g. "myUdf"), // and the values are all the overloaded variants (e.g. myUdf(double), myUdf(string)) // This includes both UDFs and UDAs. Updates are made thread safe by synchronizing // on this map. When a new Db object is initialized, this list is updated with the
<|startcomment|> final (rhs or join predicate) <|endcomment|>  * the filter and the scan node that applies the filter (destination node). */ public static class RuntimeFilter { // Identifier of the filter (unique within a query) private final RuntimeFilterId id_; // Join node that constructs the filter private final JoinNode constructingNode_; // Scan node that applies the filter private ScanNode destinationNode_; // Expr on which the filter is built private final Expr buildExpr_; <|startfocus|> // Expr on which the filter is applied <|endfocus|> private Expr applyExpr_; // Slots from scan tuples that are in the same equivalent classes as the slots of // 'applyExpr_'. The slots are grouped by tuple id. private Map<TupleId, List<SlotId>> applyExprSlotsByTid_; private RuntimeFilter(RuntimeFilterId filterId, JoinNode filterConstructingNode, Expr buildExpr, Expr applyExpr, Map<TupleId, List<SlotId>> applyExprSlots) { id_ = filterId; constructingNode_ = filterConstructingNode; buildExpr_ = buildExpr; applyExpr_ = applyExpr; applyExprSlotsByTid_ = applyExprSlots; } 
<|startcomment|> Spaces instead of tabs <|endcomment|>  // IsNullPredicate. testToSql("select 5 is null, (5 is null), 10 is not null, (10 is not null)", "SELECT 5 IS NULL, (5 IS NULL), 10 IS NOT NULL, (10 IS NOT NULL)"); // LikePredicate. testToSql("select 'a' LIKE '%b.', ('a' LIKE '%b.'), " + <|startfocus|> "'a' ILIKE '%b.', ('a' ILIKE '%b.'), " + <|endfocus|> "'b' RLIKE '.c%', ('b' RLIKE '.c%')," + "'d' IREGEXP '.e%', ('d' IREGEXP '.e%')," + "'d' REGEXP '.e%', ('d' REGEXP '.e%')", "SELECT 'a' LIKE '%b.', ('a' LIKE '%b.'), " + "'a' ILIKE '%b.', ('a' ILIKE '%b.'), " + "'b' RLIKE '.c%', ('b' RLIKE '.c%'), " +
<|startcomment|> duplicated from catalogservicecatalog. only keep this description in one of the two classes and refer to it in the other one (yes, it's annoying that the code is split in this way, it's very obvious that that doesn't make sense). <|endcomment|>  * metastore out of this class. */ public class CatalogOpExecutor { // Format string for exceptions returned by Hive Metastore RPCs. private final static String HMS_RPC_ERROR_FORMAT_STR = "Error making '%s' RPC to Hive Metastore: "; private final CatalogServiceCatalog catalog_; <|startfocus|> // Lock used to synchronize metastore CREATE/DROP/ALTER TABLE/DATABASE requests. <|endfocus|> private final Object metastoreDdlLock_ = new Object(); private static final Logger LOG = Logger.getLogger(CatalogOpExecutor.class); // Only applies to partition updates after an INSERT for now. private static final int NUM_CONCURRENT_METASTORE_OPERATIONS = 16; // The maximum number of partitions to update in one Hive Metastore RPC. // Used when persisting the results of COMPUTE STATS statements. private final static short MAX_PARTITION_UPDATES_PER_RPC = 500; // Used to execute metastore updates in parallel. Currently only used for bulk // partition creations. private final ExecutorService executor_ = Executors.newFixedThreadPool(NUM_CONCURRENT_METASTORE_OPERATIONS); public CatalogOpExecutor(CatalogServiceCatalog catalog) { catalog_ = catalog;
<|startcomment|> ... assigned to this node ... comment when the entries are the build and when the apply side of a runtime filter <|endcomment|>  // invalid: -1 protected long cardinality_; // number of nodes on which the plan tree rooted at this node would execute; // set in computeStats(); invalid: -1 protected int numNodes_; // sum of tupleIds_' avgSerializedSizes; set in computeStats() protected float avgRowSize_; // estimated per-host memory requirement for this node; // set in computeCosts(); invalid: -1 protected long perHostMemCost_ = -1; <|startfocus|> // Runtime filters assigned at this node <|endfocus|> protected Map<RuntimeFilterId, Expr> runtimeFilters_ = Maps.newHashMap(); protected PlanNode(PlanNodeId id, ArrayList<TupleId> tupleIds, String displayName) { id_ = id; limit_ = -1; // make a copy, just to be on the safe side tupleIds_ = Lists.newArrayList(tupleIds); tblRefIds_ = Lists.newArrayList(tupleIds); cardinality_ = -1; numNodes_ = -1; displayName_ = displayName;
<|startcomment|> I know this was originally my name suggestion :), but I think we can shrink it ti getFirstBoundChild() it's clear from the arg what the binding is about <|endcomment|> <|startfocus|> protected Expr getFirstChildBoundByTids(List<TupleId> tids) { <|endfocus|> for (Expr child: children_) { if (child.isBoundByTupleIds(tids)) return child; } return null;
<|startcomment|> UDF <|endcomment|> import com.cloudera.impala.thrift.TFunctionBinaryType; import com.cloudera.impala.thrift.TSymbolType; import com.google.common.base.Preconditions; /** * Represents a CREATE FUNCTION statement for adding Hive udfs. Hive udf * create statements do not require argument types or return types for the * function. */ public class CreateHiveUdfStmt extends CreateFunctionStmtBase { /** * Builds a CREATE FUNCTION statement * @param fnName - Name of the function <|startfocus|> * @param location - Path in HDFS containing the UDA. <|endfocus|> * @param ifNotExists - If true, no errors are thrown if the function already exists * @param additionalArgs - Key/Value pairs for additional arguments. The keys are * validated in analyze() */ public CreateHiveUdfStmt(FunctionName fnName, HdfsUri location, boolean ifNotExists, HashMap<CreateFunctionStmtBase.OptArg, String> optArgs) { super(fnName, new FunctionArgs(), new TypeDef(ScalarType.createType(PrimitiveType.INVALID_TYPE)), location, ifNotExists, optArgs); } @Override
<|startcomment|> // The return and arg types must either be both null or non-null. Preconditions.checkState(!(args == null && args != retTypeDef)); <|endcomment|>  protected CreateFunctionStmtBase(FunctionName fnName, FunctionArgs args, TypeDef retTypeDef, HdfsUri location, boolean ifNotExists, <|startfocus|> HashMap<CreateFunctionStmtBase.OptArg, String> optArgs) { <|endfocus|> fnName_ = fnName; args_ = args; retTypeDef_ = retTypeDef; location_ = location; ifNotExists_ = ifNotExists; optArgs_ = optArgs;
<|startcomment|> Map <|endcomment|>  // Update the authorization policy, waiting for the result to complete. sentryProxy_.refresh(); } catch (Exception e) { throw new CatalogException("Error updating authorization policy: ", e); } } catalogLock_.writeLock().lock(); try { nextTableId_.set(0); // Not all Java udfs are persisted to the metastore. The ones which aren't // should be restored once the catalog has been invalidated. <|startfocus|> ConcurrentHashMap<String, Db> oldDbCache = dbCache_.get(); <|endfocus|> // Build a new DB cache, populate it, and replace the existing cache in one // step. ConcurrentHashMap<String, Db> newDbCache = new ConcurrentHashMap<String, Db>(); List<TTableName> tblsToBackgroundLoad = Lists.newArrayList(); MetaStoreClient msClient = metaStoreClientPool_.getClient(); try { for (String dbName: msClient.getHiveClient().getAllDatabases()) { List<org.apache.hadoop.hive.metastore.api.Function> javaFns = Lists.newArrayList();
<|startcomment|> nit: order the if/else-if checks in the same order as the enum values so it's easier to keep them in sync note that some of the enum values have no corresponding match in this function <|endcomment|>  return JavaUdfDataType.SHORT_WRITABLE; } else if (c == IntWritable.class) { return JavaUdfDataType.INT_WRITABLE; } else if (c == LongWritable.class) { return JavaUdfDataType.LONG_WRITABLE; } else if (c == FloatWritable.class) { return JavaUdfDataType.FLOAT_WRITABLE; } else if (c == DoubleWritable.class) { return JavaUdfDataType.DOUBLE_WRITABLE; } else if (c == boolean.class || c == Boolean.class) { <|startfocus|> return JavaUdfDataType.BOOLEAN; <|endfocus|> } else if (c == byte.class || c == Byte.class) { return JavaUdfDataType.TINYINT; } else if (c == short.class || c == Short.class) { return JavaUdfDataType.SMALLINT; } else if (c == int.class || c == Integer.class) { return JavaUdfDataType.INT; } else if (c == long.class || c == Long.class) { return JavaUdfDataType.BIGINT; } else if (c == float.class || c == Float.class) { return JavaUdfDataType.FLOAT;
<|startcomment|> move this below restoring the non-persistent UDFs <|endcomment|>  List<org.apache.hadoop.hive.metastore.api.Function> javaFns = Lists.newArrayList(); for (String javaFn: msClient.getHiveClient().getFunctions(dbName, "*")) { javaFns.add(msClient.getHiveClient().getFunction(dbName, javaFn)); } org.apache.hadoop.hive.metastore.api.Database msDb = msClient.getHiveClient().getDatabase(dbName); Db db = new Db(dbName, this, msDb); <|startfocus|> loadFunctionsFromDbParams(db, msDb); <|endfocus|> // Restore UDFs that aren't persisted. Db oldDb = oldDbCache.get(db.getName().toLowerCase()); if (oldDb != null) { for (Function fn: oldDb.getTransientFunctions()) { db.addFunction(fn); fn.setCatalogVersion(incrementAndGetCatalogVersion()); } } loadJavaFunctions(db, javaFns); db.setCatalogVersion(incrementAndGetCatalogVersion()); newDbCache.put(db.getName().toLowerCase(), db); for (String tableName: msClient.getHiveClient().getAllTables(dbName)) { Table incompleteTbl = IncompleteTable.createUninitializedTable(
<|startcomment|> remove this sentence, it only made sense in the context of SelectStmt <|endcomment|>  tableRefs_.set(i, Preconditions.checkNotNull(tblRef)); tblRef.setLeftTblRef(leftTblRef); try { tblRef.analyze(analyzer); } catch (AnalysisException e) { // Only re-throw the exception if no tables are missing. if (analyzer.getMissingTbls().isEmpty()) throw e; } leftTblRef = tblRef; } <|startfocus|> // All tableRefs have been analyzed, but at least one table was found missing. // There is no reason to proceed with analysis past this point. <|endfocus|> if (!analyzer.getMissingTbls().isEmpty()) { throw new AnalysisException("Found missing tables. Aborting analysis."); } analyzed_ = true; } public FromClause clone() { ArrayList<TableRef> clone = Lists.newArrayList(); for (TableRef tblRef: tableRefs_) clone.add(tblRef.clone()); return new FromClause(clone); } public void reset() { for (int i = 0; i < size(); ++i) { TableRef origTblRef = get(i);
<|startcomment|> we only use Preconditions for internal logic errors, not expected user errors (ie, the return value is never used). <|endcomment|>  if (getMetaStoreTable() == null || !tableParamsAreValid(msTbl.getParameters())) { throw new TableLoadingException(String.format( "Cannot load Kudu table %s, table is corrupt.", cachedEntry.getFullName())); } kuduTableName_ = msTbl.getParameters().get(KEY_TABLE_NAME); kuduMasters_ = msTbl.getParameters().get(KEY_MASTER_ADDRESSES); <|startfocus|> String keyColumnsProp = Preconditions.checkNotNull(msTbl.getParameters().get(KEY_KEY_COLUMNS) .toLowerCase(), "'kudu.key_columns' cannot be null."); <|endfocus|> Set<String> keyColumns = KuduUtil.parseKeyColumns(keyColumnsProp); // Load the rest of the data from the table parameters directly loadColumns(msTbl.getSd().getCols(), client, keyColumns); numClusteringCols_ = 0; // Get row count from stats numRows_ = getRowCount(getMetaStoreTable().getParameters()); } @Override public TTable toThrift() { TTable table = super.toThrift(); table.setTable_type(TTableType.KUDU_TABLE); table.setKudu_table(getKuduTable()); return table; }
<|startcomment|> move this to a FunctionParams.clone()? this is in effect a shallow clone. why do we need that? <|endcomment|>  protected FunctionCallExpr(FunctionCallExpr other) { super(other); fnName_ = other.fnName_; isAnalyticFnCall_ = other.isAnalyticFnCall_; isInternalFnCall_ = other.isInternalFnCall_; <|startfocus|> isMergeAggFn_ = other.isMergeAggFn_; <|endfocus|> if (other.params_.isStar()) { Preconditions.checkState(children_.isEmpty()); params_ = FunctionParams.createStarParam(); } else { // The children have already been cloned in the super c'tor. params_ = new FunctionParams(other.params_.isDistinct(), children_); } label_ = other.label_;
<|startcomment|> single line <|endcomment|>  dstTbl.getFullName())); } table_ = (KuduTable) dstTbl; // Make sure that the user is allowed to modify the target table, since no // UPDATE / DELETE privilege exists, we reuse the INSERT one. analyzer.registerPrivReq(new PrivilegeRequestBuilder() .onTable(table_.getDb().getName(), table_.getName()) .allOf(Privilege.INSERT).toRequest()); // Validates the assignments_ and creates the sourceStmt_. <|startfocus|> if (sourceStmt_ == null) { createSourceStmt(analyzer); } <|endfocus|> sourceStmt_.analyze(analyzer); } @Override public void reset() { super.reset(); fromClause_.reset(); if (sourceStmt_ != null) { sourceStmt_.reset(); } table_ = null; referencedColumns_.clear(); } /** * Builds and validates the sourceStmt_. The select list of the sourceStmt_ contains * first the SlotRefs for the key Columns, followed by the expressions representing the * assignments. This method sets the member variables for the sourceStmt_ and the
<|startcomment|> looks like this message needs to change as well. <|endcomment|>  fs.getClass().getSimpleName() + ". " + CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY + " (" + CONF.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY) + ")" + " is not supported"; } } catch (IOException e) { return "couldn't retrieve FileSystem:\n" + e.getMessage(); } try { FileSystemUtil.getTotalNumVisibleFiles(new Path("/")); } catch (IOException e) { <|startfocus|> return "Could not read the HDFS root directory at " + <|endfocus|> CONF.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY) + ". Error was: \n" + e.getMessage(); } return "";
<|startcomment|> This error message may appear vague without context Does it just refer to the table.newInsert() failure? <|endcomment|>  } @Override public void initialize(Event event, KuduTable table) { this.payload = event.getBody(); this.table = table; } @Override public List<Operation> getOperations() throws FlumeException { try { Insert insert = table.newInsert(); PartialRow row = insert.getRow(); row.addBinary(payloadColumn, payload); return Collections.singletonList((Operation) insert); } catch (Exception e){ <|startfocus|> throw new FlumeException("Could not get row key!", e); <|endfocus|> } } @Override public void close() { } } 
<|startcomment|> nit: w <|endcomment|>  "Master name cannot be empty, please specify '" + KuduSinkConfigurationConstants.MASTER_ADDRESS + "' in configuration file"); Preconditions.checkNotNull(tableName, "Table name cannot be empty, please specify '" + KuduSinkConfigurationConstants.TABLE + "'in configuration file"); // Check for event producer, if null set event producer type if (eventProducerType == null || eventProducerType.isEmpty()) { eventProducerType = DEFAULT_KUDU_EVENT_PRODUCER; logger.info("No Kudu event producer defined, Will use default"); <|startfocus|> } <|endfocus|> producerContext.putAll(context.getSubProperties( KuduSinkConfigurationConstants.PRODUCER_PREFIX)); try { Class<? extends KuduEventProducer> clazz = (Class<? extends KuduEventProducer>) Class.forName(eventProducerType); eventProducer = clazz.newInstance(); eventProducer.configure(producerContext); } catch (Exception e) { logger.error("Could not instantiate Kudu event producer." , e); Throwables.propagate(e); } sinkCounter = new SinkCounter(this.getName());
<|startcomment|> should specify that this is the 'start' key <|endcomment|>  * @return Sanitized hostname with last period stripped off. * */ private static String domainNamePointerToHostName(String dnPtr) { if (dnPtr == null) return null; return dnPtr.endsWith(".") ? dnPtr.substring(0, dnPtr.length() - 1) : dnPtr; } @Override public Configuration getConf() { return conf; } static class ScanTokenSplit extends InputSplit implements Writable, Comparable<ScanTokenSplit> { <|startfocus|> private ByteBuffer token; <|endfocus|> private byte[] partitionKey; private String[] locations; public ScanTokenSplit() { } // Writable public ScanTokenSplit(ScanToken token, String[] locations) throws IOException { this.token = token.serialize(); this.token.rewind(); this.partitionKey = token.getTablet().getPartition().getPartitionKeyStart(); this.locations = locations; } @Override public long getLength() throws IOException, InterruptedException { // TODO Guesstimate a size return 0; } @Override public String[] getLocations() throws IOException, InterruptedException { return locations;
<|startcomment|> Nit: access split.token through a getter. It wasn't obvious that a private field is accessed directly by another class here. <|endcomment|>  private final NullWritable currentKey = NullWritable.get(); private RowResult currentValue; private RowResultIterator iterator; private KuduScanner scanner; private ScanTokenSplit split; @Override public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException { if (!(inputSplit instanceof ScanTokenSplit)) { throw new IllegalArgumentException("ScanTokenSplit is the only accepted input split"); } split = (ScanTokenSplit) inputSplit; try { <|startfocus|> scanner = ScanToken.deserializeIntoScanner(split.token, client); <|endfocus|> } catch (Exception e) { throw new IOException(e); } // Calling this now to set iterator. tryRefreshIterator(); } @Override public boolean nextKeyValue() throws IOException, InterruptedException { if (!iterator.hasNext()) { tryRefreshIterator(); if (!iterator.hasNext()) { // Means we still have the same iterator, we're done return false; } } currentValue = iterator.next(); return true; } /**
<|startcomment|> update comment <|endcomment|>  try { AvroSchemaParser.parse(avroSchema); } catch (SchemaParseException e) { throw new AnalysisException(String.format( "Error parsing Avro schema for table '%s': %s", table_.getFullName(), e.getMessage())); } } /** <|startfocus|> * Check that the 'skip.header.line.count' property is only set on table types and file * formats that support it, and make sure that it is set to a valid value. <|endfocus|> */ public static void analyzeSkipHeaderLineCount( Map<String, String> tblProperties, boolean isHdfsTable) throws AnalysisException { if (tblProperties.containsKey(HdfsTable.TBL_PROP_SKIP_HEADER_LINE_COUNT)) { if (!isHdfsTable) { throw new AnalysisException(String.format("Table property " + "'skip.header.line.count' is only supported for HDFS tables.")); } StringBuilder error = new StringBuilder(); HdfsTable.parseSkipHeaderLineCount(tblProperties, error); if (error.length() > 0) throw new AnalysisException(error.toString()); } } } 
<|startcomment|> Can you add a comment here explaining this logic? <|endcomment|> import org.apache.hadoop.security.authentication.util.KerberosName; import org.apache.hadoop.security.SecurityUtil; import org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod; /* * Class that represents a User of an Impala session. */ public class User extends KerberosName { static { final String defaultRule; final Configuration conf = new Configuration(); AuthenticationMethod authMethod = SecurityUtil.getAuthenticationMethod(conf); if (authMethod == AuthenticationMethod.KERBEROS || authMethod == AuthenticationMethod.KERBEROS_SSL) { defaultRule = "DEFAULT"; } else { // just extract the simple user name <|startfocus|> defaultRule = "RULE:[1:$1] RULE:[2:$1]"; <|endfocus|> } setRules(conf.get(HADOOP_SECURITY_AUTH_TO_LOCAL, defaultRule)); } private final String name_; public User(String name) { super(name); Preconditions.checkNotNull(name); this.name_ = name; } public String getName() { return name_; } /* * Returns short name for the current user. This just calls KerberosName#getShortName()
<|startcomment|> nit <|endcomment|>  */ OPTS_ERRORS(3), /** * How many rpcs have been sent to server but failed. */ RPC_ERRORS(4); Statistic(int idx) { this.idx = idx; } /** * Get index of this statistic. * @return index */ public int getIndex() { return this.idx; } private final int idx; }; /** * Increment the statistics count. <|startfocus|> * @param talbeName the table's name <|endfocus|> * @param tabletId the tablet's id * @param statistic specify the statistic type to increment * @param count the additional statistic count */ void incrementStatistic(String tableName, String tabletId, Statistic statistic, long count) { getTabletStatistics(tableName, tabletId).incrementStatistic(statistic, count); } /** * Get the statistic count. If the specified tablet doesn't have statistics, 0 will be returned. * @param tabletId the tablet's id * @param statistic specify the statistic type to get
<|startcomment|> I'd prefer to only add this in VERBOSE and EXTENDED <|endcomment|>  msg.hash_join_node.addToEq_join_conjuncts(eqJoinCondition); } for (Expr e: otherJoinConjuncts_) { msg.hash_join_node.addToOther_join_conjuncts(e.treeToThrift()); } msg.hash_join_node.setAdd_probe_filters(addProbeFilters_); for (Map.Entry<DynamicFilterId, Expr> entry: runtimeFilters_.entrySet()) { msg.hash_join_node.addToRuntime_filters( new TRuntimeFilter(entry.getKey().asInt(), entry.getValue().treeToThrift())); } } <|startfocus|> @Override <|endfocus|> protected String getNodeExplainString(String prefix, String detailPrefix, TExplainLevel detailLevel) { StringBuilder output = new StringBuilder(); output.append(String.format("%s%s [%s]\n", prefix, getDisplayLabel(), getDisplayLabelDetail())); if (detailLevel.ordinal() > TExplainLevel.MINIMAL.ordinal()) { output.append(detailPrefix + "hash predicates: "); for (int i = 0; i < eqJoinConjuncts_.size(); ++i) { Expr eqConjunct = eqJoinConjuncts_.get(i); output.append(eqConjunct.toSql());
<|startcomment|> if this must be either a dfs subclass or s3a, shouldn't this be if (!(fs instanceof DFS) && !(fs instanceof S3A)) throw ... ? <|endcomment|>  throws AnalysisException { // The user must have permission to access the source location. Since the files will // be moved from this location, the user needs to have all permission. sourceDataPath_.analyze(analyzer, Privilege.ALL); // Catch all exceptions thrown by accessing files, and rethrow as AnalysisExceptions. try { Path source = sourceDataPath_.getPath(); FileSystem fs = source.getFileSystem(FileSystemUtil.getConfiguration()); <|startfocus|> if (!(fs instanceof DistributedFileSystem) || !(fs instanceof S3AFileSystem)) { <|endfocus|> throw new AnalysisException(String.format("INPATH location '%s' " + "must point to an HDFS or S3A filesystem.", sourceDataPath_)); } if (!fs.exists(source)) { throw new AnalysisException(String.format( "INPATH location '%s' does not exist.", sourceDataPath_)); } // If the source file is a directory, we must be able to read from and write to
<|startcomment|> Why not mark the class as abstract then? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.cloudera.impala.common; import java.util.ArrayList; import java.util.Collection; import java.util.List; import com.cloudera.impala.util.Visitor; import com.google.common.base.Predicate; /** * Generic tree structure. Only concrete subclasses of this can be instantiated. */ <|startfocus|> public class TreeNode<NodeType extends TreeNode<NodeType>> { <|endfocus|> protected ArrayList<NodeType> children_ = new ArrayList<NodeType>(); protected TreeNode() {} public NodeType getChild(int i) { return hasChild(i) ? children_.get(i) : null; } public void addChild(NodeType n) { children_.add(n); } public void removeChild(NodeType n) { children_.remove(n); } public void clearChildren() { children_.clear(); } public void addChildren(List<? extends NodeType> l) {
<|startcomment|> Is this still relevant? Maybe create a JIRA and reference it here? <|endcomment|>  TCatalogObjectType.TABLE, Privilege.CREATE.toString())); // Only Avro tables can have empty column defs because they can infer them from // the Avro schema. if (columnDefs_.isEmpty() && fileFormat_ != THdfsFileFormat.AVRO) { throw new AnalysisException("Table requires at least 1 column"); } if (location_ != null) { location_.analyze(analyzer, Privilege.ALL, FsAction.READ_WRITE); } <|startfocus|> analyzeRowFormatValue(rowFormat_.getFieldDelimiter()); analyzeRowFormatValue(rowFormat_.getLineDelimiter()); analyzeRowFormatValue(rowFormat_.getEscapeChar()); <|endfocus|> // Check that all the column names are valid and unique. analyzeColumnDefs(analyzer); if (fileFormat_ == THdfsFileFormat.AVRO) { columnDefs_ = analyzeAvroSchema(analyzer); if (columnDefs_.isEmpty()) { throw new AnalysisException( "An Avro table requires column definitions or an Avro schema."); } AvroSchemaUtils.setFromSerdeComment(columnDefs_); analyzeColumnDefs(analyzer); } if (cachingOp_ != null) cachingOp_.analyze(analyzer); } /**
<|startcomment|> ?? <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.cloudera.impala.analysis; import java.util.HashMap; import java.util.Map; <|startfocus|> import org.kududb.client.shaded.com.google.common.base.Preconditions; <|endfocus|> import com.cloudera.impala.catalog.Column; import com.cloudera.impala.catalog.ColumnStats; import com.cloudera.impala.common.AnalysisException; import com.cloudera.impala.thrift.TAlterTableParams; import com.cloudera.impala.thrift.TAlterTableType; import com.cloudera.impala.thrift.TAlterTableUpdateStatsParams; import com.google.common.base.Joiner; /** * Represents an ALTER TABLE [<dbName>.]<tableName> SET COLUMN STATS <colName> * ('statsKey'='val','statsKey2',='val2') statement. * * The keys as well as the values are specified as string literals to be consistent
<|startcomment|> I find this error message opaque. What does "bounded" mean in this sense? Also, does this check that it is bounded by at most one partition column? <|endcomment|>  } HdfsPartitionPruner pruner = new HdfsPartitionPruner(tableRef_.getDesc()); List<SlotId> partitionSlots = pruner.getSlotIds(); // Verify the partition exprs. Make sure every conjunct only contains exactly // one partition slot ref. for (Expr e: partitionExprs_) { boolean bounded = false; for (SlotId sid: partitionSlots) { bounded |= e.isBound(sid); } if (!bounded) { throw new AnalysisException( <|startfocus|> "Partition expr is not applicable. It should be bounded by " + "one and only one partition column."); <|endfocus|> } } List<HdfsPartition> matchingPartitions; List<Expr> conjuncts = Lists.newArrayList(partitionExprs_); try { matchingPartitions = pruner.prunePartitions(analyzer, conjuncts, true); } catch (InternalException e) { throw new AnalysisException("Partition expr evaluation failed in the backend."); } if (!conjuncts.isEmpty()) { LOG.debug("Useless partition conjuncts in DDL."); } for (HdfsPartition partition: matchingPartitions) { partitionIds_.add(partition.getId());
<|startcomment|> "from the column definition" <|endcomment|>  * resolution policy: * * Mismatched number of columns -> Prefer Avro columns. * Mismatched name/type -> Prefer Avro column, except: * A CHAR/VARCHAR column definition maps to an Avro STRING, and is preserved * as a CHAR/VARCHAR in the reconciled schema. * * Behavior for TIMESTAMP: * A TIMESTAMP column definition maps to an Avro STRING and is presented as a STRING * in the reconciled schema, because Avro has no binary TIMESTAMP representation. * As a result, no Avro table may have a TIMESTAMP column. */ public static List<ColumnDef> reconcileSchemas( <|startfocus|> List<ColumnDef> colDefs, List<ColumnDef> avroCols, StringBuilder warning) { <|endfocus|> if (colDefs.size() != avroCols.size()) { warning.append(String.format( "Ignoring column definitions in favor of Avro schema.\n" + "The Avro schema has %s column(s) but %s column definition(s) were given.", avroCols.size(), colDefs.size())); return avroCols; } 
<|startcomment|> isn't this equivalent to partitionSpec == null || name != null? I believe the indention of this check should be that you can't have a partition spec without a valid table name, no? <|endcomment|>  public ResetMetadataStmt(TableName name, boolean isRefresh, PartitionSpec partitionSpec) { Preconditions.checkArgument(!isRefresh || name != null); <|startfocus|> Preconditions.checkArgument(partitionSpec == null || (partitionSpec != null && name != null && !name.isEmpty())); <|endfocus|> this.tableName_ = name; this.isRefresh_ = isRefresh; this.partitionSpec_ = partitionSpec; if (partitionSpec_ != null) { partitionSpec_.setTableName(tableName_); }
<|startcomment|> Remove here and everywhere else. Not needed... <|endcomment|>  private MetaStoreClient(HiveConf hiveConf) { try { LOG.debug("Creating MetaStoreClient. Pool Size = " + clientPool_.size()); <|startfocus|> this.hiveClient_ = new HiveMetaStoreClient(hiveConf); <|endfocus|> } catch (Exception e) { // Turn in to an unchecked exception throw new IllegalStateException(e); } this.isInUse_ = false;
<|startcomment|> nit, just say 'that match 'matcher'' <|endcomment|>  return dataSources_.getValues(); } /** * Returns a list of data sources names that match pattern. See filterStringsByPattern * for details of the pattern match semantics. * * pattern may be null (and thus matches everything). */ public List<String> getDataSourceNames(String pattern) { return filterStringsByPattern(dataSources_.keySet(), PatternMatcher.createHivePatternMatcher(pattern)); } /** <|startfocus|> * Returns aal DataSources that match the pattern of 'matcher'. * @see PatternMatcher for supported matchers. <|endfocus|> */ public List<DataSource> getDataSources(PatternMatcher matcher) { return filterCatalogObjectsByPattern(dataSources_.getValues(), matcher); } /** * Adds a function to the catalog. * Returns true if the function was successfully added. * Returns false if the function already exists. * TODO: allow adding a function to a global scope. We probably want this to resolve * after the local scope.
<|startcomment|> I think we typically reserve "corruption" for scrambled data and equivalent. Maybe IllegalState or InvalidArgument here? <|endcomment|>  throw new NonRecoverableException(statusIncomplete); } } RowResultIterator iterator = new RowResultIterator( deadlineTracker.getElapsedMillis(), tsUUID, schema, resp.getData(), callResponse); boolean hasMore = resp.getHasMoreResults(); if (id.length != 0 && scannerId != null && !Bytes.equals(scannerId, id)) { Status statusCorruption = Status.Corruption("Scan RPC response was for scanner" + " ID " + Bytes.pretty(id) + " but we expected " <|startfocus|> + Bytes.pretty(scannerId)); throw new NonRecoverableException(statusCorruption); <|endfocus|> } Response response = new Response(id, iterator, hasMore); if (LOG.isDebugEnabled()) { LOG.debug(response.toString()); } return new Pair<Response, Object>(response, error); } public String toString() { return "ScanRequest(scannerId=" + Bytes.pretty(scannerId) + (tablet != null? ", tabletSlice=" + tablet.getTabletIdAsString() : "") + ", attempt=" + attempt + ')'; } @Override
<|startcomment|> nit: static method? <|endcomment|>  } /** * Creates a UdfExecutor object, loading the class and validating it * has the proper function. * * @param jarFile: Path to jar containing the UDF. Empty string means using the current * jar file. * @param udfPath: fully qualified class path for the UDF. * @param retType: the return type of the UDF * @param args: the input parameters of the UDF */ <|startfocus|> UdfExecutor createUdfExecutor(String jarFile, String udfPath, Type retType, <|endfocus|> Object... args) throws ImpalaException, TException { int inputBufferSize = 0; ArrayList<Integer> inputByteOffsets = Lists.newArrayList(); ArrayList<TColumnType> argTypes = Lists.newArrayList(); for (int i = 0; i < args.length; ++i) { Preconditions.checkNotNull(args[i]); Type argType = getType(args[i]); inputByteOffsets.add(new Integer(inputBufferSize)); inputBufferSize += argType.getSlotSize(); argTypes.add(argType.toThrift()); } 
<|startcomment|> also add a test where you try to refresh a non-existent partition of a table that the user does not have access to the test is to make sure that an auth error is reported, and not an analysis error because that would reveal its non-existence to an unprivileged user <|endcomment|>  // Only column-level privileges on the table AuthzError("invalidate metadata functional.alltypestiny", "User '%s' does not " + "have privileges to access: functional.alltypestiny"); // Only column-level privileges on the table AuthzError("refresh functional.alltypestiny", "User '%s' does not have " + "privileges to access: functional.alltypestiny"); AuthzError("invalidate metadata", "User '%s' does not have privileges to access: server"); AuthzError( <|startfocus|> "refresh functional_rc.alltypesagg partition (year = 2010, month = 1, day = 1)", <|endfocus|> "User '%s' does not have privileges to access: functional_rc.alltypesagg"); // TODO: Add test support for dynamically changing privileges for // file-based policy. if (ctx_.authzConfig.isFileBasedPolicy()) return; SentryPolicyService sentryService = createSentryService(); try { sentryService.grantRoleToGroup(USER, "admin", USER.getName()); ((ImpaladTestCatalog) ctx_.catalog).reset(); AuthzOk("invalidate metadata"); } finally {
<|startcomment|> Nit: "its" <|endcomment|>  if (locationsCache == null) { locationsCache = new TableLocationsCache(); TableLocationsCache existingLocationsCache = tableLocations.putIfAbsent(tableId, locationsCache); if (existingLocationsCache != null) { locationsCache = existingLocationsCache; } } // Build of the list of discovered remote tablet instances. If we have // already discovered the tablet, it's locations are refreshed. List<RemoteTablet> tablets = new ArrayList<>(locations.size()); for (Master.TabletLocationsPB tabletPb : locations) { <|startfocus|> // Early creating the tablet so that it parses out the pb <|endfocus|> RemoteTablet rt = createTabletFromPb(tableId, tabletPb); Slice tabletId = rt.tabletId; // If we already know about this tablet, refresh the locations. RemoteTablet currentTablet = tablet2client.get(tabletId); if (currentTablet != null) { currentTablet.refreshTabletClients(tabletPb); tablets.add(currentTablet); continue; } // Putting it here first doesn't make it visible because tabletsCache is always looked up // first.
<|startcomment|> Hrm. You sure you had to override this? <|endcomment|>  } Path path = new Path(schemaPath); Schema.Parser parser = new Schema.Parser(); try { FileSystem fs = FileSystem.get(path.toUri(), new Configuration()); reader = new GenericDatumReader<>(parser.parse(fs.open(path))); } catch (IOException e) { throw new FlumeException(String.format( "Unable to open and parse schema file %s: %s", schemaPath, e.getMessage()), e); } } @Override public void configure(ComponentConfiguration conf) { } <|startfocus|> <|endfocus|> @Override public void initialize(Event event, KuduTable table) { this.payload = event.getBody(); this.table = table; } @Override public List<Operation> getOperations() throws FlumeException { List<Operation> ops = new ArrayList<>(); DataFileReader<GenericRecord> payloadReader; try { payloadReader = new DataFileReader<>(new SeekableByteArrayInput(payload), reader); } catch (IOException e) { throw new FlumeException(String.format(
<|startcomment|> make 3 a static constant with a descriptive name <|endcomment|>  if (table instanceof HdfsTable) { HdfsTable hdfsTable = (HdfsTable) table; if (getPartitionSet() != null) { // Targeting a partition rather than a table. List<HdfsPartition> partitions = getPartitionSet().getPartitions(); if (partitions.size() != 1) { List<String> partitionNames = Lists.newArrayList(); int num = 0; for (HdfsPartition partition : partitions) { partitionNames.add(partition.getPartitionName()); num++; <|startfocus|> if (num == 3) break; <|endfocus|> } throw new AnalysisException(String.format( "Too many matched partitions %s %s Partition expr in " + "set location statements can only match one partition.", Joiner.on(", ").join(partitionNames), num<partitions.size() ? "..." : ".")); } if (partitions.get(0).isMarkedCached()) { throw new AnalysisException(String.format("Target partition is cached, " + "please uncache before changing the location using: ALTER TABLE %s %s " +
<|startcomment|> partColNames <|endcomment|>  private void CheckIgnoreIfExists(Table table, List<Expr> transformedConjuncts) { boolean ignore = false; <|startfocus|> Expr logExpr = null; Set<String> columnNames = Sets.newHashSet(); <|endfocus|> Reference<SlotRef> slotRef = new Reference<>(); for (Expr e : transformedConjuncts) { if (Predicate.isEquivalencePredicate(e)) { BinaryPredicate bp = ((BinaryPredicate) e); if (bp.isSingleColumnPredicate(slotRef, null)) { columnNames.add(slotRef.getRef().getDesc().getColumn().getName()); } else { ignore = true; logExpr = e; break; } } else if (e instanceof IsNullPredicate) { IsNullPredicate nullPredicate = (IsNullPredicate) e; columnNames.add(nullPredicate.getBoundSlot().getDesc().getColumn().getName()); } else { ignore = true; logExpr = e; break; } } if (ignore) { partitionShouldExist_ = null; LOG.info(String.format( "Ignoring IF EXISTS since there are more general partition expr %s.",
<|startcomment|> I think we can combine these two conditions into one if and also a single error message. Something like: IF EXISTS requires a single fully specified partition. Ignoring IF EXISTS since the given partition exprs could select a set of partitions. <|endcomment|>  Preconditions.checkState(clusterColumns.contains(partColumn)); partColNames.add(partColumn.getName()); } else { ignore = true; break; } } else if (e instanceof IsNullPredicate) { IsNullPredicate nullPredicate = (IsNullPredicate) e; Column partColumn = nullPredicate.getBoundSlot().getDesc().getColumn(); Preconditions.checkState(clusterColumns.contains(partColumn)); partColNames.add(partColumn.getName()); } else { ignore = true; break; } } <|startfocus|> if (ignore) { <|endfocus|> if (partitionShouldExist_ != null) { analyzer.addWarning( "Ignoring IF EXISTS since there are more general partition expr."); } partitionShouldExist_ = null; } else if (partColNames.size() < table.getNumClusteringCols()) { if (partitionShouldExist_ != null) { analyzer.addWarning("Ignoring IF EXISTS since there are fewer partition exprs " + "than the table's partition columns."); } partitionShouldExist_ = null; }
<|startcomment|> I think we should log errors but continue with shutdown here. Otherwise it will screw up the preconditions in start(). <|endcomment|>  logger.error(msg, e); throw new FlumeException(msg, e); } eventProducer.initialize(table); super.start(); sinkCounter.incrementConnectionCreatedCount(); sinkCounter.start(); } @Override public void stop() { eventProducer.close(); try { if (client != null) { client.shutdown(); } client = null; table = null; session = null; } catch (Exception e) { <|startfocus|> throw new FlumeException("Error closing client", e); <|endfocus|> } sinkCounter.incrementConnectionClosedCount(); sinkCounter.stop(); } @SuppressWarnings("unchecked") @Override public void configure(Context context) { masterAddresses = context.getString(MASTER_ADDRESSES); Preconditions.checkNotNull(masterAddresses, String.format("Missing master addresses. Please specify property '$s'.", MASTER_ADDRESSES)); tableName = context.getString(TABLE_NAME); Preconditions.checkNotNull(tableName, String.format("Missing table name. Please specify property '%s'", TABLE_NAME)); batchSize = context.getLong(BATCH_SIZE, DEFAULT_BATCH_SIZE);
<|startcomment|> I don't see this being set in the analyze() fn. Actually, in that function you expect that table_ has already been set. Can you update the comment? <|endcomment|> import com.cloudera.impala.thrift.TPartitionParams; import com.google.common.base.Preconditions; import org.apache.hadoop.fs.permission.FsAction; /** * Represents the partial SQL statement of specifying a table partition * that appears in ALTER TABLE ADD statement. * It contains partition specification, location (optional) and caching * option (optional). */ public class PartitionParams implements ParseNode { private final HdfsUri location_; private final PartitionSpec partitionSpec_; private final HdfsCachingOp cacheOp_; <|startfocus|> // Set during analysis <|endfocus|> private Table table_; public PartitionParams(PartitionSpec partitionSpec, HdfsUri location, HdfsCachingOp cacheOp) { Preconditions.checkNotNull(partitionSpec); location_ = location; partitionSpec_ = partitionSpec; cacheOp_ = cacheOp; table_ = null; } public void setTable(Table table) { table_ = table; } public void setTableName(TableName tableName) { partitionSpec_.setTableName(tableName); } public void setPartitionShouldNotExist() { partitionSpec_.setPartitionShouldNotExist(); } public HdfsUri getLocation() { return location_; }
<|startcomment|> ... a table, assuming a custom name was not provided. <|endcomment|>  } public static List<String> parseKeyColumnsAsList(String cols) { return Lists.newArrayList(Splitter.on(",").trimResults().split(cols.toLowerCase())); } public static boolean isSupportedKeyType(com.cloudera.impala.catalog.Type type) { return type.isIntegerType() || type.isStringType(); } /** <|startfocus|> * Return the name that should be used in Kudu when creating a table and the user did * not provide an explicit Kudu table name. <|endfocus|> */ public static String getDefaultCreateKuduTableName(String metastoreDbName, String metastoreTableName) { return Catalog.isDefaultDb(metastoreDbName) ? metastoreTableName : metastoreDbName + "." + metastoreTableName; } /** * Converts a given Impala catalog type to the Kudu type. Throws an exception if the * type cannot be converted. */ public static Type fromImpalaType(com.cloudera.impala.catalog.Type t) throws ImpalaRuntimeException { if (!t.isScalarType()) { throw new ImpalaRuntimeException(format(
<|startcomment|> Also a partition with location <|endcomment|>  "ALTER TABLE functional.alltypes ADD PARTITION (year=2050, month=1) " + "PARTITION (year=2050, month=2)"); // with IF NOT EXISTS testToSql( "alter table functional.alltypes add if not exists " + "partition (year=2050, month=1) " + "partition (year=2050, month=2)", "ALTER TABLE functional.alltypes ADD IF NOT EXISTS " + "PARTITION (year=2050, month=1) " + "PARTITION (year=2050, month=2)"); <|startfocus|> // with caching <|endfocus|> testToSql( "alter table functional.alltypes add if not exists " + "partition (year=2050, month=1) cached in 'testPool' with replication=3 " + "partition (year=2050, month=2) uncached", "ALTER TABLE functional.alltypes ADD IF NOT EXISTS "+ "PARTITION (year=2050, month=1) CACHED IN 'testPool' WITH REPLICATION = 3 " + "PARTITION (year=2050, month=2) UNCACHED");
<|startcomment|> This invalidates the comment above that when smap is null, this function is equivalent to clone(). I'm not convinced this is the right fix. I think the right fix it probably to use perserveRootType==true in the appropriate place. <|endcomment|>  * Throws if analyzing the post-substitution expr tree failed. * If smap is null, this function is equivalent to clone(). * If preserveRootType is true, the resulting expr tree will be cast if necessary to * the type of 'this'. */ public Expr trySubstitute(ExprSubstitutionMap smap, Analyzer analyzer, boolean preserveRootType) throws AnalysisException { Expr result = clone(); // Return clone to avoid removing casts. <|startfocus|> if (smap == null || this instanceof NullLiteral) return result; <|endfocus|> result = result.substituteImpl(smap, analyzer); result.analyze(analyzer); if (preserveRootType && !type_.equals(result.getType())) result = result.castTo(type_); return result; } /** * Returns an analyzed clone of 'this' with exprs substituted according to smap. * Removes implicit casts and analysis state while cloning/substituting exprs within * this tree, such that the returned result has minimal implicit casts and types. * Expects the analysis of the post-substitution expr to succeed.
<|startcomment|> Do we need to support calling this before analysis? It'd be nice if we just have 1 possible result here, e.g. throw if fullyQualifiedTableName_ is null (not yet analyzed) and just return fullyQualifiedTableName_ <|endcomment|>  public TableName getTblName() { <|startfocus|> return fullyQualifiedTableName_ != null ? fullyQualifiedTableName_ : tableName_; <|endfocus|>
<|startcomment|> What Kudu supports for partitioning is a bit tricky when we get into nested schemes, so I'm a bit concerned that (a) we're matching their supported functionality perfectly, (b) testing our validation properly, and (c) that we'll necessarily catch any changes that they end up making down the road. It would be nice if we can get a nice error from them and avoid duplication of efforts given the complexity. Let's chat about this in person? <|endcomment|>  * http://getkudu.io/docs/schema_design.html#data-distribution. As a summary: * - Only primary key column can be used in distribution definitions * - Distributions may be either hash or ranged (value intervals) * - Multiple distributions can be used/mixed * - A column can only be used in one hash distribution * - A range distribution can only be used once and must be the last definition * (both enforced by the grammar). */ private void analyzeDistributeParams(Analyzer analyzer) throws AnalysisException { Preconditions.checkState(getFileFormat() == THdfsFileFormat.KUDU); <|startfocus|> Map<String, ColumnDef> primaryKeyColDefsByName = <|endfocus|> ColumnDef.mapByColumnNames(getPrimaryKeyColumnDefs()); Map<String, DistributeParam> hashParamsByColName = Maps.newHashMap(); for (DistributeParam distributeParam: getDistributeParams()) { List<String> colNames; if (distributeParam.getColumnNames().isEmpty()) { colNames = ColumnDef.toColumnNames(getPrimaryKeyColumnDefs()); distributeParam.getColumnNames().addAll(colNames); } else {
<|startcomment|> sprinkle some checkstates in here (on numbuckets and splitrows; or maybe a validate() function that does those checks, toThrift() would also benefit from it) <|endcomment|>  public String toSql() { StringBuilder builder = new StringBuilder(type_.toString()); if (!colNames_.isEmpty()) { builder.append(" ("); Joiner.on(", ").appendTo(builder, colNames_).append(")"); } if (type_ == Type.HASH) { <|startfocus|> builder.append(" INTO "); <|endfocus|> builder.append(numBuckets_).append(" BUCKETS"); } else { builder.append(" SPLIT ROWS ("); if (splitRows_ == null) { builder.append("..."); } else { for (List<LiteralExpr> splitRow: splitRows_) { builder.append(splitRowToString(splitRow)); } } builder.append(")"); } return builder.toString();
<|startcomment|> spelling the set <|endcomment|>  } if (!collectionConjuncts.isEmpty()) { analyzer.materializeSlots(collectionConjuncts); collectionConjuncts_.put(itemTupleDesc, collectionConjuncts); } // Recursively look for collection-typed slots in nested tuple descriptors. assignCollectionConjuncts(itemTupleDesc, analyzer); } } /** * Computes scan ranges (hdfs splits) plus their storage locations, including volume * ids, based on the given maximum number of bytes each scan range should scan. <|startfocus|> * Retrurns a set of file formats being scanned. <|endfocus|> */ private Set<HdfsFileFormat> computeScanRangeLocations(Analyzer analyzer) { long maxScanRangeLength = analyzer.getQueryCtx().getRequest().getQuery_options() .getMax_scan_range_length(); scanRanges_ = Lists.newArrayList(); Set<HdfsFileFormat> fileFormats = Sets.newHashSet(); for (HdfsPartition partition: partitions_) { fileFormats.add(partition.getFileFormat()); Preconditions.checkState(partition.getId() >= 0); for (HdfsPartition.FileDescriptor fileDesc: partition.getFileDescriptors()) { for (THdfsFileBlock thriftBlock: fileDesc.getFileBlocks()) {
<|startcomment|> This seems like weird behavior. The user issued a cascading drop db, but gets an error because one of the tables could not be fetched from the HMS. It seems fine to ignore the error because the user wanted to drop everything anyway. <|endcomment|>  org.apache.hadoop.hive.metastore.api.Table msTable = table.getMetaStoreTable(); if (msTable == null) { incompleteTableNames.add(table.getName()); } else { msTables.add(msTable); } } if (!incompleteTableNames.isEmpty()) { try (MetaStoreClient msClient = catalog_.getMetaStoreClient()) { msTables.addAll(msClient.getHiveClient().getTableObjectsByName( db.getName(), incompleteTableNames)); } catch (TException e) { <|startfocus|> throw new ImpalaRuntimeException( String.format(HMS_RPC_ERROR_FORMAT_STR, "getTableObjectsByName"), e); <|endfocus|> } } for (org.apache.hadoop.hive.metastore.api.Table msTable: msTables) { if (!KuduTable.isKuduTable(msTable)) continue; // The operation will be aborted if the Kudu table cannot be dropped. If for // some reason Kudu is permanently stuck in a non-functional state, the user is // expected to ALTER TABLE to either set the table to UNMANAGED or set the format // to something else.
<|startcomment|> Isn't it enough to check primaryKeyColDefs_ in tableDef_? <|endcomment|>  private boolean hasPrimaryKey() { Preconditions.checkState(tableDef_.isAnalyzed()); <|startfocus|> boolean hasKey = !tableDef_.getPrimaryKeyColumnNames().isEmpty(); if (!hasKey) { for (ColumnDef colDef : getColumnDefs()) { if (colDef.isPrimaryKey()) hasKey = true; } } return hasKey; <|endfocus|>
<|startcomment|> don't refer to the sort node here, SortInfo shouldn't have to know about that <|endcomment|>  for (int i = 0; i < sortTupleSlotDescs.size(); ++i) { if (sortTupleSlotDescs.get(i).isMaterialized()) { materializedExprs.add(sortTupleSlotExprs_.get(i)); } } List<Expr> substMaterializedExprs = Expr.substituteList(materializedExprs, smap, analyzer, false); analyzer.materializeSlots(substMaterializedExprs); } /** * Replaces orderingExprs_ according to smap. This needs to be called to make sure that <|startfocus|> * the exprs used by the SortNode refer to the materialized tuples instead of the * original input. <|endfocus|> */ public void substituteOrderingExprs(ExprSubstitutionMap smap, Analyzer analyzer) { orderingExprs_ = Expr.substituteList(orderingExprs_, smap, analyzer, false); } /** * Asserts that all ordering exprs are bound by the sort tuple. */ public void checkConsistency() { for (Expr orderingExpr: orderingExprs_) { Preconditions.checkState(orderingExpr.isBound(sortTupleDesc_.getId())); } } @Override public SortInfo clone() { return new SortInfo(this); } } 
<|startcomment|> I think these lines can be combined into one, Lists.newArrayList(BetweenToCompoundRule.INSTANCE) unless it was written this way for readability. <|endcomment|>  public AnalysisContext(ImpaladCatalog catalog, TQueryCtx queryCtx, AuthorizationConfig authzConfig) { catalog_ = catalog; queryCtx_ = queryCtx; authzConfig_ = authzConfig; List<ExprRewriteRule> rules = Lists.newArrayList(); <|startfocus|> rules.add(BetweenToCompoundRule.INSTANCE); <|endfocus|> rewriter_ = new ExprRewriter(rules);
<|startcomment|> remove <|endcomment|> // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.impala.analysis; import org.apache.impala.common.AnalysisException; import org.apache.impala.thrift.TExprNode; /** <|startfocus|> * Class describing a BETWEEN predicates. This predicate needs to be rewritten * into a CompoundPredicate for it to be executable, i.e., there it is illegal * to call toThrift() on this predicate because there is no BE implementation. <|endfocus|> */ public class BetweenPredicate extends Predicate { private final boolean isNotBetween_; // First child is the comparison expr which should be in [lowerBound, upperBound]. public BetweenPredicate(Expr compareExpr, Expr lowerBound, Expr upperBound, boolean isNotBetween) { children_.add(compareExpr); children_.add(lowerBound); children_.add(upperBound); isNotBetween_ = isNotBetween; } /** * Copy c'tor used in clone().
<|startcomment|> precede w/ blank line <|endcomment|>  TDescriptorTable descTbl = execRequest.desc_tbl; if (descTbl.isSetTableDescriptors()) { for (TTableDescriptor tableDesc: descTbl.tableDescriptors) { if (seenTableIds.contains(tableDesc.id)) { throw new IllegalStateException("Failed to verify table id for table: " + tableDesc.getDbName() + "." + tableDesc.getTableName() + ".\nTable id: " + tableDesc.id + " already used."); } seenTableIds.add(tableDesc.id); } <|startfocus|> } <|endfocus|> if (descTbl.isSetTupleDescriptors()) { for (TTupleDescriptor tupleDesc: descTbl.tupleDescriptors) { if (tupleDesc.isSetTableId() && !seenTableIds.contains(tupleDesc.tableId)) { throw new IllegalStateException("TableDescriptor does not include table id" + "of:\n" + tupleDesc.toString()); } } } } if (execRequest.isSetFragments() && !execRequest.fragments.isEmpty()) { TPlanFragment firstPlanFragment = execRequest.fragments.get(0); if (firstPlanFragment.isSetOutput_sink()
<|startcomment|> the <|endcomment|>  firstExprs.size() + " column(s)\n" + "'" + queryStmtToSql(query) + "' has " + exprs.size() + " column(s)"); } } catch (AnalysisException e) { if (analyzer.getMissingTbls().isEmpty()) throw e; } } <|startfocus|> if (!analyzer.getMissingTbls().isEmpty()) { throw new AnalysisException("Found missing tables. Aborting analysis."); } // Remember SQL string before unnesting operands. <|endfocus|> toSqlString_ = toSql(); // Unnest the operands before casting the result exprs. Unnesting may add // additional entries to operands_ and the result exprs of those unnested // operands must also be cast properly. unnestOperands(analyzer); // Compute hasAnalyticExprs_ hasAnalyticExprs_ = false; for (UnionOperand op: operands_) { if (op.hasAnalyticExprs()) { hasAnalyticExprs_ = true; break; } } // Cast all result exprs to a compatible type. List<List<Expr>> resultExprLists = Lists.newArrayList();
<|startcomment|> projected key columns -> distribution columns? <|endcomment|>  */ public void analyzeRangeParam(Analyzer analyzer) throws AnalysisException { for (RangePartition rangePartition: rangePartitions_) { rangePartition.analyze(analyzer); List<LiteralExpr> lowerBound = rangePartition.getLowerBound(); List<LiteralExpr> upperBound = rangePartition.getUpperBound(); if (!lowerBound.isEmpty() && lowerBound.size() != colNames_.size()) { throw new AnalysisException(String.format("Number of specified range " + <|startfocus|> "partition values is different than the number of projected key " + <|endfocus|> "columns: (%d vs %d). Range partition: '%s'", lowerBound.size(), colNames_.size(), rangePartition.toSql())); } if (!upperBound.isEmpty() && upperBound.size() != colNames_.size()) { throw new AnalysisException(String.format("Number of specified range " + "partition values is different than the number of projected key " + "columns: (%d vs %d). Range partition: '%s'", upperBound.size(), colNames_.size(), rangePartition.toSql())); }
<|startcomment|> Fix indentation. <|endcomment|>  private final static TBinaryProtocol.Factory protocolFactory_ = new TBinaryProtocol.Factory(); private final CatalogServiceCatalog catalog_; private final CatalogOpExecutor catalogOpExecutor_; // A unique identifier for this instance of the Catalog Service. private static final TUniqueId catalogServiceId_ = generateId(); private static TUniqueId generateId() { UUID uuid = UUID.randomUUID(); return new TUniqueId(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits()); } public JniCatalog(byte[] thriftBEConfig) throws InternalException, <|startfocus|> ImpalaException, TException { <|endfocus|> TBackendConfig cfg = new TBackendConfig(); JniUtil.deserializeThrift(protocolFactory_, cfg, thriftBEConfig); BackendConfig.setAuthToLocal(cfg.auth_to_local); Preconditions.checkArgument(cfg.num_metadata_loading_threads > 0); // This trick saves having to pass a TLogLevel enum, which is an object and more // complex to pass through JNI. GlogAppender.Install(TLogLevel.values()[cfg.impala_log_lvl], TLogLevel.values()[cfg.other_log_lvl]); // Check if the Sentry Service is configured. If so, create a configuration object.
<|startcomment|> move to prev line <|endcomment|> kage org.apache.impala; import java.text.ParseException; import org.apache.hadoop.hive.ql.exec.UDF; import org.apache.hadoop.io.Text; <|startfocus|> public class ReplaceStringUdf extends UDF { <|endfocus|> public Text evaluate(Text para) throws ParseException { if ((null == para) || ("".equals(para.toString()))) { return new Text(""); } return new Text(para.toString().replace("s", "ss")); } } 
<|startcomment|> empty is an error right? (same in other places below) <|endcomment|>  "%s has %d characters.", colName_, MetaStoreUtil.CREATE_MAX_COMMENT_LENGTH, comment_, comment_.length())); } } private void analyzeKuduOptions(Analyzer analyzer) throws AnalysisException { if (isPrimaryKey_ && isNullable_ != null && isNullable_) { throw new AnalysisException("Primary key columns can't have NULL values: " + toString()); } // Encoding value <|startfocus|> if (!Strings.isNullOrEmpty(encodingVal_)) { <|endfocus|> try { encoding_ = Encoding.valueOf(encodingVal_); } catch (IllegalArgumentException e) { throw new AnalysisException(String.format("Unsupported encoding value '%s'. " + "Supported encoding values are: %s", encodingVal_, Joiner.on(", ").join(Encoding.values()))); } } // Compression algorithm if (!Strings.isNullOrEmpty(compressionVal_)) { try { compression_ = CompressionAlgorithm.valueOf(compressionVal_); } catch (IllegalArgumentException e) { throw new AnalysisException(String.format("Unsupported compression " +
<|startcomment|> add comment why <|endcomment|>  col2 += col2Delta; col3 += col3Delta; } writer.close(); } /** * Generate some test data. * * @param BaseOutputDirectory * : Required base output folder of generated data files. * @throws Exception * something bad happened */ public static void main(String args[]) throws Exception { if (args.length != 1) { System.err.println("Usage: " + "TestDataGenerator BaseOutputDirectory"); } <|startfocus|> <|endfocus|> TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles")); // Generate AllTypes String dirName = args[0] + "/AllTypes"; File dir = new File(dirName); dir.mkdirs(); GenerateAllTypesData(dirName, DEFAULT_NUM_PARTITIONS, DEFAULT_MAX_TUPLES_PER_PARTITION); // Generate AllTypesSmall dirName = args[0] + "/AllTypesSmall"; dir = new File(dirName); dir.mkdirs(); GenerateAllTypesData(dirName, 4, 25); // Generate AllTypesSmall dirName = args[0] + "/AllTypesTiny";
<|startcomment|> use equals() <|endcomment|>  t.getColumn(newColDef_.getColName()) != null) { throw new AnalysisException("Column already exists: " + newColDef_.getColName()); } if (newColDef_.hasKuduOptions()) { throw new AnalysisException("Unsupported column options in ALTER TABLE CHANGE " + "COLUMN statement: " + newColDef_.toString()); } if (t instanceof KuduTable) { Column col = t.getColumn(colName_); <|startfocus|> if (col.getType() != newColDef_.getType()) { <|endfocus|> throw new AnalysisException(String.format("Cannot change the type of a Kudu " + "column using an ALTER TABLE CHANGE COLUMN statement: (%s vs %s)", col.getType().toSql(), newColDef_.getType().toSql())); } } } } 
<|startcomment|> Correct. I don't think the ConcurrentHashMaps will help us because we need to atomically update both maps sometimes. <|endcomment|>  // look in 'storageIdtoInt' map if it already exists, else we generate a new ID for // using the generator. Check getDiskId() for details. private static ConcurrentHashMap<String, AtomicInteger> storageIdGenerator = new ConcurrentHashMap(); /** * Returns a disk id (0-based) index for storageId on host 'host'. <|startfocus|> * TODO (Bharath): This method is still prone to some race conditions. Fix it before * next round of review. <|endfocus|> */ public static int getDiskId(String host, String storageId) { Preconditions.checkState(!Strings.isNullOrEmpty(host)); // Initialize the diskId as -1 to indicate it is unknown int diskId = -1; if (Strings.isNullOrEmpty(storageId)) return diskId; // Check if an existing mapping is already preset if (storageIdToInt.containsKey(storageId)) { return storageIdToInt.get(storageId).intValue(); } // No mapping exists, create a new disk ID for 'storageId' on 'host'
<|startcomment|> Why can't this stay inside addPartition()? In the loading case the size and number of file descriptors should be 0, so adding that should be harmless. <|endcomment|>  nullPartitionKeyValue_ = hdfsTable.nullPartitionKeyValue; multipleFileSystems_ = hdfsTable.multiple_filesystems; Preconditions.checkState(hdfsTable.getNetwork_addresses() instanceof ArrayList<?>); hostIndex_.populate((ArrayList<TNetworkAddress>)hdfsTable.getNetwork_addresses()); resetPartitions(); try { for (Map.Entry<Long, THdfsPartition> part: hdfsTable.getPartitions().entrySet()) { HdfsPartition hdfsPart = HdfsPartition.fromThrift(this, part.getKey(), part.getValue()); addPartition(hdfsPart); <|startfocus|> totalHdfsBytes_ += hdfsPart.getSize(); numHdfsFiles_ += hdfsPart.getNumFileDescriptors(); <|endfocus|> } } catch (CatalogException e) { throw new TableLoadingException(e.getMessage()); } avroSchema_ = hdfsTable.isSetAvroSchema() ? hdfsTable.getAvroSchema() : null; isMarkedCached_ = HdfsCachingUtil.validateCacheParams(getMetaStoreTable().getParameters()); } @Override public TTableDescriptor toThriftDescriptor(int tableId, Set<Long> referencedPartitions) { // Create thrift descriptors to send to the BE. The BE does not // need any information below the THdfsPartition level.
<|startcomment|> ... a consistent mapping ... so that the assignment of scan ranges to I/O threads is balanced and consistent for all scans on the same host. <|endcomment|>  import com.google.common.collect.Maps; import com.google.common.base.Strings; import com.google.common.base.Preconditions; import java.util.HashMap; import java.util.concurrent.ConcurrentHashMap; /** * A singleton class that maps HDFS storage-UUIDs to per-host 0-based, sequential disk * ids. This mapping is internally implemented as a global static object shared * across all the table instances. The rationale behind this implementation is <|startfocus|> * - To maintain consistent mapping across all the table instances so that the disk thread * scan assignment in the backend is balanced across all the disks. <|endfocus|> * - To Reduce memory usage in the Catalog since UUIDs can potentially consume a lot of * memory when maintained per table instance. */ public class DiskIdMapper { public static DiskIdMapper INSTANCE = new DiskIdMapper(); private DiskIdMapper() { } // Maps each "storage ID UUID string" returned by the BlockLocation API, to a per-node // sequential 0-based integer disk id used by the BE scanners. This assumes that
<|startcomment|> iterate over Map.Entry, you are doing a get() in the next line <|endcomment|>  } /** * For filesystems that don't support BlockLocation API, synthesize file blocks * by manually splitting the file range into fixed-size blocks. That way, scan * ranges can be derived from file blocks as usual. All synthesized blocks are given * an invalid network address so that the scheduler will treat them as remote. */ private void synthesizeBlockMetadata(FileSystem fs, HashMap<Path, List<HdfsPartition>> partsByPath) throws IOException { <|startfocus|> for (Path partPath: partsByPath.keySet()) { List<HdfsPartition> partitions = partsByPath.get(partPath); // For each valid file in the partPath, synthesize the block metadata. <|endfocus|> for (FileStatus fileStatus: fs.listStatus(partPath)) { if (!FileSystemUtil.isValidPartitionFile(fileStatus)) continue; String fileName = fileStatus.getPath().getName(); FileDescriptor fd = new FileDescriptor(fileName, fileStatus.getLen(), fileStatus.getModificationTime()); // Synthesize the block metadata for the file descriptor. long start = 0;
<|startcomment|> !expr.contains(SlotRef.class) <|endcomment|>  } catch (TException e) { // this should never happen throw new InternalException( "Couldn't cache jar at HDFS location " + hdfsLocation, e); } } private static byte[] CacheJar(byte[] thriftParams) { try { return NativeCacheJar(thriftParams); } catch (UnsatisfiedLinkError e) { loadLibrary(); } return NativeCacheJar(thriftParams); } public static TColumnValue EvalExprWithoutRow(Expr expr, TQueryCtx queryCtx) throws InternalException { <|startfocus|> Preconditions.checkState(expr.isConstant()); <|endfocus|> TExprBatch exprBatch = new TExprBatch(); exprBatch.addToExprs(expr.treeToThrift()); TSerializer serializer = new TSerializer(new TBinaryProtocol.Factory()); byte[] result; try { result = EvalExprsWithoutRow( serializer.serialize(exprBatch), serializer.serialize(queryCtx)); Preconditions.checkNotNull(result); TDeserializer deserializer = new TDeserializer(new TBinaryProtocol.Factory()); TResultRow val = new TResultRow(); deserializer.deserialize(val, result); Preconditions.checkState(val.getColValsSize() == 1); return val.getColVals().get(0);
<|startcomment|> The Cached suffix seems weird because this is set during analyze(), i.e. this member is no different than other members set during analyze() that don't have "Cached". Let's just call this isConstant_ <|endcomment|>  // or any of its children was not set, but it is required to be set for any // expression which may be part of a conjunct. protected float evalCost_; // estimated number of distinct values produced by Expr; invalid: -1 // set during analysis protected long numDistinctValues_; // Cached value of IsConstant(), set during analyze() and valid if isAnalyzed_ is true. <|startfocus|> private boolean isConstantCached_; <|endfocus|> // The function to call. This can either be a scalar or aggregate function. // Set in analyze(). protected Function fn_; protected Expr() { super(); type_ = Type.INVALID; selectivity_ = -1.0; evalCost_ = -1.0f; numDistinctValues_ = -1;
<|startcomment|> We only do this for AUTO_FLUSH_BACKGROUND, with manual flushes it's easy to get the errors so there's no point using the error collector. <|endcomment|>  * them successful. * * <p>Disabled by default. * @param ignoreAllDuplicateRows true if this session should enforce this, else false */ void setIgnoreAllDuplicateRows(boolean ignoreAllDuplicateRows); /** * Return the number of errors which are pending. Errors may accumulate when <|startfocus|> * using * {@link FlushMode#AUTO_FLUSH_BACKGROUND AUTO_FLUSH_BACKGROUND} or * {@link FlushMode#MANUAL_FLUSH MANUAL_FLUSH} mode. <|endfocus|> * @return a count of errors */ int countPendingErrors(); /** * Return any errors from previous calls. If there were more errors * than could be held in the session's error storage, the overflow state is set to true. * * <p>Clears the pending errors. * @return an object that contains the errors and the overflow status */ RowErrorsAndOverflowStatus getPendingErrors(); } 
<|startcomment|> We usually use the MS suffix elsewhere, i.e., TBL_LOCK_TIMEOUT_MS I think we should consider making this higher and/or even configurable (in a separate patch). <|endcomment|>  if (FileSystemUtil.getDefaultFileSystem() instanceof DistributedFileSystem) { cachePoolReader_.scheduleAtFixedRate( new CachePoolReader(), 0, 1, TimeUnit.MINUTES); } } catch (IOException e) { LOG.error("Couldn't identify the default FS. Cache Pool reader will be disabled."); } if (sentryConfig != null) { sentryProxy_ = new SentryProxy(sentryConfig, this, kerberosPrincipal); } else { sentryProxy_ = null; } <|startfocus|> localLibraryPath_ = new String("file://" + localLibraryPath); <|endfocus|>
<|startcomment|> use java-style function comments /** * This ... */ <|endcomment|> import org.apache.impala.common.AnalysisException; import org.apache.impala.common.FrontendTestBase; import org.junit.Assert; import org.junit.Test; /** * Tests computeNumDistinctValues() estimates for Exprs */ public class ExprNdvTest extends FrontendTestBase { public void verifyNdv(String expr, long expectedNdv) throws AnalysisException { String stmtStr = "select " + expr + " from functional.alltypes"; verifyNdvStmt(stmtStr, expectedNdv); } <|startfocus|> // This test queries two tables to allow testing missing statistics. // functional.alltypes (a) has stats // functional.tinytable (tiny) does not <|endfocus|> public void verifyNdvTwoTable(String expr, long expectedNdv) throws AnalysisException { String stmtStr = "select " + expr + " from functional.alltypes a, " + "functional.tinytable tiny"; verifyNdvStmt(stmtStr, expectedNdv); } public void verifyNdvStmt(String stmtStr, long expectedNdv) throws AnalysisException { SelectStmt stmt = (SelectStmt) ParsesOk(stmtStr); Analyzer analyzer = createAnalyzer(Catalog.DEFAULT_DB); stmt.analyze(analyzer);
<|startcomment|> let's only add this for >= EXTENDED it will show up in query profiles, but not in regular explain plans I think we should add a warning at the top of the explain plan listing the tables that have missing disk ids (like we do for missing stats) <|endcomment|>  protected String getNodeExplainString(String prefix, String detailPrefix, TExplainLevel detailLevel) { StringBuilder output = new StringBuilder(); HdfsTable table = (HdfsTable) desc_.getTable(); output.append(String.format("%s%s [%s", prefix, getDisplayLabel(), getDisplayLabelDetail())); if (detailLevel.ordinal() >= TExplainLevel.EXTENDED.ordinal() && fragment_.isPartitioned()) { output.append(", " + fragment_.getDataPartition().getExplainString()); } output.append("]\n"); if (detailLevel.ordinal() >= TExplainLevel.STANDARD.ordinal()) { <|startfocus|> int numPartitions = partitions_.size(); <|endfocus|> if (tbl_.getNumClusteringCols() == 0) numPartitions = 1; output.append(String.format("%spartitions=%s/%s files=%s size=%s", detailPrefix, numPartitions, table.getPartitions().size() - 1, totalFiles_, PrintUtils.printBytes(totalBytes_))); output.append("\n"); if (!conjuncts_.isEmpty()) { output.append(
<|startcomment|> I think we should address this TODO while we are here. We should materialize: 1. All known non-deterministic functions. We can add an Expr.isDeterministic() function and implement that for FunctionCallExpr like we implement isConstant(). 2. All UDFs. We can check whether an Expr is a UDF. 3. Exprs that are 'expensive' according to some cost threshold. If the cost is unknown, I'd say materialize. <|endcomment|>  // TODO: I copied this from QueryStmt.java and would like to add an explanatory // comment, but I don't know why this distinction has to be made. if (stmt.hasLimit()) { analyzer.registerValueTransfer(origSlotRef.getSlotId(), cloneRef.getSlotId()); } else { analyzer.createAuxEquivPredicate(cloneRef, origSlotRef); } sortTupleExprs.add(origSlotRef); } <|startfocus|> if (materializeSlots) { sortTupleDesc.materializeSlots(); } stmt.substituteResultExprs(substOrderBy, analyzer); <|endfocus|> // The ordering exprs still point to the old slot refs and need to be replaced with // ones that point to the slot refs the new, materialized input rows. substituteOrderingExprs(substOrderBy, analyzer); // Update the tuple descriptor used to materialize the input tuple of the sort. setMaterializedTupleInfo(sortTupleDesc, sortTupleExprs);
<|startcomment|> how about simply createClippedDecimalType()? or truncated instead of clipped. same for createAdjustedDecimalType. same checkstates as in 'adjusted' below? <|endcomment|> <|startfocus|> public static ScalarType createDecimalTypeClipPrecScale(int precision, int scale) { <|endfocus|> ScalarType type = new ScalarType(PrimitiveType.DECIMAL); type.precision_ = Math.min(precision, MAX_PRECISION); type.scale_ = Math.min(type.precision_, scale); return type;
<|startcomment|> Fix this nit and this is good to go. <|endcomment|>  if (parentRpc != null) { rpc.setTimeoutMillis(parentRpc.deadlineTracker.getMillisBeforeDeadline()); rpc.setParentRpc(parentRpc); } else { rpc.setTimeoutMillis(defaultTimeoutMs); } Deferred<ConnectToClusterResponse> d = rpc.getDeferred(); rpc.attempt++; masterClient.sendRpc(rpc); return d; } /** * Retrieve the master registration (see {@link ConnectToClusterResponse} * from the leader master. * <|startfocus|> * @param masterAddresses the addresses of masters to fetch from. <|endfocus|> * @param parentRpc RPC that prompted a master lookup, can be null * @param connCache the client's connection cache, used for creating connections * to masters * @param defaultTimeoutMs timeout to use for RPCs if the parentRpc has no timeout * @return a Deferred object for the master replica's current registration */ public static Deferred<GetTableLocationsResponsePB> run( List<HostAndPort> masterAddresses, KuduRpc<?> parentRpc, ConnectionCache connCache, long defaultTimeoutMs) {
<|startcomment|> you can leave it as-is, i don't mean to belabor the point, but putting this more concisely would also be fine: "Walks through conjuncts and populates dictionaryFilterConjuncts_." (you already described what that variable means elsewhere) <|endcomment|>  if (!analyzer.evalAfterJoin(conjunct)) analyzer.markConjunctAssigned(conjunct); } if (!collectionConjuncts.isEmpty()) { analyzer.materializeSlots(collectionConjuncts); collectionConjuncts_.put(itemTupleDesc, collectionConjuncts); } // Recursively look for collection-typed slots in nested tuple descriptors. assignCollectionConjuncts(itemTupleDesc, analyzer); } } /** <|startfocus|> * Walks through conjuncts and builds a map from slot id to the conjuncts * that are eligible for dictionary filtering. This populates the * dictionaryFilterConjuncts_ map. <|endfocus|> */ private void computeDictionaryFilterConjuncts(Analyzer analyzer) { for (int conjunct_idx = 0; conjunct_idx < conjuncts_.size(); ++conjunct_idx) { Expr conjunct = conjuncts_.get(conjunct_idx); List<TupleId> tupleIds = Lists.newArrayList(); List<SlotId> slotIds = Lists.newArrayList(); conjunct.getIds(tupleIds, slotIds); Preconditions.checkState(tupleIds.size() == 1); if (slotIds.size() != 1) continue; // Check to see if this conjunct contains any non-deterministic function
<|startcomment|> how about instead of this, checking if there were columns specified or not? <|endcomment|>  if (KuduTable.KUDU_STORAGE_HANDLER.equals( getTblProperties().get(KuduTable.KEY_STORAGE_HANDLER))) { throw new AnalysisException(KUDU_STORAGE_HANDLER_ERROR_MESSAGE); } AnalysisUtils.throwIfNotEmpty(getKuduPartitionParams(), "Only Kudu tables can use the PARTITION BY clause."); if (hasPrimaryKey()) { throw new AnalysisException("Only Kudu tables can specify a PRIMARY KEY."); } return; } analyzeKuduTableProperties(analyzer); <|startfocus|> if (isExternal() && !createAsSelect_) { analyzeExternalKuduTableParams(analyzer); <|endfocus|> } else { analyzeManagedKuduTableParams(analyzer); } } /** * Analyzes and checks table properties which are common to both managed and external * Kudu tables. */ private void analyzeKuduTableProperties(Analyzer analyzer) throws AnalysisException { if (getTblProperties().containsKey(KuduTable.KEY_STORAGE_HANDLER)) { throw new AnalysisException(KUDU_STORAGE_HANDLER_ERROR_MESSAGE); } getTblProperties().put(KuduTable.KEY_STORAGE_HANDLER, KuduTable.KUDU_STORAGE_HANDLER); 
<|startcomment|> Why not run the rewrites here directly. That way we skip over exprs that have not changed. <|endcomment|>  ExprSubstitutionMap smap = new ExprSubstitutionMap(); smap.put(slotRef, subst); for (int i = 0; i < output.size(); ++i) { Expr to_rewrite = output.get(i); if (to_rewrite.equals(expr)) continue; Expr rewritten = to_rewrite.substitute(smap, analyzer, true); if (!rewritten.equals(to_rewrite)) { ++changes; LOG.info("Constant substitution from slot " + slotRef.getSlotId().toString() + ": " + rewritten.toSql()); } output.set(i, rewritten); <|startfocus|> } <|endfocus|> } } } if (changes > 0) { for (int i = 0; i < output.size(); ++i) { Expr rewritten; Expr to_rewrite = output.get(i); rewriter.reset(); try { rewritten = rewriter.rewrite(to_rewrite, analyzer); } catch (AnalysisException e) { LOG.error("Not able to analyze after rewrite" + e.toString()); throw e; } if (rewriter.changed()) {
<|startcomment|> Have you tried running a few queries that end up with a constant 'false' predicate? I think in those cases we should generate an EmptySetNode instead of a ScanNode. <|endcomment|>  TupleDescriptor tupleDesc = hdfsTblRef.getDesc(); // Get all predicates bound by the tuple. List<Expr> conjuncts = Lists.newArrayList(); conjuncts.addAll(analyzer.getBoundPredicates(tupleDesc.getId())); // Also add remaining unassigned conjuncts List<Expr> unassigned = analyzer.getUnassignedConjuncts(tupleDesc.getId().asList()); conjuncts.addAll(unassigned); analyzer.markConjunctsAssigned(unassigned); analyzer.createEquivConjuncts(tupleDesc.getId(), conjuncts); <|startfocus|> // Allow constant propagation within conjuncts. ConstantPropagator.optimizeConjuncts(conjuncts, analyzer, analyzer.getQueryCtx().client_request.query_options.enable_expr_rewrites); <|endfocus|> // Do partition pruning before deciding which slots to materialize, // We might end up removing some predicates. HdfsPartitionPruner pruner = new HdfsPartitionPruner(tupleDesc); List<HdfsPartition> partitions = pruner.prunePartitions(analyzer, conjuncts, false); // Mark all slots referenced by the remaining conjuncts as materialized. analyzer.materializeSlots(conjuncts); // If the optimization for partition key scans with metadata is enabled, // try evaluating with metadata first. If not, fall back to scanning.
<|startcomment|> nonMaterializedOrderingExprs <|endcomment|>  } sortTupleExprs.add(origSlotRef); } if (materializeSlots) { sortTupleDesc.materializeSlots(); } stmt.substituteResultExprs(substOrderBy, analyzer); // The ordering exprs still point to the old slot refs and need to be replaced with // ones that point to the slot refs the new, materialized input rows. substituteOrderingExprs(substOrderBy, analyzer); // Update the tuple descriptor used to materialize the input tuple of the sort. <|startfocus|> setMaterializedTupleInfo(sortTupleDesc, sortTupleExprs); <|endfocus|>
<|startcomment|> toFlatBuffer()? <|endcomment|>  return compression == null ? NONE : compression; } public THdfsCompression toThrift() { switch (this) { case NONE: return THdfsCompression.NONE; case DEFLATE: return THdfsCompression.DEFLATE; case GZIP: return THdfsCompression.GZIP; case BZIP2: return THdfsCompression.BZIP2; case SNAPPY: return THdfsCompression.SNAPPY_BLOCKED; case LZO: return THdfsCompression.LZO; default: throw new IllegalStateException("Unexpected codec: " + this); } } <|startfocus|> public byte toFbCompression() { <|endfocus|> switch (this) { case NONE: return FbCompression.NONE; case DEFLATE: return FbCompression.DEFLATE; case GZIP: return FbCompression.GZIP; case BZIP2: return FbCompression.BZIP2; case SNAPPY: return FbCompression.SNAPPY; case LZO: return FbCompression.LZO; default: throw new IllegalStateException("Unexpected codec: " + this); } } /* Returns a compression type based on (Hive's) intput format. Special case for LZO. */ public static HdfsCompression fromHdfsInputFormatClass(String inputFormatClass) { // TODO: Remove when we have the native LZO writer.
<|startcomment|> nit: Here and elsewhere, inline comments should end with a period. <|endcomment|>  public void testGetUnsetColumn() { Schema schema = BaseKuduTest.getSchemaWithAllTypes(); PartialRow partialRow = schema.newPartialRow(); for (ColumnSchema columnSchema : schema.getColumns()) { assertFalse(partialRow.isSet("null")); assertFalse(partialRow.isNull("null")); try { callGetByName(partialRow, columnSchema.getName(), columnSchema.getType()); fail("Expected IllegalArgumentException for type: " + columnSchema.getType()); } catch (IllegalArgumentException ex) { <|startfocus|> // This is the expected exception <|endfocus|> } }
<|startcomment|> this disappeared (but the comment for it didn't) <|endcomment|>  } else { // Print the fragmented parallel plan. for (int i = 0; i < fragments.size(); ++i) { PlanFragment fragment = fragments.get(i); str.append(fragment.getExplainString(ctx_.getQueryOptions(), explainLevel)); if (i < fragments.size() - 1) str.append("\n"); } } return str.toString(); } /** <|startfocus|> * Returns true if the fragments are for a trivial, coordinator-only query: * Case 1: Only an EmptySetNode, e.g. query has a limit 0. * Case 2: Query has only constant exprs. */ /** <|endfocus|> * Estimates the per-host resource requirements for the given plan fragments, * and sets the results in request. * TODO: The LOG.warn() messages should eventually become Preconditions checks * once resource estimation is more robust. * TODO: Revisit during MT work - scheduling of fragments will change. */ public void computeResourceReqs(List<PlanFragment> fragments, TQueryExecRequest request) {
<|startcomment|> nit: extra space <|endcomment|>  private static List<String> getSortByColumns(Map<String, String> properties) { final String sortByKey = AlterTableSortByColumnsStmt.TBL_PROP_SORT_BY_COLUMNS; if (!properties.containsKey(sortByKey)) return null; <|startfocus|> return Lists.newArrayList( Splitter.on(",").trimResults().omitEmptyStrings().split( <|endfocus|> properties.get(sortByKey)));
<|startcomment|> nit, remove <|endcomment|>  * not specified during scanner creation, the table schema is returned. * @return the projection schema for this scanner */ public Schema getProjectionSchema() { return asyncScanner.getProjectionSchema(); } /** * Returns the RemoteTablet currently being scanned, if any. */ @VisibleForTesting RemoteTablet currentTablet() { return asyncScanner.currentTablet(); } /** * Gets the replica selection mechanism being used. * <|startfocus|> * @return the replica selection mechanism. <|endfocus|> */ @VisibleForTesting ReplicaSelection getReplicaSelection() { return asyncScanner.getReplicaSelection(); } /** * A Builder class to build {@link KuduScanner}. * Use {@link KuduClient#newScannerBuilder} in order to get a builder instance. */ @InterfaceAudience.Public @InterfaceStability.Evolving public static class KuduScannerBuilder extends AbstractKuduScannerBuilder<KuduScannerBuilder, KuduScanner> { KuduScannerBuilder(AsyncKuduClient client, KuduTable table) { super(client, table); } /** * Builds a {@link KuduScanner} using the passed configurations.
<|startcomment|> please describe this encoding in the .fb file. <|endcomment|>  Preconditions.checkNotNull(fbb); Preconditions.checkNotNull(location); Preconditions.checkNotNull(replicas); Preconditions.checkNotNull(stats); // replica host ids FbFileBlock.startReplicaHostIdxsVector(fbb, replicas.size()); for (BlockReplica replica: replicas) { short replicaIdx = replica.getHostIdx(); // Encode information about caching in the MSB of the replica index. replicaIdx = replica.isCached() ? (short) (replicaIdx | ~REPLICA_HOST_IDX_MASK) : replicaIdx; fbb.addShort(replicaIdx); } <|startfocus|> int replicaHostIdxOffset = fbb.endVector(); <|endfocus|> // disk ids short[] diskIds = createDiskIds(location, stats); int diskIdsOffset = -1; if (diskIds.length != 0) { diskIdsOffset = FbFileBlock.createDiskIdsVector(fbb, diskIds); } FbFileBlock.startFbFileBlock(fbb); FbFileBlock.addOffset(fbb, location.getOffset()); FbFileBlock.addLength(fbb, location.getLength()); FbFileBlock.addReplicaHostIdxs(fbb, replicaHostIdxOffset);
<|startcomment|> or "that were added to the table" to avoid the gender reference :) <|endcomment|>  */ public org.apache.hadoop.hive.metastore.api.Table getMetaStoreTable() { return msTable_; } public void setMetaStoreTable(org.apache.hadoop.hive.metastore.api.Table msTbl) { msTable_ = msTbl; } public int getNumClusteringCols() { return numClusteringCols_; } /** * Sets the number of clustering columns. This method should only be used for tests and <|startfocus|> * the caller must make sure that the value matches any columns he/she added to the <|endfocus|> * table. */ public void setNumClusteringCols(int n) { Preconditions.checkState(RuntimeEnv.INSTANCE.isTestEnv()); numClusteringCols_ = n; } public long getNumRows() { return numRows_; } public ArrayType getType() { return type_; } @Override public long getCatalogVersion() { return catalogVersion_; } @Override public void setCatalogVersion(long catalogVersion) { catalogVersion_ = catalogVersion; } @Override public boolean isLoaded() { return true; } public static boolean isExternalTable(
<|startcomment|> synchronized (functions_) ? <|endcomment|>  public void removeAllFunctions() { <|startfocus|> functions_.clear(); <|endfocus|>
<|startcomment|> Use Expr.unwrapExpr(false) here. This optimization is ok if the SlotRef has an implicit or even an explicit cast. Add tests for the implicit and explicit cast scenarios, e.g.: // test implicitly cast partition col coalesce(year, bigint_col) -> year // test explicitly cast partition col coalesce(cast(year as string), string_col) -> year <|endcomment|>  private boolean canSimplifyCoalesceUsingChild(Expr child) { if (child.isConstant() && !child.contains(NullLiteral.class)) { return true; <|startfocus|> } <|endfocus|> if (child instanceof SlotRef) { SlotRef slot = (SlotRef) child; // Can not assume column stats is correctly and newest // just check partition column using partition metadata. // check all case in case of NullPointerException. if (slot.getDesc() != null && slot.getDesc().getParent() != null && slot.getDesc().getParent().getTable() instanceof HdfsTable && slot.getDesc().getColumn() != null && slot.getDesc().getParent().getTable().isClusteringColumn(slot.getDesc().getColumn())) { HdfsTable table = (HdfsTable) slot.getDesc().getParent().getTable(); // return true if this partition column has no-null value. if (table.getNullPartitionIds(slot.getDesc().getColumn().getPosition()).isEmpty()) { return true; } } } return false;
<|startcomment|> remove first comma <|endcomment|>  if (inAndOtherExpr != null) return inAndOtherExpr; Expr orChildExpr = rewriteEqEqPredicate(expr.getChild(0), expr.getChild(1)); if (orChildExpr != null) return orChildExpr; return expr; } /** * Takes the children of an OR predicate and attempts to combine them into a single IN predicate. <|startfocus|> * The transformation is applied, if one of the children is an IN predicate and the other child <|endfocus|> * is a compatible IN predicate or equality predicate. Returns the transformed expr or null * if no transformation was possible. */ private Expr rewriteInAndOtherExpr(Expr child0, Expr child1) { InPredicate inPred = null; Expr otherPred = null; if (child0 instanceof InPredicate) { inPred = (InPredicate) child0; otherPred = child1; } else if (child1 instanceof InPredicate) { inPred = (InPredicate) child1; otherPred = child0; } if (inPred == null || inPred.isNotIn()) return null;
<|startcomment|> remove else block and just return expr at the end <|endcomment|>  public static ExprRewriteRule INSTANCE = new NormalizeBinaryPredicatesRule(); @Override public Expr apply(Expr expr, Analyzer analyzer) throws AnalysisException { if (!(expr instanceof BinaryPredicate)) return expr; if (expr.getChild(0).unwrapSlotRef(false) != null) return expr; if (expr.getChild(1).unwrapSlotRef(false) == null) return expr; BinaryPredicate.Operator op = ((BinaryPredicate) expr).getOp(); <|startfocus|> return new BinaryPredicate(op.converse(), expr.getChild(1), expr.getChild(0)); <|endfocus|> } } 
<|startcomment|> Any reason you removed this instead of changing it to the new package: import org.apache.sentry.core.common.exception.SentryUserException That seems to work for me, and then the SentryUserExceptions below don't need to be removed. <|endcomment|> // with the License. You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.impala.util; import java.util.List; <|startfocus|> <|endfocus|> import org.apache.sentry.provider.db.SentryAccessDeniedException; import org.apache.sentry.provider.db.SentryAlreadyExistsException; import org.apache.sentry.provider.db.service.thrift.SentryPolicyServiceClient; import org.apache.sentry.provider.db.service.thrift.TSentryGrantOption; import org.apache.sentry.provider.db.service.thrift.TSentryPrivilege; import org.apache.sentry.provider.db.service.thrift.TSentryRole; import org.apache.sentry.service.thrift.SentryServiceClientFactory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.apache.impala.analysis.PrivilegeSpec; import org.apache.impala.authorization.SentryConfig; import org.apache.impala.authorization.User;
<|startcomment|> Could you move the increment of retries out of the if condition? It's difficult to determine that it's doing the right thing when it's on the right hand side of a short-circuiting &&. <|endcomment|>  c.notifyAuthnTokenAcquireSuccess(); } } } // Errback to retry on getting authn token if exception occurs while communicating with master. final class NewAuthnTokenErrB implements Callback<Void, Exception> { private final NewAuthnTokenCB cb; int retries; NewAuthnTokenErrB(NewAuthnTokenCB cb) { this.cb = cb; this.retries = 0; } @Override public Void call(Exception e) throws Exception { <|startfocus|> if (e instanceof RecoverableException && retries++ < 5) { <|endfocus|> ConnectToCluster.run(masterTable, masterAddresses, null, defaultAdminOperationTimeoutMs, true).addCallbacks(cb, this); return null; } notifyAffectedConnections(); // Finally, propagate the received exception. throw e; } void notifyAffectedConnections() { HashSet<Connection> connections; lock.lock(); try { Preconditions.checkState(!affectedConnections.isEmpty()); connections = affectedConnections; affectedConnections = Sets.newHashSet(); } finally { lock.unlock(); } for (final Connection c : connections) {
<|startcomment|> connections? <|endcomment|>  * to encounter memory issues. * * This class is thread-safe. */ @InterfaceAudience.Private @InterfaceStability.Unstable class ConnectionCache { /** Security context to use for connection negotiation. */ private final SecurityContext securityContext; /** Read timeout for the connection (used by Netty's ReadTimeoutHandler) */ private final long socketReadTimeoutMs; <|startfocus|> /** Timer to monitor read timeouts for the connection (used by Netty's ReadTimeoutHandler) */ <|endfocus|> private final HashedWheelTimer timer; /** Netty's channel factory to use for the connections. */ private final ClientSocketChannelFactory channelFactory; /** Synchronization primitive to guard access to the fields below. */ private final ReentrantLock lock = new ReentrantLock(); @GuardedBy("lock") private final HashMap<String, Connection> uuid2connection = new HashMap<>(); /** * Create a new empty ConnectionCache given the specified parameters. */ ConnectionCache(SecurityContext securityContext, long socketReadTimeoutMs, HashedWheelTimer timer, ClientSocketChannelFactory channelFactory) { this.securityContext = securityContext;
<|startcomment|> I think this comment may be stale: 'if the current one expires.' <|endcomment|>  /** * SSLContext which trusts only the configured certificate. */ private final SSLContext sslContextWithCert; /** * SSLContext which trusts any certificate. */ private final SSLContext sslContextTrustAny; /** * The JAAS Subject that the client's credentials are stored in. */ @Nullable private final Subject subject; /** <|startfocus|> * A helper class to facilitate re-acquiring of authentication token if the current one in * the securityContext expires */ @Nullable private AuthnTokenReacquirer tokenReacquirer; /** <|endfocus|> * The currently trusted CA certs, in DER format. */ private List<ByteString> trustedCertDers = Collections.emptyList(); /** * Construct SecurityContext object with null authn token re-acquirer: an attempt to re-acquire * authentication token will lead to NullPointerException. This constructor is for tests only. * * @param subject JAAS Subject that the client's credentials are stored in */ @VisibleForTesting SecurityContext(Subject subject) { try { this.subject = subject;
<|startcomment|> succesful <|endcomment|>  private void reacquireAuthnToken() { /** * An utility class providing callbacks for successful completion of authn token re-acqusition. */ final class NewAuthnTokenCB implements Callback<Void, Boolean> { @Override /** <|startfocus|> * Callback upon 'successul' completion of an attemp to acquire a new token (i.e. no exception * encountered). <|endfocus|> * * @param tokenAcquired {@link Boolean.TRUE} if a new token acquired, {@link Boolean.FALSE} if * the ConnectToCluster returned no authn token. */ public Void call(Boolean tokenAcquired) throws Exception { // TODO(aserbin): do we need to handle a successful re-connect with no token some other way? handleAffectedRpcs(); return null; } /** * Handle the affected RPCs on the completion of authn token re-acquisition. The result authn * token might be null, so in that case Kerberos credentials will be used to negotiate future * connections. */ void handleAffectedRpcs() {
<|startcomment|> I was thinking that this trace frame should be added when the RPC is popped, so that the timestamp includes the time waiting in the queue, but I'm not entirely sure. I think we should get JD to weigh in. <|endcomment|>  // re-acquisition completes (it could succeed or fail). // // TODO(aserbin): introduce a timestamp for the recently acquired authn token, so it would // not try to re-acquire a token too often if there is a race between clearing // the container after token acquisition is completed and scheduling token re-acquisition. doReacquire = true; } affectedRpcList.add(rpc); } rpc.addTrace(new RpcTraceFrame.RpcTraceFrameBuilder( <|startfocus|> rpc.method(), RpcTraceFrame.Action.GET_NEW_AUTHENTICATION_TOKEN_THEN_RETRY) .callStatus(ex.getStatus()) <|endfocus|> .build()); if (doReacquire) { reacquireAuthnToken(); } } private List<KuduRpc<?>> prepareRpcListToNotify() { List<KuduRpc<?>> rpcList; synchronized (affectedRpcInfoListLock) { Preconditions.checkState(!affectedRpcList.isEmpty()); rpcList = affectedRpcList; affectedRpcList = Lists.newArrayList(); } return rpcList; } private void reacquireAuthnToken() { /** * An utility class providing callbacks for successful completion of authn token re-acqusition.
<|startcomment|> That made more sense in ImportCsbMapper, I'd just remove this javadoc completely. <|endcomment|> import org.apache.kudu.client.Bytes; import org.apache.kudu.client.RowResult; /** * Mapper that ingests Kudu rows and turns them into CSV lines. */ @InterfaceAudience.Private @InterfaceStability.Evolving public class ExportCsvMapper extends Mapper<NullWritable, RowResult, NullWritable,Text> { private static final NullWritable NULL_KEY = NullWritable.get(); /** Column seperator */ private String separator; private Schema schema; /** <|startfocus|> * Handles initializing this class with objects specific to it (i.e., the parsing). <|endfocus|> */ @Override protected void setup(Context context) { Configuration conf = context.getConfiguration(); this.separator = conf.get(ExportCsv.SEPARATOR_CONF_KEY); if (this.separator == null) { this.separator = ExportCsv.DEFAULT_SEPARATOR; } } /** * Convert Kudu Insert into a line of CSV text */ @Override public void map(NullWritable key, RowResult value, Context context) throws IOException { this.schema = value.getSchema(); try {
<|startcomment|> Allow user to pass this in, however 5 sec is too short in extreme cases. Use 30 sec. <|endcomment|>  } private void scanUntilCount(KuduTable table, int count) throws Exception{ final int countCopy = count; final KuduTable tableCopy = table; AssertHelpers.assertEventuallyTrue(String.format("Read count should be %s", countCopy), new AssertHelpers.BooleanPredicate() { @Override public boolean get() throws Exception { AsyncKuduScanner scanner = client.newScannerBuilder(tableCopy).build(); int read_count = countRowsInScan(scanner); return read_count == countCopy; } }, 5000); <|startfocus|> } <|endfocus|> /** * This test writes 3 rows. Then in a loop, it kills the leader, then tries to write inner_row * rows, and finally restarting the tablet server it killed. Verifying with a read as it goes. * Finally it counts to make sure we have total_rows_to_insert of them. */ @Test(timeout = 100000) public void testMultipleFailover() throws Exception { KuduTable table; CreateTableOptions builder = getBasicCreateTableOptions(); String tableName =
<|startcomment|> Having System.exits in the code isn't good, ideally this case would be tested and if you exit then how can you catch the error? <|endcomment|>  ParquetInputFormat.setInputPaths(job, inputDir); CommandLineParser cmdLineParser = new CommandLineParser(conf); KuduClient client = cmdLineParser.getClient(); KuduTable table = client.openTable(tableName); //pre-flight checks of input parquet schema and table schema for (ColumnSchema sche : table.getSchema().getColumns()) { if (!schema.containsField(sche.getName())) { LOG.warn("The column " + sche.getName() + " does not exists in the Kudu table"); System.exit(0); } } <|startfocus|> //Kudu does not recommend using TIMESTAMP <|endfocus|> Iterator<ColumnDescriptor> fields = schema.getColumns().iterator(); while (fields.hasNext()) { if (fields.next().getType().equals(TIMESTAMP)) { LOG.error("This " + fields.next().getType() + " parquet type is not supported in Kudu"); System.exit(0); } } FileInputFormat.setInputPaths(job, inputDir); new KuduTableMapReduceUtil.TableOutputFormatConfiguratorWithCommandLineParser( job, tableName) .configure(); return job; } /*
<|startcomment|> What do we need this change for? This adds a lot expected test output. <|endcomment|>  public void testKudu() { Assume.assumeTrue(RuntimeEnv.INSTANCE.isKuduSupported()); <|startfocus|> TQueryOptions options = defaultQueryOptions(); options.setExplain_level(TExplainLevel.VERBOSE); runPlannerTestFile("kudu", options); <|endfocus|>
<|startcomment|> nit: alignment <|endcomment|>  boolean hasMore = resp.getHasMoreResults(); if (id.length != 0 && scannerId != null && !Bytes.equals(scannerId, id)) { Status statusIllegalState = Status.IllegalState("Scan RPC response was for scanner" + " ID " + Bytes.pretty(id) + " but we expected " + Bytes.pretty(scannerId)); throw new NonRecoverableException(statusIllegalState); } <|startfocus|> Response response = new Response(id, iterator, hasMore); <|endfocus|> if (LOG.isDebugEnabled()) { LOG.debug(response.toString()); } return new Pair<Response, Object>(response, error); } public String toString() { return "ScanRequest(scannerId=" + Bytes.pretty(scannerId) + (tablet != null? ", tabletSlice=" + tablet.getTabletIdAsString() : "") + ", attempt=" + attempt + ')'; } @Override public byte[] partitionKey() { // This key is used to lookup where the request needs to go return pruner.nextPartitionKey(); } } /**
<|startcomment|> nit: move these lines below L557. No need to get these values if we don't even have a valid scan node. <|endcomment|>  private void assignRuntimeFilters(PlannerContext ctx, ScanNode scanNode) { Preconditions.checkNotNull(ctx); Preconditions.checkNotNull(scanNode); Analyzer analyzer = ctx.getRootAnalyzer(); boolean isSingleNodeExec = ctx.isSingleNodeExec(); boolean disableRowRuntimeFiltering = ctx.getQueryOptions().isDisable_row_runtime_filtering(); TRuntimeFilterMode runtimeFilterMode = ctx.getQueryOptions().getRuntime_filter_mode(); <|startfocus|> if (!(scanNode instanceof HdfsScanNode)) return; TupleId tid = scanNode.getTupleIds().get(0); if (!runtimeFiltersByTid_.containsKey(tid)) return; <|endfocus|> for (RuntimeFilter filter: runtimeFiltersByTid_.get(tid)) { if (filter.isFinalized()) continue; Expr targetExpr = computeTargetExpr(filter, tid, analyzer); if (targetExpr == null) continue; boolean isBoundByPartitionColumns = IsBoundByPartitionColumns(analyzer, targetExpr, scanNode); if (disableRowRuntimeFiltering && !isBoundByPartitionColumns) continue; boolean isLocalTarget = IsLocalTarget(filter, scanNode); if (!isSingleNodeExec && runtimeFilterMode == TRuntimeFilterMode.LOCAL && !isLocalTarget) { continue;
<|startcomment|> Would it make sense to add the short-circuiting if (state == State.TERMINATED) { return; } check here as well? Or we have some guarantees from Netty that it would not be the case? <|endcomment|>  public void channelConnected(final ChannelHandlerContext ctx, final ChannelStateEvent e) { lock.lock(); try { Preconditions.checkState(state == State.CONNECTING); state = State.NEGOTIATING; } finally { lock.unlock(); } Channels.write(channel, ChannelBuffers.wrappedBuffer(CONNECTION_HEADER)); Negotiator negotiator = new Negotiator( serverInfo.getHostname(), securityContext, usePrimaryCredentials); ctx.getPipeline().addBefore(ctx.getName(), "negotiation", negotiator); negotiator.sendHello(channel); } <|startfocus|> /** {@inheritDoc} */ <|endfocus|> @Override public void handleUpstream(final ChannelHandlerContext ctx, final ChannelEvent e) throws Exception { if (LOG.isTraceEnabled()) { LOG.trace(e.toString()); } super.handleUpstream(ctx, e); } /** {@inheritDoc} */ @Override public void channelDisconnected(final ChannelHandlerContext ctx, final ChannelStateEvent e) throws Exception { // No need to call super.channelClosed(ctx, e) -- there should be nobody in the upstream // pipeline after Connection itself. So, just handle the disconnection event ourselves.
<|startcomment|> nit: extra space <|endcomment|>  Arrays.fill(chars, 'a'); String hugeString = new String(chars); TTestObject test = new TTestObject(hugeString, hugeString, hugeString, hugeString, hugeString, hugeString, hugeString, hugeString); serializeTestObject(test, protocolFactory); } /** * Creates a thrift object of size > 4GB (thrift limit) and makes sure the allocation * fails. */ private void testThriftLimits(TProtocolFactory protocolFactory) throws Exception { <|startfocus|> // Create a huge string of size 512MB. The combined size of the test object // crosses 4GB. // The reason we split the message into 8 strings instead of allocating a single <|endfocus|> // huge string is due to the fact that thrift internally does a copy of the string // into bytes (using getBytes()) and this potentially can hit JVM array limitations. // The reason it is not a problem with Impala's catalog updates is because a single // object inside a struct can never be that big. char[] chars = new char[512 * 1000 * 1000];
<|startcomment|> Mention that we have this wrapper so we can override the methods for a testing. <|endcomment|> // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.impala.thrift; import org.apache.impala.util.UnsafeUtil; /** <|startfocus|> * A wrapper around UnsafeUtil class that exposes allocate(), free() and copy() * methods. <|endfocus|> */ public class NativeAllocator { /** * Reallocates the memory pointed by bufferPtr to size 'size'. */ public long allocate(long bufferPtr, long size) { return UnsafeUtil.UNSAFE.reallocateMemory(bufferPtr, size); } /** * Frees the bufferPtr. */ public void free(long bufferPtr) { UnsafeUtil.UNSAFE.freeMemory(bufferPtr); } /** * Copies src[srcOffset, srcOffset + len) into dst. */ public void copy(long dst, byte[] src, int srcOffset, int len) {
<|startcomment|> remove first space in string <|endcomment|>  // Limit on the size to which the underlying buffer can grow. This limit is chosen // since thrift uses uint32_t for representing the buffer size internally, thus capping // the message size to a little over 4 gigabytes (uint32_max). public static final long BUFFER_MAX_SIZE_LIMIT = 4L * 1024L * 1024L * 1024L; // 4GB <|startfocus|> private static final String BUFFER_LIMIT_EXCEEDED_MSG = "Buffer allocation exceeds " + " maximum limit of " + BUFFER_MAX_SIZE_LIMIT + " bytes"; <|endfocus|> private static final String ALLOCATION_FAILED_MSG = "Failed to allocate/re-allocate memory using Unsafe"; // Pointer and length (in bytes) of the underlying native buffer. protected long bufferPtr_; protected long bufferLen_; // Actual bytes written to the buffer. private long bytesWritten_; private NativeAllocator nativeAllocator_; /** * Creates a new byte array output stream with a given NativeAllocator * implementation and 'BUFFER_INITIAL_SIZE_DEFAULT' as the buffer initial size. */
<|startcomment|> NbaosTest <|endcomment|> <|startfocus|> public void nbaosTest() { NativeTestAllocator testAllocator; <|endfocus|> NativeByteArrayOutputStream nbaos; testAllocator = new NativeTestAllocator(); // Check that initial allocation failure in NBAOS c'tor testAllocator.setThrowOnReallocate(true); boolean exceptionCaught = false; try { nbaos = new NativeByteArrayOutputStream(testAllocator); } catch (Throwable t) { Assert.assertTrue(t instanceof OutOfMemoryError); exceptionCaught = true; } Assert.assertTrue(exceptionCaught && testAllocator.getAllocatedBytes() == 0); // Check the initial allocation size. testAllocator = new NativeTestAllocator(); nbaos = new NativeByteArrayOutputStream(testAllocator); Assert.assertEquals(testAllocator.getAllocatedBytes(), NativeByteArrayOutputStream.BUFFER_INITIAL_SIZE_DEFAULT); // Check that the memory is freed when the first realloc() fails. byte[] b = new byte[512 * 1024 * 1024]; testAllocator.setThrowOnReallocate(true); writeNotOk(nbaos, testAllocator, b, 0, 512 * 1024 * 1024); // Reset the nbaos state. testAllocator = new NativeTestAllocator(); nbaos = new NativeByteArrayOutputStream(testAllocator);
<|startcomment|> What happens if you set this to false? Is your client going to blow up when you try to use the KuduTable? Also, isn't waiting here kind of an implementation detail? It's not known to the user that there happens to be a call to create a table, which returns after the master accepts it but still hasn't assigned the tablets. Why are we calling this out as an API? <|endcomment|>  return this; } /** * Sets the number of replicas that each tablet will have. If not specified, it uses the * server-side default which is usually 3 unless changed by an administrator. * * @param numReplicas the number of replicas to use * @return this instance */ public CreateTableOptions setNumReplicas(int numReplicas) { pb.setNumReplicas(numReplicas); return this; } /** <|startfocus|> * Whether to wait for all tablets to be created before the table creation is * considered to be successful. <|endfocus|> * <p> * If not provided, defaults to true. * <p> * @param wait whether to wait for table creation to finish * @return this instance */ public CreateTableOptions setWait(boolean wait) { this.wait = wait; return this; } Master.CreateTableRequestPB.Builder getBuilder() { if (!splitRows.isEmpty() || !rangePartitions.isEmpty()) { pb.setSplitRowsRangeBounds(new Operation.OperationsEncoder()
<|startcomment|> Let's add the new tests under a separate TestTruthTestPredicate() <|endcomment|>  "Operand 'int_struct_col' part of predicate 'FALSE AND int_struct_col' should " + "return type 'BOOLEAN' but returns type 'STRUCT<f1:INT,f2:INT>'."); AnalysisError("select not int_map_col from functional.allcomplextypes", "Operand 'int_map_col' part of predicate 'NOT int_map_col' should return " + "type 'BOOLEAN' but returns type 'MAP<STRING,INT>'."); } @Test <|startfocus|> public void TestIsNullOrBoolPredicates() throws AnalysisException { <|endfocus|> AnalyzesOk("select * from functional.alltypes where int_col is null"); AnalyzesOk("select * from functional.alltypes where string_col is not null"); AnalyzesOk("select * from functional.alltypes where null is not null"); String[] rhs_options = new String[] {"true", "false", "unknown"}; String[] lhs_options = new String[] { "bool_col", // column reference "1>1", // boolean expression "istrue(false)", // function "(1>1 is true)" // nested expression }; 
<|startcomment|> I believe you meant parseResult? <|endcomment|>  } return NativeParseQueryOptions(optionsStr, thriftInQueryOptions); } public static TParseQueryOptionsResult ParseQueryOptions(String optionsStr, TQueryOptions inQueryOptions) throws InternalException { Preconditions.checkNotNull(optionsStr); Preconditions.checkNotNull(inQueryOptions); TSerializer serializer = new TSerializer(new TBinaryProtocol.Factory()); try { byte[] result = ParseQueryOptions(optionsStr, serializer.serialize(inQueryOptions)); Preconditions.checkNotNull(result); TDeserializer deserializer = new TDeserializer(new TBinaryProtocol.Factory()); <|startfocus|> TParseQueryOptionsResult paresResult = new TParseQueryOptionsResult(); deserializer.deserialize(paresResult, result); return paresResult; <|endfocus|> } catch (TException e) { // this should never happen throw new InternalException("Could not parse query options: " + e.getMessage(), e); } } /** * This function should only be called explicitly by the FeSupport to ensure that * native functions are loaded. */ private static synchronized void loadLibrary() { if (loaded_) return; LOG.info("Loading libfesupport.so"); NativeLibUtil.loadLibrary("libfesupport.so");
<|startcomment|> ... using Tarjan's algorithm. It's a really neat algorithm that deserves a brief description here :) <|endcomment|>  for (ArrayList<Integer> dsts : transitiveClosure.adjList_) { transitiveClosureRA.add(new HashSet<>(dsts)); } long end = System.currentTimeMillis(); if (LOG.isDebugEnabled()) { LOG.trace("Time taken in computeValueTransfers(): " + (end - start) + "ms"); } return new CondensedTransitiveClosure(scc.first, scc.second, transitiveClosure, transitiveClosureRA); } /** <|startfocus|> * Compute the strongly connected components. * Time complexity: O(V+E). * @param g The input graph. * @return A pair of {@link #sccId_} and {@link #sccMemberList_}. <|endfocus|> */ static private Pair<int[], ArrayList<ArrayList<Integer>>> tarjanScc(Graph g) { int[] sccId = new int[g.numVertices()]; Arrays.fill(sccId, -1); ArrayList<ArrayList<Integer>> sccMembers = new ArrayList<>(); int[] index = new int[g.numVertices()]; int[] lowLink = new int[g.numVertices()];
<|startcomment|> Add here if the scanner is fault tolerant then all the lines will now contain this useful information. <|endcomment|>  tablet = null; } /** * Returns the tabletSlice currently being scanned, if any. */ AsyncKuduClient.RemoteTablet currentTablet() { return tablet; } /** * Returns an RPC to open this scanner. */ KuduRpc<Response> getOpenRequest() { checkScanningNotStarted(); <|startfocus|> // This is the only point where we know we haven't started scanning and where the scanner // should be fully configured if (this.inFirstTablet) { this.inFirstTablet = false; } <|endfocus|> return new ScanRequest(table, State.OPENING); } /** * Returns an RPC to fetch the next rows. */ KuduRpc<Response> getNextRowsRequest() { return new ScanRequest(table, State.NEXT); } /** * Returns an RPC to close this scanner. */ KuduRpc<Response> getCloseRequest() { return new ScanRequest(table, State.CLOSING); } /** * Throws an exception if scanning already started. * @throws IllegalStateException if scanning already started. */
<|startcomment|> Add a comment stating that the validity of this is checked elsewhere (and where exactly) <|endcomment|>  tFilterTarget.setTarget_expr(expr.treeToThrift()); List<SlotId> sids = Lists.newArrayList(); expr.getIds(null, sids); List<Integer> tSlotIds = Lists.newArrayListWithCapacity(sids.size()); for (SlotId sid: sids) tSlotIds.add(sid.asInt()); tFilterTarget.setTarget_expr_slotids(tSlotIds); tFilterTarget.setIs_bound_by_partition_columns(isBoundByPartitionColumns); tFilterTarget.setIs_local_target(isLocalTarget); <|startfocus|> if (node instanceof KuduScanNode) { SlotRef slotRef = expr.unwrapSlotRef(false); tFilterTarget.setKudu_col_name(slotRef.getDesc().getColumn().getName()); } <|endfocus|> return tFilterTarget;
<|startcomment|> remove (not needed and does not compile on Java7) <|endcomment|> // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.impala.util; import com.google.common.base.Preconditions; import org.apache.impala.common.Pair; import java.util.*; <|startfocus|> import static java.lang.Math.addExact; <|endfocus|> import static java.lang.Math.min; /** Data structures for graphs represented with an adjacency list. */ public abstract class Graph { public abstract int numVertices(); /** Return an iterator of vertex IDs with an edge from srcVid. */ public abstract IntIterator dstIter(int srcVid); public String print() { StringBuilder sb = new StringBuilder(); for (int i = 0; i < numVertices(); ++i) { IntIterator dstIter = dstIter(i); if (!dstIter.hasNext()) continue;
<|startcomment|> isArrayPosRef() (we typically abbreviate Reference with Ref) <|endcomment|> <|startfocus|> public boolean isArrayPosReference() { <|endfocus|> TupleDescriptor parent = getDesc().getParent(); if (parent == null) return false; Type parentType = parent.getType(); if (parentType instanceof CollectionStructType) { if (((CollectionStructType)parentType).isArrayStruct() && getDesc().getLabel().equals(Path.ARRAY_POS_FIELD_NAME)) { return true; } } return false;
<|startcomment|> the old deleted catalog objects -> the old entries in this log <|endcomment|>  * "invalidate metadata" is run concurrently with async catalog operations. */ public class CatalogDeltaLog { // Map of the catalog version an object was removed from the catalog // to the catalog object, ordered by catalog version. private SortedMap<Long, TCatalogObject> removedCatalogObjects_ = new TreeMap<Long, TCatalogObject>(); <|startfocus|> // Map of removed catalog object keys to the catalog versions the objects were removed. private Map<String, Long> removedCatalogObjectVersionsByKey_ = Maps.newHashMap(); <|endfocus|> /** * Adds a new item to the map of removed catalog objects. */ public synchronized void addRemovedObject(TCatalogObject catalogObject) { Preconditions.checkNotNull(catalogObject); removedCatalogObjects_.put(catalogObject.getCatalog_version(), catalogObject); String key = toCatalogObjectKey(catalogObject); removedCatalogObjectVersionsByKey_.put(key, catalogObject.getCatalog_version()); } /** * Deletes from the removed objects the entry corresponding to a catalog object with * key 'key'. */ public synchronized void deleteRemovedObject(TCatalogObject object) {
<|startcomment|> rename to actualStringHints <|endcomment|>  private void TestInsertHints(String stmt, String... expectedHints) { InsertStmt insertStmt = (InsertStmt) ParsesOk(stmt); <|startfocus|> List<String> actualHints = insertStmt.getPlanHints(); if (actualHints == null) actualHints = Lists.newArrayList((String) null); <|endfocus|> assertEquals(Lists.newArrayList(expectedHints), actualHints);
<|startcomment|> sleepPeriodMs. <|endcomment|>  } assertEquals(numOpenSessions, (Long)metrics.getMetric( "impala-server.num-open-hiveserver2-sessions")); assertEquals(numExpiredSessions, (Long)metrics.getMetric( "impala-server.num-sessions-expired")); for (int timeout : timeoutPeriods) { // Let's expire a session by sleeping, // while renewing the remainders by issuing a query // (except for the 0 timeout, which should never expire) <|startfocus|> double timeoutTolerance = 1.5; int sleepPeriod = (int)(timeout * timeoutTolerance * 1000) + 500; Thread.sleep(sleepPeriod); <|endfocus|> for (int i = 0; i < connections.size(); ++i) { Connection connection = connections.get(i); if (connection != null) { Integer timeoutPeriod = timeoutPeriods.get(i); long lastExecStatementTime = System.currentTimeMillis() / 1000; boolean sessionIsValid = timeoutPeriod == 0 || timeoutPeriod > lastExecStatementTime - lastTimeSessionActive.get(i); try (ResultSet rs = connection.createStatement().executeQuery("SELECT 1+2")) { assertTrue(sessionIsValid);
<|startcomment|> nit: ++i <|endcomment|>  if (currentChar == '\\' && (i + 1) < lengthOfValue) { final char nextChar = value_.charAt(i + 1); if (nextChar == '"' || nextChar == '\'' || nextChar == '\\') { if (nextChar == '"') { // unescape an escaped double quote: remove back-slash in front of the quote. sb.append("\""); } else { sb.append(currentChar); sb.append(nextChar); } <|startfocus|> i++; <|endfocus|> continue; } sb.append(currentChar); } else if (currentChar == '\'') { // escape a single quote: add back-slash in front of the quote. sb.append("\\\'"); } else { sb.append(currentChar); } } return sb.toString();
<|startcomment|> let's include the format of the table <|endcomment|>  "on TEXT or SEQUENCE file formats: " + partition.getPartitionName()); } } } else { HdfsFileFormat format = HdfsFileFormat.fromHdfsInputFormatClass( ((HdfsTable) tbl).getMetaStoreTable().getSd().getInputFormat()); if (format != HdfsFileFormat.TEXT && format != HdfsFileFormat.SEQUENCE_FILE) { <|startfocus|> throw new AnalysisException("ALTER TABLE SET ROW FORMAT is only supported " + "on TEXT or SEQUENCE file formats: " + tbl.getFullName()); <|endfocus|> } } } } 
<|startcomment|> add 'final' <|endcomment|>  private static final long REFRESH_RATE_LIMIT_SECS = 10; @VisibleForTesting static Ticker ticker = Ticker.systemTicker(); @GuardedBy("this") @Nullable private SignedTokenPB authnToken; private final DelegatedTrustManager trustManager = new DelegatedTrustManager(); /** * SSLContext which trusts only the configured certificate. */ private final SSLContext sslContextWithCert; /** * SSLContext which trusts any certificate. */ private final SSLContext sslContextTrustAny; <|startfocus|> private Object subjectLock = new Object(); <|endfocus|> /** * The JAAS Subject that the client's credentials are stored in. */ @Nullable @GuardedBy("subjectLock") private Subject subject; private static enum SubjectType { CREATED, PROVIDED, NONE }; @Nonnull private final SubjectType subjectType; /** * The currently trusted CA certs, in DER format. */ private List<ByteString> trustedCertDers = Collections.emptyList(); @GuardedBy("subjectLock") private long nextAllowedRefreshNanotime = 0; @GuardedBy("subjectLock")
<|startcomment|> "associated table columns"? <|endcomment|>  * that satisfy predicate T2.c = '1'. The runtime filter is subsequently sent to the * scan node of table T1 and is applied on the values of T1.a (lhs of the join condition) * to prune tuples of T2 that cannot be part of the join result. * * TODO: Consider combining multiple filters, that are applied to the same scan node, * into a single filter. */ public final class RuntimeFilterGenerator { private final static Logger LOG = LoggerFactory.getLogger(RuntimeFilterGenerator.class); <|startfocus|> <|endfocus|> // Map of base table tuple ids to a list of runtime filters that // can be applied at the corresponding scan nodes. private final Map<TupleId, List<RuntimeFilter>> runtimeFiltersByTid_ = Maps.newHashMap(); // Generator for filter ids private final IdGenerator<RuntimeFilterId> filterIdGenerator = RuntimeFilterId.createGenerator(); private RuntimeFilterGenerator() {}; /** * Internal representation of a runtime filter. A runtime filter is generated from
<|startcomment|> Consider hoisting the size into a local variable now that it's no longer a cheap accessor. This method is called once for each row in a write batch, so I think it's perf sensitive. <|endcomment|>  if (col.getType() == Type.STRING || col.getType() == Type.BINARY) { ByteBuffer varLengthData = row.getVarLengthData().get(colIdx); varLengthData.reset(); rows.putLong(indirectWrittenBytes); int bbSize = varLengthData.remaining(); rows.putLong(bbSize); indirect.add(varLengthData); indirectWrittenBytes += bbSize; } else { // This is for cols other than strings <|startfocus|> rows.put(rowData, currentRowOffset, col.getType().getSize(col.getTypeAttributes())); <|endfocus|> } } currentRowOffset += col.getType().getSize(col.getTypeAttributes()); colIdx++; }
<|startcomment|> comment is stale, pls update. <|endcomment|>  * Throws if the expression cannot be evaluated, if the value evaluates to null, or if * the result is negative. The 'name' parameter is used in exception messages, e.g. * "LIMIT expression evaluates to NULL". */ private static long evalIntegerExpr(Analyzer analyzer, Expr expr, String name) throws AnalysisException { <|startfocus|> // Check for slotrefs before analysis so we can provide a more helpful message than // "Could not resolve column/field reference". <|endfocus|> if (expr.contains(SlotRef.class) || expr.contains(Subquery.class)) { throw new AnalysisException(name + " expression must be a constant expression: " + expr.toSql()); } expr.analyze(analyzer); if (!expr.isConstant()) { throw new AnalysisException(name + " expression must be a constant expression: " + expr.toSql()); } if (!expr.getType().isIntegerType()) { throw new AnalysisException(name + " expression must be an integer type but is '" +
<|startcomment|> 'static' is redundant for inner enums. <|endcomment|>  private final DelegatedTrustManager trustManager = new DelegatedTrustManager(); /** * SSLContext which trusts only the configured certificate. */ private final SSLContext sslContextWithCert; /** * SSLContext which trusts any certificate. */ private final SSLContext sslContextTrustAny; private final Object subjectLock = new Object(); /** * The JAAS Subject that the client's credentials are stored in. */ @Nullable @GuardedBy("subjectLock") private Subject subject; <|startfocus|> private static enum SubjectType { <|endfocus|> /** * The Subject was created when this class was instantiated. */ CREATED, /** * A Subject with appropriate credentials was provided by the caller who * instantiated this class. */ PROVIDED, /** * We have no Subject at all (i.e we could not login on our own, and the * caller did not provide a Subject with appropriate credentials. */ NONE }; @Nonnull private final SubjectType subjectType; /**
<|startcomment|> confusing collection of function names that need cleanup: getLastModifiedTime() setLastModifiedTime() UpdateLastModifiedTime() GetLastModifiedTime() <|endcomment|>  lookup.location = binaryType_ != TFunctionBinaryType.BUILTIN ? location_.toString() : ""; lookup.symbol = symbol; lookup.symbol_type = symbolType; lookup.fn_binary_type = binaryType_; lookup.arg_types = Type.toThrift(argTypes); lookup.has_var_args = hasVarArgs; if (retArgType != null) lookup.setRet_arg_type(retArgType.toThrift()); return lookup; } <|startfocus|> // Looks up the last time the function's source file was updated. public final void UpdateLastModifiedTime() { <|endfocus|> if (getBinaryType() != TFunctionBinaryType.BUILTIN && getLocation() != null && getLocation().toString().length() > 0) { setLastModifiedTime(GetLastModifiedTime()); } } protected long GetLastModifiedTime() { return Long.MAX_VALUE; } // Returns the resolved symbol in the binary. The BE will do a lookup of 'symbol' // in the binary and try to resolve unmangled names. // If this function is expecting a return argument, retArgType is that type. It should
<|startcomment|> intDesc <|endcomment|>  private void testMTime(String fnCall, boolean expectMTime) { SelectStmt stmt = (SelectStmt) AnalyzesOk("select " + fnCall + " from functional.alltypes"); Preconditions.checkState(stmt.getSelectList().getItems().size() == 1); TupleDescriptor tblRefDesc = stmt.fromClause_.get(0).getDesc(); tblRefDesc.materializeSlots(); tblRefDesc.computeMemLayout(); if (stmt.hasAggInfo()) { <|startfocus|> TupleDescriptor int_desc = stmt.getAggInfo().intermediateTupleDesc_; int_desc.materializeSlots(); int_desc.computeMemLayout(); <|endfocus|> checkSerializedMTime(stmt.getAggInfo().getAggregateExprs().get(0), expectMTime); checkSerializedMTime( stmt.getAggInfo().getMergeAggInfo().getAggregateExprs().get(0), expectMTime); } else { checkSerializedMTime(stmt.getSelectList().getItems().get(0).getExpr(), expectMTime); }
<|startcomment|> Test looks good! Thanks for adding it. <|endcomment|>  fail(String.format("The number of members in %s have changed.\n" + "Expected %s but found %s. Please modify clone() accordingly and " + "change the expected number of members in this test.", cl.getSimpleName(), expectedNumMembers, actualNumMembers)); } } @Test public void TestSetQueryOption() { AnalyzesOk("set foo=true"); AnalyzesOk("set"); } @Test public void TestFunctionPaths() throws ImpalaException { <|startfocus|> AnalysisContext analysisCtx = createAnalysisCtx(); <|endfocus|> // The statement here does not matter since we just need to get a dummy analyzer // to be able to call FuntionName.analyze(Analyzer, boolean) method. Analyzer dummyAnalyzer = parseAndAnalyze("select 1", analysisCtx).getAnalyzer(); FunctionName fnName = new FunctionName(null, "sin"); fnName.analyze(dummyAnalyzer, false); assertFalse(fnName.isBuiltin()); fnName = new FunctionName(null, "f"); fnName.analyze(dummyAnalyzer, false); assertFalse(fnName.isBuiltin()); 
<|startcomment|> decimalV2 (camel-case in Java land) <|endcomment|> <|startfocus|> public static boolean isImplicitlyCastable( Type t1, Type t2, boolean strict, boolean decimal_v2) { <|endfocus|> if (t1.isScalarType() && t2.isScalarType()) { return ScalarType.isImplicitlyCastable( (ScalarType) t1, (ScalarType) t2, strict, decimal_v2); } return false;
<|startcomment|> Not alphabetical with below. <|endcomment|> // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.impala.common; import java.io.IOException; import java.io.PrintWriter; import java.io.StringWriter; import java.io.Writer; <|startfocus|> import java.lang.StackTraceElement; import java.lang.Thread.State; <|endfocus|> import java.lang.management.LockInfo; import java.lang.management.ManagementFactory; import java.lang.management.MemoryMXBean; import java.lang.management.MemoryPoolMXBean; import java.lang.management.MemoryUsage; import java.lang.management.MonitorInfo; import java.lang.management.RuntimeMXBean; import java.lang.management.ThreadMXBean; import java.lang.management.ThreadInfo; import java.util.ArrayList; import java.util.Map; import org.apache.thrift.TBase; import org.apache.thrift.TSerializer; import org.apache.thrift.TDeserializer; import org.apache.thrift.TException; import org.apache.thrift.protocol.TBinaryProtocol; import org.apache.thrift.protocol.TProtocolFactory; 
<|startcomment|> Doesn't the HMS set this in alter_table()? <|endcomment|>  } catch (ImpalaRuntimeException e) { throw new TableLoadingException("Error loading metadata for Kudu table " + kuduTableName_, e); } // Update the table schema in HMS. try { <|startfocus|> long lastDdlTime = CatalogOpExecutor.calculateDdlTime(msTable_); msTable_.putToParameters("transient_lastDdlTime", Long.toString(lastDdlTime)); <|endfocus|> msTable_.putToParameters(StatsSetupConst.DO_NOT_UPDATE_STATS, StatsSetupConst.TRUE); msClient.alter_table(msTable_.getDbName(), msTable_.getTableName(), msTable_); } catch (TException e) { throw new TableLoadingException(e.getMessage()); } } finally { context.stop(); } } /** * Loads the schema from the Kudu table including column definitions and primary key * columns. Replaces the columns in the HMS table with the columns from the Kudu table. * Throws an ImpalaRuntimeException if Kudu column data types cannot be mapped to * Impala data types. */ private void loadSchema(org.apache.kudu.client.KuduTable kuduTable)
<|startcomment|> likewise <|endcomment|>  long millis = timestamp.getTime() * 1000L; // Sub millisecond time since the Unix epoch, in microseconds. long micros = (timestamp.getNanos() % 1000000L) / 1000L; if (micros >= 0) { return millis + micros; } else { return millis + 1000000L + micros; } } /** <|startfocus|> * Converts a microsecond offset from the Unix epoch (1970-01-01T00:00:00Z) to a [[Timestamp]]. <|endfocus|> * * @param micros the offset in microseconds since the Unix epoch * @return the corresponding timestamp */ public static Timestamp microsToTimestamp(long micros) { long millis = micros / 1000L; long nanos = (micros % 1000000L) * 1000L; if (nanos < 0) { millis -= 1L; nanos += 1000000000L; } Timestamp timestamp = new Timestamp(millis); timestamp.setNanos((int) nanos); return timestamp; } /** * Transforms a timestamp into a string, whose formatting and timezone is consistent * across Kudu.
<|startcomment|> It doesn't seem related to the changes of this commit and it might change the behavior of this method. Could you add a comment why can we skip the default partition? <|endcomment|>  Map<Long, HdfsPartition> partitionMap = tbl_.getPartitionMap(); // Set of partition ids that pass a filter HashSet<Long> matchingIds = Sets.newHashSet(); // Batch of partitions ArrayList<HdfsPartition> partitionBatch = Lists.newArrayList(); // Identify the partitions that pass all filters. for (HdfsPartitionFilter filter: filters) { // Iterate through the currently valid partitions for (Long id: matchingPartitionIds) { HdfsPartition p = partitionMap.get(id); <|startfocus|> if (p.isDefaultPartition()) continue; <|endfocus|> Preconditions.checkState( p.getPartitionValues().size() == tbl_.getNumClusteringCols()); // Add the partition to the current batch partitionBatch.add(partitionMap.get(id)); if (partitionBatch.size() == PARTITION_PRUNING_BATCH_SIZE) { // Batch is full. Evaluate the predicates of this batch in the BE. matchingIds.addAll(filter.getMatchingPartitionIds(partitionBatch, analyzer)); partitionBatch.clear(); } } // Check if there are any unprocessed partitions. if (!partitionBatch.isEmpty()) {
<|startcomment|> Table? (so that the child class is not used) In either case, this is an odd dep. Seems like SchemaInfo can be the class that knows specifically about HMS, so the detail about what param to pull out would go there explicitly (then replace that method of Table) <|endcomment|>  public long getNumRows() { <|startfocus|> return HdfsTable.getRowCount(schemaInfo_.msTable_.getParameters()); <|endfocus|>
<|startcomment|> make this a public member so the test can use it as well. <|endcomment|>  "default: %d", maxPartitionsPerRpc_, DEFAULT_MAX_PARTITIONS_PER_RPC)); maxPartitionsPerRpc_ = DEFAULT_MAX_PARTITIONS_PER_RPC; } } /** * Return the value that Hive is configured to use for NULL partition key values. */ public static String getNullPartitionKeyValue(IMetaStoreClient client) throws ConfigValSecurityException, TException { return client.getConfigValue( <|startfocus|> "hive.exec.default.partition.name", "__HIVE_DEFAULT_PARTITION__"); <|endfocus|> } /** * Fetches all partitions for a table in batches, with each batch containing at most * 'maxPartsPerRpc' partitions. Returns a List containing all fetched Partitions. * Will throw a MetaException if existing partitions are dropped while a fetch is in * progress. To help protect against this, the operation can be retried if there is * a MetaException by setting the "numRetries" parameter. * Failures due to thrift exceptions (TExceptions) are not retried because they * generally mean the connection is broken or has timed out. The HiveClient supports
<|startcomment|> nit: indentation <|endcomment|>  * shutdown('host:port'), shutdown(deadline), shutdown('host:port', deadline). */ private void analyzeShutdown(Analyzer analyzer) throws AnalysisException { if (analyzer.getAuthzConfig().isEnabled()) { // Only admins (i.e. user with ALL privilege on server) can execute admin functions. String authzServer = analyzer.getAuthzConfig().getServerName(); Preconditions.checkNotNull(authzServer); <|startfocus|> analyzer.registerPrivReq(new PrivilegeRequestBuilder().onServer( authzServer).all().toRequest()); <|endfocus|> } // TODO: this parsing and type checking logic is specific to the command, similar to // handling of other top-level commands. If we add a lot more of these functions we // could consider making it generic, similar to handling of normal function calls. Pair<Expr, Expr> args = getShutdownArgs(); Expr backendExpr = args.first; Expr deadlineExpr = args.second; backend_ = null; deadlineSecs_ = -1; if (backendExpr != null) { if (!(backendExpr instanceof StringLiteral)) { throw new AnalysisException(
<|startcomment|> Isn't the semantics that sqlString_ is populated in analyze(), if so, doesn't it make sense to set this to null after rewrite and before reanalyze()? <|endcomment|>  throws AnalysisException { for (TableRef tblRef : stmt.fromClause_) { if (!(tblRef instanceof InlineViewRef)) continue; InlineViewRef inlineViewRef = (InlineViewRef) tblRef; rewriteQueryStatement(inlineViewRef.getViewStmt(), inlineViewRef.getAnalyzer()); } // Currently only SubqueryRewriter touches the where clause. Recurse into the where // clause when the need arises. rewriteSelectStmtHook(stmt, analyzer); <|startfocus|> if (LOG.isTraceEnabled()) LOG.trace("rewritten stmt: " + stmt.toSql(true)); <|endfocus|> } /** * Rewrite all operands in a UNION. The conditions that apply to SelectStmt rewriting * also apply here. */ private void rewriteUnionStatement(UnionStmt stmt) throws AnalysisException { for (UnionOperand operand : stmt.getOperands()) { Preconditions.checkState(operand.getQueryStmt() instanceof SelectStmt); rewriteSelectStatement((SelectStmt) operand.getQueryStmt(), operand.getAnalyzer()); } } protected void rewriteSelectStmtHook(SelectStmt stmt, Analyzer analyzer) throws AnalysisException {} static class SubqueryRewriter extends StmtRewriter {
<|startcomment|> AvroSchemaUtils <|endcomment|> import org.apache.hadoop.hive.metastore.api.FieldSchema; import org.apache.hadoop.hive.serde2.avro.AvroSerdeUtils; import org.apache.impala.analysis.ColumnDef; import org.apache.impala.catalog.HdfsTable; import org.apache.impala.catalog.PrimitiveType; import org.apache.impala.common.AnalysisException; import org.apache.impala.common.FileSystemUtil; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * Contains utility functions for dealing with Avro schemas. */ public abstract class AvroSchemaUtils { <|startfocus|> private final static Logger LOG = LoggerFactory.getLogger(HdfsTable.class); <|endfocus|> /** * Gets an Avro table's JSON schema from the list of given table property search * locations. The schema may be specified as a string literal or provided as a * Hadoop FileSystem or http URL that points to the schema. Apart from ensuring * that the JSON schema is not SCHEMA_NONE, this function does not perform any * additional validation on the returned string (e.g., it may not be a valid
<|startcomment|> move this comment before L51, then bring the "implements" up a line. <|endcomment|> import org.apache.hadoop.hbase.client.Connection; import org.apache.hadoop.hbase.client.ConnectionFactory; import org.apache.hadoop.hbase.client.RegionLocator; import org.apache.hadoop.hbase.client.Result; import org.apache.hadoop.hbase.client.ResultScanner; import org.apache.hadoop.hbase.client.Scan; import org.apache.hadoop.hbase.io.compress.Compression; import org.apache.hadoop.hbase.util.Bytes; import org.apache.hadoop.hbase.TableName; import org.apache.hadoop.hive.hbase.HBaseSerDe; import org.apache.hadoop.hive.metastore.IMetaStoreClient; <|startfocus|> import org.apache.hadoop.hive.metastore.api.FieldSchema; import org.apache.hadoop.hive.metastore.api.MetaException; <|endfocus|> import org.apache.hadoop.hive.metastore.api.StorageDescriptor; import org.apache.hadoop.hive.serde2.SerDeException; import org.apache.log4j.Logger; import org.apache.impala.common.Pair; import org.apache.impala.thrift.TCatalogObjectType; import org.apache.impala.thrift.TColumn; import org.apache.impala.thrift.THBaseTable; import org.apache.impala.thrift.TResultSet; import org.apache.impala.thrift.TResultSetMetadata; import org.apache.impala.thrift.TTable; import org.apache.impala.thrift.TTableDescriptor; import org.apache.impala.thrift.TTableType;
<|startcomment|> are these the checks that expect expr/simplified to be analyzed? if so, then i'm wondering if any code-path below that creates a new expression, whether it can run into similar issues. perhaps its easier to just analyze simplified before this block (if it was rewritten). <|endcomment|>  } else { return expr; } // IMPALA-5125: We can't eliminate aggregates as this may change the meaning of the // query, for example: // 'select if (true, 0, sum(id)) from alltypes' != 'select 0 from alltypes' if (expr != simplified && expr.contains(Expr.isAggregatePredicate()) && !simplified.contains(Expr.isAggregatePredicate())) { return expr; } return simplified; } /** * Simplifies IF by returning the corresponding child if the condition has a constant * TRUE, FALSE, or NULL (equivalent to FALSE) value. */ <|startfocus|> private Expr simplifyIfFunctionExpr(FunctionCallExpr expr) { <|endfocus|> Preconditions.checkState(expr.getChildren().size() == 3); if (expr.getChild(0) instanceof BoolLiteral) { if (((BoolLiteral) expr.getChild(0)).getValue()) { // IF(TRUE) return expr.getChild(1); } else { // IF(FALSE) return expr.getChild(2); } } else if (expr.getChild(0) instanceof NullLiteral) {
<|startcomment|> can you give this thread a name? <|endcomment|>  private ImpaladTableUsageTracker() { <|startfocus|> req = new TReportTableUsageRequest(new HashMap<TTableName, TTableUsage>()); reportThread = new Thread(new Runnable() { <|endfocus|> @Override public void run() { report(); } }); reportThread.setDaemon(true); reportThread.start();
<|startcomment|> table names? <|endcomment|>  new Callable<List<PartitionRef>>() { @Override public List<PartitionRef> call() throws Exception { hitCache.setRef(false); TGetPartialCatalogObjectRequest req = newReqForTable(table); req.table_info_selector.want_partition_list = true; TGetPartialCatalogObjectResponse resp = sendRequest(req); checkResponse(resp.table_info != null && resp.table_info.partitions != null, req, "missing partition list result"); List<PartitionRef> ret = Lists.newArrayListWithCapacity( resp.table_info.partitions.size()); <|startfocus|> for (TPartialPartitionInfo p : resp.table_info.partitions) { ret.add(new PartitionRefImpl(p)); <|endfocus|> } return ret; } }); } catch (ExecutionException e) { Throwables.propagateIfPossible(e.getCause(), TException.class); throw new RuntimeException(e); } finally { LOG.trace("Request for partition list of {}: {}", table, hitCache.getRef() ? "hit":"miss"); } } @Override public Map<String, PartitionMetadata> loadPartitionsByRefs(TableMetaRef table,
<|startcomment|> At a high level, I'm a little confused in this patch about the boolean hasIncrementalStats. It seems like you're setting that boolean based on whether the decoded TPartitionStats has the intermediate_col_stats member. But, this function seems like the old behavior was to return the TPartitionStats regardless -- ie even if it has a TTableStats 'stats' member but _not_ the 'intermediate_col_stats' member. Maybe we can chat about this? <|endcomment|>  public static TPartitionStats getPartStatsOrWarn(FeFsPartition part) { try { <|startfocus|> if (!part.hasIncrementalStats()) return null; <|endfocus|> TCompactProtocol.Factory protocolFactory = new TCompactProtocol.Factory(); TPartitionStats ret = new TPartitionStats(); byte[] decompressed = CompressionUtil.deflateDecompress(part.getPartitionStatsCompressed()); JniUtil.deserializeThrift(protocolFactory, ret, decompressed); return ret; } catch (ImpalaException e) { LOG.warn("Bad partition stats for " + part.getPartitionName()); return null; }
<|startcomment|> Update? <|endcomment|>  private void loadFunctionNames() { if (functions_ != null) return; // Load the Java functions names. We don't load the actual metadata // for them unless they get looked up. <|startfocus|> List<String> funcNames; <|endfocus|> try { funcNames = catalog_.getMetaProvider().loadFunctionNames(name_); } catch (TException e) { throw new LocalCatalogException(String.format( "Could not load functions for database '%s' from metadata provider", name_), e); } functions_ = Maps.newHashMapWithExpectedSize(funcNames.size()); for (String fn : funcNames) { functions_.put(fn, null); }
<|startcomment|> please resolve TODO <|endcomment|>  * - 1st phase grouping exprs: a, b, c * - 1st phase agg exprs: MIN(d), COUNT(*) * - 2nd phase grouping exprs: a * - 2nd phase agg exprs: COUNT(*), MIN(<MIN(d) from 1st phase>), * SUM(<COUNT(*) from 1st phase>) <|startfocus|> * * TODO: expand implementation to cover the general case; this will require * a different execution strategy <|endfocus|> */ private void createDistinctAggInfo(List<Expr> origGroupingExprs, List<FunctionCallExpr> distinctAggExprs, Analyzer analyzer) throws AnalysisException { Preconditions.checkState(!distinctAggExprs.isEmpty()); // make sure that all DISTINCT params are the same; // ignore top-level implicit casts in the comparison, we might have inserted // those during analysis List<Expr> expr0Children = AggregateFunction.getCanonicalDistinctAggChildren(distinctAggExprs.get(0)); for (int i = 1; i < distinctAggExprs.size(); ++i) { List<Expr> exprIChildren =
<|startcomment|> needs update <|endcomment|>  while (true) { try { synchronized (CatalogdTableInvalidator.this) { if (stopped_) return; if (shouldEvictFromFullHeapAfterGc()) { invalidateSome(gcInvalidationFraction_); triggerCount_.incrementAndGet(); } long now = nanoTime(); if (unusedTableTtlNano_ > 0 && now >= lastInvalidationTime + unusedTableTtlNano_) { invalidateOlderThan(unusedTableTtlNano_); lastInvalidationTime = now; triggerCount_.incrementAndGet(); } // Wait unusedTableTtlSec if it is configured. Otherwise wait // indefinitely. <|startfocus|> TimeUnit.NANOSECONDS.timedWait(CatalogdTableInvalidator.this, Math.min(unusedTableTtlNano_ / 10, DAEMON_MAXIMUM_SLEEP_NANO)); <|endfocus|> } } catch (Exception e) { LOG.error("Unexpected exception thrown: ", e); } }
<|startcomment|> Can you explain what is going on here? Is there a case where oldThreadLocalValue_ is not null? <|endcomment|>  private Scope(FrontendProfile profile) { <|startfocus|> oldThreadLocalValue_ = THREAD_LOCAL.get(); <|endfocus|> THREAD_LOCAL.set(profile);
<|startcomment|> The implementation doesn't implement what the JavaDoc says regarding the ttl and throwing an IllegalArgumentException. <|endcomment|> <|startfocus|> public boolean isTimedOut(long ttl) { <|endfocus|> long elapsed = System.nanoTime(); long ttlNanos = ttl * 1000 * 1000; /* ttl supplied is millis */ if (elapsed - creationTime > ttlNanos) timedout = true; return timedout;
<|startcomment|> This should have a message indicating why it's unsupported. Simply saying touch is a binary protocol only operation would be sufficient. Would save someone a lot of hassle. <|endcomment|>  public KeyedOperation touch(String key, int expiration, OperationCallback cb) { <|startfocus|> throw new UnsupportedOperationException(); <|endfocus|>
<|startcomment|> Move up to other jboss imports <|endcomment|> import org.jboss.netty.handler.codec.http.DefaultHttpRequest; import org.jboss.netty.handler.codec.http.HttpHeaders; import org.jboss.netty.handler.codec.http.HttpMethod; import org.jboss.netty.handler.codec.http.HttpRequest; import org.jboss.netty.handler.codec.http.HttpVersion; import java.net.InetSocketAddress; import java.net.URI; import java.util.Observable; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.logging.Level; import java.util.logging.Logger; import java.text.ParseException; <|startfocus|> import org.jboss.netty.channel.ChannelFactory; <|endfocus|> import net.spy.memcached.vbucket.config.Bucket; import net.spy.memcached.vbucket.config.ConfigurationParser; /** * * The BucketMonitor will open an HTTP comet stream to monitor for * changes to the list of nodes. If the list of nodes changes */ public class BucketMonitor extends Observable { private final URI cometStreamURI; private Bucket bucket; private final String httpUser; private final String httpPass; private final ChannelFactory factory; private Channel channel; private final String host; private final int port; private ConfigurationParser configParser;
<|startcomment|> You can pass in the exact size from servers.size() so the ArrayList doesn't need to use its default size. <|endcomment|>  public static List<InetSocketAddress> getAddresses(List<String> servers) { <|startfocus|> ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>(); <|endfocus|> for (String server : servers) { int finalColon=server.lastIndexOf(':'); if(finalColon < 1) { throw new IllegalArgumentException("Invalid server ``" + server + "'' in list: " + server); } String hostPart=server.substring(0, finalColon); String portNum=server.substring(finalColon+1); addrs.add(new InetSocketAddress(hostPart, Integer.parseInt(portNum))); } assert !addrs.isEmpty() : "No addrs found"; return addrs; 
<|startcomment|> If this is truly public, you probably want to say what unit TTL is. <|endcomment|>  * @return The flags data. */ public int getFlags() { if (FLAGS_OFFSET + FLAGS_FIELD_LENGTH > getExtralength()) throw new FieldDoesNotExistException("Flags field is not defined in this message"); int offset = HEADER_LENGTH + FLAGS_OFFSET; return (int) Util.fieldToValue(mbytes, offset, FLAGS_FIELD_LENGTH); } /** <|startfocus|> * Gets the value of the ttl field if the field exists in the message. * @return The ttl data. <|endfocus|> */ public int getTTL() { if (TTL_OFFSET + TTL_FIELD_LENGTH > getExtralength()) throw new FieldDoesNotExistException("TTL field is not defined in this message"); int offset = HEADER_LENGTH + TTL_OFFSET; return (int) Util.fieldToValue(mbytes, offset, TTL_FIELD_LENGTH); } /** * Gets the value of the reserved1 field if the field exists in the message. * @return The reserved1 data. */ public int getReserved1() {
<|startcomment|> This at least seems worthy of some docs. I know this isn't public for a user, but this would seem confusing if you just showed up. <|endcomment|>  private final TapOpcode opcode; private final int opaque; TapAckOperationImpl(TapOpcode opcode, int opaque, OperationCallback cb) { super(cb); this.opcode = opcode; this.opaque = opaque; } @Override public void initialize() { RequestMessage message = new RequestMessage(); message.setMagic(TapMagic.PROTOCOL_BINARY_RES); message.setOpcode(opcode); message.setOpaque(opaque); setBuffer(message.getBytes()); } @Override public void readFromBuffer(ByteBuffer data) { // Do Nothing } <|startfocus|> <|endfocus|> @Override public Collection<String> getKeys() { return null; } @Override public void streamClosed(OperationState state) { transitionState(state); } } 
<|startcomment|> from what I just read in TestConfig, it seems like you're testing something impossible here. <|endcomment|>  protected String getExpectedVersionSource() { <|startfocus|> // If no ipv6 address is given and we're not using localhost then we default to ipv4 if (TestConfig.IPV4_ADDR.equals(System.getProperty(TestConfig.IPV6_PROP, "::1"))) { <|endfocus|> return "/" + TestConfig.IPV4_ADDR + ":11211"; } return "/" + TestConfig.IPV6_ADDR + ":11211";
<|startcomment|> I think with this assert statement should look like this: assertEquals(OBJ_KEY, memcachedClient.get(OBJ_KEY)) : "Fail during getting data with primary non active node"; Then you can remove all of these try-catches <|endcomment|>  } catch (Exception e) { logger.error(e); throw e; } } public void testNodeFail() throws Exception { memcachedClient.set(OBJ_KEY, 100000, OBJ_KEY); try { Thread.sleep(500); } catch (InterruptedException ex) { logger.error(ex); } failPrimaryNode(); try { Thread.sleep(500); } catch (InterruptedException ex) { logger.error(ex); } <|startfocus|> try { assertEquals(OBJ_KEY, memcachedClient.get(OBJ_KEY)); } catch (Exception e) { e.printStackTrace(); logger.error(e); fail("Fail during getting data with primary non active node"); } <|endfocus|> } public void tearDown() throws Exception { couchBaseMockProcess.destroy(); } /** * Fail primary node */ private void failPrimaryNode() { int port = ((InetSocketAddress) memcachedClient.getNodeLocator().getPrimary(OBJ_KEY).getSocketAddress()). getPort(); logger.info("Failing primary node on port no " + port); try {
<|startcomment|> whitespace! <|endcomment|> kage net.spy.memcached.protocol.couchdb; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.OperationException; import org.apache.http.HttpRequest; import org.apache.http.HttpResponse; public interface HttpOperation { public HttpRequest getRequest(); <|startfocus|> <|endfocus|> OperationCallback getCallback(); boolean isCancelled(); boolean hasErrored(); boolean isTimedOut(); void cancel(); void timeOut(); OperationException getException(); void handleResponse(HttpResponse response); } 
<|startcomment|> Now that this is one line, it need not be concatenated. <|endcomment|>  if (!op.isTimedOut() && !op.isCancelled()) { AsyncConnectionRequest connRequest = connMgr.requestConnection(); try { connRequest.waitFor(); } catch (InterruptedException e) { getLogger().warn( "Interrupted while trying to get a connection." + " Cancelling op"); op.cancel(); return; } NHttpClientConnection conn = connRequest.getConnection(); if (conn == null) { <|startfocus|> getLogger().error("Failed to obtain connection. " + "Cancelling op"); <|endfocus|> op.cancel(); } else { HttpContext context = conn.getContext(); RequestHandle handle = new RequestHandle(connMgr, conn); context.setAttribute("request-handle", handle); context.setAttribute("operation", op); conn.requestOutput(); } } }
<|startcomment|> Minor, but isn't an @override supposed to be here? <|endcomment|>  } } private MemcachedNode findNode(SocketAddress sa) { MemcachedNode node = null; for(MemcachedNode n : conn.getLocator().getAll()) { if(n.getSocketAddress().equals(sa)) { node = n; } } assert node != null : "Couldn't find node connected to " + sa; return node; } public void connectionLost(SocketAddress sa) { // Don't care. } <|startfocus|> public String toString() { return connFactory.toString(); } <|endfocus|> } 
<|startcomment|> misspelling <|endcomment|>  System.out.println(" Default values: REST-port: 8091"); System.out.println(" bucketsSpec: default:"); System.out.println(" #nodes: 100"); System.out.println(" #vbuckets: 4096"); System.out.println("Buckets descriptions is a comma-separated list of {name}:{password} pairs. " <|startfocus|> + "To allow unauthrized connections, omit password after colon. E.g.\n" <|endfocus|> + " default:,test:,protected:secret"); System.exit(0); } } try { if (port == 0) { ServerSocket server = new ServerSocket(0); port = server.getLocalPort(); server.close(); } CouchbaseMock mock = new CouchbaseMock(hostname, port, nodes, vbuckets, BucketType.BASE, bucketsSpec); if (harakirimonitor != null) { mock.setupHarakiriMonitor(harakirimonitor); } mock.start(); } catch (Exception e) { Logger.getLogger(CouchbaseMock.class.getName()).log(Level.SEVERE, "Fatal error! failed to create socket: ", e); }
<|startcomment|> remove this comment, since it just tells us what the next line is. <|endcomment|>  } else if (vbnodesMap.containsKey(hostname)) { vbnodesMap.put(hostname, node); getLogger().debug("Adding node with hostname %s.", hostname); getLogger().debug("Node added is %s.", node); } } // Iterate over the map and check for entries not populated for (Map.Entry<String, MemcachedNode> entry : vbnodesMap.entrySet()) { if (entry.getValue() == null) { <|startfocus|> // Log a critical error and remove the key from the map getLogger().error("Critical reconfiguration error for %s", <|endfocus|> entry.getKey()); vbnodesMap.remove(entry.getKey()); } } return Collections.unmodifiableMap(vbnodesMap); } /** * Method returns the node that is not contained in the specified collection * of the failed nodes. * * @param k the key * @param notMyVbucketNodes a collection of the nodes are excluded * @return The first MemcachedNode which meets requirements */ public MemcachedNode getAlternative(String k,
<|startcomment|> Is it really possible to have a bucket without any server? <|endcomment|>  public void execute(CouchbaseMock mock, List<String> tokens) { extractParams(tokens); <|startfocus|> Map<MemcachedServer,Boolean> servers_set = new HashMap<MemcachedServer,Boolean>(); for (Bucket bucket : mock.buckets.values()) { if (bucket.getServers() == null) { <|endfocus|> continue; } for (MemcachedServer server : bucket.getServers()) { if (server == null) { continue; } if (servers_set.containsKey(server) == false) { doServerCommand(server); servers_set.put(server, true); } } } 
<|startcomment|> The compiler may take care of it for you, but a switch would usually be more efficient. <|endcomment|>  * The operation was canceled by the client. */ CANCELLED((byte) 0xF1), /** * THIS IS A CLIENT SPECIFIC ERROR CODE. * The operation was timed out in the client. */ TIMED_OUT((byte) 0xF2), /** * Client threw exception cause operation failure. */ EXCEPTION((byte) 0xF3); private final byte error; ErrorCode(byte err) { error = err; } <|startfocus|> public static ErrorCode getErrorCode(byte b) { <|endfocus|> if (b == ErrorCode.SUCCESS.error) { return ErrorCode.SUCCESS; } else if (b == ErrorCode.ERR_NOT_FOUND.error) { return ErrorCode.ERR_NOT_FOUND; } else if (b == ErrorCode.ERR_EXISTS.error) { return ErrorCode.ERR_EXISTS; } else if (b == ErrorCode.ERR_2BIG.error) { return ErrorCode.ERR_2BIG; } else if (b == ErrorCode.ERR_INVAL.error) { return ErrorCode.ERR_INVAL;
<|startcomment|> javadoc? <|endcomment|>  public CouchbaseCache(String name, String hostname, String bucket, String password) throws URISyntaxException, IOException { this.name = name; URI local = new URI(String.format("http://%s:8091/pools", hostname)); List<URI> baseURIs = new ArrayList<URI>(); baseURIs.add(local); CouchbaseConnectionFactoryBuilder cfb = new CouchbaseConnectionFactoryBuilder(); c = new CouchbaseClient(cfb.buildCouchbaseConnection(baseURIs, bucket, password)); tapClient = new TapClient(baseURIs, bucket, password); clear(); } <|startfocus|> <|endfocus|> @Override public void clear() { try { tapClient.tapDump(""); } catch (IOException ex) { Logger.getLogger(CouchbaseCache.class.getName()).log(Level.SEVERE, null, ex); } catch (ConfigurationException ex) { Logger.getLogger(CouchbaseCache.class.getName()).log(Level.SEVERE, null, ex); } while(tapClient.hasMoreMessages()) { ResponseMessage response = tapClient.getNextMessage(); if (response != null) { c.delete(response.getKey()); } } } @Override
<|startcomment|> Some red markers here... <|endcomment|>  public void execute(BinaryCommand cmd, MemcachedServer server, MemcachedConnection client) { Item item = server.getDatastore().get(server, cmd.getVBucketId(), cmd.getKey()); ErrorCode ec; if (item == null) { ec = ErrorCode.KEY_ENOENT; } else if (!item.isLocked()) { ec = ErrorCode.ETMPFAIL; } else if (!item.ensureUnlocked(cmd.getCas())) { ec = ErrorCode.ETMPFAIL; } else { ec = ErrorCode.SUCCESS; } <|startfocus|> <|endfocus|> client.sendResponse(new BinaryResponse(cmd, ec));
<|startcomment|> never used? <|endcomment|>  * limitations under the License. */ package org.couchbase.mock.harakiri; import com.google.gson.Gson; import com.google.gson.JsonObject; import java.lang.reflect.InvocationTargetException; import java.util.*; import org.couchbase.mock.CouchbaseMock; import org.couchbase.mock.control.*; /** * * @author Mark Nunberg */ public class HarakiriDispatcher { public enum PayloadFormat { JSON, PLAIN }; <|startfocus|> public final static Gson gs = new Gson(); public static final Map<String,Class> commandMap = new HashMap<String, Class>(); static private Map<HarakiriCommand.Command, Class> classMap <|endfocus|> = new EnumMap<HarakiriCommand.Command, Class>(HarakiriCommand.Command.class); protected static void registerClass(HarakiriCommand.Command cmd, Class cls) { if (!HarakiriCommand.class.isAssignableFrom(cls)) { throw new RuntimeException("Can process only HarakiriMonitor objects"); } String commandName = cmd.toString().toUpperCase(); commandMap.put(commandName, cls); classMap.put(cmd, cls); } static { registerClass(HarakiriCommand.Command.HICCUP, HiccupCommandHandler.class);
<|startcomment|> this means DEBUG includes PERFORMANCE? this may be a bit ambiguious. That seems to be what you mean though? <|endcomment|>  /** * No metrics collection. * * If the "OFF" type is chosen, no metrics will be registered * and collected. */ OFF, /** * Metrics useful for performance-related tracing. * * These metrics provide insight into the application performance * and show how the operations flow in and out of the library. */ PERFORMANCE, /** * Metrics useful for debugging. * <|startfocus|> * These metrics (in addition to the "PERFORMANCE" metrics) provide <|endfocus|> * more insight into the state of the library (for example node states), * but it comes with larger aggregation overhead. Use during development * and debug sessions. */ DEBUG } 
<|startcomment|> typo herel. Signals. <|endcomment|>  * * @see net.spy.memcached.internal.BulkFuture#isTimeout() */ public boolean isTimeout() { return timeout; } @Override public Future<Map<String, T>> addListener( BulkGetCompletionListener listener) { super.addToListeners((GenericCompletionListener) listener); return this; } @Override public Future<Map<String, T>> removeListener( BulkGetCompletionListener listener) { super.removeFromListeners((GenericCompletionListener) listener); return this; } /** <|startfocus|> * Signas that this future is complete. <|endfocus|> */ public void signalComplete() { notifyListeners(); } } 
<|startcomment|> I think your IDE did this again. <|endcomment|> import net.spy.memcached.ops.KeyedOperation; import net.spy.memcached.ops.MultiGetOperationCallback; import net.spy.memcached.ops.Mutator; import net.spy.memcached.ops.MutatorOperation; import net.spy.memcached.ops.NoopOperation; import net.spy.memcached.ops.Operation; import net.spy.memcached.ops.OperationCallback; import net.spy.memcached.ops.SASLAuthOperation; import net.spy.memcached.ops.SASLMechsOperation; import net.spy.memcached.ops.SASLStepOperation; import net.spy.memcached.ops.StatsOperation; import net.spy.memcached.ops.StoreOperation; import net.spy.memcached.ops.StoreType; <|startfocus|> import net.spy.memcached.ops.TapOperation; <|endfocus|> import net.spy.memcached.ops.VersionOperation; import net.spy.memcached.tapmessage.TapOpcode; import net.spy.memcached.tapmessage.RequestMessage; /** * Operation factory for the ascii protocol. */ public class AsciiOperationFactory extends BaseOperationFactory { public DeleteOperation delete(String key, OperationCallback cb) { return new DeleteOperationImpl(key, cb); } public FlushOperation flush(int delay, OperationCallback cb) { return new FlushOperationImpl(delay, cb); } public GetAndTouchOperation getAndTouch(String key, int expiration, GetAndTouchOperation.Callback cb) {
<|startcomment|> please put the imports in the import section and relative ones here like the others. <|endcomment|>  * * Always apply a {@link Observable#timeout(long, TimeUnit)} of some form to add a boundary between the SDK as an * integration point and the application. Networks are unreliable, servers can fail and the SDK contains bugs. With applying * a timeout and reacting to them accordingly, application level code is less likely to fail. * <|startfocus|> * Note that a {@link #isClosed() closed} Bucket will throw {@link com.couchbase.client.java.error.BucketClosedException} * if any more attempts to use it are made. * <|endfocus|> * @author Michael Nitschinger * @since 2.0 */ @InterfaceStability.Committed @InterfaceAudience.Public public interface AsyncBucket { /** * The name of the {@link Bucket}. * * @return the name of the bucket. */ String name(); /** * Retrieves a {@link JsonDocument} by its unique ID. * * If the document is found, a {@link JsonDocument} is returned. If the document is not found, the
<|startcomment|> do we need to make this thread safe of some form (including the getObject()) <|endcomment|>  * <bean class="net.rubyeye.xmemcached.transcoders.SerializingTranscoder"/> * <property name="hashAlg" value="${pajamas.client.hashAlg}"/> * <property name="locatorType" value="${pajamas.client.locatorType}"/> * } * </pre> * </p> * * @author Eran Harel */ @SuppressWarnings("rawtypes") public class MemcachedClientFactoryBean implements FactoryBean { private final ConnectionFactoryBuilder connectionFactoryBuilder = new ConnectionFactoryBuilder(); private String servers; <|startfocus|> private MemcachedClient instance; <|endfocus|> @Override public Object getObject() throws Exception { if(instance == null) { instance = new MemcachedClient(connectionFactoryBuilder.build(), AddrUtil.getAddresses(servers)); } return instance; } @Override public Class<?> getObjectType() { return MemcachedClient.class; } @Override public boolean isSingleton() { return true; } public void shutdown() { if(instance != null) { instance.shutdown(); } } public void setServers(final String newServers) { this.servers = newServers; } 
<|startcomment|> dcpEnabled not sslEnabled <|endcomment|>  sb.append(", requestBufferSize=").append(requestBufferSize); sb.append(", kvServiceEndpoints=").append(kvServiceEndpoints); sb.append(", viewServiceEndpoints=").append(viewServiceEndpoints); sb.append(", queryServiceEndpoints=").append(queryServiceEndpoints); sb.append(", ioPool=").append(ioPool.getClass().getSimpleName()); sb.append(", coreScheduler=").append(coreScheduler.getClass().getSimpleName()); sb.append(", packageNameAndVersion=").append(packageNameAndVersion); <|startfocus|> sb.append(", dcpEnabled=").append(sslEnabled); <|endfocus|> sb.append('}'); return sb.toString();
<|startcomment|> missing 202 here (see ConfigHandler)? <|endcomment|>  public static ResponseStatus fromHttp(final int code) { ResponseStatus status; switch (code) { case HTTP_OK: <|startfocus|> case HTTP_CREATED: <|endfocus|> status = ResponseStatus.SUCCESS; break; case HTTP_NOT_FOUND: status = ResponseStatus.NOT_EXISTS; break; default: status = ResponseStatus.FAILURE; } return status;
<|startcomment|> this is more commonly done as a `flatMap` (use lambda notation for shorter code, just reuse the same anonymous class): open(name, aggregatorState) .flatMap(response -> response.stream()) <|endcomment|>  public Observable<DCPRequest> feed(final String name, final BucketStreamAggregatorState aggregatorState) { return Observable.merge(open(name, aggregatorState) .map(new Func1<StreamRequestResponse, Observable<DCPRequest>>() { @Override public Observable<DCPRequest> call(StreamRequestResponse response) { return response.stream(); } <|startfocus|> } )); <|endfocus|>
<|startcomment|> this makes me wonder: does the local "extras" buffer serve any purpose? why not directly readLong on extraReleased? @michael any insight? <|endcomment|>  bySeqno = extras.readLong(); revSeqno = extras.readLong(); flags = extras.readInt(); expiration = extras.readInt(); lockTime = extras.readInt(); extras.release(); } request = new MutationMessage(msg.getStatus(), msg.getKey(), msg.content().retain(), expiration, bySeqno, revSeqno, flags, lockTime, msg.getCAS(), connection.bucket()); break; case OP_REMOVE: if (msg.getExtrasLength() > 0) { <|startfocus|> final ByteBuf extrasReleased = msg.getExtras(); final ByteBuf extras = ctx.alloc().buffer(msg.getExtrasLength()); extras.writeBytes(extrasReleased, extrasReleased.readerIndex(), extrasReleased.readableBytes()); <|endfocus|> bySeqno = extras.readLong(); revSeqno = extras.readLong(); extras.release(); } request = new RemoveMessage(msg.getStatus(), msg.getKey(), msg.getCAS(), bySeqno, revSeqno, connection.bucket()); break; case OP_STREAM_END: final ByteBuf extrasReleased = msg.getExtras();
<|startcomment|> any reason values and constructor are protected and not private? <|endcomment|> kage com.couchbase.client.java.document.subdoc; import com.couchbase.client.core.annotations.InterfaceAudience; import com.couchbase.client.core.annotations.InterfaceStability; import com.couchbase.client.core.message.ResponseStatus; import com.couchbase.client.core.message.kv.subdoc.multi.Lookup; /** * A result corresponding to a single {@link LookupSpec}, usually grouped inside a {@link MultiLookupResult}. * * @author Simon Basl * @since 2.2 */ @InterfaceStability.Experimental @InterfaceAudience.Public public class LookupResult { <|startfocus|> protected final String path; protected final Lookup operation; <|endfocus|> protected final ResponseStatus status; protected final Object value; /** * Create a new LookupResult. * * @param path the path that was looked up in a document. * @param operation the kind of lookup that was performed. * @param status the status for this lookup. * @param value the value for a successful GET, true/false for a EXIST, an Exception in case of FAILURE, null otherwise. */
<|startcomment|> I would keep that out of this method, and instead do the retryOrCancel in the if block above (line 277), as this is a side effect and the method could be reused later on, not expecting a retry to be scheduled <|endcomment|>  private static boolean handleNotEqualNodeSizes(int configNodeSize, int actualNodeSize, final BinaryRequest request, CoreEnvironment env, RingBuffer<ResponseEvent> responseBuffer) { if (configNodeSize != actualNodeSize) { if (LOGGER.isDebugEnabled()) { LOGGER.debug("Node list and configuration's partition hosts sizes : {} <> {}, rescheduling", actualNodeSize, configNodeSize); } <|startfocus|> RetryHelper.retryOrCancel(env, request, responseBuffer); <|endfocus|> return true; } return false;
<|startcomment|> does this need to be public? <|endcomment|> <|startfocus|> public void checkRange(String name, String start, String end) { <|endfocus|> if (name == null) { throw new NullPointerException("Cannot create date range without a name"); } if (start == null && end == null) { throw new NullPointerException("Cannot create date range without start nor end"); }
<|startcomment|> There could be more than one of these, correct? Do we need more trace identification information? <|endcomment|>  public DCPConnection(final CoreEnvironment env, final ClusterFacade core, final String bucket, final String password) { this(env, core, bucket, password, UnicastAutoReleaseSubject.<DCPRequest>create(env.autoreleaseAfter(), TimeUnit.MILLISECONDS, env.scheduler()) <|startfocus|> .withTraceIdentifier("DCPConnection") <|endfocus|> .toSerialized());
<|startcomment|> no observable here, also there are more exceptions that can happen, right? like timeouts? also backpressue and request cancelled <|endcomment|>  /** * Synchronously perform a N1QL query that can span multiple buckets, with the default * {@link CouchbaseEnvironment#queryTimeout() timeout}. * * The query will use any credential set through this cluster's {@link #authenticate(Authenticator) Authenticator}. * In order to use that method, at least one {@link Bucket} must currently be opened. * <|startfocus|> * The Observable can fail in the following notable conditions: * - {@link UnsupportedOperationException}: no bucket is currently opened. <|endfocus|> * * @param query the {@link N1qlQuery} to execute. * @return the {@link N1qlQueryResult query result}. */ N1qlQueryResult query(N1qlQuery query); /** * Synchronously perform a N1QL query that can span multiple buckets, with a custom timeout. * * The query will use any credential set through this cluster's {@link #authenticate(Authenticator) Authenticator}. * In order to use that method, at least one {@link Bucket} must currently be opened.
<|startcomment|> same here <|endcomment|>  public E call(DocumentFragment<Lookup> documentFragment) { ResponseStatus status = documentFragment.status(0); if (status == ResponseStatus.SUCCESS) { return (E) documentFragment.content(0); } else { <|startfocus|> if (status == ResponseStatus.SUBDOC_PATH_NOT_FOUND) { throw new PathNotFoundException("Index not found in list"); } else { throw new CouchbaseException(status.toString()); } <|endfocus|> }
<|startcomment|> nit: just call reset() ? <|endcomment|>  public JsonStringByteBufProcessor() { <|startfocus|> this.currentState = State.UNESCAPED; <|endfocus|>
<|startcomment|> private final probably? <|endcomment|> <|startfocus|> public String password; <|endfocus|> public Credential(String username, String password) { this.username = username; this.password = password;
<|startcomment|> License? <|endcomment|> <|startfocus|> kage com.couchbase.client.dcp; <|endfocus|> import com.couchbase.client.deps.io.netty.buffer.ByteBuf; public interface DcpAckHandle { void ack(ByteBuf message); } 
<|startcomment|> pretty sure they need to be volatile, right? <|endcomment|>  private final long creationTime; /** * Additional subscriber information to check if the request has timed out */ <|startfocus|> private Subscriber subscriber; <|endfocus|> private volatile int retryCount; private volatile long retryAfter; private volatile long maxRetryDuration; private Delay retryDelay; /**
<|startcomment|> assertEquals(ResponseStatus.SUCCESS, response.status()); so the test fails correctly when built-in assertions are not enabled. Ditto the other usages of "assert" later in the code. <|endcomment|>  ReferenceCountUtil.releaseLater(fragment); SubDictAddRequest insertRequest = new SubDictAddRequest("shouldAddDocumentIfSet", subPath, fragment, bucket()); insertRequest.createDocument(true); SimpleSubdocResponse insertResponse = cluster().<SimpleSubdocResponse>send(insertRequest).toBlocking().single(); ReferenceCountUtil.releaseLater(insertResponse.content()); assertTrue(insertResponse.status().isSuccess()); RemoveResponse response = cluster().<RemoveResponse>send(new RemoveRequest("shouldAddDocumentIfSet", bucket())).toBlocking().single(); <|startfocus|> assert(response.status() == ResponseStatus.SUCCESS); <|endfocus|>
<|startcomment|> Since this c'tor is for testing, would it make sense for it to be package protected? <|endcomment|> <|startfocus|> public KeyValueSelectBucketHandler(String bucket, boolean selectBucketEnabled) { <|endfocus|> this.bucket = bucket; this.selectBucketEnabled = selectBucketEnabled;
<|startcomment|> if this isn't expected frequently, make it warn. This way we will know if a problem happens because of it. <|endcomment|>  private void handleFailoverLogResponse(ByteBuf buf) { short vbid = channel.getVbuckets().remove(MessageUtil.getOpaque(buf)); short status = MessageUtil.getStatus(buf); switch (status) { case 0x00: LOGGER.debug("Failover Log retrieved successfully for vbucket " + vbid); handleFailoverLogResponseSuccess(buf, vbid); break; case 0x07: <|startfocus|> LOGGER.debug("Failover Log not my vbucket response for vbucket " + vbid); <|endfocus|> break; default: LOGGER.warn("Failover Log unknown response (" + status + ")for vbucket " + vbid); }
<|startcomment|> NIT: Prefer declaring the test method as "throws Exception" and *not* catching it (so JUnit shows the stack trace, etc) <|endcomment|>  public void shouldLogValueIfNotDecodable() { String invalidValue = "{\"invalid:true}"; DefaultAsyncN1qlQueryRow row = new DefaultAsyncN1qlQueryRow(invalidValue.getBytes(CharsetUtil.UTF_8)); try { row.value(); fail("did expect transcoding exception"); } catch (TranscodingException ex) { assertEquals( "Error deserializing row value from bytes to JsonObject \"{\"invalid:true}\"", ex.getMessage() ); <|startfocus|> } catch (Exception ex) { fail("did expect transcoding exception"); <|endfocus|> }
<|startcomment|> why? <|endcomment|>  ctx.disconnect(promise); } @Override public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception { ctx.close(promise); } @Override public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception { ctx.deregister(promise); } @Override public void read(ChannelHandlerContext ctx) throws Exception { ctx.read(); } @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { <|startfocus|> ctx.read(); <|endfocus|> } @Override public void flush(ChannelHandlerContext ctx) throws Exception { ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { if (originalPromise != null) { originalPromise.setFailure(cause); } ctx.fireExceptionCaught(cause); } } 
<|startcomment|> This test failed on our build machine, presumably since map iteration order is undefined and can change between Java versions. The test will need to be insensitive to changes in the order of the assignment clauses. <|endcomment|>  .put("string", "string") .put("int", 10) .put("boolean", true) .put("double", 10.1) .put("long", 10L); write(object); verify(bucket).query(argument.capture()); ParameterizedN1qlQuery query = (ParameterizedN1qlQuery) argument.getValue(); <|startfocus|> assertEquals("UPDATE `default` USE KEYS \"id\" SET boolean = $boolean, string = $string, double = $double, int = $int, long = $long RETURNING meta().id;", <|endfocus|> query.statement().toString()); assertEquals(object.toString(), query.statementParameters().toString());
<|startcomment|> you may use Objects.nonNull or something like that <|endcomment|>  * @param clusterAt * seed nodes. * @return this {@link Builder} for nice chainability. */ public Builder clusterAt(InetSocketAddress... clusterAt) { return clusterAt(Arrays.asList(clusterAt)); } /** * The uuid of the bucket * * @param uuid * the bucket uuid * @return this {@link Builder} for nice chainability. */ public Builder uuid(String uuid) { <|startfocus|> if (uuid == null) { throw new NullPointerException(); } <|endfocus|> this.uuid = uuid; return this; } public String uuid() { return this.uuid; } /** * Whether the addresses of configuration providers should be dynamic * * @param dynamicConfigurationNodes * @return this {@link Builder} for nice chainability. */ public Builder dynamicConfigurationNodes(boolean dynamicConfigurationNodes) { this.dynamicConfigurationNodes = dynamicConfigurationNodes; return this; } public boolean dynamicConfigurationNodes() { return this.dynamicConfigurationNodes; } /**
<|startcomment|> Minor style-nit: I prefer these to be one line: /** The only instance of FSAccess. */ <|endcomment|>  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.util.fs; import java.io.File; import org.eclipse.jgit.util.FS; /** * Abstraction of file system access functions */ public abstract class FSAccess { private static Throwable nativeLoadError; <|startfocus|> /** * The only instance */ <|endfocus|> public final static FSAccess INSTANCE; static { FSAccess fsa = null; try { fsa = new FSAccessNative(); } catch (IllegalArgumentException e) { nativeLoadError = e; } catch (SecurityException e) { nativeLoadError = e; } // fall back to (slower) Java implementation if native implementation is // not available if (fsa == null) { fsa = new FSAccessJava(); } INSTANCE = fsa; } /** * @return the loading exception in case loading the native implementation * failed */
<|startcomment|> this formatting change looks unnecessary <|endcomment|>  public void addPages() { String pageTitle = UIText.GitCreatePatchWizard_SelectLocationTitle; String pageDescription = UIText.GitCreatePatchWizard_SelectLocationDescription; locationPage = new LocationPage(pageTitle, pageTitle, UIIcons.WIZBAN_CREATE_PATCH); locationPage.setDescription(pageDescription); addPage(locationPage); pageTitle = UIText.GitCreatePatchWizard_SelectOptionsTitle; pageDescription = UIText.GitCreatePatchWizard_SelectOptionsDescription; <|startfocus|> optionsPage = new OptionsPage(pageTitle, pageTitle, UIIcons.WIZBAN_CREATE_PATCH); <|endfocus|> optionsPage.setDescription(pageDescription); addPage(optionsPage);
<|startcomment|> externalize string ? <|endcomment|>  protected RepositorySelection getRepositorySelection() { try { return (new RepositorySelection(new URIish(currentSearchResult.getGitRepositoryInfo().getCloneUri()), null)); } catch (URISyntaxException e) { <|startfocus|> Activator.error("URI can't be parsed", e); //$NON-NLS-1$ <|endfocus|> return null; }
<|startcomment|> this can be final <|endcomment|>  return; addCloneSourceProvider(cloneSourceProvider, config, myIndex); } /** * Encapsulates a clone source provided by an extension of the extension * point "org.eclipse.egit.ui.cloneSourceProvider" */ public static class CloneSourceProvider { /** * The constant provider for used for local repositories */ public static final CloneSourceProvider LOCAL = new CloneSourceProvider( "Local", null, null, true); //$NON-NLS-1$ private String label; <|startfocus|> private IConfigurationElement repositoryServerProviderElement; <|endfocus|> private IConfigurationElement repositorySearchPageELement; private boolean hasFixLocation = false; private CloneSourceProvider(String label, IConfigurationElement repositoryServerProviderElement, IConfigurationElement repositorySearchPageElement, boolean hasFixLocation) { this.label = label; this.repositoryServerProviderElement = repositoryServerProviderElement; this.repositorySearchPageELement = repositorySearchPageElement; this.hasFixLocation = hasFixLocation; } /** * @return label the human readable name of a type of servers which * contains repositories */ public String getLabel() { return label; } /**
<|startcomment|> I would add a blank line above this one <|endcomment|>  } /** * @return the config section */ public String getSection() { return section; } /** * @return the config sub section */ public String getSubsection() { return subsection; } /** * @return the name of the config parameter */ public String getName() { return name; } /** * @return the value of the config parameter */ public String getValue() { return value; } <|startfocus|> } <|endfocus|> private final List<RepositoryConfigProperty> repositoryConfigProperties = new ArrayList<RepositoryConfigProperty>(); /** * @param cloneUri * the URI where the repository can be cloned from */ public GitRepositoryInfo(String cloneUri) { this.cloneUri = cloneUri; } /** * @return the URI where the repository can be cloned from */ public String getCloneUri() { return cloneUri; } /** * @param user * @param password */
<|startcomment|> I would rather check all configured remotes not only default one. <|endcomment|>  private boolean repositoryAlreadyExistsForUrl(File repositoryPath, URIish gitUrl) { if (repositoryPath.exists()) { try { FileRepository existingRepository = new FileRepository( repositoryPath); <|startfocus|> String remoteUrl = existingRepository.getConfig().getString( ConfigConstants.CONFIG_REMOTE_SECTION, Constants.DEFAULT_REMOTE_NAME, ConfigConstants.CONFIG_KEY_URL); <|endfocus|> existingRepository.close(); URIish existingUrl = new URIish(remoteUrl); if (existingUrl.equals(gitUrl)) { return true; } } catch (IOException e) { return false; } catch (URISyntaxException e) { return false; } } return false;
<|startcomment|> s/list of checked in commits/list of commits/ <|endcomment|> import java.util.Map; import org.eclipse.compare.structuremergeviewer.Differencer; import org.eclipse.jgit.lib.AbbreviatedObjectId; import org.eclipse.jgit.lib.MutableObjectId; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevFlag; import org.eclipse.jgit.revwalk.RevFlagSet; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.treewalk.TreeWalk; import org.eclipse.jgit.treewalk.filter.TreeFilter; /** <|startfocus|> * Retrieves list of checked in commits and changes associated with each commit <|endfocus|> */ public class GitCommitsModelCache { /** * Corresponds to {@link RevCommit} object, but contains only those data * that are required by Synchronize view Change Set */ public static class Commit { private int direction; private String shortMessage; private AbbreviatedObjectId commitId; private Date commitDate; private String authorName; private String committerName; private Map<String, Change> children; private Commit() { // reduce the visibility of the default constructor } /**
<|startcomment|> this keyword not needed <|endcomment|>  public CleanCommand setCleanDirectories(boolean dirs) { <|startfocus|> this.directories = dirs; <|endfocus|> return this;
<|startcomment|> curlies not needed here <|endcomment|>  public Set<String> call() { Set<String> files = new TreeSet<String>(); try { StatusCommand command = new StatusCommand(repo); Status status = command.call(); Set<String> filtered = filterUntrackedFolders( status.getUntracked(), status.getUntrackedFolders()); <|startfocus|> for (String file : filtered) { <|endfocus|> if (paths.isEmpty() || paths.contains(file)) { if (!dryRun) FileUtils.delete(new File(repo.getWorkTree(), file)); files.add(file); } } if (directories) for (String dir : status.getUntrackedFolders()) if (paths.isEmpty() || paths.contains(dir)) { if (!dryRun) FileUtils.delete(new File(repo.getWorkTree(), dir), FileUtils.RECURSIVE); files.add(dir + "/"); } } catch (IOException e) { throw new JGitInternalException(e.getMessage(), e); } return files;
<|startcomment|> Can you add "PREFIX +" to the string value? <|endcomment|>  /** * The value is an boolean specifying whether the timeout is used for GDB commands. * @since 4.1 */ public static final String PREF_COMMAND_TIMEOUT = "commandTimeout"; //$NON-NLS-1$ /** * The value is an integer specifying the timeout value (milliseconds) for GDB commands. * @since 4.1 */ <|startfocus|> public static final String PREF_COMMAND_TIMEOUT_VALUE = "commandTimeoutValue"; //$NON-NLS-1$ <|endfocus|> /** * The value is a string specifying the list of GDB/MI commands with custom timeout values. * @since 4.1 */ public static final String PREF_COMMAND_CUSTOM_TIMEOUTS = "commandTimeoutSpecials"; //$NON-NLS-1$ /** * Default default value for <code>PREF_COMMAND_TIMEOUT</code>; * @since 4.1 */ public static final int COMMAND_TIMEOUT_VALUE_DEFAULT = 10000; /** * Help prefixes. */ public static final String PREFIX = GdbPlugin.PLUGIN_ID + "."; //$NON-NLS-1$ } 
<|startcomment|> There should be some kind of while loop here to allow doRun() to switch between HALTED and RUNNING. The current scheme has a potentially memory exhausting trace of doRun()->halted()->doRun()->running()->doRun()->etc... <|endcomment|>  private void doRun() { <|startfocus|> if ( fState == TimerThreadState.HALTED ) { halted(); <|endfocus|> } else { running(); }
<|startcomment|> Remove this line since it does add any value. <|endcomment|>  MapProblemPreference preferences = (MapProblemPreference) problem.getPreference(); settings.updateValuesFrom(preferences); } private ErrorParserManager createErrorParserManager(InvocationParameters parameters) { IProject project = parameters.getActualFile().getProject(); URI workingDirectory = URIUtil.toURI(parameters.getWorkingDirectory()); return new ErrorParserManager(project, workingDirectory, this, getParserIDs(), CODAN); } /** <|startfocus|> * Returns the IDs of the parsers to use to parse the output of the external tool. <|endfocus|> * @return the IDs of the parsers to use to parse the output of the external tool. */ protected abstract String[] getParserIDs(); /** * Handles a failure reported when invoking the external tool. This implementation simply * logs the failure. * @param error the reported failure. * @param parameters the parameters passed to the external tool executable. */ protected void handleInvocationFailure(InvocationFailure error, InvocationParameters parameters) { logResourceProcessingFailure(error, parameters.getActualFile()); } private void logResourceProcessingFailure(Throwable error, IResource resource) {
<|startcomment|> Please replace StringTokenizer with simple iteration over characters. <|endcomment|>  public String[] splitArguments(String s) { if (s == null || s.isEmpty()) { return NO_ARGS; } <|startfocus|> int state = NORMAL; String delimiter = DOUBLE_QUOTE + SINGLE_QUOTE + SPACE; StringTokenizer tokenizer = new StringTokenizer(s, delimiter, true); List<String> args = new ArrayList<String>(); <|endfocus|> StringBuilder current = new StringBuilder(); boolean lastTokenInQuotes = false; while (tokenizer.hasMoreTokens()) { String token = tokenizer.nextToken(); switch (state) { case IN_SINGLE_QUOTE: if (SINGLE_QUOTE.equals(token)) { lastTokenInQuotes = true; state = NORMAL; } else { current.append(token); } break; case IN_DOUBLE_QUOTE: if (DOUBLE_QUOTE.equals(token)) { lastTokenInQuotes = true; state = NORMAL; } else { current.append(token); } break; default: if (SINGLE_QUOTE.equals(token)) { state = IN_SINGLE_QUOTE; } else if (DOUBLE_QUOTE.equals(token)) {
<|startcomment|> Please make it more symmetrical. Option 1: BUILD = 1 << 0; CODAN = 1 << 1; Option 2: BUILD = 0x01; CODAN = 0x02; Option 2 makes debugging easier in my opinion. <|endcomment|>  * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Alex Ruiz (Google) - initial API and implementation *******************************************************************************/ package org.eclipse.cdt.core; /** * Indicates how <code>{@link org.eclipse.cdt.core.IErrorParser}</code>s are used. * * @since 5.4 */ public class ErrorParserContext { <|startfocus|> public static final int BUILD = 1; <|endfocus|> public static final int CODAN = 1 << 1; public static int getValue(String text) { if (text == null || text.isEmpty() || text.equals("build")) { //$NON-NLS-1$ return BUILD; } if (text.equals("codan")) { //$NON-NLS-1$ return CODAN; } throw new IllegalArgumentException("Unknown context value: " + text); //$NON-NLS-1$ } } 
<|startcomment|> Restore formatting. <|endcomment|>  marker = fErrors.get(0); fErrors.clear(); } } if (consume) break outer; } } outputLine(line, marker); return false; } /** * Conditionally output line to outputStream. If stream * supports error markers, use it, otherwise use conventional stream */ private void outputLine(String line, ProblemMarkerInfo marker) { String l = line + "\n"; //$NON-NLS-1$ <|startfocus|> if ( outputStream == null ) return; <|endfocus|> try { if ( marker != null && outputStream instanceof IErrorMarkeredOutputStream ) { IErrorMarkeredOutputStream s = (IErrorMarkeredOutputStream) outputStream; s.write(l, marker); } else { byte[] b = l.getBytes(); outputStream.write(b, 0, b.length); } } catch (IOException e) { CCorePlugin.log(e); } } /** * @return counter counting processed lines of output * @since 5.2 */ public int getLineCounter() { return lineCounter; } /**
<|startcomment|> Here also newWalk -> walk <|endcomment|> <|startfocus|> private TreeWalk createFileWalker(RevWalk newWalk, Repository db, List<FilterPath> paths) { <|endfocus|> final TreeWalk fileWalker = new TreeWalk(db); fileWalker.setRecursive(true); fileWalker.setFilter(TreeFilter.ANY_DIFF); if (store.getBoolean(UIPreferences.RESOURCEHISTORY_FOLLOW_RENAMES) && !paths.isEmpty() && allRegularFiles(paths)) { pathFilters = paths; List<String> selectedPaths = new ArrayList<String>(paths.size()); for (FilterPath filterPath : paths) selectedPaths.add(filterPath.getPath()); TreeFilter followFilter = createFollowFilterFor(selectedPaths); newWalk.setTreeFilter(followFilter); } else if (paths.size() > 0) { pathFilters = paths; List<String> stringPaths = new ArrayList<String>(paths.size()); for (FilterPath p : paths) stringPaths.add(p.getPath()); newWalk.setTreeFilter(AndTreeFilter.create(PathFilterGroup .createFromStrings(stringPaths), TreeFilter.ANY_DIFF)); } else { pathFilters = null; newWalk.setTreeFilter(TreeFilter.ALL); } return fileWalker;
<|startcomment|> trailing space <|endcomment|>  * Receive a pack from the input and store it in the repository. * * @throws IOException * an error occurred reading or indexing the pack. */ private void receivePack() throws IOException { // It might take the client a while to pack the objects it needs // to send to us. We should increase our timeout so we don't // abort while the client is computing. // if (timeoutIn != null) timeoutIn.setTimeout(10 * timeout * 1000); <|startfocus|> <|endfocus|> ProgressMonitor receiving = NullProgressMonitor.INSTANCE; ProgressMonitor resolving = NullProgressMonitor.INSTANCE; if (sideBand) resolving = new SideBandProgressMonitor(msgOut); ObjectInserter ins = db.newObjectInserter(); try { String lockMsg = "jgit receive-pack"; if (getRefLogIdent() != null) lockMsg += " from " + getRefLogIdent().toExternalString(); parser = ins.newPackParser(rawIn); parser.setAllowThin(true); parser.setNeedNewObjectIds(checkReferencedIsReachable); parser.setNeedBaseObjectIds(checkReferencedIsReachable);
<|startcomment|> I think this comment isn't necessary <|endcomment|>  remote = Constants.DEFAULT_REMOTE_NAME; // get the name of the branch in the remote repository // stored in configuration key branch.<branch name>.merge String remoteBranchName = repoConfig.getString( ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE); // determines whether rebase should be used after fetching boolean doRebase = false; switch (pullRebaseMode) { case REBASE: // use --rebase doRebase = true; break; case NO_REBASE: <|startfocus|> // use --no-rebase <|endfocus|> doRebase = false; break; case USE_CONFIG: default: // check if the branch is configured for pull-rebase doRebase = repoConfig.getBoolean( ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false); break; } if (remoteBranchName == null) { String missingKey = ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE; throw new InvalidConfigurationException(MessageFormat.format( JGitText.get().missingConfigurationForKey, missingKey)); } 
<|startcomment|> Curlies not needed <|endcomment|>  return; SWTCommit commit = (SWTCommit) item.getData(); if (commit == null || commit.getRefCount() == 0) return; int relativeX = e.x - item.getBounds().x; for (int i = 0; i < commit.getRefCount(); i++) { Ref ref = commit.getRef(i); Point textSpan = renderer.getRefHSpan(ref); if ((textSpan != null) <|startfocus|> && (relativeX >= textSpan.x && relativeX <= textSpan.y)) { <|endfocus|> showHover(ref, e); } } }
<|startcomment|> I'd rather say that this is related to bug 375111 - we should have an IArtifactRepository wrapper around remote artifact repositories that transparantly caches in the local Maven repository. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2009 David Green and others. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * David Green - initial API and implementation * Torkild U. Resheim - bugs 337405, 336592, 336683, 336813 *******************************************************************************/ package org.eclipse.mylyn.wikitext.core.parser.builder; import java.io.Writer; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import java.util.Stack; import java.util.TreeMap; import java.util.logging.Logger; import org.eclipse.mylyn.internal.wikitext.core.util.css.CssParser; import org.eclipse.mylyn.internal.wikitext.core.util.css.CssRule; import org.eclipse.mylyn.wikitext.core.parser.Attributes; import org.eclipse.mylyn.wikitext.core.parser.ImageAttributes; import org.eclipse.mylyn.wikitext.core.parser.ListAttributes;
<|startcomment|> Worth factoring this block into GitSmartHttpTools? <|endcomment|>  } finally { req.removeAttribute(ATTRIBUTE_HANDLER); } } public void init(FilterConfig filterConfig) throws ServletException { // Nothing. } public void destroy() { // Nothing. } } @Override public void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException { if (!UPLOAD_PACK_REQUEST_TYPE.equals(req.getContentType())) { rsp.sendError(SC_UNSUPPORTED_MEDIA_TYPE); return; } <|startfocus|> if (ClientVersionUtil.hasChunkedRequestBug(req)) { <|endfocus|> GitSmartHttpTools.sendError(req, rsp, SC_BAD_REQUEST, "\n\n" + HttpServerText.get().clientHas175ChunkedEncodingBug); return; } SmartOutputStream out = new SmartOutputStream(req, rsp) { @Override public void flush() throws IOException { doFlush(); } }; UploadPack up = (UploadPack) req.getAttribute(ATTRIBUTE_HANDLER); try { up.setBiDirectionalPipe(false); rsp.setContentType(UPLOAD_PACK_RESULT_TYPE); up.upload(getInputStream(req), out, null); out.close(); 
<|startcomment|> One more thing: I don't think "Fast" should be part of the method name. I'd rather name it just findContainer. <|endcomment|> <|startfocus|> public static IContainer findContainerFast(File file) { <|endfocus|> String absFile = file.getAbsolutePath(); IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot(); IProject[] allProjects = root.getProjects(); for (IProject prj : allProjects) if (checkContainerMatch(prj, absFile)) return prj; if (checkContainerMatch(root, absFile)) return root; return null;
<|startcomment|> Use Collection instead of Set? <|endcomment|> <|startfocus|> public static void removeBreakpoints(Set<IBreakpoint> set) { <|endfocus|> try { DebugPlugin.getDefault().getBreakpointManager().removeBreakpoints(set.toArray(new IBreakpoint[0]), true); } catch (CoreException e) { StatusHandler.log(new Status(IStatus.WARNING, Activator.PLUGIN_ID, "Could not remove obsolete breakpoints from workspace", e)); //$NON-NLS-1$ }
<|startcomment|> formatting change, avoid <|endcomment|>  public static String getClasspathVariableDeprecationMessage(String variableName) { JavaModelManager manager = JavaModelManager.getJavaModelManager(); // Returns the stored deprecation message String message = (String) manager.deprecatedVariables.get(variableName); if (message != null) { return message; } <|startfocus|> // If the variable has been already initialized, then there's no deprecation message <|endfocus|> IPath variablePath = manager.variableGet(variableName); if (variablePath != null && variablePath != JavaModelManager.VARIABLE_INITIALIZATION_IN_PROGRESS) { return null; } // Search for extension point to get the possible deprecation message Plugin jdtCorePlugin = JavaCore.getPlugin(); if (jdtCorePlugin == null) return null; IExtensionPoint extension = Platform.getExtensionRegistry().getExtensionPoint(JavaCore.PLUGIN_ID, JavaModelManager.CPVARIABLE_INITIALIZER_EXTPOINT_ID); if (extension != null) { IExtension[] extensions = extension.getExtensions(); for(int i = 0; i < extensions.length; i++){ IConfigurationElement [] configElements = extensions[i].getConfigurationElements(); for(int j = 0; j < configElements.length; j++){
<|startcomment|> If there is no TmfStatisticsViewer defined for the trace type we shouldn't create a default TmfStatisticsViewer because there will be redundant information in the global stats and trace specific stats. <|endcomment|>  */ ITmfStatisticsViewer viewer = new TmfStatisticsViewer(); viewer.init(folder, Messages.TmfStatisticsView_GlobalTabName, fExperiment); tabsView.addTab(viewer, defaultStyle); tabsView.setSelection(0); if (fExperiment != null) { String traceName; IResource traceResource; // Create a statistics viewer for each traces for (ITmfTrace trace : fExperiment.getTraces()) { traceName = trace.getName(); traceResource = trace.getResource(); viewer = TmfViewerFactory.getStatisticsViewer(traceResource); if (viewer == null) { <|startfocus|> // Creates a default statistics viewer if there is none defined for the trace type. <|endfocus|> viewer = new TmfStatisticsViewer(); } viewer.init(folder, traceName, trace); tabsView.addTab(viewer, defaultStyle); } } return tabsView;
<|startcomment|> \n <|endcomment|> import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.linuxtools.internal.tmf.ui.Activator; import org.eclipse.linuxtools.tmf.core.TmfCommonConstants; import org.eclipse.linuxtools.tmf.ui.project.model.TmfTraceType; import org.eclipse.linuxtools.tmf.ui.viewers.statistics.TmfStatisticsViewer; /** * Factory that creates a base class of TmfViewer from the definition of a trace * type viewer element in the plug-in.xml * * @author Mathieu Denis * @version 2.0 * @since 2.0 */ <|startfocus|> public class TmfViewerFactory { <|endfocus|> /** * Retrieves and instantiates a viewer based on his plug-in definition for a * specific trace type. * * The viewer is instantiated using its 0-argument constructor. * * @param resource * The resource where to find the information about the trace * properties * @param element * The name of the element to find under the trace type * definition * @return a new TmfViewer based on his definition in plugin.xml, or null if * no definition was found
<|startcomment|> Missing ~ <|endcomment|>  else flags &= ~DO_NOT_DELTA; } boolean isEdge() { return (flags & EDGE) != 0; } void setEdge() { flags |= EDGE; } boolean isAttemptDelta() { return (flags & ATTEMPT_DELTA_MASK) != ATTEMPT_DELTA_MASK; } boolean isDeltaAttempted() { return (flags & DELTA_ATTEMPTED) != 0; } void setDeltaAttempted(boolean deltaAttempted) { if (deltaAttempted) flags |= DELTA_ATTEMPTED; else <|startfocus|> flags &= DELTA_ATTEMPTED; <|endfocus|> } /** @return the extended flags on this object, in the range [0x0, 0xf]. */ protected int getExtendedFlags() { return (flags >>> EXT_SHIFT) & EXT_MASK; } /** * Determine if a particular extended flag bit has been set. * * This implementation may be faster than calling * {@link #getExtendedFlags()} and testing the result. * * @param flag * the flag mask to test, must be between 0x0 and 0xf.
<|startcomment|> style nit: we don't use braces around single line blocks <|endcomment|>  private ISchedulingRule calculateSchedulingRule() { Set<IContainer> containers = new HashSet<IContainer>(); for (IPath path : paths) { IResource resource = ResourceUtil.getResourceForLocation(path); <|startfocus|> if (resource != null) { <|endfocus|> containers.add(resource.getParent()); } } return new MultiRule(containers.toArray(new IResource[containers.size()]));
<|startcomment|> I think you can replace these 4 lines with: // Move the element to the end of the list remap.add(remap.remove(index)); <|endcomment|>  int index = -1; for (int i = 0; i < remap.size(); ++i) if (data.getColumnNames()[remap.get(i)].equals(column)) { index = i; break; } if (index == -1) return; <|startfocus|> int saved = remap.get(index); for (int i = index; i < remap.size()-1; ++i) remap.set(i, remap.get(i+1)); remap.set(remap.size()-1, saved); <|endfocus|> } public int getColumnCount() { return remap.size(); } public String getColumnName(int i) { return data.getColumnNames()[remap.get(i)]; } public boolean getColumnIsInteger(int j) { return columnIsInteger[j]; } @Override public String getColumnText(Object obj, int index) { return ((String[]) obj)[remap.get(index)]; } @Override public Image getColumnImage(Object obj, int index) { return getImage(obj); } @Override public Image getImage(Object obj) {
<|startcomment|> We could additionally also make this useful for PathNodes: IPath repoPath = getRepositoryPath(); List<IResource> resources = new ArrayList<IResource>(); ITreeSelection selection = (ITreeSelection) tree.getSelection(); for (Iterator it = selection.iterator(); it.hasNext();) { Object obj = it.next(); if (obj instanceof IResource) resources.add((IResource) obj); else if (obj instanceof PathNode && repoPath != null) { PathNode pathNode = (PathNode) obj; IResource resource = ResourceUtil.getResourceForLocation(repoPath.append(pathNode.path.toString())); if (resource != null) resources.add(resource); } } return new ShowInContext(null, new StructuredSelection(resources)); <|endcomment|>  .create(getSite().getWorkbenchWindow())); manager.appendToGroup(ICommonMenuConstants.GROUP_OPEN, showInSubMenu); } /* * @see org.eclipse.ui.part.IShowInSource#getShowInContext() * @since 2.1 */ public ShowInContext getShowInContext() { ITreeSelection selection = (ITreeSelection) tree.getSelection(); for (Iterator it = selection.iterator(); it.hasNext();) { if (!(it.next() instanceof IResource)) { return null; } } <|startfocus|> return new ShowInContext(null, selection); <|endfocus|> } private void createContextMenu() { MenuManager manager = new MenuManager("#PopupMenu"); //$NON-NLS-1$ manager.setRemoveAllWhenShown(true); manager.addMenuListener(this); Menu contextMenu = manager.createContextMenu(tree.getControl()); tree.getControl().setMenu(contextMenu); getSite().registerContextMenu(manager, tree); } private void openFileInEditor(String filePath) { IWorkbenchWindow window = PlatformUI.getWorkbench() .getActiveWorkbenchWindow(); File file = new File(filePath); if (!file.exists()) {
<|startcomment|> Need to use CommandFactory here too <|endcomment|>  public void getResourceClasses(final IDMContext dmc, final DataRequestMonitor<IResourceClass[]> rm) { IGDBControl control = getServicesTracker().getService(IGDBControl.class); if (control == null) { rm.done(new Status(IStatus.ERROR, GdbPlugin.PLUGIN_ID, INVALID_STATE, "Service not available", null)); //$NON-NLS-1$ return; } <|startfocus|> control.queueCommand(new MIInfoOs(dmc), new DataRequestMonitor<MIInfoOsInfo>(getExecutor(), rm) { <|endfocus|> @Override @ConfinedToDsfExecutor("fExecutor") protected void handleSuccess() { rm.setData(getData().getResourceClasses()); rm.done(); } });
<|startcomment|> typo: s/Interactliveley/Interactively/ <|endcomment|> <|startfocus|> public RebaseCommand runInteractliveley(InteractiveHandler handler) { <|endfocus|> this.interactiveHandler = handler; return this;
<|startcomment|> mark this as a TODO <|endcomment|>  public void widgetSelected(SelectionEvent e) { String description = fResourceClassCombo.getText(); String id = null; for (int i = 0; i < resourceClasses.length; ++i) if (resourceClasses[i].getHumanDescription().equals(description)) { id = resourceClasses[i].getId(); break; } // id is never null here, unless we messed up our data structures. <|startfocus|> if (!id.equals(fResourceClassId)) <|endfocus|> { fResourceClassId = id; getDialogSettings().put("resourceClass", id); //$NON-NLS-1$ if (fListener != null && !blockListener) fListener.resourceClassChanged(fResourceClassId); }
<|startcomment|> Strings like these should be externalized. You can look else where in the code base for examples of this. <|endcomment|>  * as the file name. The page will only accept file name without the extension * OR with the extension that matches the expected one (mpe). */ public class StapNewWizardPage extends WizardPage { private Text fileText; private Text containerText; private ISelection selection; /** * Constructor for StapNewWizardPage. * * @param pageName */ public StapNewWizardPage(ISelection selection) { <|startfocus|> super("wizardPage"); setTitle("Systemtap Script"); setDescription("This wizard creates a new systemtap script."); <|endfocus|> this.selection = selection; } /** * @see IDialogPage#createControl(Composite) */ public void createControl(Composite parent) { Composite container = new Composite(parent, SWT.NULL); GridLayout layout = new GridLayout(); container.setLayout(layout); layout.numColumns = 3; layout.verticalSpacing = 9; Label label = new Label(container, SWT.NULL); label.setText("&Script name:"); fileText = new Text(container, SWT.BORDER | SWT.SINGLE);
<|startcomment|> Interesting! but I don't think we should have this in the public API until it's actually needed. They can use getCallsiteCandidates().getFirst() already, it's not really more verbose... <|endcomment|>  * * @param eventName * the event name * @return the callsite list can be empty * @since 1.2 */ public List<CTFCallsite> getCallsiteCandidates(String eventName) { LinkedList<CTFCallsite> retVal = callsitesByName.get(eventName); if( retVal == null ) { retVal = new LinkedList<CTFCallsite>(); } return retVal; } /** * The I'm feeling lucky of getCallsiteCandidates O(1) * * @param eventName * the event name <|startfocus|> * @return the first callsite that has that event name, can be null <|endfocus|> * @since 1.2 */ public CTFCallsite getCallsite(String eventName) { return callsitesByName.get(eventName).getFirst(); } /** * Gets a callsite from the instruction pointer O(log(n)) * * @param ip * the instruction pointer to lookup * @return the callsite just before that IP in the list remember the IP is
<|startcomment|> Chunk size should depend on the trace cache size. <|endcomment|>  total = 0; } public long getResult() { return total; } @Override public void handleData(final ITmfEvent event) { super.handleData(event); if (event != null) { if (event.getTrace() == trace) { total += 1; } } } } /** * Event request to get the counts per event type */ private class StatsPerTypeRequest extends TmfEventRequest { <|startfocus|> private final static int chunkSize = 50000; <|endfocus|> /* Map in which the results are saved */ private final Map<String, Long> stats; public StatsPerTypeRequest(ITmfTrace trace, TmfTimeRange range) { super(trace.getEventType(), range, TmfDataRequest.ALL_DATA, chunkSize, ITmfDataRequest.ExecutionType.FOREGROUND); this.stats = new HashMap<String, Long>(); } public Map<String, Long> getResults() { return stats; } @Override public void handleData(final ITmfEvent event) { super.handleData(event); if (event != null) {
<|startcomment|> Missing a b in Babby ;) <|endcomment|>  "surprise", "umbrella", "anything", "anywhere", "baseball", "birthday", "bluebird", "cheerful", "colorful", "daylight", "doghouse", "driveway", "everyone" }; @SuppressWarnings("nls") private final String[] files = { "Adult.java", "Aeroplane.java", "Air.java", "Airforce.java", "Airport.java", "Album.java", <|startfocus|> "Alphabet.java", "Apple.java", "Arm.java", "Army.java", "Baby.java" }; <|endfocus|> Random rnd = new Random(); public static void main(String[] args) { new org.junit.runner.JUnitCore().run(CTFTraceCallsitePerformanceTest.class); } CTFTrace fTrace = null; @Before public void setup() throws CTFReaderException, SecurityException, IllegalArgumentException { fTrace = new CTFTrace(TestParams.getTraceFile().getParentFile()); } private void addCallsites(int numCallsites) { long stepSize = (Long.MAX_VALUE / (numCallsites + 1)); int jitter = (int) Math.min(stepSize, Integer.MAX_VALUE);
<|startcomment|> Cuddle catch with the closing curly on the prior line <|endcomment|>  buf.append("author A. U. Thor <a@example.com> 1 +0000\n"); buf.append("committer A. U. Thor <a@example.com> 1 +0000\n"); buf.append("\n"); buf.append(msg); final RevWalk walk = new RevWalk(db); walk.setRetainBody(true); final RevCommit c = new RevCommit(ObjectId.zeroId()); <|startfocus|> try { c.parseCanonical(walk, Constants.encode(buf.toString())); } catch (IOException ex) { fail(); } <|endfocus|> return c;
<|startcomment|> any reason why they are not private also? as in, "private static" :P <|endcomment|>  import static org.junit.Assert.*; import java.io.File; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.IOException; import org.eclipse.linuxtools.ctf.core.trace.CTFReaderException; import org.eclipse.linuxtools.ctf.core.trace.CTFTrace; import org.junit.Test; /** * @author Matthew Khouzam * */ public class IOstructgenTest { <|startfocus|> @SuppressWarnings("nls") static final String metadataDecs = "typealias integer { size = 8; align = 8; signed = false; } := uint8_t;\n" <|endfocus|> + "typealias integer { size = 16; align = 8; signed = false; } := uint16_t;\n" + "typealias integer { size = 32; align = 8; signed = false; } := uint32_t;\n" + "typealias integer { size = 64; align = 8; signed = false; } := uint64_t;\n" + "typealias integer { size = 64; align = 8; signed = false; } := unsigned long;\n"
<|startcomment|> style nit: these lines seem to be not properly formatted, they look too wide <|endcomment|>  private static String getShowInMenuLabel() { <|startfocus|> IBindingService bindingService = (IBindingService) PlatformUI.getWorkbench().getAdapter(IBindingService.class); <|endfocus|> if (bindingService != null) { String keyBinding = bindingService.getBestActiveBindingFormattedFor(IWorkbenchCommandConstants.NAVIGATE_SHOW_IN_QUICK_MENU); if (keyBinding != null) return UIText.UIUtils_ShowInMenuLabel + '\t' + keyBinding; } return UIText.UIUtils_ShowInMenuLabel;
<|startcomment|> I think this one should not be an else but an if statement as in previous version since you don't know if the participant e-mail was successfully resolved in which case you want to check of null and set it to empty string. PLease validate with LDAP as welll as no LDAP and for the default user as well as for any other user.  <|endcomment|>  if (null == fParticipant.getEmail() || fParticipant.getEmail().length() < 1) { fParticipant.setEmail(userInfo.getEmail()); } } } catch (NamingException e) { R4EUIPlugin.Ftracer.traceWarning("Exception: " + e.toString() + " (" + e.getMessage() + ")"); } catch (IOException e) { R4EUIPlugin.Ftracer.traceWarning("Exception: " + e.toString() + " (" + e.getMessage() + ")"); } <|startfocus|> } else { <|endfocus|> fParticipant.setEmail(""); //$NON-NLS-1$ } } 
<|startcomment|> Since we try to remove dependencies to EMF, we will have the EObjects still depending on EMF here !!! The other dependencies (EMap) should be clean from the code, no more dependencies here <|endcomment|>  * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Description: * * Contributors: * Alvaro Sanchez-Leon - Initial API and implementation * */ package org.eclipse.mylyn.reviews.r4e.core.model; import java.util.Map; import org.eclipse.core.resources.IResource; <|startfocus|> import org.eclipse.emf.common.util.EMap; <|endfocus|> import org.eclipse.emf.ecore.EObject; import org.eclipse.team.core.history.IFileRevision; /** * <!-- begin-user-doc --> A representation of the model object '<em><b>R4E File Version</b></em>'. <!-- end-user-doc * --> * <p> * The following features are supported: * <ul> * <li>{@link org.eclipse.mylyn.reviews.r4e.core.model.R4EFileVersion#getPlatformURI <em>Platform URI</em>}</li>
<|startcomment|> Overiden methods are not needed <|endcomment|>  * Created on Feb 9, 2012 * * PLACE_YOUR_DISTRIBUTION_STATEMENT_RIGHT_HERE */ package org.eclipse.osee.ats.api; import org.eclipse.osee.framework.core.data.HasDescription; import org.eclipse.osee.framework.core.data.Identifiable; /** * Base class to build all ats config and action objects on * * @author Donald G. Dunne */ public interface IAtsObject extends Identifiable, HasDescription { @Override public String getName(); @Override public String getGuid(); <|startfocus|> @Override public String getDescription(); public String getHumanReadableId(); public String toStringWithId(); <|endfocus|> } 
<|startcomment|> Loks like this unnecessary line was added by regenerating the model. Please remove <|endcomment|> import org.eclipse.mylyn.reviews.core.model.ILocation; import org.eclipse.mylyn.reviews.core.model.IModelVersioning; import org.eclipse.mylyn.reviews.core.model.IReview; import org.eclipse.mylyn.reviews.core.model.IReviewComponent; import org.eclipse.mylyn.reviews.core.model.IReviewGroup; import org.eclipse.mylyn.reviews.core.model.IReviewItem; import org.eclipse.mylyn.reviews.core.model.IReviewState; import org.eclipse.mylyn.reviews.core.model.ITaskReference; import org.eclipse.mylyn.reviews.core.model.ITopic; import org.eclipse.mylyn.reviews.core.model.IUser; <|startfocus|> import org.eclipse.mylyn.reviews.r4e.core.model.*; <|endfocus|> import org.eclipse.mylyn.reviews.r4e.core.model.R4EAnomaly; import org.eclipse.mylyn.reviews.r4e.core.model.R4EAnomalyTextPosition; import org.eclipse.mylyn.reviews.r4e.core.model.R4EAnomalyType; import org.eclipse.mylyn.reviews.r4e.core.model.R4EComment; import org.eclipse.mylyn.reviews.r4e.core.model.R4ECommentType; import org.eclipse.mylyn.reviews.r4e.core.model.R4EContent; import org.eclipse.mylyn.reviews.r4e.core.model.R4EDelta; import org.eclipse.mylyn.reviews.r4e.core.model.R4EFileContext;
<|startcomment|> which call can throw ArtifactDoesNotExist? Should WorkItemUtil maybe catch the exception or call a different method that does not throw exceptions when the artifact DNE? <|endcomment|>  Conditions.checkNotNull(artifact, "workItem", "Can't locate Work Item %s", artifact.toStringWithId()); return artifact.getArtifactTypeToken(); } @Override public Collection<Object> getAttributeValues(IAtsObject atsObject, IAttributeType attributeType) throws OseeCoreException { try { <|startfocus|> Artifact artifact = WorkItemUtil.get(atsObject); Conditions.checkNotNull(artifact, "workItem", "Can't Find Artifact matching " + atsObject.toStringWithId()); return artifact.getAttributeValues(attributeType); <|endfocus|> } catch (ArtifactDoesNotExist ex) { // if atsObject not represented as persisted artifact, return empty set return Collections.emptyList(); } } @Override public boolean isOfType(IAtsWorkItem workItem, IArtifactType matchType) throws OseeCoreException { Artifact artifact = WorkItemUtil.get(workItem); Conditions.checkNotNull(artifact, "workItem", "Can't Find Artifact matching " + workItem.toStringWithId()); return artifact.isOfType(matchType); } } 
<|startcomment|> point of (view) <|endcomment|>  // The IProject is needed e.g. for link with Editor to work correctly. return folder.getParent().getResource(); } if (element instanceof TmfTraceElement) { TmfTraceElement traceElement = (TmfTraceElement) element; return traceElement.getParent(); } if (element instanceof TmfExperimentFolder) { TmfExperimentFolder folder = (TmfExperimentFolder) element; <|startfocus|> // Return the corresponding IProject as parent because from CNF point of the IProject is the parent. <|endfocus|> // The IProject is needed e.g. for link with Editor to work correctly. return folder.getParent().getResource(); } if (element instanceof TmfExperimentElement) { TmfExperimentElement expElement = (TmfExperimentElement) element; return expElement.getParent(); } return null;
<|startcomment|> Unfinished comment or it's just my English? <|endcomment|>  try { Pattern pattern = Pattern.compile(ARRAY_INDEX_RANGE_REGEXP, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(expr.substring(openBracketIndex+1, expr.length()-1)); if (!matcher.find()) { return false; } } catch(Exception e) { // If the user put an invalid pattern, we just ignore it return false; } return true; } /** <|startfocus|> * Split the expression-group a list of strings that make up <|endfocus|> */ protected List<String> splitExpressionsInGroup(IExpressionGroupDMContext groupDmc) { // Split the list of expressions String[] splitExpressions = groupDmc.getExpression().split(EXPRESSION_GROUP_SEPARATORS_REGEXP); // Remove any extra whitespace from each resulting expression, // and ignore any empty expressions. List<String> expressions = new ArrayList<String>(splitExpressions.length); for (String expr : splitExpressions) { expr = expr.trim(); if (!expr.isEmpty()) { expressions.add(expr); } } return expressions; } /**
<|startcomment|> I think this class should extend StubbyLaunchConfigurationDelegate given their similarity, and that it would eliminate the need to override the 2 null-returning methods. <|endcomment|>  * * Contributors: * Red Hat initial API and implementation *******************************************************************************/ package org.eclipse.linuxtools.profiling.provider.tests.stubby; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.debug.core.ILaunch; import org.eclipse.debug.core.ILaunchConfiguration; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.linuxtools.profiling.launch.ProfileLaunchConfigurationDelegate; import org.eclipse.swt.widgets.Display; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.PlatformUI; public class StubbyTimingLaunchConfigurationDelegate extends <|startfocus|> ProfileLaunchConfigurationDelegate { <|endfocus|> @Override public String generateCommand(ILaunchConfiguration config) { return null; } @Override public void launch(ILaunchConfiguration configuration, String mode, ILaunch launch, IProgressMonitor monitor) throws CoreException { Display.getDefault().asyncExec(new Runnable() { public void run() { IWorkbenchWindow window = PlatformUI.getWorkbench() .getActiveWorkbenchWindow(); MessageDialog.openConfirm(window.getShell(), "Successful profile launch", "Successful profile launch"); } }); } @Override protected String getPluginID() { return null; } 
<|startcomment|> You don't need to protect instanceof against null pointerns. Wrap this like we've done with registerAutoShareProjects <|endcomment|>  public void resourceChanged(IResourceChangeEvent event) { IResource project = event.getResource(); <|startfocus|> if (project != null && project instanceof IProject) <|endfocus|> GitProjectData.reconfigureWindowCache();
<|startcomment|> No parens on condition. <|endcomment|>  public long getFileSize(String ext) { Long size = sizeMap.get(ext); <|startfocus|> return (size == null) ? 0 : size.longValue(); <|endfocus|>
<|startcomment|> Should document that this tries the context first, then does a state system query. <|endcomment|> <|startfocus|> public int getPid() { <|endfocus|> ITmfEventField pidContext = this.getContent().getField("context._pid"); //$NON-NLS-1$ if (null != pidContext) { return ((Integer) pidContext.getValue()).intValue(); } CtfKernelTrace trace = (CtfKernelTrace) this.getTrace(); ITmfStateSystem ss = trace.getStateSystem(CtfKernelTrace.STATE_ID); Integer threadNode = -1; int retVal = -1; try { threadNode = ss.getQuarkAbsolute(Attributes.CPUS, String.valueOf(getCPU()), Attributes.CURRENT_THREAD); ITmfStateValue sv = ss.querySingleState(this.getTimestamp().getValue(), threadNode).getStateValue(); retVal = sv.unboxInt(); } catch (AttributeNotFoundException e) { e.printStackTrace(); } catch (TimeRangeException e) { e.printStackTrace(); } catch (StateSystemDisposedException e) { e.printStackTrace(); } catch (StateValueTypeException e) { e.printStackTrace(); } return retVal;
<|startcomment|> CtfKernelEvent <|endcomment|> <|startfocus|> public CtfTmfEvent getCurrentEvent() { <|endfocus|> final StreamInputReader top = super.prio.peek(); if (top != null) { return new CtfKernelEvent(top.getCurrentEvent(), top.getFilename(), (CtfKernelTrace) this.getCtfTmfTrace()); } return null;
<|startcomment|> Can this be tested? It would not only prove this works, but serve as an example on how to use the weighted builder. <|endcomment|>  * Boeing - initial API and implementation *******************************************************************************/ package org.eclipse.osee.framework.core.operation; import java.util.ArrayList; import java.util.List; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.MultiStatus; import org.eclipse.core.runtime.SubMonitor; import org.eclipse.osee.framework.core.enums.OperationBehavior; import org.eclipse.osee.framework.core.util.Conditions; import org.eclipse.osee.framework.jdk.core.type.Pair; /** * @author Roberto E. Escobar */ public class OperationBuilder { <|startfocus|> private final String name; private final String pluginId; private OperationBehavior behavior; private OperationLogger logger; <|endfocus|> private List<Pair<Double, ? extends IOperation>> operations; private double runningTotal; private int itemsWithHints; OperationBuilder(String name, String pluginId) { this.name = name; this.pluginId = pluginId; reset(); } private void reset() { behavior = OperationBehavior.TerminateOnError; logger = NullOperationLogger.getSingleton();
<|startcomment|> You should put your real name here :P And the description of what you did should go under Contributors in the copyright header instead. <|endcomment|> import org.eclipse.linuxtools.tmf.core.ctfadaptor.CtfTmfTrace; import org.eclipse.linuxtools.tmf.core.exceptions.TmfTraceException; import org.eclipse.linuxtools.tmf.core.statesystem.IStateChangeInput; import org.eclipse.linuxtools.tmf.core.statesystem.ITmfStateSystem; import org.eclipse.linuxtools.tmf.core.statesystem.StateSystemManager; /** * This is the specification of CtfTmfTrace for use with LTTng 2.x kernel * traces. It uses the CtfKernelStateInput to generate the state history. * * @version 1.0 * @author Alexandre Montplaisir <|startfocus|> * @author ematkho - rename <|endfocus|> * @since 2.0 */ public class LttngKernelTrace extends CtfTmfTrace { /** * The file name of the History Tree */ public final static String HISTORY_TREE_FILE_NAME = "stateHistory.ht"; //$NON-NLS-1$ /** * ID of the state system we will build * * @since 2.0 * */ public static final String STATE_ID = "org.eclipse.linuxtools.lttng2.kernel"; //$NON-NLS-1$ /** * Default constructor */
<|startcomment|> If we are to support a (target) parent folder parameter, then it could be anywhere and the new path should be relative to it. But the copySupplementaryFolder method only supports copying to the same project. So it's probably better to remove the parentFolder parameter. The parent folder can be found with getResource().getParent(). <|endcomment|> <|startfocus|> public IResource copy(final String newName, final IFolder parentFolder, final boolean copySuppFiles) { <|endfocus|> IPath oldPath = getResource().getFullPath(); final IPath newPath = oldPath.append("../" + newName); //$NON-NLS-1$ // Copy supplementary files first, only if needed if (copySuppFiles) { copySupplementaryFolder(newName); } // Copy the trace try { getResource().copy(newPath, IResource.FORCE | IResource.SHALLOW, null); // Delete any bookmarks file found in copied trace folder IFolder folder = parentFolder.getFolder(newName); if (folder.exists()) { for (IResource member : folder.members()) { if (TmfTrace.class.getCanonicalName().equals(member.getPersistentProperty(TmfCommonConstants.TRACETYPE))) { member.delete(true, null); } } } return folder; } catch (CoreException e) { } return null; 
<|startcomment|> we don't use braces around single line blocks, many more occurrences in this patch <|endcomment|>  public void queryFile1Contributors() { final IFileHistory history = historyProvider.getFileHistoryFor(iFile1, IFileHistoryProvider.NONE, new NullProgressMonitor()); assertNotNull(history); final IFileRevision[] revisions = history.getFileRevisions(); IFileRevision branchFileRevision1 = null; IFileRevision masterFileRevision3 = null; IFileRevision masterFileRevision1 = null; for (IFileRevision revision : revisions) { final String revisionId = revision.getContentIdentifier(); <|startfocus|> if (branchCommit1.getName().equals(revisionId)) { <|endfocus|> branchFileRevision1 = revision; } else if (masterCommit3.getName().equals(revisionId)) { masterFileRevision3 = revision; } else if (masterCommit1.getName().equals(revisionId)) { masterFileRevision1 = revision; } } assertNotNull(branchFileRevision1); assertNotNull(masterFileRevision3); assertNotNull(masterFileRevision1); /* The "direct" parent of branchCommit1 is masterCommit2. However, that commit did not contain file1. We thus * expect the returned contributor to be masterCommit1. */
<|startcomment|> Why is the case changed here? We have complete sentences. <|endcomment|>  if (emitAsDocument) { endBody(); writer.writeEndElement(); // html writer.writeEndDocument(); } writer.close(); // Handle any document builder extensions that needs to do any post build work for (AbstractDocumentBuilderExtension extension : getDocumentBuilderExtensions()) { if (extension instanceof HtmlDocumentBuilderExtension) { ((AbstractDocumentBuilderExtension) extension).postBuild(); } } } /** <|startfocus|> * Begin the body by emitting the body element. Overriding methods should call <code>super.beginBody()</code>. <|endfocus|> * * @see #endBody() */ protected void beginBody() { writer.writeStartElement(htmlNsUri, "body"); //$NON-NLS-1$ // Handle any document builder extensions that contribute to document body for (AbstractDocumentBuilderExtension extension : getDocumentBuilderExtensions()) { if (extension instanceof HtmlDocumentBuilderExtension) { ((HtmlDocumentBuilderExtension) extension).prependToDocumentBody(writer); } } } /** * End the body by emitting the body end element tag. Overriding methods should call <code>super.endBody()</code>.
<|startcomment|> Fix java doc (First sentence should describe class) and add @author <|endcomment|> import org.eclipse.swt.graphics.Font; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.FileDialog; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Text; import org.eclipse.ui.dialogs.SelectionStatusDialog; /** <|startfocus|> * SelectTraceExecutableDialog <|endfocus|> * * @author Francois Chouinard */ public class SelectTraceExecutableDialog extends SelectionStatusDialog { private final IStatus OK_STATUS = new Status(IStatus.OK, GdbTraceUiPlugin.PLUGIN_ID, ""); //$NON-NLS-1$ private final IStatus PATH_ERROR_STATUS = new Status(IStatus.ERROR, GdbTraceUiPlugin.PLUGIN_ID, Messages.SelectTraceExecutableDialog_Message); private final IStatus BINARY_ERROR_STATUS = new Status(IStatus.ERROR, GdbTraceUiPlugin.PLUGIN_ID, Messages.SelectTraceExecutableDialog_BinaryError); private Text fExecutableNameEntry; private IPath fExecutablePath; /** * Creates a SelectTraceExecutableDialog
<|startcomment|> Does the connection need to be closed in the event of an exception? <|endcomment|>  super(); this.proxiedFactory = proxiedFactory; this.connectionURL = connectionURL; this.properties = properties; this.supportsIsolationLevel = supportsIsolationLevel; } @Override public Connection createConnection() throws SQLException { Connection connection = null; try { connection = proxiedFactory.getConnection(properties, connectionURL); if (supportsIsolationLevel) { connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); } } catch (Exception ex) { <|startfocus|> throw new SQLException(ex); <|endfocus|> } return connection; } } } 
<|startcomment|> fix java doc warnings <|endcomment|>  * * Contributors: * Matthew Khouzam - Initial API and implementation *******************************************************************************/ package org.eclipse.linuxtools.tmf.ui.project.wizards.importtrace; import java.io.File; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.linuxtools.tmf.core.trace.ITmfTrace; import org.eclipse.linuxtools.tmf.ui.project.model.TmfTraceType; class FileAndName implements Comparable<FileAndName> { final private File file; private IConfigurationElement fConfiguration; public String name; private boolean fConflict; <|startfocus|> /** <|endfocus|> * @param f * @param n * */ public FileAndName(File f, String n) { file = f; name = n; fConfiguration = null; } /** * @return the name */ public String getName() { return name; } /** * @param name * the name to set */ public void setName(String name) { this.name = name; } public ITmfTrace getTraceType(){ if( fConfiguration != null ){
<|startcomment|> It seems that the scanning can be only done once. I suspect that the the variables used in the thread are not initialized properly when going back and forth between pages (next and previous buttons). Also the wizard and runnable class are not thread safe! This needs to be reworked. <|endcomment|>  } getBatchWizard().updateConflicts(); getBatchWizard().getContainer().updateButtons(); traceTypeViewer.update(event.getElement(), null); } private void maintainCheckIntegrity(final CheckboxTreeViewer viewer, final FileAndName element) { String parentElement = (String) getBatchWizard().getScannedTraces().getParent(element); boolean allChecked = true; for (FileAndName child : getBatchWizard().getScannedTraces().getSiblings(element)) { allChecked &= viewer.getChecked(child); } viewer.setChecked(parentElement, allChecked); } } <|startfocus|> private final class scanRunnable implements Runnable { <|endfocus|> @Override public void run() { while (!canScan()) { try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if (pos == null) { pos = getBatchWizard().getFilesToScan().iterator(); } while (pos.hasNext()) { if (getBatchWizard().isReset()) { getBatchWizard().set();
<|startcomment|> I don't think you should use the same ID as the select all button <|endcomment|>  layout.marginWidth = 0; layout.horizontalSpacing = convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_SPACING); buttonComposite.setLayout(layout); buttonComposite.setFont(composite.getFont()); GridData data = new GridData(GridData.HORIZONTAL_ALIGN_END | GridData.GRAB_HORIZONTAL); data.grabExcessHorizontalSpace = true; buttonComposite.setLayoutData(data); /* Create the buttons in the good order to place them as we want */ Button checkSubtreeButton = createButton(buttonComposite, <|startfocus|> IDialogConstants.SELECT_ALL_ID, Messages.TmfTimeFilterDialog_CHECK_SUBTREE, <|endfocus|> false); Button checkAllButton = createButton(buttonComposite, IDialogConstants.SELECT_ALL_ID, Messages.TmfTimeFilterDialog_CHECK_ALL, false); Button checkSelectedButton = createButton(buttonComposite, IDialogConstants.CLIENT_ID, Messages.TmfTimeFilterDialog_CHECK_SELECTED, false); new Label(buttonComposite, 0); // Leave an empty cell Button uncheckAllButton = createButton(buttonComposite, IDialogConstants.DESELECT_ALL_ID, Messages.TmfTimeFilterDialog_UNCHECK_ALL, false); Button uncheckSelectedButton = createButton(buttonComposite, IDialogConstants.CLIENT_ID + 1, Messages.TmfTimeFilterDialog_UNCHECK_SELECTED, false); /*
<|startcomment|> If this logic correct ? Seems like we would execute this block with the attribute type isValid for the artifact. <|endcomment|>  } else if (UIEvents.Dirtyable.DIRTY.equals(attName)) { Boolean dirtyState = (Boolean) newValue; String text = cti.getText(); boolean hasAsterisk = text.length() > 0 && text.charAt(0) == '*'; if (dirtyState.booleanValue()) { if (!hasAsterisk) { cti.setText('*' + text); } } else if (hasAsterisk) { cti.setText(text.substring(1)); } } else if (UIEvents.UILifeCycle.BUSY.equals(attName)) { <|startfocus|> updateBusyIndicator(cti, part, (Boolean) newValue); } <|endfocus|>
<|startcomment|> You can't add protected methods to ViewPart or WorkbenchPart, They would be API. In this case, something that needs the model can get the site from the part and do the test+cast itself. <|endcomment|>  for (String id : inputArtIds) { Artifact art = ArtifactQuery.getArtifactFromId(id, branch); if (!art.isAttributeTypeValid(attributeType)) { List<Attribute<?>> attrs = art.getAttributes(false); for (Attribute<?> attr : attrs) { if (attr.isOfType(attributeType)) { attr.delete(); log(String.format("Artifact [%s] attribute type [%s] deleted: [%s]\n", art.toStringWithId(), attributeType.toString(), attr.toString())); } } art.persist(transaction); } else { <|startfocus|> log(String.format("Artifact [%s] attribute type [%s] is not invalid\n", art.toStringWithId(), attributeType.toString())); <|endfocus|> } } transaction.execute(); } @Override public String getXWidgetsXml() throws OseeCoreException { return getXWidgetsXmlFromUiFile(getClass().getSimpleName(), Activator.PLUGIN_ID); } @Override public Collection<String> getCategories() { return Arrays.asList("Admin"); } } 
<|startcomment|> Seems to be the same as if (((ReferenceChange)diff).getReference().isContainment()) but much more convoluted. Please change this condition. <|endcomment|>  public Iterable<Diff> apply(Diff diff) { if (diff instanceof ReferenceChange) { Match match = diff.getMatch(); Match matchOfValue = diff.getMatch().getComparison().getMatch( ((ReferenceChange)diff).getValue()); <|startfocus|> if (!match.equals(matchOfValue) && match.getSubmatches().contains(matchOfValue)) { <|endfocus|> final Iterable<Diff> subDiffs = matchOfValue.getAllDifferences(); addAll(processedDiffs, subDiffs); final Iterable<Diff> associatedDiffs = getAssociatedDiffs(diff, subDiffs, processedDiffs, leftToRight); return ImmutableSet.copyOf(concat(subDiffs, associatedDiffs)); } } return ImmutableSet.of();
<|startcomment|> Remove commented out code. <|endcomment|> import org.eclipse.osee.framework.core.data.Identity; import org.eclipse.osee.framework.core.exception.OseeCoreException; /** * @author Donald G. Dunne */ public interface IAtsVersionStore { public IAtsTeamWorkflow removeTargetedVersionLinks(IAtsTeamWorkflow teamWf) throws OseeCoreException; public IAtsTeamWorkflow setTargetedVersionLink(IAtsTeamWorkflow teamWf, IAtsVersion version) throws OseeCoreException; public IAtsVersion loadTargetedVersion(Object object) throws OseeCoreException; <|startfocus|> // public Collection<IAtsVersion> getVersions(IAtsTeamDefinition teamDef) throws OseeCoreException; <|endfocus|> public IAtsTeamDefinition getTeamDefinition(IAtsVersion version) throws OseeCoreException; public void setTeamDefinition(IAtsVersion version, IAtsTeamDefinition teamDef) throws OseeCoreException; public IAtsVersion getById(Identity<String> id) throws OseeCoreException; } 
<|startcomment|> Distribution Statement? Author? <|endcomment|>  * Created on Apr 3, 2013 * <|startfocus|> * PLACE_YOUR_DISTRIBUTION_STATEMENT_RIGHT_HERE */ <|endfocus|> package org.eclipse.osee.ats.core.client.internal; import java.util.Collection; import java.util.List; import org.eclipse.osee.ats.api.IAtsObject; import org.eclipse.osee.ats.api.IAtsWorkItem; import org.eclipse.osee.ats.api.team.IAtsTeamDefinition; import org.eclipse.osee.ats.api.workflow.IAtsTeamWorkflow; import org.eclipse.osee.framework.core.exception.OseeCoreException; import org.eclipse.osee.framework.skynet.core.artifact.Artifact; public interface IAtsWorkItemArtifactProvider { public abstract Artifact get(IAtsObject atsObject) throws OseeCoreException; public abstract <A extends Artifact> A get(IAtsWorkItem workItem, Class<?> clazz) throws OseeCoreException; public abstract <A extends Artifact> List<A> get(Collection<? extends IAtsWorkItem> workItems, Class<?> clazz) throws OseeCoreException; public abstract Collection<? extends IAtsWorkItem> getWorkItems(Collection<Artifact> arts); public abstract IAtsTeamWorkflow getParentTeamWorkflow(IAtsWorkItem workItem) throws OseeCoreException; 
<|startcomment|> Remove commented out code. <|endcomment|>  try { teamDefArt = verArt.getRelatedArtifact(AtsRelationTypes.TeamDefinitionToVersion_TeamDefinition); } catch (ArtifactDoesNotExist ex) { if (!verArt.isDeleted() && verArt.isInDb()) { OseeLog.logf(Activator.class, Level.SEVERE, "Version [%s] has no related team defininition", verArt.toStringWithId()); } } if (teamDefArt != null) { <|startfocus|> result = loadFromStore(teamDefArt); //cache.getSoleByGuid(teamDefArt.getGuid(), IAtsTeamDefinition.class); <|endfocus|> } } return result; } @Override public IAtsVersion getById(Identity<String> id) throws OseeCoreException { IAtsVersion version = null; Artifact verArt = ArtifactQuery.getArtifactFromId(id.getGuid(), AtsUtilCore.getAtsBranchToken()); if (verArt != null) { version = loadFromStore(verArt); } return version; } @Override public Collection<IAtsTeamWorkflow> getTargetedForTeamWorkflows(IAtsVersion version) throws OseeCoreException {
<|startcomment|> Should have the standard Boeing/Eclipse distribution statement and author <|endcomment|>  * Created on Apr 2, 2013 * <|startfocus|> * PLACE_YOUR_DISTRIBUTION_STATEMENT_RIGHT_HERE */ <|endfocus|> package org.eclipse.osee.ats.reports.burndown.internal; import org.eclipse.osee.ats.core.client.IAtsClient; public class AtsClientService { private static IAtsClient atsClient; public void setAtsClient(IAtsClient atsClient) { AtsClientService.atsClient = atsClient; } public static IAtsClient get() { return atsClient; } } 
<|startcomment|> Why, it's not so ugly? However in the parse.. method I would put a nice comment to explain that the CTFLexer auto-generated class will always have as first declared fields a list of int constants whose unique value correspond to the integer value returned in the MismatchedTokenExecption 'expecting' and 'c' fields. <|endcomment|>  public CTFReaderException(RecognitionException e) throws IllegalAccessException { super(e); this.fErrorLine = e.line; this.fFile = "metadata"; //$NON-NLS-1$ // we're in CTF, the only thing using antlr is metadata <|startfocus|> // UGLY UGLY UGLY if (e instanceof MismatchedTokenException) { parseMismatchedException(e); } <|endfocus|>
<|startcomment|> ctrl+shit+f. you can safely use it on whole files before saving now (we can't set it to run automatically unfortunately, it adds whitespace where it shouldn't). <|endcomment|>  public boolean validate(final IProject project, final String path) { <|startfocus|> try { final CTFTrace temp = new CTFTrace(path); return temp.majortIsSet(); // random test } catch (final CTFReaderException e) { /* Nope, not a CTF trace we can read */ return false; <|endfocus|> }
<|startcomment|> I do not see the benefit of this class. The first method is misspelled and never called. The second method is never called. <|endcomment|>  Node node = elem.getFirstChild(); while (node != null) { node = processNodeWithChildren(node, doc); node = node.getNextSibling(); } TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); DOMSource DOMsource = new DOMSource(doc); ByteArrayOutputStream output = new ByteArrayOutputStream(); StreamResult result = new StreamResult(output); transformer.transform(DOMsource, result); resultString = output.toString("UTF-8"); return resultString; } <|startfocus|> <|endfocus|> private static class HTMLConfig extends HTMLConfiguration { static String getReportErrorFeatrue() { return REPORT_ERRORS; } static String getSimpleErrorFeature() { return SIMPLE_ERROR_FORMAT; } static String getNamesElementFeature() { return NAMES_ELEMS; } static String getNamesAttrFeatures() { return NAMES_ATTRS; } } private Node processTextNode(Node node, Document doc) { Node localNode = node; String theText = localNode.getNodeValue(); /***********************************************
<|startcomment|> nodes should be sorted by name <|endcomment|> import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.swt.SWT; import org.eclipse.ui.handlers.HandlerUtil; /** * Check out of a commit. */ public class CheckoutCommitHandler extends AbstractHistoryCommandHandler { public Object execute(ExecutionEvent event) throws ExecutionException { RevCommit commit = (RevCommit) getSelection(getPage()).getFirstElement(); Repository repo = getRepository(event); final BranchOperationUI op; List<RefNode> nodes = getRefNodes(commit, repo, Constants.R_HEADS, <|startfocus|> Constants.R_REMOTES); <|endfocus|> if (nodes.isEmpty()) op = BranchOperationUI.checkout(repo, commit.name()); else if (nodes.size() == 1) op = BranchOperationUI.checkout(repo, nodes.get(0).getObject().getName()); else { BranchSelectionDialog<RefNode> dlg = new BranchSelectionDialog<RefNode>( HandlerUtil.getActiveShellChecked(event), nodes, UIText.CheckoutHandler_SelectBranchTitle, UIText.CheckoutHandler_SelectBranchMessage, SWT.SINGLE); if (dlg.open() == Window.OK) {
<|startcomment|> use FileRepositoryBuilder.create <|endcomment|>  } @Test public void testMergeOnRepo() throws Exception { Activator.getDefault().getRepositoryUtil().addConfiguredRepository( clonedRepositoryFile); SWTBotTree tree = getOrOpenView().bot().tree(); myRepoViewUtil.getRootItem(tree, clonedRepositoryFile).select(); ContextMenuHelper.clickContextMenu(tree, myUtil .getPluginLocalizedValue("RepoViewMerge.label")); String title = NLS.bind( UIText.MergeTargetSelectionDialog_TitleMergeWithBranch, <|startfocus|> new RepositoryBuilder().setGitDir(clonedRepositoryFile).build() .getBranch()); <|endfocus|> SWTBotShell mergeDialog = bot.shell(title); // TODO do some merge here mergeDialog.close(); } @Test public void testBranchConfiguration() throws Exception { Repository repo = lookupRepository(clonedRepositoryFile); Git git = new Git(repo); git.branchCreate().setName("configTest") .setStartPoint("refs/remotes/origin/master") .setUpstreamMode(SetupUpstreamMode.TRACK).call(); boolean rebase = repo.getConfig().getBoolean( ConfigConstants.CONFIG_BRANCH_SECTION, "configTest", ConfigConstants.CONFIG_KEY_REBASE, false); assertFalse(rebase); 
<|startcomment|> Released code should not contain code that is commented out <|endcomment|>  importActionableItems(atsDsl.getActionableItemDef(), AtsClientService.get().getConfigArtifact(ActionableItems.getTopActionableItem())); } private void importUserDefinitions(EList<UserDef> userDefs) throws OseeCoreException { for (UserDef dslUserDef : userDefs) { String dslUserName = Strings.unquote(dslUserDef.getName()); Artifact userArt = null; <|startfocus|> // if (dslUserDef.getUserDefOption().contains("GetOrCreate")) { userArt = UserManager.createUser(getOseeUser(dslUserDef), transaction); // } <|endfocus|> if (userArt == null) { userArt = ArtifactTypeManager.addArtifact(CoreArtifactTypes.User, AtsUtil.getAtsBranch(), dslUserName); } if (userArt == null) { throw new OseeStateException(String.format("No user found in datbase with name [%s] from [%s]", dslUserName, modelName), modelName); } } } private IUserToken getOseeUser(final UserDef dslUserDef) { return TokenFactory.createUserToken(GUID.create(), Strings.unquote(dslUserDef.getName()),
<|startcomment|> You can move this into the run method <|endcomment|>  private void refresh() { <|startfocus|> final TmfTraceManager tm = TmfTraceManager.getInstance(); <|endfocus|> Display.getDefault().asyncExec(new Runnable() { @Override public void run() { if (fTimeGraphCombo.isDisposed()) { return; } ITimeGraphEntry[] entries = null; synchronized (fEntryListMap) { fEntryList = fEntryListMap.get(fTrace); if (fEntryList == null) { fEntryList = new ArrayList<ControlFlowEntry>(); } entries = fEntryList.toArray(new ITimeGraphEntry[0]); } Arrays.sort(entries, fControlFlowEntryComparator); fTimeGraphCombo.setInput(entries); fTimeGraphCombo.getTimeGraphViewer().setTimeBounds(fStartTime, fEndTime); long timestamp = fTrace == null ? 0 : tm.getCurrentTime().normalize(0, ITmfTimestamp.NANOSECOND_SCALE).getValue(); long startTime = fTrace == null ? 0 : tm.getCurrentRange().getStartTime().normalize(0, ITmfTimestamp.NANOSECOND_SCALE).getValue();
<|startcomment|> It seems unnecessary to check this, just return traceFolder even if it's null. <|endcomment|>  ISelectionProvider selectionProvider = part.getSite().getSelectionProvider(); if (selectionProvider == null) { return null; } ISelection selection = selectionProvider.getSelection(); TmfTraceFolder traceFolder = null; if (selection instanceof TreeSelection) { TreeSelection sel = (TreeSelection) selection; // There should be only one item selected as per the plugin.xml Object element = sel.getFirstElement(); if (element instanceof TmfTraceFolder) { traceFolder = (TmfTraceFolder) element; } } <|startfocus|> if (traceFolder == null) { return null; } <|endfocus|> return traceFolder;
<|startcomment|> add empty line below <|endcomment|> import org.eclipse.swt.widgets.DirectoryDialog; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.FileDialog; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableItem; import org.eclipse.ui.IWorkbench; /** * <b>Select the directories to scan for traces</b> this page is the second of * three pages shown. This one selects the files to be scanned. * * @author Matthew Khouzam * @since 2.0 * */ <|startfocus|> public class ImportTraceWizardPageSelectDirectories extends AbstractImportTraceWizardPage { <|endfocus|> /** * ID */ public static String ID = "org.eclipse.linuxtools.tmf.ui.project.wizards.importtrace.ImportTraceWizardPagePopulate"; //$NON-NLS-1$ /** * Constructor. Creates the trace wizard page. * * @param name * The name of the page. * @param selection * The current selection */ protected ImportTraceWizardPageSelectDirectories(String name, IStructuredSelection selection) { super(name, selection); } /** * Constructor * * @param workbench
<|startcomment|> space before { <|endcomment|>  * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Matthew Khouzam - Initial API and implementation *******************************************************************************/ package org.eclipse.linuxtools.tmf.ui.project.wizards.importtrace; /** * Trace import helper class * @author Matthew Khouzam * @since 2.0 */ <|startfocus|> class TraceToValidate implements Comparable<TraceToValidate>{ <|endfocus|> final private String fTraceToScan; final private String fTraceType; public TraceToValidate(String traceToScan, String traceType) { this.fTraceToScan = traceToScan; this.fTraceType = traceType; } public String getTraceToScan() { return fTraceToScan; } public String getTraceType() { return fTraceType; } @Override public int hashCode() { final int prime = 31; int result = 1;
<|startcomment|> an array of child elements <|endcomment|>  } /** IUiModelElement functions * Returns the text to display in the tree viewer as required by the label provider. * @return text Text string describing this element */ public String getLabelText() { if (session.getName().equals(DEFAULT_SESSION_NAME)){ return OprofileUiMessages.getString("UiModelSession_current"); //$NON-NLS-1$ } return toString(); } /** * Returns the children of this element. <|startfocus|> * @return samples An array of IUiModelElements <|endfocus|> */ public IUiModelElement[] getChildren() { if (dependent != null) { return new IUiModelElement[] {image, dependent}; } else { return new IUiModelElement[] {image}; } } /** * Returns if the element has any children. * @return true if the element has children, false otherwise */ public boolean hasChildren() { return (image != null); } /** * Returns the element's parent. * @return parent The parent element */
<|startcomment|> Three unused imports. <|endcomment|> import org.eclipse.cdt.core.dom.ast.IASTName; import org.eclipse.cdt.core.dom.ast.IASTNode; import org.eclipse.cdt.core.dom.ast.IASTUnaryExpression; import org.eclipse.cdt.core.dom.ast.IPointerType; import org.eclipse.cdt.core.dom.ast.IQualifierType; import org.eclipse.cdt.core.dom.ast.IType; import org.eclipse.cdt.core.dom.ast.c.ICASTFieldDesignator; import org.eclipse.cdt.core.dom.ast.c.ICASTTypeIdInitializerExpression; import org.eclipse.cdt.internal.core.dom.parser.VariableReadWriteFlags; <|startfocus|> import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTArraySubscriptExpression; import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTIdExpression; import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTUnaryExpression; <|endfocus|> /** * Helper class to determine whether a variable is accessed for reading and/or writing. * The algorithm works starting from the variable and looking upwards what's being done * with the variable. */ public final class CVariableReadWriteFlags extends VariableReadWriteFlags { private static CVariableReadWriteFlags INSTANCE= new CVariableReadWriteFlags(); public static int getReadWriteFlags(IASTName variable) { return INSTANCE.rwAnyNode(variable, 0); }
<|startcomment|> Surround this branch with curly braces since other branches have them. <|endcomment|>  if (expr instanceof IASTIdExpression) { final IASTNode parent = expr.getParent(); if (parent instanceof IASTArraySubscriptExpression) { // arrays ++indirection; if (indirection > 0 && expr.getPropertyInParent() == IASTArraySubscriptExpression.ARRAY) { return rwAnyNode(parent, indirection - 1); } return READ; } else if (parent instanceof IASTUnaryExpression) { // prefix/postfix operators return rwInUnaryExpression(expr, (IASTUnaryExpression) parent, indirection); } else return rwAnyNode(expr, indirection); <|startfocus|> } <|endfocus|> if (expr instanceof IASTBinaryExpression) { return rwInBinaryExpression(node, (IASTBinaryExpression) expr, indirection); } if (expr instanceof IASTFieldReference) { return rwInFieldReference(node, (IASTFieldReference) expr, indirection); } if (expr instanceof IASTCastExpression) { // must be ahead of unary return rwAnyNode(expr, indirection); } if (expr instanceof IASTUnaryExpression) { return rwInUnaryExpression(node, (IASTUnaryExpression) expr, indirection); } if (expr instanceof IASTArraySubscriptExpression) { if ( node instanceof IASTArraySubscriptExpression ) { // multidimensional array ++indirection; }
<|startcomment|> any reason to use Long instead of long? This might cause unneeded boxing/unboxing. <|endcomment|> <|startfocus|> public final static String formatNumber(Long value, int base, boolean signed) { <|endfocus|> String s; /* Format the number correctly according to the integer's base */ switch (base) { case 2: s = "0b" + Long.toBinaryString(value); //$NON-NLS-1$ break; case 8: s = "0" + Long.toOctalString(value); //$NON-NLS-1$ break; case 16: s = "0x" + Long.toHexString(value); //$NON-NLS-1$ break; case 10: default: /* For non-standard base, we'll just print it as a decimal number */ if (!signed && value < 0) { BigInteger bigInteger = BigInteger.valueOf(value); // powerOfTwo = 2^64 // we add 2^64 to the negative number to get the real unsigned // value BigInteger powerOfTwo = (BigInteger.valueOf(Long.MAX_VALUE)).add(BigInteger.valueOf(1)); powerOfTwo = powerOfTwo.multiply(BigInteger.valueOf(2)); bigInteger = bigInteger.add(powerOfTwo); 
<|startcomment|> needs a context <|endcomment|>  0x44, (byte) 0xc1, (byte) 0x8d, (byte) 0x89, 0x4b, (byte) 0xb4, 0x38, (byte) 0x85, 0x7f, (byte) 0x8d }; final int size = 4096; byte[] data = new byte[size]; for (int i = 0; i < size; i++) { data[i] = 0x00; } <|startfocus|> f = new File(tempTraceDir + "/dummyChan"); //$NON-NLS-1$ <|endfocus|> fw = new FileWriter(f); FileOutputStream fos = new FileOutputStream(f); fos.write(magicLE); fos.write(uuid); fos.write(data); fos.close(); fw.close(); f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } finally { f = null; } 
<|startcomment|> Get "in an editor" (there can be more than one open). <|endcomment|>  } if (getParent() instanceof TmfExperimentElement) { TmfExperimentElement experiment = (TmfExperimentElement) getParent(); TmfExperimentFolder folder = (TmfExperimentFolder) experiment.getParent(); TmfProjectElement project = (TmfProjectElement) folder.getParent(); return project; } return null; } // ------------------------------------------------------------------------ // IPropertySource2 // ------------------------------------------------------------------------ @Override public Object getEditableValue() { return null; } /** <|startfocus|> * get the trace properties of this traceElement if the corresponding * trace is opened in the editor <|endfocus|> * * @return a map with the names an values of the trace properties * respectively as keys and values */ private Map<String, String> getTraceProperties() { for (ITmfTrace fTrace : TmfTraceManager.getInstance().getOpenedTraces()) { if (fTrace.getResource().equals(this.getResource())) { if (fTrace instanceof ITmfTraceProperties) { ITmfTraceProperties traceProperties = (ITmfTraceProperties) fTrace; return traceProperties.getTraceProperties(); } } } return null; } @Override
<|startcomment|> Ctrl-Shift-O <|endcomment|> import org.eclipse.linuxtools.tmf.core.exceptions.StateSystemDisposedException; import org.eclipse.linuxtools.tmf.core.exceptions.StateValueTypeException; import org.eclipse.linuxtools.tmf.core.exceptions.TimeRangeException; import org.eclipse.linuxtools.tmf.core.interval.ITmfStateInterval; import org.eclipse.linuxtools.tmf.core.statesystem.ITmfStateSystem; import org.eclipse.linuxtools.tmf.core.statevalue.ITmfStateValue; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.StateItem; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.TimeGraphPresentationProvider; <|startfocus|> import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.model.TimeGraphEntry; <|endfocus|> import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.model.ITimeEvent; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.model.TimeEvent; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.widgets.Utils; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.RGB; import org.eclipse.swt.graphics.Rectangle; /** * Presentation provider for the control flow view */ public class ControlFlowPresentationProvider extends TimeGraphPresentationProvider { private enum State { UNKNOWN (new RGB(100, 100, 100)), WAIT_BLOCKED (new RGB(200, 200, 0)),
<|startcomment|> 2.1 <|endcomment|>  public CtfTmfEvent parseEvent(ITmfContext context) { CtfTmfEvent event = null; if (context instanceof CtfTmfContext) { <|startfocus|> CtfTmfContext itt = (CtfTmfContext) context.clone(); event = itt.getCurrentEvent(); <|endfocus|> } return event;
<|startcomment|> We don't need this cast. <|endcomment|>  public IReviewRemoteFactoryProvider getFactoryProvider() { <|startfocus|> if ((ReviewsConnector) getConnector() != null) { ReviewsClient client = ((ReviewsConnector) getConnector()).getReviewClient(getTaskRepository()); if (client != null) { return (IReviewRemoteFactoryProvider) client.getFactoryProvider(); } } return null; <|endfocus|>
<|startcomment|> see the comment below about the comparator, it can apply to fWeight too. <|endcomment|>  /** * The start time */ protected long fStartTime; /** * The end time */ protected long fEndTime; /** * The display width */ protected final int fDisplayWidth; // The zoom thread private ZoomThread fZoomThread; // The next resource action private Action fNextResourceAction; // The previous resource action private Action fPreviousResourceAction; // The relative weight of the sash private int[] fWeight = { 1, 1 }; <|startfocus|> /** * A comparator class */ <|endfocus|> protected Comparator<ITimeGraphEntry> fEntryComparator = null; // The redraw state used to prevent unnecessary queuing of display runnables private State fRedrawState = State.IDLE; // The redraw synchronization object final private Object fSyncObj = new Object(); final private TimeGraphPresentationProvider fPresentation; private TreeLabelProvider fLabelProvider = new TreeLabelProvider(); /** * Text for the "next" button */ protected String fNextText = Messages.AbstractTimeGraphtView_NextText; /**
<|startcomment|> Leftover? <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2012, 2013 Ericsson, cole Polytechnique de Montral <|endfocus|> * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Patrick Tasse - Initial API and implementation *******************************************************************************/ package org.eclipse.linuxtools.tmf.ui.widgets.timegraph; import java.util.Map; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.model.ITimeEvent; import org.eclipse.linuxtools.tmf.ui.widgets.timegraph.model.ITimeGraphEntry; import org.eclipse.swt.graphics.GC; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.graphics.Rectangle; /** * Interface for the time graph widget provider * * @version 1.0 * @author Patrick Tasse */ public interface ITimeGraphPresentationProvider { /** State table index for an invisible event * @since 2.0 */ final int INVISIBLE = -1; 
<|startcomment|> Please update copyright range and holders. Copyright (c) 2012, 2013 Obeo and others. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2012 Obeo. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.emf.compare.match.eobject; import com.google.common.collect.Maps; import java.util.Map; import org.eclipse.emf.compare.Comparison; import org.eclipse.emf.compare.match.eobject.ProximityEObjectMatcher.DistanceFunction; import org.eclipse.emf.ecore.EObject; /** * This class wraps a DistanceFunction and cache its result. Any call to distance(a,b) will be cached and the * same value will be returned to distance(b,a). * * @author <a href="mailto:cedric.brun@obeo.fr">Cedric Brun</a> */ public class CachingDistance implements DistanceFunction { /** * The wrapped function. */ private DistanceFunction wrapped; /**
<|startcomment|> this warning shouldn't be suppressed here. Perhaps it'd be better to put all the static final Strings in a separate interface, in which you could suppress both javadoc and NLS warnings. <|endcomment|>  *******************************************************************************/ package org.eclipse.linuxtools.tmf.core.timestamp; import java.util.HashMap; import java.util.Map; import java.util.TimeZone; import org.eclipse.core.runtime.Platform; import org.eclipse.core.runtime.preferences.DefaultScope; import org.eclipse.core.runtime.preferences.IEclipsePreferences; import org.eclipse.core.runtime.preferences.InstanceScope; import org.eclipse.linuxtools.internal.tmf.core.Activator; /** * TMF Time format preferences * * @author Francois Chouinard * @version 1.0 * @since 2.1 */ <|startfocus|> @SuppressWarnings("javadoc") <|endfocus|> public class TmfTimePreferences { // ------------------------------------------------------------------------ // Constants // ------------------------------------------------------------------------ public static final String DEFAULT_TIME_PATTERN = "HH:mm:ss.SSS_CCC_NNN"; //$NON-NLS-1$ static final String TIME_FORMAT_PREF = "org.eclipse.linuxtools.tmf.core.prefs.time.format"; //$NON-NLS-1$ public static final String DATIME = TIME_FORMAT_PREF + ".datime"; //$NON-NLS-1$ public static final String SUBSEC = TIME_FORMAT_PREF + ".subsec"; //$NON-NLS-1$
<|startcomment|> I think multipleValuesFound would be more clear. This name made me take a while to understand how it was used. <|endcomment|> import org.eclipse.osee.framework.skynet.core.artifact.Artifact; import org.eclipse.osee.framework.skynet.core.artifact.BranchManager; import org.eclipse.osee.framework.skynet.core.transaction.SkynetTransaction; import org.eclipse.osee.framework.skynet.core.transaction.TransactionManager; import org.eclipse.osee.framework.ui.skynet.internal.Activator; /** * @author Angel Avila */ public class AttributeCheckOperation extends AbstractOperation { private final List<Artifact> folders; private final IAttributeType attribute; private final boolean changeValues; private final boolean multipleValuesRequested; <|startfocus|> private boolean multipleValuesAllowed; <|endfocus|> public AttributeCheckOperation(OperationLogger logger, List<Artifact> artifacts, IAttributeType attribute, boolean changeValues, boolean multipleRequested) { super("Attribute Check ", Activator.PLUGIN_ID, logger); this.folders = artifacts; this.attribute = attribute; this.changeValues = changeValues; this.multipleValuesRequested = multipleRequested; } @Override protected void doWork(IProgressMonitor monitor) throws OseeCoreException { for (Artifact folder : folders) { if (!monitor.isCanceled()) {
<|startcomment|> ':' <|endcomment|>  private static boolean isSelectedCategory(CustomTxtTraceDefinition[] customTxtTraceDefinitions, Set<String> selectedTraceTypes) { for (CustomTxtTraceDefinition def : customTxtTraceDefinitions) { <|startfocus|> String traceTypeId = CustomTxtTrace.class.getCanonicalName() + ":" + def.definitionName; //$NON-NLS-1$ <|endfocus|> if (selectedTraceTypes.contains(traceTypeId)) { return true; } } return false;
<|startcomment|> see comment above <|endcomment|>  * | | * +-> c3 -+-> c4 */ @Test public void t1DominatesT2() throws Exception { ObjectId c1 = modify("aaa"); tag("t1"); ObjectId c2 = modify("bbb"); tag("t2"); git.checkout().setCreateBranch(true).setName("b").setStartPoint(c1.name()).call(); ObjectId c3 = modify("ccc"); <|startfocus|> git.merge().include(c2).call(); ObjectId c4 = head(); <|endfocus|> assertNameStartsWith(c4, "119892b"); assertEquals("t2-2-g119892b", describe(c4)); // 2 commits: c4 and c3 assertNameStartsWith(c3, "0244e7f"); assertEquals("t1-1-g0244e7f", describe(c3)); } private ObjectId modify(String content) throws Exception { File a = new File(db.getWorkTree(),"a.txt"); touch(a, content); git.commit().setAll(true).setMessage(content).call(); return head(); } 
<|startcomment|> why do you create a String here? Is it even gonna work with an empty array? Why not use new ByteArrayInputStream(new byte[10]) or something? <|endcomment|>  public InputSource resolveEntity(String publicId, String systemId) { <|startfocus|> String empty = ""; //$NON-NLS-1$ ByteArrayInputStream bais = new ByteArrayInputStream(empty.getBytes()); return new InputSource(bais); <|endfocus|>
<|startcomment|> Would be better to use EModelService.createModelElement(). <|endcomment|>  @Inject private ECommandService commandService; @Inject private CommandManager commandManager; @Inject private MApplication application; @Inject private IEventBroker broker; private Category undefinedCategory; private EventHandler additionHandler; private ICommandManagerListener cmListener; /** * @param cmd * @param categoryModel * @return a command model element * @throws NotDefinedException */ <|startfocus|> public static MCommand createCommand(Command cmd, final MCategory categoryModel) throws NotDefinedException { MCommand command = CommandsFactoryImpl.eINSTANCE.createCommand(); <|endfocus|> command.setElementId(cmd.getId()); command.setCategory(categoryModel); command.setCommandName(cmd.getName()); command.setDescription(cmd.getDescription()); // deal with parameters // command.getParameters().addAll(parameters); IParameter[] cmdParms = cmd.getParameters(); if (cmdParms != null) { for (IParameter cmdParm : cmdParms) { MCommandParameter parmModel = CommandsFactoryImpl.eINSTANCE .createCommandParameter(); parmModel.setElementId(cmdParm.getId()); parmModel.setName(cmdParm.getName()); parmModel.setOptional(cmdParm.isOptional());
<|startcomment|> It'd be safer to use a real object than a 'null'. Especially with a List, you can use a final List and call .clear() to make a new empty array. <|endcomment|>  * * @since 2.1 */ public class TimeGraphEntry implements ITimeGraphEntry { /** Entry's parent */ private TimeGraphEntry fParent = null; /** List of child entries */ private final List<TimeGraphEntry> fChildren = new ArrayList<TimeGraphEntry>(); /** Name of this entry (text to show) */ private String fName; private long fStartTime = -1; private long fEndTime = -1; <|startfocus|> private List<ITimeEvent> fEventList = null; <|endfocus|> private List<ITimeEvent> fZoomedEventList = null; /** * Constructor * * @param name * The name of this entry * @param startTime * The start time of this entry * @param endTime * The end time of this entry */ public TimeGraphEntry(String name, long startTime, long endTime) { fName = name; fStartTime = startTime; fEndTime = endTime; } // --------------------------------------------- // Getters and setters // --------------------------------------------- @Override
<|startcomment|> Please add //$NON-NLS-1$ <|endcomment|>  for(int i = 0; i < options.getExecutionsNumber(); i++){ if (i!=0) argArray.add(APPEND); String[] arguments = new String[argArray.size()]; arguments = argArray.toArray(arguments); try { process = RuntimeProcessFactory.getFactory().exec(arguments, OprofileProject.getProject()); } catch (IOException e1) { process.destroy(); <|startfocus|> Status status = new Status(IStatus.ERROR, OprofileLaunchPlugin.PLUGIN_ID, OprofileLaunchMessages.getString("oprofilelaunch.error.interrupted_error.status_message")); <|endfocus|> throw new CoreException(status); } DebugPlugin.newProcess( launch, process, renderProcessLabel( exePath.toOSString() ) ); try{ process.waitFor(); } catch (InterruptedException e){ process.destroy(); Status status = new Status(IStatus.ERROR, OprofileLaunchPlugin.PLUGIN_ID, OprofileLaunchMessages.getString("oprofilelaunch.error.interrupted_error.status_message")); throw new CoreException(status); } } } postExec(options, daemonEvents, process); } protected abstract boolean preExec(LaunchOptions options, OprofileDaemonEvent[] daemonEvents, ILaunch launch); 
<|startcomment|> spaces around - <|endcomment|>  private void moveBuckets(int offset) { <|startfocus|> for(int i = fNbBuckets - 1; i >= offset; i--) { fBuckets[i] = fBuckets[i-offset]; fLostEventsBuckets[i] = fLostEventsBuckets[i-offset]; <|endfocus|> } for (int i = 0; i < offset; i++) { fBuckets[i] = 0; fLostEventsBuckets[i] = 0; }
<|startcomment|> Is the commented out code needed? <|endcomment|>  } } break; case ID: break; case DOCUMENT_APPLICABILITY: break; case VERIFICATION_CRITERIA: break; case PARENT_ID: /************** * TODO: Requirements trace GUID<-->GUID pair. Need an example */ break; case CHANGE_STATUS: case OBJECT_HEADING: case OBJECT_TEXT: case CHANGE_RATIONALE: case LINKS: case OBJECT_NUMBER: case IS_REQ: case PARAGRAPH_HEADING: case OTHER: break; <|startfocus|> } <|endfocus|> if (inArtifact) { ListIterator<String> iter = theArtifact.listIterator(rowIndex); String theColumnValue = iter.next(); theColumnValue += "\n" + rowValue; iter.set(theColumnValue); } else { theArtifact.add(rowValue); } } } inArtifact = true; } private void processArtifact() throws OseeCoreException { RoughArtifact roughArtifact = new RoughArtifact(RoughArtifactKind.PRIMARY); roughArtifact.setSectionNumber(paragraphNumber);
<|startcomment|> Looks like this doesn't need to be a field anymore. <|endcomment|>  private SashForm stagingSashForm; private IndexDiffChangedListener myIndexDiffListener = new IndexDiffChangedListener() { public void indexDiffChanged(Repository repository, IndexDiffData indexDiffData) { reload(repository); } }; private IndexDiffCacheEntry cacheEntry; private UndoRedoActionGroup undoRedoActionGroup; private Button commitButton; private Button commitAndPushButton; private Section rebaseSection; private Button rebaseContinueButton; private Button rebaseSkipButton; private Button rebaseAbortButton; private ListenerHandle refsChangedListener; <|startfocus|> private Composite buttonsContainer; <|endfocus|> private LocalResourceManager resources = new LocalResourceManager( JFaceResources.getResources()); private Image getImage(ImageDescriptor descriptor) { return (Image) this.resources.get(descriptor); } @Override public void createPartControl(Composite parent) { GridLayoutFactory.fillDefaults().applyTo(parent); toolkit = new FormToolkit(parent.getDisplay()); parent.addDisposeListener(new DisposeListener() { public void widgetDisposed(DisposeEvent e) { resources.dispose(); toolkit.dispose(); } }); form = toolkit.createForm(parent); 
<|startcomment|> Is this case necessary? <|endcomment|>  public String getColumnText(MyModel element, int columnIndex) { <|startfocus|> if (element instanceof MyModel) { switch (columnIndex) { case 0: return ((MyModel)element).col1; case 1: return ((MyModel)element).col2; } <|endfocus|> } return "";
<|startcomment|> I think this is still flawed. If the reason putArchiveEntry() throws is also going to cause closeArchiveEntry() to throw we still lose the original exception and get get something from the closeArchiveEntry() instead. <|endcomment|>  out.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX); return out; } public void putEntry(ArchiveOutputStream out, String path, FileMode mode, ObjectLoader loader) throws IOException { if (mode == FileMode.SYMLINK) { final TarArchiveEntry entry = new TarArchiveEntry( path, TarConstants.LF_SYMLINK); entry.setLinkName(new String( loader.getCachedBytes(100), "UTF-8")); //$NON-NLS-1$ <|startfocus|> try { out.putArchiveEntry(entry); } finally { out.closeArchiveEntry(); } <|endfocus|> return; } final TarArchiveEntry entry = new TarArchiveEntry(path); if (mode == FileMode.REGULAR_FILE || mode == FileMode.EXECUTABLE_FILE) { entry.setMode(mode.getBits()); } else { // TODO(jrn): Let the caller know the tree contained // an entry with unsupported mode (e.g., a submodule). } entry.setSize(loader.getSize()); try { out.putArchiveEntry(entry); loader.copyTo(out); } finally { out.closeArchiveEntry(); } } 
<|startcomment|> Usage should not describe syntax but what the value is for (semantics). Meta-var might be "GROUP_ID:ARTIFACT_ID:VERSION" or (shorter) "COORDINATE" <|endcomment|>  @Option(name = "-u", metaVar = "<URL>", handler = ExtURLOptionHandler.class, usage = "Uploads the generated javadoc output to the repository (as jar with classifier javadoc)") private URL uploadRepo; @Option(name = "-highlight", usage = "Should Livedoc highlight its output with a yellow background?") private boolean highlight; <|startfocus|> @Argument(index = 0, metaVar = "[MavenCoordinate]", required = true, usage = "<GroupId>:<ArtifactId>:<Version>", handler = ArtifactOptionHandler.class) <|endfocus|> private Artifact coordinate; @Option(name = "-t", handler = StringArrayOptionHandler.class, metaVar = "\"ovrm, ovrp, ...\"", usage = "Choose Recommenders Taglets (Default: Use all registered Taglets): \n ovrm: Method Overrides \n ovrp: Method Override Patterns") private String[] taglets; public boolean isVerbose() { return verbose; } public String getPackages() { return packages; } public Artifact getCoordinate() { return coordinate; } public File getOutputDir() { return outputDir;
<|startcomment|> Likewise, keep original author name. <|endcomment|>  * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.emf.compare.internal; import java.util.Collection; import org.eclipse.emf.common.notify.Notification; import org.eclipse.emf.common.notify.Notifier; import org.eclipse.emf.ecore.util.ECrossReferenceAdapter; /** * Abstract class that redefines {@link #handleContainment(org.eclipse.emf.common.notify.Notification)} to * mimic {@link org.eclipse.emf.ecore.util.EContentAdapter} behavior. <|startfocus|> * * @author <a href="mailto:mikael.barbero@obeo.fr">Mikael Barbero</a> <|endfocus|> */ public abstract class AbstractCompareECrossReferencerAdapter extends ECrossReferenceAdapter { /** * {@inheritDoc} * * @see org.eclipse.emf.ecore.util.ECrossReferenceAdapter#handleContainment(org.eclipse.emf.common.notify.Notification) */ @Override protected void handleContainment(Notification notification) { // Handle eventype the same way as EContentAdapter. // This cross referencer adapter should not let client find object if they have been deleted at a // given time. // CHECKSTYLE:OFF copy past from EContentAdapter#handleContainment(Notification)
<|startcomment|> add author <|endcomment|>  * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Boeing - initial API and implementation *******************************************************************************/ package org.eclipse.osee.ats.core.config; import java.util.Collection; import org.eclipse.osee.ats.api.ai.IAtsActionableItem; import org.eclipse.osee.ats.api.team.IAtsTeamDefinition; import org.eclipse.osee.framework.core.exception.OseeCoreException; <|startfocus|> <|endfocus|> public class TeamDefinitionUtility implements ITeamDefinitionUtility { @Override public Collection<IAtsTeamDefinition> getImpactedTeamDefs(Collection<IAtsActionableItem> aias) throws OseeCoreException { return TeamDefinitions.getImpactedTeamDefs(aias); } } 
<|startcomment|> This could become 'return false;' and the final statement could be 'return true;' , eliminating the need for 'rc'. <|endcomment|>  return false; } IContainer container = original.getParent(); IResource resourceToOpen = container.findMember(fileName); IFile file = null; if (resourceToOpen == null) { IResource sourcesFolder = container.getProject().findMember( "SOURCES"); //$NON-NLS-1$ file = container.getFile(new Path(fileName)); if (sourcesFolder != null) { file = ((IFolder) sourcesFolder).getFile(new Path(fileName)); } if (!file.exists()) { <|startfocus|> rc = false; <|endfocus|> } } return rc;
<|startcomment|> Change this condition to "candidateIsDelete" (the one we moved out of the if) <|endcomment|>  && !candidateIsDelete && matchingIndices(comparison, diff.getMatch(), diff.getReference(), diff.getValue(), candidate.getValue())) { kind = ConflictKind.PSEUDO; } } conflictOn(comparison, diff, candidate, kind); } else if (diff.getKind() == DifferenceKind.DELETE) { /* * We removed an element from its containment difference, but it has been used in some way on the * other side. */ <|startfocus|> if (candidate.getKind() == DifferenceKind.DELETE) { <|endfocus|> // No conflict here } else if (isDiffOfPseudoDeleteConflict(candidate)) { // No conflict here between the given diff and this candidate that is a diff of a pseudo // delete conflict } else { // Be it added, moved or changed, this is a REAL conflict conflictOn(comparison, diff, candidate, ConflictKind.REAL); } }
<|startcomment|> defaultOverwrite could be null here Remove extra parentheses in (configuration.isDefault()) <|endcomment|>  } private static <T> List<T> loadFixtures(List<FixtureConfiguration> configurations, Class<T> clazz, String fixtureType, boolean defaultOnly) { List<T> result = new ArrayList<T>(); String defaultOverwrite = System.getProperty("defaultOverwrite", ""); for (FixtureConfiguration configuration : configurations) { if (configuration != null && fixtureType.equals(configuration.getType()) <|startfocus|> && (!defaultOnly || (defaultOverwrite.equals("") && (configuration.isDefault())) || (configuration.url.equals(defaultOverwrite)))) { <|endfocus|> try { Constructor<T> constructor = clazz.getConstructor(FixtureConfiguration.class); result.add(constructor.newInstance(configuration)); } catch (Exception e) { throw new RuntimeException("Unexpected error creating test fixture", e); } } } return result; } private static List<FixtureConfiguration> getConfigurations(String url) { try { URLConnection connection = new URL(url).openConnection(); InputStreamReader in = new InputStreamReader(connection.getInputStream()); try { TypeToken<List<FixtureConfiguration>> type = new TypeToken<List<FixtureConfiguration>>() { };
<|startcomment|> This should remain private. It can be easily obtained by any class using : getServicesTracker().getService(IMICommandControl.class).getCommandFactory(); <|endcomment|>  * @DsfServiceEventHandler * public void eventDispatched(ExpressionChangedEvent e) { * IExpressionDMContext context = e.getDMContext(); * // do something... * } */ protected static class ExpressionChangedEvent extends AbstractDMEvent<IExpressionDMContext> implements IExpressionChangedDMEvent { public ExpressionChangedEvent(IExpressionDMContext context) { super(context); } } /** * @since 4.3 */ protected CommandCache fExpressionCache; /** * @since 4.3 */ <|startfocus|> protected CommandFactory fCommandFactory; <|endfocus|> private MIVariableManager varManager; /** * Indicates that we are currently visualizing trace data. * In this case, some errors should not be reported. */ private boolean fTraceVisualization; public MIExpressions(DsfSession session) { super(session); } /** * This method initializes this service. * * @param requestMonitor * The request monitor indicating the operation is finished */ @Override public void initialize(final RequestMonitor requestMonitor) {
<|startcomment|> Lets better call it skip instead of delete. The commit is not deleted but skipped, and rebase skip does the same in case of a stopped rebase. <|endcomment|>  return true; } @Override public int hashCode() { return super.hashCode(); } } /** * Wraps {@link Action} and additionally provides * {@link ElementAction#DELETE} */ public enum ElementAction { /** * The {@link PlanElement} will not be cherry-picked, i.e. changes are * lost on the new branch. Internally this is mapped to * {@link Action#COMMENT}, to comment out a {@link RebaseTodoLine} */ <|startfocus|> DELETE, <|endfocus|> /** * Equivalent to {@link Action#EDIT}; */ EDIT, /** * Equivalent to {@link Action#PICK}; */ PICK, /** * Equivalent to {@link Action#SQUASH}; */ SQUASH, /** * Equivalent to {@link Action#FIXUP}; */ FIXUP, /** * Equivalent to {@link Action#REWORD}; */ REWORD; } /** * The type of an {@link PlanElement} */ public static enum ElementType { /**
<|startcomment|> consider throwing state exception with this text <|endcomment|>  public void remove() { <|startfocus|> // This method has no effect and should never be called <|endfocus|>
<|startcomment|> here also the synchronized is not needed. And in fact I think it could lead to a deadlock, if one thread comes in here and stays on the .wait, it keeps the lock. Then another thread calling resume() would get stuck on the synchronized {} <|endcomment|>  fRequest.cancel(); return; } try { // Get the ordered events ITmfEvent event = fProvider.getNext(context); TmfCoreTracer.traceRequest(fRequest, "read first event"); //$NON-NLS-1$ while (event != null && !fProvider.isCompleted(fRequest, event, nbRead)) { TmfCoreTracer.traceEvent(fProvider, fRequest, event); if (fRequest.getDataType().isInstance(event)) { fRequest.handleData(event); } // Pause execution if requested <|startfocus|> synchronized (fSynchObject) { while (fIsPaused) { <|endfocus|> try { fSynchObject.wait(); } catch (InterruptedException e) { // continue } } } // To avoid an unnecessary read passed the last event requested if (++nbRead < nbRequested) { event = fProvider.getNext(context); } } isCompleted = true; if (fRequest.isCancelled()) { fRequest.cancel(); } else { fRequest.done(); } } catch (Exception e) {
<|startcomment|> I think the filter should be part of the TmfTraceContext. Please move it there. <|endcomment|>  private TmfTraceManager() { <|startfocus|> fTraces = new LinkedHashMap<ITmfTrace, TmfTraceContext>(); fFilters = new LinkedHashMap<ITmfTrace, ITmfFilter>(); <|endfocus|> TmfSignalManager.registerVIP(this);
<|startcomment|> Why call a private method that calls another private method with the same name and almost identical parameters. Can the functionality go in the one method and the "middle-man" method be removed? <|endcomment|>  super(guid, branch, artifactType); } public void initializeNewStateMachine(List<? extends IAtsUser> assignees, Date createdDate, IAtsUser createdBy) throws OseeCoreException { initializeNewStateMachine(getWorkDefinition(), assignees, createdDate, createdBy); } <|startfocus|> private void initializeNewStateMachine(IAtsWorkDefinition workDefinition, List<? extends IAtsUser> assignees, Date createdDate, IAtsUser createdBy) throws OseeCoreException { initializeNewStateMachine(workDefinition, assignees, createdDate, createdBy, null); } <|endfocus|> private void initializeNewStateMachine(IAtsWorkDefinition workDefinition, List<? extends IAtsUser> assignees, Date createdDate, IAtsUser createdBy, IAtsChangeSet changes) throws OseeCoreException { IAtsStateDefinition startState = workDefinition.getStartState(); StateManagerUtility.initializeStateMachine(getStateMgr(), startState, assignees, (createdBy == null ? AtsClientService.get().getUserAdmin().getCurrentUser() : createdBy), changes); IAtsUser user = createdBy == null ? AtsClientService.get().getUserAdmin().getCurrentUser() : createdBy; setCreatedBy(user, true, createdDate);
<|startcomment|> remove <|endcomment|>  if (data == null) { request.handleData(null); } else { long start = request.getIndex(); long end = start + request.getNbRequested(); if (!request.isCompleted() && index >= start && index < end) { ITmfTimestamp ts = data.getTimestamp(); if (request.getRange().contains(ts)) { if (request.getDataType().isInstance(data)) { request.handleData(data); } } } } } } <|startfocus|> // ------------------------------------------------------------------------ // ITmfEventRequest // ------------------------------------------------------------------------ <|endfocus|> @Override public void start() { for (ITmfEventRequest request : fRequests) { if (!request.isCompleted()) { request.start(); } } super.start(); } @Override public void done() { for (ITmfEventRequest request : fRequests) { if (!request.isCompleted()) { request.done(); } } super.done(); } @Override public void fail() { for (ITmfEventRequest request : fRequests) { request.fail(); } super.fail();
<|startcomment|> Can you update the javadoc to match -gdb-show language? <|endcomment|> ***************************************************************************** * Copyright (c) 2013 AdaCore and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Philippe Gil (AdaCore) - Initial API and implementation *******************************************************************************/ package org.eclipse.cdt.dsf.mi.service.command.output; /** <|startfocus|> * 'show language' returns the current source language. <|endfocus|> * * sample output: * * (gdb) set language c * (gdb) show language * The current source language is "c". * Warning: the current language does not match this frame. * * (gdb) set language auto * (gdb) show language * The current source language is "auto; currently ada". * * (gdb) set language local * (gdb) show language * The current source language is "auto; currently ada". * * (gdb) help set language
<|startcomment|> s/different// remove the extra blank line <|endcomment|> import org.eclipse.jface.layout.GridDataFactory; import org.eclipse.jgit.api.ResetCommand.ResetType; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.lib.Repository; import org.eclipse.osgi.util.NLS; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.ISharedImages; import org.eclipse.ui.PlatformUI; /** <|startfocus|> * Offer different options to cleanup uncommitted changes * <|endfocus|> */ public class CleanupUncomittedChangesDialog extends MessageDialog { private static final Image INFO = PlatformUI.getWorkbench() .getSharedImages().getImage(ISharedImages.IMG_OBJS_INFO_TSK); private final Repository repository; private List<String> fileList; private boolean shouldContinue = false; /** * @param shell * @param dialogTitle * @param dialogMessage * @param repository * @param fileList */ public CleanupUncomittedChangesDialog(Shell shell, String dialogTitle,
<|startcomment|> missing blank after , <|endcomment|>  // not possible. int newMode = mergeFileModes(modeB, modeO, modeT); if (newMode != FileMode.MISSING.getBits()) { if (newMode == modeO) // ours version is preferred keep(ourDce); else { // the preferred version THEIRS has a different mode // than ours. Check it out! if (isWorktreeDirty(tw, work)) { <|startfocus|> failingPaths.put(tw.getPathString(),MergeFailureReason.DIRTY_WORKTREE); <|endfocus|> return false; } // we know about length and lastMod only after we have written the new content. // This will happen later. Set these values to 0 for know. DirCacheEntry e = add(tw.getRawPath(), theirs, DirCacheEntry.STAGE_0, 0, 0); toBeCheckedOut.put(tw.getPathString(), e); } return true; } else { // FileModes are not mergeable. We found a conflict on modes. // For conflicting entries we don't know lastModified and length.
<|startcomment|> trailing whitespace <|endcomment|>  static final RebaseResult INTERACTIVE_PREPARED_RESULT = new RebaseResult( Status.INTERACTIVE_PREPARED); private final Status status; private final RevCommit currentCommit; private Map<String, MergeFailureReason> failingPaths; private List<String> conflicts; private RebaseResult(Status status) { this.status = status; currentCommit = null; } private RebaseResult(Status status, RevCommit commit) { this.status = status; currentCommit = commit; } /** * Create <code>RebaseResult</code> <|startfocus|> * <|endfocus|> * @param status * @param commit * current commit * @return the RebaseResult */ static RebaseResult result(RebaseResult.Status status, RevCommit commit) { return new RebaseResult(status, commit); } /** * Create <code>RebaseResult</code> with status {@link Status#FAILED} * * @param failingPaths * list of paths causing this rebase to fail * @return the RebaseResult */ static RebaseResult failed( Map<String, MergeFailureReason> failingPaths) {
<|startcomment|> No, keep the timeout, a failed test is MUCH better than a hanging build. <|endcomment|> import org.eclipse.linuxtools.ctf.core.trace.CTFTraceReader; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Parameterized test class running the CTF Test Suite * * (from https://github.com/efficios/ctf-testsuite). * * @author Alexandre Montplaisir */ @RunWith(Parameterized.class) public class CtfTestSuiteTests { // // /** Time-out tests after 10 seconds. */ // @Rule // public TestRule globalTimeout = new Timeout(10000); <|startfocus|> <|endfocus|> private static final String basePath = "traces/ctf-testsuite/tests/1.8/"; private final String fTracePath; private final boolean fExpectSuccess; // ------------------------------------------------------------------------ // Methods for the Parametrized runner // ------------------------------------------------------------------------ /** * Get the existing trace paths in the CTF-Testsuite git tree. * * @return The list of CTF traces (directories) to test */ @Parameters(name = "{index}: {0}") public static Iterable<Object[]> getTracePaths() {
<|startcomment|> private final <|endcomment|>  if (r.intersects(newRange)) { return false; } } ranges.add(newRange); return true; } /** * Return the first label that matches a value * * @param value * the value to query * @return the label corresponding to that value */ public String query(long value) { for (Range r : ranges) { if (r.intersects(value)) { return r.str; } } return null; } } <|startfocus|> private class Range { <|endfocus|> final private long low, high; final private String str; public Range(long low, long high, String str) { this.low = low; this.high = high; this.str = str; } public boolean intersects(long i) { return (i >= this.low) && (i <= this.high); } public boolean intersects(Range other) { return this.intersects(other.low) || this.intersects(other.high); } } @Override public String toString() {
<|startcomment|> idem <|endcomment|>  /** * State System Module for lttng kernel traces * * @author Genevive Bastien */ public class LttngKernelAnalysisModule extends TmfStateSystemAnalysisModule { /** * The file name of the History Tree */ public final static String HISTORY_TREE_FILE_NAME = "stateHistory.ht"; //$NON-NLS-1$ /** The ID of this analysis module */ <|startfocus|> public final static String ID = "org.eclipse.linuxtools.lttng2.kernel.analysis"; //$NON-NLS-1$ <|endfocus|> /** * Constructor adding the views to the analysis */ public LttngKernelAnalysisModule() { super(); this.registerOutput(new TmfAnalysisViewOutput(ControlFlowView.ID)); this.registerOutput(new TmfAnalysisViewOutput(ResourcesView.ID)); } @Override protected @NonNull ITmfStateProvider createStateProvider() { ITmfTrace trace = getTrace(); if (!(trace instanceof LttngKernelTrace)) { throw new IllegalStateException("LttngKernelStateSystemModule: trace should be of type LttngKernelTrace"); //$NON-NLS-1$ } return new LttngKernelStateProvider((LttngKernelTrace) trace); } @Override
<|startcomment|> Are you sure? Implied parentheses are a || (b && !c) And as far as I know, constructors are never abstract. <|endcomment|>  return true; } @Override public String getName() { return "ovrm"; } @Override public TagletOutput getTagletOutput(Tag tag, TagletWriter writer) throws IllegalArgumentException { throw new UnsupportedOperationException(); } @Override public TagletOutput getTagletOutput(Doc holder, TagletWriter writer) throws IllegalArgumentException { if (holder.isClass()) { return generateClassDoc((ClassDoc) holder, writer); <|startfocus|> } else if (holder.isMethod() || holder.isConstructor() && !((MethodDoc) holder).isAbstract()) { <|endfocus|> return generateMethodDoc((MethodDoc) holder, writer); } else if (holder instanceof PackageDoc) { return generatePackageDoc((PackageDoc) holder, writer); } return null; } private TagletOutput generatePackageDoc(PackageDoc packageDoc, TagletWriter writer) { StringBuilder sb = new StringBuilder(); sb.append("<h2 style=\"font-size:200%; color:blue\" title=").append("\"Code Recommenders\">") .append("Code Recommenders").append("</h2>")
<|startcomment|> If you don't use them in the code, setters are not required for dependency-injected mojo fields so you could probably remove them. <|endcomment|>  * @parameter expression="${tocOptions}" */ private TocOptions tocOptions = new TocOptions (); /** * The output location of the toc file.<br/> * This file will be overwritten. * @parameter required=false, default-value="${project.build.directory}/tocjavadoc.xml", expression="${tocFile}" */ private File tocFile; /** * @component */ private BundleReader bundleReader; <|startfocus|> public void setTocOptions ( TocOptions tocOptions ) { this.tocOptions = tocOptions; } public void setSourceTypes ( final Set<String> sourceTypes ) { <|endfocus|> this.sourceTypes = sourceTypes; } public void setScopes ( final Set<String> scopes ) { this.scopes = scopes; } public void setJavadocOptions ( final JavadocOptions javadocOptions ) { this.javadocOptions = javadocOptions; } public void execute () throws MojoExecutionException { getLog ().info ( "Scopes: " + this.scopes ); getLog ().info ( "Output directory: " + this.outputDirectory );
<|startcomment|> I'd rather use an enumeration type here. <|endcomment|> <|startfocus|> public static String createLocaleSpecificNumberString(Locale loc, boolean minus, String integerPart, String fractionPart, int percent) { <|endfocus|> DecimalFormatSymbols symbols = ((DecimalFormat) DecimalFormat.getPercentInstance(loc)).getDecimalFormatSymbols(); StringBuilder sb = new StringBuilder(); if (minus) { sb.append(symbols.getMinusSign()); } sb.append(integerPart); if (fractionPart != null) { sb.append(symbols.getDecimalSeparator()).append(fractionPart); } if (percent == 2) { sb.append(" "); } if (percent == 1 || percent == 2) { sb.append(symbols.getPercent()); } return sb.toString();
<|startcomment|> Instead of sending the files before the report, I would collect the prcIds into a list since it is probably smaller in memory size than the report, and then process the pcr id list after the report has been sent. <|endcomment|>  File file = new File(serverData + CHANGE_REPORTS_PATH + pcrFileName); if (file.exists()) { try { zout.putNextEntry(new ZipEntry("changeReports/" + pcrFileName)); zout.write(Lib.fileToBytes(file)); zout.closeEntry(); } catch (IOException ex) { OseeExceptions.wrapAndThrow(ex); } } } }; <|startfocus|> createTraceReport(buildId, programName, buildName, AtsElementData.ARCHIVE_URL_TEMPLATE, collector, tableStream); zout.putNextEntry(new ZipEntry(fileName + ".html")); tableStream.writeTo(zout); zout.closeEntry(); zout.close(); <|endfocus|> } }).header("Content-Disposition", contentDisposition).build(); } @GET @Path("{programId}/{buildId}") @Produces(MediaType.TEXT_HTML)
<|startcomment|> I had to get Leo to explain this to me. Maybe change the comment to "Protect against case where java.sql.Timestamp is used" <|endcomment|>  protected EClass eStaticClass() { return ReviewsPackage.Literals.CHANGE; } /** * <!-- begin-user-doc --> <!-- end-user-doc --> * * @generated */ public Date getCreationDate() { return creationDate; } /** * <!-- begin-user-doc --> <!-- end-user-doc --> * * @generated NOT */ public void setCreationDate(Date newCreationDate) { Date oldCreationDate = creationDate; <|startfocus|> //Protect against case where timestamp is used <|endfocus|> creationDate = new Date(newCreationDate.getTime()); if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, ReviewsPackage.CHANGE__CREATION_DATE, oldCreationDate, creationDate)); } /** * <!-- begin-user-doc --> <!-- end-user-doc --> * * @generated */ public Date getModificationDate() { return modificationDate; } /** * <!-- begin-user-doc --> <!-- end-user-doc --> * * @generated NOT */
<|startcomment|>  Obeo in this case. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2014 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.tools.internal.menu; import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.gmf.runtime.common.ui.services.action.contributionitem.IPopupMenuContributionPolicy; import org.eclipse.gmf.runtime.diagram.ui.editparts.IGraphicalEditPart; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.StructuredSelection; import org.eclipse.sirius.diagram.tools.internal.graphical.edit.part.DDiagramRootEditPart; /** * A PopupMenuContributionPolicy to filter on which edit part the Sirius * popupContribution should be applied. * * @author Florian Barbin * */ public class SiriusPopupMenuContributionPolicy implements IPopupMenuContributionPolicy { @Override public boolean appliesTo(ISelection arg0, IConfigurationElement arg1) {
<|startcomment|> Whitespace. Use 4.4M5 to remove them (before that JDT would add them again)... <|endcomment|>  return getVisibleLinesInViewport(fCachedTextWidget); } /** * Returns <code>true</code> if the viewport displays the entire viewer contents, i.e. the * viewer is not vertically scrollable. * * @return <code>true</code> if the viewport displays the entire contents, <code>false</code> otherwise * @since 3.2 */ protected final boolean isViewerCompletelyShown() { return JFaceTextUtil.isShowingEntireContents(fCachedTextWidget); } /** * Draws the ruler column. <|startfocus|> * <|endfocus|> * @param gc the GC to draw into * @param visibleLines the visible model lines * @since 3.2 */ void doPaint(GC gc, ILineRange visibleLines) { Display display= fCachedTextWidget.getDisplay(); // draw diff info int y= -JFaceTextUtil.getHiddenTopLinePixels(fCachedTextWidget); // If fillerText will be externalized the following lines do make sense. // Otherwise it would be easier just to remove the fillerText variable and write: final String filler = " "; 
<|startcomment|> use ICompareColor instead, it will ease the maintenance <|endcomment|>  * @param style * the style of the control to construct. * @param width * the control's width. * @param treeViewer * the TreeViewer associated with this control. * @param config * the configuration for this control. */ EMFCompareDiffTreeRuler(Composite parent, int style, WrappableTreeViewer treeViewer, DependencyData dependencyData, ColorRegistry registry) { super(parent, style); fTreeViewer = treeViewer; this.dependencyData = dependencyData; <|startfocus|> this.registry = registry; <|endfocus|> updateColors(); annotationsData = Maps.newHashMap(); paintListener = new PaintListener() { public void paintControl(PaintEvent e) { handlePaintEvent(e); } }; addPaintListener(paintListener); mouseClickListener = new MouseListener() { public void mouseUp(MouseEvent e) { handleMouseClickEvent(e); } public void mouseDown(MouseEvent e) { // Do nothing. } public void mouseDoubleClick(MouseEvent e) { // Do nothing. } }; addMouseListener(mouseClickListener); 
<|startcomment|> Please no trailing whitespaces. <|endcomment|>  p.setValue(IDEPreferenceConstants.P_TAPSETS, tapsets + File.pathSeparator + file.getAbsolutePath()); IViewPart ivp = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(FunctionBrowserView.ID); ((FunctionBrowserView)ivp).refresh(); ivp = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findView(ProbeAliasBrowserView.ID); ((ProbeAliasBrowserView)ivp).refresh(); } return null; } @Override public boolean isEnabled() { return true; } <|startfocus|> <|endfocus|> } 
<|startcomment|> The event generating this 'length' is triggered when we change memory (or a variable) from a CLI command i.e., the gdb console. I had made the assumption that the length was in octets but I guess it should be in addressable units, so I think this code must be updated. <|endcomment|>  // it send the potential IMemoryChangedEvent as we will send it ourselves (see below). final IMemoryDMContext memoryDMC = DMContexts.getAncestorOfType(containerDmc, IMemoryDMContext.class); final IAddress address = new Addr64(addr); <|startfocus|> // The length returned by GDB is in bytes, while the memory cache expects // a count of number of addresses of 8 bytes. int count = length/8 + 1; <|endfocus|> getMemoryCache(memoryDMC).refreshMemory(memoryDMC, address, 0, getAddressableSize(memoryDMC), count, false, new RequestMonitor(getExecutor(), null) { @Override protected void handleCompleted() { // Only once the memory cache is updated, we send the IMemoryChangedEvent. If we were to do it // earlier, the memory view may not show the updated value. // // We must always send this event when GDB reports a memory change because it can mean that
<|startcomment|> I understand the HasChildrenAdapter as "we know we have children to create but we need to delay the refresh". 1. I'm not sure the HasChildrenAdapter is well named. 2. When we will effectively do the refresh we will have to recompute the items to add ie to interprete the mapping expressions a second time. <|endcomment|>  update(createdOutput); } } for (CreatedOutput outDesc : plan.getDescriptorToUpdateMapping()) { outDesc.updateMapping(); outDesc.refresh(); } for (CreatedOutput outDesc : descriptorsToRefresh) { outDesc.refresh(); } } else { if (childSupport.some()) { int nbChild = descriptorsToRefresh.size() - descriptorsToDelete.size() + descriptorsToCreate.size(); boolean willHaveChildren = nbChild > 0; EObject createdElement = container.getCreatedElement(); if (createdElement != null) { <|startfocus|> Adapter adapter = EcoreUtil.getAdapter(createdElement.eAdapters(), HasChildrenAdapter.class); <|endfocus|> if (willHaveChildren && adapter == null) { createdElement.eAdapters().add(new HasChildrenAdapter()); } else if (!willHaveChildren && adapter != null) { createdElement.eAdapters().remove(adapter); } } } }
<|startcomment|> Do we need empty function? Am I getting it wrong? <|endcomment|>  /* clear the menu */ long /*int*/ children = OS.gtk_container_get_children (webkit_menu); long /*int*/ current = children; while (current != 0) { long /*int*/ item = OS.g_list_data (current); OS.gtk_container_remove (webkit_menu, item); current = OS.g_list_next (current); } OS.g_list_free (children); } return 0; } <|startfocus|> long webkit_resource_load_started (long /*int*/ web_view, long /*int*/ resource, long /*int*/ request) { return 0; } <|endfocus|> private void addRequestHeaders(long /*int*/ requestHeaders, String[] headers){ for (int i = 0; i < headers.length; i++) { String current = headers[i]; if (current != null) { int index = current.indexOf (':'); if (index != -1) { String key = current.substring (0, index).trim (); String value = current.substring (index + 1).trim (); if (key.length () > 0 && value.length () > 0) {
<|startcomment|> I would change the message string to start with "getControl() ... " -> note the brackets after the function name. The same style with brackets is used for "setControl()" text in the message, so please make it consistent. <|endcomment|>  public void createPageControls(Composite pageContainer) { // the default behavior is to create all the pages controls for (int i = 0; i < pages.size(); i++) { IWizardPage page = pages.get(i); page.createControl(pageContainer); // page is responsible for ensuring the created control is // accessible // via getControl. Assert.isNotNull( page.getControl(), <|startfocus|> "getControl of wizard page returns null. Did you call setControl() in your wizard page?"); //$NON-NLS-1$ <|endfocus|> }
<|startcomment|> getHighestRankingProvider is called way to much and in performance critical loops (like millions of calls during a comparison). It's implementation does not look sustainable if called like that (I just had a quick look but it seems to me the extension point is going to be parsed and parsed and parsed again), Calling it for each EObject might be something overkill too. In my understanding a weightprovider scope is an nsURI. I added this commit here but it's scattered accross the change. <|endcomment|>  public void referenceChange(Match match, EReference reference, EObject value, DifferenceKind kind, DifferenceSource source) { if (!alreadyChanged.contains(reference)) { switch (kind) { case MOVE: <|startfocus|> distance += weightProviderRegistry.getHighestRankingWeightProvider(reference) .getWeight(reference) <|endfocus|> * orderChangeCoef; break; case ADD: case DELETE: case CHANGE: distance += weightProviderRegistry.getHighestRankingWeightProvider(reference) .getWeight(reference); break; default: break; } alreadyChanged.add(reference); } else { distance += 1; }
<|startcomment|> Maybe you could extract this magic values to constants. For example: private final long ONE_MIN = 60000l; <|endcomment|>  assertNull(new DateFormatter().formatUnit(null, new Date())); assertNull(new DateFormatter().formatUnit(new Date(), null)); } @Test public final void formatMinutes() { String minuteConverter = new DateFormatter().formatUnit(new Date(0), new Date(120000)); assertEquals("2 minutes ago", minuteConverter); } @Test <|startfocus|> public final void formatOneMinute() { String minuteConverter = new DateFormatter().formatUnit(new Date(0), new Date(60000)); assertEquals("1 minute ago", minuteConverter); <|endfocus|> } @Test public final void formatOneHours() { String minuteConverter = new DateFormatter().formatUnit(new Date(0), new Date(3600000)); assertEquals("1 hour ago", minuteConverter); } @Test public final void formatHours() { String minuteConverter = new DateFormatter().formatUnit(new Date(0), new Date(7200000)); assertEquals("2 hours ago", minuteConverter); } @Test public final void formatOneDays() {
<|startcomment|> Would it be possible to use CachedCheckboxTreeViewer#getCheckedLeafElements instead? <|endcomment|>  public boolean isElementVisible(Viewer viewer, Object element) { <|startfocus|> if (checkedItems.contains(element)) <|endfocus|> return true; return super.isElementVisible(viewer, element);
<|startcomment|> I'd rather we create the variable here instead of storing it as an instance variable. Remove the package protected "root" variable and initialize it here instead. <|endcomment|>  while (candidatesIterator.hasNext()) { final IStorage candidate = candidatesIterator.next(); final String candidateName = candidate.getName(); if (referenceName.equals(candidateName)) { candidatesIterator.remove(); return candidate; } } return null; } /** * Check if the given IStrorage exists in the workspace or not. * * @return true, if the given IStorage exists in the workspace, false otherwise. */ <|startfocus|> boolean isInWorkspace(IStorage storage) { <|endfocus|> if (root != null) { if (root.getFile(storage.getFullPath()).exists()) { return true; } } return false; } } 
<|startcomment|> Avoid calling getOverload twice. <|endcomment|>  public boolean isConstantExpression(IASTNode point) { return fArg1.isConstantExpression(point) && fArg2.isConstantExpression(point) <|startfocus|> && (getOverload(point) == null || getOverload(point).isConstexpr()); <|endfocus|>
<|startcomment|> I'd use SwingConstants.TOP, etc. <|endcomment|>  public void testVerticalAlignment() { <|startfocus|> m_label.setVerticalAlignmentFromScout(0); <|endfocus|> String text = ((JTextPane) m_label.getSwingField()).getText(); assertTrue(text.contains("valign=\"middle\"")); m_label.setVerticalAlignmentFromScout(-1); text = ((JTextPane) m_label.getSwingField()).getText(); assertTrue(text.contains("valign=\"top\"")); m_label.setVerticalAlignmentFromScout(1); text = ((JTextPane) m_label.getSwingField()).getText(); assertTrue(text.contains("valign=\"bottom\""));
<|startcomment|> Should we drop "current" from the test names? It doesn't mean anything to me... <|endcomment|> <|startfocus|> public void testGetProposalsCurrentTask() { <|endfocus|> MockTask task = new MockTask(null, "1", null); task.setOwner("foo"); PersonProposalProvider provider = new PersonProposalProvider(task, (TaskData) null); assertProposalsForFoo(provider);
<|startcomment|> No use checking if the list contains() before remove(), let's avoid double iterations. <|endcomment|>  public void removeCompareInputChangeListener(ICompareInputChangeListener listener) { <|startfocus|> if (containsListener(listener)) { listeners.remove(listener); } <|endfocus|>
<|startcomment|> CSSSWTConstants.CSS_ID_KEY <|endcomment|>  /** * Hacks the progress monitor to have absolute positioning for its controls. * In addition, all methods that access the controls will be wrapped in an * asynchExec(). */ class AbsolutePositionProgressMonitorPart extends ProgressMonitorPart { public AbsolutePositionProgressMonitorPart(Composite parent) { super(parent, null); setLayout(null); <|startfocus|> this.setData(CSS_ID_KEY, SPLASH_PROGRESS_PART_ID); fProgressIndicator.setData(CSS_ID_KEY, SPLASH_PROGRESS_INDICATOR_ID); fLabel.setData(CSS_ID_KEY, SPLASH_PROGRESS_TEXT_ID); <|endfocus|> } public ProgressIndicator getProgressIndicator() { return fProgressIndicator; } public Label getProgressText() { return fLabel; } /* (non-Javadoc) * @see org.eclipse.jface.wizard.ProgressMonitorPart#beginTask(java.lang.String, int) */ @Override public void beginTask(final String name, final int totalWork) { updateUI(new Runnable() { @Override public void run() { if (isDisposed()) return; AbsolutePositionProgressMonitorPart.super.beginTask(name, totalWork); }
<|startcomment|> Is the ordering important in the values? If not, you might as well return a Set directly, that would avoid the need to instantiate an arrayList. <|endcomment|> <|startfocus|> public List<String> getValues() { return new ArrayList<>(fValues.keySet()); <|endfocus|>
<|startcomment|> Remove a line here <|endcomment|>  fPlugin.getLog().log(new Status(IStatus.WARNING, PLUGIN_ID, message, exception)); } // ------------------------------------------------------------------------ // Log ERROR // ------------------------------------------------------------------------ /** * Logs a message and exception with severity ERROR in the runtime log of * the plug-in. * * @param message * A message to log */ public static void logError(String message) { fPlugin.getLog().log(new Status(IStatus.ERROR, PLUGIN_ID, message)); } <|startfocus|> <|endfocus|> /** * Logs a message and exception with severity ERROR in the runtime log of * the plug-in. * * @param message * A message to log * @param exception * The corresponding exception */ public static void logError(String message, Throwable exception) { fPlugin.getLog().log(new Status(IStatus.ERROR, PLUGIN_ID, message, exception)); } /** * Gets an image object using given path within plug-in. * * @param path * path to image file *
<|startcomment|> That 3rd one is a weird condition: I cannot add an attribute "0" (the tid) as a subattribute of "0" (the cpu) it throws this exception. Since the asserts did do nothing, I never noticed before. <|endcomment|>  public void addSubAttribute(Attribute newSubAttribute) { <|startfocus|> /* This should catch buggy state changing statements */ if (newSubAttribute == null || newSubAttribute.getName() == null || newSubAttribute.getName().equals(this.getName())) { <|endfocus|> throw new IllegalArgumentException(); } subAttributes.put(newSubAttribute.getName(), newSubAttribute);
<|startcomment|> number of clients? <|endcomment|>  /** Session name, like 'streaming session' */ private byte fSessionName[] = new byte[LTTngViewerCommands.LTTNG_VIEWER_NAME_MAX]; /** * Gets the Id * * @return the Id */ public long getId() { return fId; } /** * Gets the LiveTimer * * @return the LiveTimer */ public int getLiveTimer() { return fLiveTimer; } /** <|startfocus|> * Gets the Clients <|endfocus|> * * @return the Clients */ public int getClients() { return fClients; } /** * Gets the Streams * * @return the Streams */ public int getStreams() { return fStreams; } /** * Gets the Hostname * * @return the Hostname */ public byte[] getHostname() { return fHostname; } /** * Gets the SessionName * * @return the SessionName */ public byte[] getSessionName() { return fSessionName;
<|startcomment|> empty line <|endcomment|>  * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Matthew Khouzam - Initial implementation and API * Marc-Andre Laperle - Initial implementation and API **********************************************************************/ package org.eclipse.linuxtools.internal.lttng2.core.live.relayd.connector.lttngviewerCommands; /** * Get packet return code * @since 3.0 */ <|startfocus|> public enum GetPacketReturnCode implements IBaseCommand { <|endfocus|> /** Response was OK */ VIEWER_GET_PACKET_OK(1), /** Response was RETRY */ VIEWER_GET_PACKET_RETRY(2), /** Response was ERROR */ VIEWER_GET_PACKET_ERR(3), /** Response was End of File */ VIEWER_GET_PACKET_EOF(4); private final int fCode; private GetPacketReturnCode(int c) { fCode = c; } @Override public int getCommand() { return fCode; } } 
<|startcomment|> This method should have a more descriptive name. What happens when another newer Jenkins has to be supported? <|endcomment|> <|startfocus|> public boolean isNewerJenkinsServer() { <|endfocus|> return Type.JENKINS.equals(type) && JENKINS_1_519.compareTo(version) <= 0;
<|startcomment|> all fields could be final. For the Map, maybe add a quick Javadoc what the key/values are, it's not obvious at first glance. <|endcomment|> import org.eclipse.linuxtools.internal.lttng2.core.live.relayd.connector.lttngviewerCommands.TracePacketResponse; import org.eclipse.linuxtools.tmf.core.ctfadaptor.CtfTmfTrace; /** * Consumer of the relay d * * @author Matthew Khouzam * @since 3.0 */ public class LttngRelaydConsumer { private Job fConsumerJob; private final String fAddress; private final int fPort; private final int fSession; private final CtfTmfTrace fCtfTrace; <|startfocus|> private Map<Long, File> fStreams; <|endfocus|> /** * Start a lttng consumer * * @param address * the ip address in string format * @param port * the port, an integer * @param session * the session id * @param ctfTrace * the parent trace */ public LttngRelaydConsumer(String address, final int port, final int session, final CtfTmfTrace ctfTrace) { fAddress = address; fPort = port; fSession = session; fCtfTrace = ctfTrace; fStreams = new TreeMap<>();
<|startcomment|> space before { empty line after <|endcomment|>  * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Matthew Khouzam - Initial implementation and API * Marc-Andre Laperle - Initial implementation and API **********************************************************************/ package org.eclipse.linuxtools.internal.lttng2.core.live.relayd.connector.lttngviewerCommands; /** * Get metadata return code * @since 3.0 */ <|startfocus|> public enum GetMetadataReturnCode implements IBaseCommand{ <|endfocus|> /** Response was OK */ VIEWER_METADATA_OK(1), /** Response was nothing new */ VIEWER_NO_NEW_METADATA(2), /** Response was Error */ VIEWER_METADATA_ERR(3); private final int fCode; private GetMetadataReturnCode(int c) { fCode = c; } @Override public int getCommand() { return fCode; } } 
<|startcomment|> This should also be a LinkedHashMap, so that the order in which the uncommitted changes dialogs appear is predictable. <|endcomment|>  public void run() { <|startfocus|> Map<Repository, Object> res = new HashMap<Repository, Object>( <|endfocus|> PullOperationUI.this.results); Shell shell = PlatformUI.getWorkbench() .getActiveWorkbenchWindow().getShell(); handlePullResults(res, shell);
<|startcomment|> This looks strange: if you remove the call to the abstract method getEClass, then the abstract method will never be called, and the design of this class would make no sense. Why did calling getEClass() make the error happen? Do you have a reproducible example where this bug happened? <|endcomment|>  public void createPartControl(Composite parent) { super.createPartControl(parent); tableFormComposite = tableFormFactory <|startfocus|> .createTableFormMasterDetailComposite(parent, SWT.BORDER); <|endfocus|> tableFormComposite.update(getContents(getResource())); addContextMenu(tableFormComposite.getViewer());
<|startcomment|> Do we need to pass in this context? LocalizationHelper#getLocalized(String, MAppElement) will find the appropriate context. <|endcomment|> import org.eclipse.e4.ui.model.application.descriptor.basic.MPartDescriptor; import org.eclipse.jface.viewers.Viewer; import org.eclipse.ui.dialogs.PatternFilter; /** * A class that handles filtering view node items based on a supplied matching * string. * * @since 3.2 * */ public class ViewPatternFilter extends PatternFilter { private IEclipseContext context; <|startfocus|> /** * Create a new instance of a ViewPatternFilter * * @param context */ public ViewPatternFilter(IEclipseContext context) { this.context = context; } <|endfocus|> @Override public boolean isElementSelectable(Object element) { return element instanceof MPartDescriptor; } @Override protected boolean isLeafMatch(Viewer viewer, Object element) { if (element instanceof String) { return false; } String text = null; if (element instanceof MPartDescriptor) { MPartDescriptor desc = (MPartDescriptor) element; text = LocalizationHelper.getLocalized(desc.getLabel(), desc, context); if (wordMatches(text)) { return true; } } return false; } } 
<|startcomment|> Preconditions.checkNotNull? <|endcomment|> <|startfocus|> public PrivateDatum(String id, String name, String description, ImageDescriptor icon) { <|endfocus|> this.id = id; this.name = name; this.description = description; this.icon = icon;
<|startcomment|> The above call seem useless. Remove? <|endcomment|>  private void createBars() { BarGraphicObject bar; m_container = new VirtualBoundsGraphicObject(); <|startfocus|> m_container.setVirtualBounds(BAR_CONTAINER_BOUNDS); <|endfocus|> m_container.setDrawContainerBounds(false); // The inside of the bars use a proportional width with the maximum width and // the largest amount of markers for one severity. // Find the maximum marker count to dictate the width int maxCount = Math.max(m_markerCount[0], m_markerCount[1]); maxCount = Math.max(maxCount, m_markerCount[2]); if (maxCount == 0) maxCount = 1; // Set to anything but 0. It will be multiplied by 0 and not matter. // go from high severity to low for (int severity = IMarker.SEVERITY_ERROR; severity >= IMarker.SEVERITY_INFO; severity--) { float barPercent = m_markerCount[severity] / (float) maxCount * 100.0f; bar = new BarGraphicObject(severity, Math.round(barPercent)); bar.setVirtualBounds(BARS_VIRTUAL_BOUNDS[severity]);
<|startcomment|> Wrong change. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2014 Red Hat, Inc. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Red Hat - initial API and implementation * IBM Corporation - Jeff Briggs, Henry Hughes, Ryan Morse * (original Action implementation) *******************************************************************************/ package org.eclipse.linuxtools.systemtap.ui.editor.handlers.file; import org.eclipse.linuxtools.internal.systemtap.ui.editor.Localization; import org.eclipse.swt.SWT; /** * A handler that can be used to create a new SystemTap file. * @since 3.0 */ public class NewFileHandler extends OpenFileHandler { @Override protected int dialogStyle() { return SWT.SAVE; } @Override protected String dialogName() { return Localization.getString("NewFileHandler.NewFile"); //$NON-NLS-1$ } } 
<|startcomment|> single // will suffice <|endcomment|>  State state = getStateById(newStateId); if (state != null) { // set transition's results in if (sourceTransition != null && !state.getIncomingTransitions().contains(sourceTransition)) { sourceTransition.setResultsIn(state); state.addInTransition((Transition) sourceTransition); //TODO logger.debug(" Arrived to state " + state.getId() + " " + state); fireTransitionFiredEvent(sourceTransition); } return false; } boolean result; <|startfocus|> /////// create new state <|endfocus|> state = new State(newStateId); // set outgoing transitios for (Object transitionId : outgoingTransitionIds.keySet()) { Transition t = new Transition(transitionId, state, outgoingTransitionIds.get(transitionId)); state.addOutTransition(t); fireNewTransitionEvent(t); // TODO this can be faulty if race is lost. Is this needed? } // set incoming transition if (sourceTransition != null) { state.addInTransition((Transition) sourceTransition); } /////// save new state State elderState = objectToStateMap.putIfAbsent(newStateId, state); // Thread won the state creation
<|startcomment|> nit: we try to avoid curly braces around simple conditionals <|endcomment|>  final TreeWalk walk = new TreeWalk(repo); try { final T outa = fmt.createArchiveOutputStream(out); try { final MutableObjectId idBuf = new MutableObjectId(); final ObjectReader reader = walk.getObjectReader(); final RevWalk rw = new RevWalk(walk.getObjectReader()); walk.reset(rw.parseTree(tree)); if (paths.size() != 0) { walk.setFilter(PathFilterGroup.createFromStrings(paths)); <|startfocus|> } <|endfocus|> while (walk.next()) { final String name = pfx + walk.getPathString(); FileMode mode = walk.getFileMode(0); if (walk.isSubtree()) walk.enterSubtree(); if (mode == FileMode.GITLINK) // TODO(jrn): Take a callback to recurse // into submodules. mode = FileMode.TREE; if (mode == FileMode.TREE) { fmt.putEntry(outa, name + "/", mode, null); continue; } walk.getObjectId(idBuf, 0); fmt.putEntry(outa, name, mode, reader.open(idBuf)); }
<|startcomment|> delete <|endcomment|>  public void keyPressed(KeyEvent e) { <|startfocus|> // // If there has been a key pressed then mark as dirty // entryChanged = true; <|endfocus|> if (e.character == SWT.CR) { // Windows... entryChanged = false; updateFromSourceField(); }
<|startcomment|> why? ctrl+shift+o puts it back the other way <|endcomment|>  * * Contributors: * Matthew Khouzam - Initial API and implementation *******************************************************************************/ package org.eclipse.linuxtools.ctf.core.tests.types; import static org.junit.Assert.*; import java.nio.ByteBuffer; import java.nio.ByteOrder; import org.eclipse.linuxtools.ctf.core.event.io.BitBuffer; import org.eclipse.linuxtools.ctf.core.event.scope.IDefinitionScope; import org.eclipse.linuxtools.ctf.core.event.types.ArrayDeclaration; import org.eclipse.linuxtools.ctf.core.event.types.Encoding; <|startfocus|> import org.eclipse.linuxtools.ctf.core.event.types.ArrayDefinition; <|endfocus|> import org.eclipse.linuxtools.ctf.core.event.types.IDeclaration; import org.eclipse.linuxtools.ctf.core.event.types.IntegerDeclaration; import org.eclipse.linuxtools.ctf.core.event.types.StringDeclaration; import org.eclipse.linuxtools.ctf.core.trace.CTFReaderException; import org.junit.Before; import org.junit.Test; /** * The class <code>ArrayDeclarationTest</code> contains tests for the class * <code>{@link ArrayDeclaration}</code>. * * @author ematkho * @version $Revision: 1.0 $ */ public class ArrayDeclarationTest { private ArrayDeclaration fixture; /**
<|startcomment|> this is already included in validateCoreStashedCommit() <|endcomment|>  commitFile("file.txt", "master", "master"); git.merge().include(side).call(); git.stashCreate().call(); } @Test public void untrackedFileIncluded() throws Exception { String trackedPath = "tracked.txt"; writeTrashFile(trackedPath, "content2"); git.add().addFilepattern(trackedPath).call(); RevCommit stashed = git.stashCreate() .setIncludeUntracked(true).call(); <|startfocus|> assertNotNull(stashed); validateStashedCommitWithAdditionalParent(stashed); <|endfocus|> assertEquals( "Expected commits for workingDir,stashedIndex and untrackedFiles.", 3, stashed.getParentCount()); assertFalse("untracked file should be deleted.", untrackedFile.exists()); } @Test public void untrackedFileNotIncluded() throws Exception { String trackedPath = "tracked.txt"; // at least one modification needed writeTrashFile(trackedPath, "content2"); git.add().addFilepattern(trackedPath).call(); RevCommit stashed = git.stashCreate().call(); assertNotNull(stashed); validateStashedCommit(stashed); assertTrue("untracked file should be left untouched.", untrackedFile.exists());
<|startcomment|> Update copyright range <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2012, 2013 Obeo. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.emf.compare.internal.utils; import static com.google.common.collect.Iterables.addAll; import static com.google.common.collect.Iterables.concat; import com.google.common.base.Function; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Iterables; import java.util.Collection; import java.util.HashSet; import java.util.LinkedHashSet; import org.eclipse.emf.compare.AttributeChange; import org.eclipse.emf.compare.Diff; import org.eclipse.emf.compare.DifferenceKind; import org.eclipse.emf.compare.DifferenceSource; import org.eclipse.emf.compare.Match; import org.eclipse.emf.compare.ReferenceChange; import org.eclipse.emf.compare.utils.ReferenceUtil; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.EStructuralFeature; 
<|startcomment|> Make these fields private final <|endcomment|> import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.MockitoAnnotations; /** * @author Angel Avila */ public class STRSReportTest { @Mock DispoApi dispoApi; @Mock DispoProgram program; @Mock DispoSet set1; @Mock DispoSet set2; <|startfocus|> DispoItemData item1 = new DispoItemData(); DispoItemData item2 = new DispoItemData(); DispoItemData item3 = new DispoItemData(); DispoItemData item4 = new DispoItemData(); <|endfocus|> @Before public void setUp() { MockitoAnnotations.initMocks(this); } @Test public void testReportGeneration() throws Exception { initItems(); STRSReport reportWriter = new STRSReport(dispoApi); List<DispoItem> itemsForPrimary = new ArrayList<DispoItem>(); itemsForPrimary.add(item1); itemsForPrimary.add(item2); Mockito.when(dispoApi.getDispoItems(program, set1.getGuid())).thenReturn(itemsForPrimary); List<DispoItem> itemsForSecondary = new ArrayList<DispoItem>(); itemsForSecondary.add(item1);
<|startcomment|> ruleName is not a very good variable name. What about fullVariable(Name|Rule)? Othwerwise I have a hard time understanding this line alone; I always have to look up what rule is meant a few lines further up. <|endcomment|>  public void testParserFullVariableRule() { TemplateGrammarAccess.FullVariableElements fullVariable = grammarAccess .getFullVariableAccess(); String ruleName = fullVariable.getRule().getName(); String fullVariableArray = "array:array"; // array is both a // FullVariable and a // TemplateVariableID <|startfocus|> testParserRule(fullVariableArray, ruleName); <|endfocus|> String fullVariableNewName = "array_element:newName(array)"; testParserRule(fullVariableNewName, ruleName); String templateVariableID = "argType"; // argType is also a valid // TemplateVariableID testParserRuleErrors(templateVariableID, ruleName, "no viable alternative at input '<EOF>'");
<|startcomment|> The boolean is not needed, use the parent parameter. <|endcomment|>  protected void doExecute() { <|startfocus|> boolean toolToolGroupCreated = false; <|endfocus|> ToolGroup toolgroup = ToolFactory.eINSTANCE.createToolGroup(); for (EObject node : selection) { if (toolToolGroupCreated == false) { final ToolSectionSpec nodetoolsection = (ToolSectionSpec) node.eContainer(); nodetoolsection.getOwnedTools().add(toolgroup); toolToolGroupCreated = true; } toolgroup.getTools().add((AbstractToolDescription) node); }
<|startcomment|> Can you please document the format of the preference string somewhere in a Javadoc comment. <|endcomment|>  private void store(String datumId, String principalId, PermissionState state) { <|startfocus|> StringBuilder newValue = new StringBuilder(); String oldValue = getGlobalPermissionPreferences().get(datumId, ""); <|endfocus|> if (oldValue.contains(principalId)) { for (String principal : oldValue.split(Constants.PREF_SEPARATOR)) { if (principal.isEmpty() || principal.substring(1).equals(principalId)) { char prefix = state.equals(PermissionState.APPROVED) ? Constants.PREF_APPROVED : Constants.PREF_DISAPPROVED; principal = prefix + principalId; } newValue.append(principal + Constants.PREF_SEPARATOR); } } else { newValue.append(oldValue); char prefix = state.equals(PermissionState.APPROVED) ? Constants.PREF_APPROVED : Constants.PREF_DISAPPROVED; newValue.append(prefix + principalId + Constants.PREF_SEPARATOR); } IEclipsePreferences prefs = getGlobalPermissionPreferences(); prefs.put(datumId, newValue.toString()); try { prefs.flush(); } catch (BackingStoreException e) { LOG.error("Failed to flush preferences", e); }
<|startcomment|> See comments about canExecute <|endcomment|> kage org.eclipse.sirius.diagram.editor.tools.internal.menu.refactoring.grouping; import java.util.Collection; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.resource.ResourceSet; import org.eclipse.sirius.diagram.description.tool.ToolSection; import org.eclipse.sirius.editor.tools.api.menu.AbstractUndoRecordingCommand; public abstract class AbstractToolGroupIntoCommand extends AbstractUndoRecordingCommand { protected Collection<EObject> selection; protected ToolSection parent; public AbstractToolGroupIntoCommand(ResourceSet set) { super(set); this.selection = selection; this.parent = parent; } <|startfocus|> <|endfocus|> } 
<|startcomment|> unclear <|endcomment|> import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.resource.ResourceSet; import org.eclipse.sirius.diagram.description.tool.ToolFactory; import org.eclipse.sirius.diagram.description.tool.ToolGroupExtension; import org.eclipse.sirius.diagram.description.tool.ToolSection; import org.eclipse.sirius.viewpoint.description.tool.AbstractToolDescription; import com.google.common.collect.Iterables; /** * Group the current selection on ToolGroupExtension. * * @author Joao Martins * */ public class GroupIntoToolGroupExtensionCommand extends AbstractToolGroupIntoCommand { /** <|startfocus|> * for setTextIfDisable. <|endfocus|> */ public static final String TEXT = "Group into a new Tool Group Extension"; /** * Constructor. * * @param set * the current resourceset. * @param parent * ToolSection to group the selection. * @param selection * the current selection. */ public GroupIntoToolGroupExtensionCommand(ResourceSet set, ToolSection parent, Collection<EObject> selection) { super(set, parent, selection); } @Override protected void doExecute() {
<|startcomment|> private <|endcomment|>  } public Resource getOrigin() throws IOException { return loadFromClassLoader("data/a1/origin.uml");//$NON-NLS-1$ } public Resource getRight() throws IOException { return loadFromClassLoader("data/a1/right.uml");//$NON-NLS-1$ } } /** * Expected result data. * * @author <a href="mailto:arthur.daussy@obeo.fr">Arthur Daussy</a> */ <|startfocus|> public static class ExpectedResultData extends AbstractInputData { <|endfocus|> public Resource getExpectedResultWithoutFilter() throws IOException { return loadFromClassLoader("data/a1/expectedResultWithoutUMLRefineElementFilter.nodes"); //$NON-NLS-1$ } public Resource getExpectedResultWithFilter() throws IOException { return loadFromClassLoader("data/a1/expectedResultWithUMLRefineElementFilter.nodes"); //$NON-NLS-1$ } } } 
<|startcomment|> Add 2014 to copyright range <|endcomment|>  <|startfocus|> * Copyright (c) 2012, 2013 Obeo. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation */ package org.eclipse.emf.compare.uml2.internal.provider; import java.util.ArrayList; import java.util.Collection; import org.eclipse.emf.common.notify.Adapter; import org.eclipse.emf.common.notify.Notification; import org.eclipse.emf.common.notify.Notifier; import org.eclipse.emf.compare.uml2.internal.util.UMLCompareAdapterFactory; import org.eclipse.emf.edit.provider.ChangeNotifier; import org.eclipse.emf.edit.provider.ComposeableAdapterFactory; import org.eclipse.emf.edit.provider.ComposedAdapterFactory; import org.eclipse.emf.edit.provider.IChangeNotifier; import org.eclipse.emf.edit.provider.IDisposable; import org.eclipse.emf.edit.provider.IEditingDomainItemProvider; import org.eclipse.emf.edit.provider.IItemColorProvider; import org.eclipse.emf.edit.provider.IItemFontProvider; import org.eclipse.emf.edit.provider.IItemLabelProvider;
<|startcomment|> Copyright 2009-2014 them. First date is creation date, last one is last modif date. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2009 SWTBot Committers and others <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ralf Ebert www.ralfebert.de - (bug 271630) SWTBot Improved RCP / Workbench support * Matt Biggs - Added e4 support *******************************************************************************/ package org.eclipse.swtbot.eclipse.finder.e4.matchers; import static org.hamcrest.Matchers.equalTo; import org.eclipse.e4.ui.model.application.ui.advanced.MPerspective; import org.eclipse.swtbot.swt.finder.matchers.AbstractMatcher; import org.hamcrest.Description; import org.hamcrest.Factory; import org.hamcrest.Matcher; /** * @author Ralf Ebert www.ralfebert.de (bug 271630) * @author Matt biggs - Converted to E4 * @version $Id$ * @since 2.0 */ public class WithPerspectiveLabel extends AbstractMatcher<MPerspective> { private final Matcher<String> labelMatcher; /**
<|startcomment|> probably should have a cdt in there. How about: org.eclipse.cdt.debug.ui.toolbar.openNewView <|endcomment|>  public String getId() { <|startfocus|> return "org.eclipse.debug.ui.toolbar.openNewView"; //$NON-NLS-1$ <|endfocus|>
<|startcomment|> Seems like this shouldn't be externalized. <|endcomment|>  public void processCommands(String aQuery) { <|startfocus|> GerritUi.Ftracer.traceInfo(NLS.bind(Messages.GerritTableView_processCommand, aQuery)); <|endfocus|> String lastSaved = fServerUtil.getLastSavedGerritServer(); if (lastSaved != null) { //Already saved a Gerrit server, so use it fTaskRepository = fServerUtil.getTaskRepo(lastSaved); } if (fTaskRepository == null) { //If we did not find the task Repository fMapRepoServer = GerritServerUtility.getInstance().getGerritMapping(); //Verify How many gerrit server are defined Set<TaskRepository> mapSet = fMapRepoServer.keySet(); if (fMapRepoServer.size() == 1) { for (TaskRepository key : mapSet) { fTaskRepository = key; //Save it for the next query time fServerUtil.saveLastGerritServer(key.getRepositoryUrl()); break; } } else if (fMapRepoServer.size() > 1) { List<TaskRepository> listTaskRepository = new ArrayList<TaskRepository>(); for (TaskRepository key : mapSet) { listTaskRepository.add(key); }
<|startcomment|> If that's true why don't you just remove the class? <|endcomment|>  * Mickael Istria (Red Hat Inc.) - 438887 Deprecate *******************************************************************************/ package org.eclipse.compare.internal; import java.util.ResourceBundle; import java.lang.reflect.InvocationTargetException; import org.eclipse.swt.widgets.Shell; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.dialogs.ProgressMonitorDialog; import org.eclipse.jface.viewers.ISelection; import org.eclipse.ui.actions.WorkspaceModifyOperation; import org.eclipse.core.resources.*; import org.eclipse.core.runtime.*; <|startfocus|> /** * @deprecated This class doesn't seem to be used any more */ <|endfocus|> public class AddFromHistoryAction extends BaseCompareAction { private static final String BUNDLE_NAME= "org.eclipse.compare.internal.AddFromHistoryAction"; //$NON-NLS-1$ public AddFromHistoryAction() { // empty default implementation } protected boolean isEnabled(ISelection selection) { return Utilities.getResources(selection).length == 1; } protected void run(ISelection selection) { ResourceBundle bundle= ResourceBundle.getBundle(BUNDLE_NAME); String title= Utilities.getString(bundle, "title"); //$NON-NLS-1$ Shell parentShell= CompareUIPlugin.getShell();
<|startcomment|> Why a List here? Does the notion of "getStreams().get(10);" make any sense? Probably not, since you use HashMap's, and those do not keep the insertion order the same as the iteration order anyway. In this case I'd recommend to use Iterable<> or at worst Collection<> for the return value. It's ok to do a copy internally though, since the map is mutable, you do not want to return it (or its .values()) directly. I'd suggest using LinkedList instead though, since you won't be accessing it by indexes. <|endcomment|>  * stream is found between the two endpoints. */ public synchronized @Nullable PacketStream getStream(ProtocolEndpoint endpointA, ProtocolEndpoint endpointB) { ProtocolEndpointPair set = new ProtocolEndpointPair(endpointA, endpointB); int id = fIDs.get(set); return fStreams.get(id); } /** * Method that returns all the streams at the specified protocol level. * * @return The streams as a list. */ <|startfocus|> public synchronized List<PacketStream> getStreams() { List<PacketStream> list = new ArrayList<>(fStreams.values()); return list; <|endfocus|> } /** * Method that is called when the filter accepts a packet. This methods add * the packet to a stream based on its characteristics. * * @param packet * The packet to be added. */ public synchronized void addPacketToStream(PcapPacket packet) { if (fPacketFilter.accepts(packet)) { @Nullable Packet newPacket = packet.getPacket(fProtocol); if (newPacket == null) { return; }
<|startcomment|> to which this compareInput can be adapted to. <|endcomment|>  /** * Store the listeners for notifications. */ private final ListenerList fListener; /** * The {@link AdapterFactory} used to implement {@link #getName()} and {@link #getImage()}. */ private final AdapterFactory fAdapterFactory; /** The item delegator to use to retrieve item */ private final ExtendedAdapterFactoryItemDelegator itemDelegator; <|startfocus|> /** A {@link IDeferredWorkbenchAdapter} in which this object can adapt to. */ <|endfocus|> private IDeferredWorkbenchAdapter deferredWorkbenchAdapter; /** * Simple constructor storing the given {@link AdapterFactory}. * * @param adapterFactory * the factory. */ public CompareInputAdapter(AdapterFactory adapterFactory) { fAdapterFactory = adapterFactory; itemDelegator = new ExtendedAdapterFactoryItemDelegator(getRootAdapterFactory()); fListener = new ListenerList(); } /** * {@inheritDoc} * * @see org.eclipse.emf.common.notify.impl.AdapterImpl#isAdapterForType(java.lang.Object) */ @Override public boolean isAdapterForType(Object type) {
<|startcomment|> Take the habit to use the interfaces as far as possible: List<Port> ports = new ArrayList<Port>(); <|endcomment|>  private List<Port> getAllInheritedPorts(org.eclipse.uml2.uml.Class aClass) { <|startfocus|> ArrayList<Port> ports = new ArrayList<Port>(); <|endfocus|> ports.addAll(aClass.getOwnedPorts()); for (org.eclipse.uml2.uml.Classifier parent : aClass.allParents()) { if (parent instanceof org.eclipse.uml2.uml.Class) { ports.addAll(getAllInheritedPorts((org.eclipse.uml2.uml.Class)parent)); } } return ports;
<|startcomment|> Remove this comment <|endcomment|>  public TmfXmlValueChange createValueChange(Element node, IXmlStateSystemContainer container) { <|startfocus|> // TODO Auto-generated method stub <|endfocus|> return new TmfXmlValueChange(this, node, container);
<|startcomment|> is that an extra white space I see between implements and IThingy? :p <|endcomment|> import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.EntityResolver; import org.xml.sax.ErrorHandler; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; /** * Trace object for custom XML trace parsers. * * @author Patrick Tass * @since 3.0 */ <|startfocus|> public class CustomXmlTrace extends TmfTrace implements ITmfPersistentlyIndexable { <|endfocus|> private static final TmfLongLocation NULL_LOCATION = new TmfLongLocation(-1L); private static final int DEFAULT_CACHE_SIZE = 100; private static final int MAX_LINES = 100; private static final int CONFIDENCE = 100; private final CustomXmlTraceDefinition fDefinition; private final CustomXmlEventType fEventType; private final InputElement fRecordInputElement; private BufferedRandomAccessFile fFile; /** * Basic constructor * * @param definition * Trace definition */ public CustomXmlTrace(final CustomXmlTraceDefinition definition) { fDefinition = definition;
<|startcomment|> Mark the page part containing the editor as dirty <|endcomment|>  EmbeddedEditor handle = factory.newEditor(resourceProvider).showErrorAndWarningAnnotations() .withParent(form.getForm().getBody()); EmbeddedEditorModelAccess partialEditor = handle.createPartialEditor(true); // Needed handle.getDocument().set(snippet.getCode()); handle.getDocument().addDocumentListener(new IDocumentListener() { @Override public void documentChanged(DocumentEvent event) { String code = event.getDocument().get(); <|startfocus|> ((Snippet) SnippetSourcePage.this.snippet).setCode(code); codePart.markDirty(); <|endfocus|> } @Override public void documentAboutToBeChanged(DocumentEvent event) { // No-op } });
<|startcomment|> Test hangs here, because the dialog was closed a few lines above. Remove this line and add the selection to the parser. <|endcomment|>  } } catch (Exception e) { e.printStackTrace(); } } }); button[3].click(); fBot.tree().getTreeItem(TRACE).getNode(EVENT).select(); fBot.checkBox("Log Entry").click(); fBot.button("Next >").click(); fBot.button("Finish").click(); fBot.button("Close").click(); String xmlPart = extractTestXml(xmlFile, PROJECT_NAME); assertEquals(EXPECTED_TEST_DEFINITION, xmlPart); <|startfocus|> fBot.button("Delete").click(); fBot.button("Yes").click(); fBot.button("Close").click(); <|endfocus|> xmlPart = extractTestXml(xmlFile, PROJECT_NAME); assertEquals("", xmlPart); } private static String extractTestXml(File xmlFile, String definitionName) throws IOException, FileNotFoundException { StringBuilder xmlPart = new StringBuilder(); boolean started = false; try (RandomAccessFile raf = new RandomAccessFile(xmlFile, "r");) { String s = raf.readLine(); while (s != null) {
<|startcomment|> Please add "and others" to this. This way we don't need to update the header when somebody else makes changes to this file <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2014 Vadim Dmitriev. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Vadim Dmitriev - initial implementation *******************************************************************************/ package org.eclipse.egit.ui.internal.rebase; import java.util.Iterator; import org.eclipse.egit.core.internal.rebase.RebaseInteractivePlan; import org.eclipse.egit.core.internal.rebase.RebaseInteractivePlan.PlanElement; import org.eclipse.jface.action.Action; import org.eclipse.jface.resource.ImageDescriptor; import org.eclipse.jface.viewers.ISelection; import org.eclipse.jface.viewers.IStructuredSelection; import org.eclipse.jface.viewers.TreeViewer; class PlanContextMenuActionListener extends Action { private RebaseInteractivePlan.ElementAction action; private TreeViewer planViewer; private RebaseInteractiveStepActionToolBarProvider actionToolbarProvider; public PlanContextMenuActionListener(String text, ImageDescriptor image, RebaseInteractivePlan.ElementAction action, TreeViewer planViewer, RebaseInteractiveStepActionToolBarProvider actionToolbarProvider) { super(text, image);
<|startcomment|> can that actually happen considering the plugin.xml definition? <|endcomment|>  fSelection = (TreeSelection) selection; Iterator<Object> iterator = fSelection.iterator(); while (iterator.hasNext()) { Object element = iterator.next(); if (element instanceof TmfTraceElement) { tl.add((TmfTraceElement) element); } else if (element instanceof TmfExperimentElement) { TmfExperimentElement exp = (TmfExperimentElement) element; uiexperiment.add(exp); for (TmfTraceElement trace : exp.getTraces()) { tl.add(trace); } } } } <|startfocus|> if (tl.isEmpty()) { <|endfocus|> TraceUtils.displayErrorMsg(Messages.SynchronizeTracesHandler_Title, Messages.SynchronizeTracesHandler_WrongTraceNumber); return null; } Thread thread = new Thread() { @Override public void run() { final ITmfTrace[] traces = new ITmfTrace[tl.size()]; for (int i = 0; i < tl.size(); i++) { ITmfTrace trace = tl.get(i).instantiateTrace(); ITmfEvent traceEvent = tl.get(i).instantiateEvent(); if (trace == null) {
<|startcomment|> Using both synchronized and an explicity ReadWriteLock is highly confusing. Please use one or the other. (Preferrably the later.) <|endcomment|>  readLock = readWriteLock.readLock(); writeLock = readWriteLock.writeLock(); } public void generateAnonymousId() { generateFreshAnonymousId(); try { writeAnonymousIdToFile(anonymousIdFile, anonymousId); } catch (IOException e) { LOG.error(getErrorMessage("write"), e); //$NON-NLS-1$ } } public UUID getAnonymousId() { if (anonymousId == null) { readOrCreateAnonymousId(); } return anonymousId; } <|startfocus|> private synchronized void readOrCreateAnonymousId() { <|endfocus|> if (anonymousId != null) { return; } if (anonymousIdFile.exists() && anonymousIdFile.canRead()) { try { anonymousId = readAnonymousIdFromFile(anonymousIdFile); } catch (IOException e) { LOG.error(getErrorMessage("read"), e); //$NON-NLS-1$ generateFreshAnonymousId(); } } else { generateAnonymousId(); } } private synchronized void generateFreshAnonymousId() { UUID freshAnonymousId; do { freshAnonymousId = UUID.randomUUID(); } while (freshAnonymousId.equals(anonymousId));
<|startcomment|> Extra space after ( <|endcomment|>  * method will return a string with the value, otherwise it will fall back showing the * enumerator constant. * * @param ast the AST of the translation unit * @param binding the binding of the macro name * @return the enumerator value, source or <code>null</code> * @throws CoreException */ private String computeSourceForEnumerator(IASTTranslationUnit ast, IEnumerator binding) throws CoreException { Long numValue = binding.getValue().numericalValue(); if ( numValue != null) { <|startfocus|> return String.valueOf(numValue); <|endfocus|> } else { // Search for the enumerator definition IName[] defs = ast.getDefinitions(binding); for (IName def : defs) { String source= computeSourceForName(def, binding); if (source != null) { return source; } } } return null; } /** * Find a definition or declaration for the given binding and returns the source for it. * Definitions are preferred over declarations. In case of multiple definitions or declarations,
<|startcomment|> Somehow our source formatter doesn't cooperate so nicely with the source cleanup ;-( Until I've found out how to fix that, please format the entire projects *after* all saves haven been done. <|endcomment|>  * @apiviz.uses {@link org.eclipse.emf.cdo.CDOObject} - - manages * @apiviz.uses {@link CDOViewAdaptersNotifiedEvent} - - fires * @apiviz.uses {@link CDOViewDurabilityChangedEvent} - - fires * @apiviz.uses {@link CDOViewInvalidationEvent} - - fires * @apiviz.uses {@link CDOViewLocksChangedEvent} - - fires * @apiviz.uses {@link CDOViewTargetChangedEvent} - - fires */ public interface CDOView extends CDOCommonView, CDOUpdatable, CDOCommitHistory.Provider<CDOObject, CDOObjectHistory>, <|startfocus|> IContainer<CDOResourceNode> <|endfocus|> { /** * Returns the {@link CDOSession session} this view was opened by. * * @return The session this view was opened by, or <code>null</code> if this view is closed. * @see #close() * @see #isClosed() * @see CDOSession#openView() * @see CDOSession#openTransaction() */ public CDOSession getSession(); /** * Returns the {@link CDOViewSet view set} this view is associated with. *
<|startcomment|> It would be better not to have anything specific to Bugzilla here. What is "4.5+"? Is that an actual version? <|endcomment|>  if (this.qualifier.equals("+")) { //$NON-NLS-1$ return 1; } else { return -1; } } if (this.qualifier == null && other.qualifier != null) { if (other.qualifier.equals("+")) { //$NON-NLS-1$ return -1; } else { return 1; } } if (this.qualifier != null && other.qualifier != null) { erg = this.qualifier.compareTo(other.qualifier); <|startfocus|> // special case for Bugzilla 4.5rc1 < 4.5+ <|endfocus|> if (this.qualifier.equals("+") || other.qualifier.equals("+")) { //$NON-NLS-1$ //$NON-NLS-2$ return erg * -1; } if (erg != 0) { return erg; } } return 0;
<|startcomment|> Representation deletion pop-up title <|endcomment|> import org.eclipse.sirius.ui.business.api.session.IEditingSession; import org.eclipse.sirius.ui.business.api.session.SessionUIManager; import org.eclipse.sirius.viewpoint.DRepresentation; import org.eclipse.sirius.viewpoint.DRepresentationContainer; import org.eclipse.sirius.viewpoint.provider.SiriusEditPlugin; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.plugin.AbstractUIPlugin; import com.google.common.base.Predicate; import com.google.common.collect.Iterables; /** * Action to delete on or more Sirius representations. * * @author mchauvin */ public class DeleteRepresentationAction extends Action { <|startfocus|> <|endfocus|> private Collection<DRepresentation> selectedRepresentations; /** * Create a new instance. * * @param representations * the representations to delete */ public DeleteRepresentationAction(Collection<DRepresentation> representations) { super("Delete", AbstractUIPlugin.imageDescriptorFromPlugin(SiriusEditPlugin.ID, "/icons/full/others/delete.gif")); this.selectedRepresentations = representations; // Disable the action if the selection is not valid if (!isValidSelection()) { this.setEnabled(false); } } @Override
<|startcomment|> private? (the outer class will still be able to access it) <|endcomment|> <|startfocus|> String getViewId() { <|endfocus|> return fViewId;
<|startcomment|> Good: this needs to be checked first; this flag should override a custom EE configuration. <|endcomment|>  public static ExecutionEnvironmentResolutionHandler adapt(ExecutionEnvironmentConfiguration eeConfiguration) { if (eeConfiguration.isIgnoredByResolver()) { <|startfocus|> return new AllKnownEEsResolutionHandler(); <|endfocus|> } else if (eeConfiguration.isCustomProfile()) { return new CustomEEResolutionHandler(eeConfiguration); } else { return new StandardEEResolutionHandler(eeConfiguration.getProfileName()); }
<|startcomment|> and again <|endcomment|>  <|startfocus|> * Copyright (c) 2011, 2012 Obeo. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation */ package org.eclipse.emf.compare.tests.nodes.util; import org.eclipse.emf.common.notify.Adapter; import org.eclipse.emf.common.notify.Notifier; import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl; import org.eclipse.emf.compare.tests.nodes.*; import org.eclipse.emf.compare.tests.nodes.Node; import org.eclipse.emf.compare.tests.nodes.NodeFeatureMapContainment; import org.eclipse.emf.compare.tests.nodes.NodeFeatureMapNonContainment; import org.eclipse.emf.compare.tests.nodes.NodeMultiValueReference; import org.eclipse.emf.compare.tests.nodes.NodeMultiValuedAttribute; import org.eclipse.emf.compare.tests.nodes.NodeMultipleContainment; import org.eclipse.emf.compare.tests.nodes.NodeOppositeRefManyToMany; import org.eclipse.emf.compare.tests.nodes.NodeOppositeRefOneToMany;
<|startcomment|> Bordered => Border <|endcomment|>  if (adaptObject instanceof AbstractDNode) { AbstractDNode abstractDNode = (AbstractDNode) adaptObject; Point absoluteLayoutConstraint = shapeEditPart.getFigure().getBounds().getTopLeft().getCopy(); shapeEditPart.getFigure().translateToAbsolute(absoluteLayoutConstraint); GraphicalHelper.screen2logical(absoluteLayoutConstraint, (IGraphicalEditPart) getHost()); Point scaledMoveDelta = moveDelta.getScaled(1.0d / GraphicalHelper.getZoom(getHost())); absoluteLayoutConstraint.translate(scaledMoveDelta); <|startfocus|> boolean isBorderedTarget = editPart instanceof AbstractDiagramBorderNodeEditPart; if (isBorderedTarget) { <|endfocus|> // Get the computed location for feedback if (borderNodeLocationForDDiagramElement != null && borderNodeLocationForDDiagramElement.get(abstractDNode) != null) { // Adapt this location to the current zoom Point borderNodeFeedbackLocation = borderNodeLocationForDDiagramElement.get(abstractDNode).getScaled(1.0d / GraphicalHelper.getZoom(getHost())); // Translate the original delta with the diff // between proposed location and the real one. Dimension deltaBetweenProposedAndRealLocation = borderNodeFeedbackLocation.getDifference(absoluteLayoutConstraint);
<|startcomment|> You can remove this line and use directly this.value, like you do in other places. <|endcomment|>  if (object == null) { /* * We assume that every integer state value is greater than any null * state value. */ return 1; } int result = 0; switch (object.getType()) { case INTEGER: IntegerStateValue other = (IntegerStateValue) object; result = Integer.compare(this.value, other.value); break; case DOUBLE: double otherDoubleValue = ((DoubleStateValue) object).unboxDouble(); <|startfocus|> double thisDoubleValue = this.value; result = Double.compare(thisDoubleValue, otherDoubleValue); <|endfocus|> break; case LONG: long otherLongValue = ((LongStateValue) object).unboxLong(); result = Long.compare(this.value, otherLongValue); break; case NULL: /* * We assume that every integer state value is greater than any null * state value. */ result = 1; break; case STRING: /* * We assume that every state value is smaller than any string state * value. */ result = -1; break; default: break; } 
<|startcomment|> extract to constant? <|endcomment|>  TraceTypeHelper helper = TmfTraceType.getTraceType(getTraceType()); if (helper != null) { return helper.getCategoryName() + " : " + helper.getName(); //$NON-NLS-1$ } } return ""; //$NON-NLS-1$ } if (sfTimeOffset.equals(id)) { long offset = TimestampTransformFactory.getTimestampTransform(getResource()).transform(0); if (offset != 0) { <|startfocus|> TmfTimestampFormat offsetFormat = new TmfTimestampFormat("T.SSS SSS SSS s"); //$NON-NLS-1$ return offsetFormat.format(offset); <|endfocus|> } return ""; //$NON-NLS-1$ } Map<String, String> traceProperties = getTraceProperties(); if (id != null && !traceProperties.isEmpty()) { String key = (String) id; key = key.substring(this.getName().length() + 1); // remove name_ String value = traceProperties.get(key); return value; } return null;
<|startcomment|> Can be removed <|endcomment|>  * * @return the scheduling rule to use when redoing this operation, or * <code>null</code> if there are no scheduling restrictions for * this operation. * * @see IWorkspace#run(IWorkspaceRunnable, ISchedulingRule, int, * IProgressMonitor) */ protected ISchedulingRule getRedoSchedulingRule() { return getExecuteSchedulingRule(); } @Override public void setQuietCompute(boolean quiet) { quietCompute = quiet; } <|startfocus|> /* * @see java.lang.Object#toString() */ <|endfocus|> @Override public String toString() { StringBuffer text = new StringBuffer(super.toString()); text.append("\n"); //$NON-NLS-1$ text.append(this.getClass().getName()); appendDescriptiveText(text); return text.toString(); } /** * Append any descriptive text to the specified string buffer to be shown in * the receiver's {@link #toString()} text. * <p>Note that this method is not intend to be subclassed by clients. * 
<|startcomment|> "loadResource". Remove the boolean parameter an dsimply pass true to super. <|endcomment|> <|startfocus|> private Resource unprotectedGetResource(URI uri, boolean loadOnDemand) { return super.getResource(uri, loadOnDemand); <|endfocus|>
<|startcomment|> This should return an immutable collection. <|endcomment|> <|startfocus|> public Collection<Field> getFields() { return fields.values(); <|endfocus|>
<|startcomment|> As an IFile array is retured by this method, List<IFile> would be appropriate instead of List<IResource> <|endcomment|>  getActiveWorkbenchWindow().getShell().forceActive(); } public static String showPerspective(String perspective) throws WorkbenchException { String shownPerspective= getActivePage().getPerspective().getId(); if (!perspective.equals(shownPerspective)) { IWorkbench workbench= PlatformUI.getWorkbench(); IWorkbenchWindow activeWindow= workbench.getActiveWorkbenchWindow(); workbench.showPerspective(perspective, activeWindow); } return shownPerspective; } public static IFile[] findFiles(IResource resource) throws CoreException { <|startfocus|> List<IResource> files= new ArrayList<IResource>(); <|endfocus|> findFiles(resource, files); return files.toArray(new IFile[files.size()]); } private static void findFiles(IResource resource, List<IResource> files) throws CoreException { if (resource instanceof IFile) { files.add(resource); return; } if (resource instanceof IContainer) { IResource[] resources= ((IContainer) resource).members(); for (int i= 0; i < resources.length; i++) findFiles(resources[i], files); } } } 
<|startcomment|> I think it's worth logging the URI. LOG.info("Heartbeat successfuly sent to specified URI: <{}>", uri); <|endcomment|>  public void sendHeartbeat(String uriPrefix, String bundleName, String bundleVersion, IProgressMonitor monitor) { RepositoryTransport transport = new RepositoryTransport(); URI uri = createURI(uriPrefix, bundleName, bundleVersion); try { transport.getLastModified(uri, monitor); <|startfocus|> LOG.info("Heartbeat successfuly sent to specified URI"); //$NON-NLS-1$ <|endfocus|> } catch (AuthenticationFailedException e) { LOG.error("Authentication with specified URI failed", e); //$NON-NLS-1$ } catch (FileNotFoundException e) { // ignore because it is expected that the URI doesn't represent a resource. } catch (CoreException e) { LOG.error("Sending Heartbeat failed", e); //$NON-NLS-1$ }
<|startcomment|> Are you sure about the private final class? This inner class may be big enough to be in its own file <|endcomment|>  } public InternalCDOObject getObject() { return object; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } } /** * A {@link IListener} to prefetch {@link CDOLockState}s when {@link CDORevision}s are loaded, according to {@link Options#setLockStatePrefetchEnabled(boolean)} option. * * @author Esteban Dugueperoux */ private final class CDOLockStatePrefetcher implements IListener { <|startfocus|> public CDOLockStatePrefetcher() <|endfocus|> { getSession().getRevisionManager().addListener(this); } public void notifyEvent(IEvent event) { if (event instanceof CDORevisionsLoadedEvent) { CDORevisionsLoadedEvent cdoRevisionsLoadedEvent = (CDORevisionsLoadedEvent)event; List<CDORevision> loadedRevisions = cdoRevisionsLoadedEvent.getLoadedRevisions(); Map<CDOID, CDOObject> cdoIDs = updateCDOViewObjectsCache(loadedRevisions); if (!cdoIDs.isEmpty()) { updateCDOViewLockStatesCache(cdoIDs.keySet()); } } } private Map<CDOID, CDOObject> updateCDOViewObjectsCache(List<CDORevision> loadedRevisions)
<|startcomment|> This seems good. Maybe extract to a waitForCacheRemoval method and call it instead of the other sleeps? <|endcomment|>  public BugzillaRestConnectorTest(BugzillaRestTestFixture fixture) { this.actualFixture = fixture; } @Before public void setUp() { connector = new BugzillaRestConnector(); } @Test public void testReloadCache() throws Exception { connector = new BugzillaRestConnectorLocal(new Duration(5, TimeUnit.SECONDS)); assertNotNull(connector); configuration = connector.getRepositoryConfiguration(actualFixture.repository()); assertNotNull(configuration); Thread.sleep(6000L); BugzillaRestConfiguration configuration_new = connector.getRepositoryConfiguration(actualFixture.repository()); assertEquals(configuration, configuration_new); <|startfocus|> <|endfocus|> mySync = this; synchronized (mySync) { try { mySync.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } mySync = null; BugzillaRestConfiguration configuration_new1 = connector.getRepositoryConfiguration(actualFixture.repository()); assertThat(configuration, not(configuration_new1)); } @Test public void testLoadCache() throws Exception { BugzillaRestConfiguration configuration = connector.getRepositoryConfiguration(actualFixture.repository()); assertNotNull(configuration); Thread.sleep(7000L);
<|startcomment|> Please follow the convention of the other tags description. This tag can be applied to an element (usually an MPart) to indicate that the element should be handled as view. Same for editor, please lower lower cases for editor. <|endcomment|>  * * @since 1.3 */ public static final String ACTIVE = "active"; //$NON-NLS-1$ /** * Tag for {@link MPart} or {@link MPartDescriptor} objects, which are considered as Views. * * @since 1.3 * */ public static final String VIEW_TAG = "View"; //$NON-NLS-1$ /** <|startfocus|> * Tag for {@link MPart} or {@link MPartDescriptor} objects, which are considered as Editors. <|endfocus|> * * @since 1.3 * */ public static final String EDITOR_TAG = "Editor"; //$NON-NLS-1$ /** * Creates and returns the UI element for the given model element. * * @param element * the model element * @param parentWidget * the parent * @param parentContext * the context within which this element is being rendered * * @return the created UI element */ public Object createGui(MUIElement element, Object parentWidget, IEclipseContext parentContext); 
<|startcomment|> EObject returnedValue = null; --> EObject returnedValue = newObject; returnedValue = contribution.updateCreatedObject(newObject, loadedVersion); if (returnedValue != null) { break; } --> returnedValue = contribution.updateCreatedObject(returnedValue, loadedVersion); <|endcomment|>  public EObject updateCreatedObject(EObject newObject, String loadedVersion) { EObject returnedValue = null; for (IMigrationParticipant contribution : delegatesParticipants) { <|startfocus|> returnedValue = contribution.updateCreatedObject(newObject, loadedVersion); if (returnedValue != null) { break; } <|endfocus|> } return returnedValue;
<|startcomment|> I find reassignments to the SUT in tests very confusing. Also, I would avoid using the default constructor; each test should use its own file (allows tests to be executed in parallel). <|endcomment|>  import org.junit.Rule; import org.junit.Test; import org.junit.rules.TemporaryFolder; public class AnonymousIdTest { private static final String ANONYMOUS_ID_FILE_NAME = "anonymousId"; //$NON-NLS-1$ @Rule public TemporaryFolder folder = new TemporaryFolder(); @Test public void testGetAnonymousIdIsNotNull() throws IOException { AnonymousIdService sut = new AnonymousIdService(); UUID anonymousId = sut.getAnonymousId(); assertThat(anonymousId, is(notNullValue())); <|startfocus|> sut = new AnonymousIdService(folder.newFile()); anonymousId = sut.getAnonymousId(); assertThat(anonymousId, is(notNullValue())); <|endfocus|> } @Test public void testGetAnonymousIdIsIdempotent() throws IOException { AnonymousIdService sut = new AnonymousIdService(); UUID firstAnonymousId = sut.getAnonymousId(); UUID secondAnonymousId = sut.getAnonymousId(); assertThat(secondAnonymousId, is(equalTo(firstAnonymousId))); sut = new AnonymousIdService(folder.newFile()); firstAnonymousId = sut.getAnonymousId(); secondAnonymousId = sut.getAnonymousId();
<|startcomment|> Please add bug number. Note that a bug can be used for different git commits. <|endcomment|>  * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ericsson - initial API and implementation * Andy Jin (QNX) - Not output thread osId as a string when it is null (Bug 397039) <|startfocus|> * Simon Marchi (Ericsson) - Pass thread name from MIThread to the data model. <|endfocus|> *******************************************************************************/ package org.eclipse.cdt.dsf.gdb.service; import org.eclipse.cdt.dsf.concurrent.DataRequestMonitor; import org.eclipse.cdt.dsf.concurrent.ImmediateDataRequestMonitor; import org.eclipse.cdt.dsf.concurrent.ImmediateRequestMonitor; import org.eclipse.cdt.dsf.concurrent.Immutable; import org.eclipse.cdt.dsf.concurrent.RequestMonitor; import org.eclipse.cdt.dsf.datamodel.DMContexts; import org.eclipse.cdt.dsf.datamodel.IDMContext; import org.eclipse.cdt.dsf.debug.service.IRunControl.IContainerResumedDMEvent; import org.eclipse.cdt.dsf.debug.service.IRunControl.IContainerSuspendedDMEvent; import org.eclipse.cdt.dsf.debug.service.IRunControl.IExitedDMEvent;
<|startcomment|> I'd add a comment here that order is important to decide which property level wins if a property is set on multiple levels <|endcomment|>  * <li>{@link MavenSession#getSettings()} as {@link PrefixedObjectValueSource}</li> * <li>{@link MavenProject#getBasedir()} for ${basedir}</li> * <li>{@link Settings#getLocalRepository()} for ${localRepository}</li> * </ul> * </p> * */ public class Interpolator { private StringSearchInterpolator interpolator; public Interpolator(MavenSession mavenSession, MavenProject mavenProject) { <|startfocus|> final Properties baseProps = new Properties(); <|endfocus|> baseProps.putAll(mavenProject.getProperties()); baseProps.putAll(mavenSession.getSystemProperties()); baseProps.putAll(mavenSession.getUserProperties()); final Settings settings = mavenSession.getSettings(); interpolator = new StringSearchInterpolator(); interpolator.addValueSource(new PrefixedObjectValueSource("project", mavenProject)); interpolator.addValueSource(new PrefixedObjectValueSource("settings", settings)); interpolator.addValueSource(new SingleResponseValueSource("localRepository", settings.getLocalRepository())); interpolator.addValueSource(new SingleResponseValueSource("basedir", mavenProject.getBasedir() .getAbsolutePath())); interpolator.addValueSource(new ValueSource() {
<|startcomment|> Should document that the empty string is returned if there is no proxy connection and that null is never returned. <|endcomment|>  } /** * Gets the proxy connection. If no proxy connection is used it returns null. * * @return proxy connection */ public JSchConnection getProxyConnection() { String proxyConnectionName = getProxyConnectionName(); if (proxyConnectionName.equals(EMPTY_STRING)) { return null; } else { return (JSchConnection) fManager.getConnection(proxyConnectionName); } } /** * Gets the proxy connection name * <|startfocus|> * @return proxy connection name <|endfocus|> */ public String getProxyConnectionName() { return fAttributes.getAttribute(JSchConnectionAttributes.PROXYCONNECTION_ATTR, EMPTY_STRING); } /* * (non-Javadoc) * * @see org.eclipse.remote.core.IRemoteConnection#getRemoteServices() */ @Override public IRemoteServices getRemoteServices() { return fRemoteServices; } /** * Open an sftp channel to the remote host. Always use the second session if available. * * @return sftp channel or null if the progress monitor was cancelled * @throws RemoteConnectionException
<|startcomment|> could this be a private static abstract interface? <|endcomment|>  * * @author Alexandre Montplaisir */ public interface ITmfEventAspect { /** * Static definition of an empty string. You can use this instead of 'null'! */ String EMPTY_STRING = ""; //$NON-NLS-1$ /** * Some basic aspects that all trace types should be able to use, using * methods found in {@link ITmfEvent}. */ interface BaseAspects { /** Aspect for the event timestamp */ <|startfocus|> ITmfEventAspect TIMESTAMP = new ITmfEventAspect() { <|endfocus|> @Override public String getName() { String ret = Messages.AspectName_Timestamp; return (ret == null ? EMPTY_STRING : ret); } @Override public String resolve(ITmfEvent event) { String ret = event.getTimestamp().toString(); return (ret == null ? EMPTY_STRING : ret); } @Override public String getHelpText() { return EMPTY_STRING; } @Override public @NonNull String getFilterId() { return ITmfEvent.EVENT_FIELD_TIMESTAMP; } }; 
<|startcomment|> Please make fields final where possible <|endcomment|> import org.eclipse.jface.viewers.Viewer; import org.eclipse.jface.viewers.ViewerFilter; import org.eclipse.jface.window.ToolTip; import org.eclipse.recommenders.internal.privacy.rcp.data.ICategory; import org.eclipse.recommenders.internal.privacy.rcp.data.PrivatePermission; import org.eclipse.recommenders.internal.privacy.rcp.l10n.Messages; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Label; public class SingleDatumWidget { private TreeViewer permissionsViewer; <|startfocus|> private Set<? extends ICategory> permissionsInput; private String datumId; <|endfocus|> private Set<PrivatePermission> checkedPermissions = Collections.emptySet(); private Composite principalComposite; public SingleDatumWidget(Set<? extends ICategory> permissionSet, String datumId) { permissionsInput = permissionSet; this.datumId = datumId; } public void setCheckedPermissions(Set<PrivatePermission> checkedPermissions) { this.checkedPermissions = checkedPermissions; } public Control createContents(Composite parent) { createPermissionLabel(parent); principalComposite = createTreeViewLayout(parent); GridDataFactory.fillDefaults().grab(true, true).applyTo(principalComposite);
<|startcomment|> If you put it between "", you probably need to define it ;-) "The [machine|thing] the packet originates from" <|endcomment|>  * * Contributors: * Vincent Perot - Initial API and implementation * Alexandre Montplaisir - Update to new ITmfEventAspect API *******************************************************************************/ package org.eclipse.tracecompass.internal.tmf.pcap.core.event.aspect; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.tracecompass.internal.tmf.pcap.core.event.PcapEvent; import org.eclipse.tracecompass.internal.tmf.pcap.core.protocol.TmfPcapProtocol; import org.eclipse.tracecompass.tmf.core.event.ITmfEvent; import org.eclipse.tracecompass.tmf.core.event.aspect.ITmfEventAspect; /** <|startfocus|> * The "packet source" aspect for pcap events <|endfocus|> * * @author Alexandre Montplaisir */ public class PcapSourceAspect implements ITmfEventAspect { @Override public String getName() { return Messages.getMessage(Messages.PcapAspectName_Source); } @Override public String getHelpText() { return EMPTY_STRING; } @Override public String resolve(ITmfEvent event) { if (!(event instanceof PcapEvent)) { return EMPTY_STRING; } PcapEvent pcapEvent = (PcapEvent) event; TmfPcapProtocol protocol = pcapEvent.getMostEncapsulatedProtocol(); 
<|startcomment|> components -> event providers <|endcomment|>  /** The type of event handled by this provider */ private Class<? extends ITmfEvent> fType; private final TmfRequestExecutor fExecutor; private final Object fLock = new Object(); private int fSignalDepth = 0; private int fRequestPendingCounter = 0; private Timer fTimer; private boolean fIsTimeout = false; /** * The parent component. */ private TmfEventProvider fParent = null; <|startfocus|> /** * The list if children components. */ <|endfocus|> private final List<TmfEventProvider> fChildren = Collections.synchronizedList(new ArrayList<TmfEventProvider>()); // ------------------------------------------------------------------------ // Constructors // ------------------------------------------------------------------------ /** * Default constructor */ public TmfEventProvider() { super(); fExecutor = new TmfRequestExecutor(); } /** * Standard constructor. Instantiate and initialize at the same time. * * @param name * Name of the provider * @param type * The type of events that will be handled */
<|startcomment|> Can return null <|endcomment|>  * counter */ void notifyPendingRequest(boolean isIncrement); /** * Return the next event based on the context supplied. The context * will be updated for the subsequent read. * * @param context the trace read context (updated) * @return the event referred to by context */ ITmfEvent getNext(ITmfContext context); /** * Gets the parent event provider. * <|startfocus|> * @return the parent event provider. <|endfocus|> */ @Nullable ITmfEventProvider getParent(); /** * Sets the parent event provider. * * @param parent * the parent to set. */ void setParent(@Nullable ITmfEventProvider parent); /** * Adds a child event provider. * * @param child * child to add. */ void addChild(@NonNull ITmfEventProvider child); /** * Gets the children event providers. * * @return the children event providers */ @NonNull List<ITmfEventProvider> getChildren(); /**
<|startcomment|> "test" use a constant for this <|endcomment|>  public void testTextInputComp() { ComponentIdentifier identifier = OM_factories.TextField_pfr_txf; TextInputComponent textField = ConcreteComponents .createTextInputComponent(identifier); Assert.assertNotNull(textField); CAP cap1 = textField.checkEditability(true); Assert.assertNotNull(cap1); <|startfocus|> CAP cap2 = textField.checkText("test", Operator.equals); //$NON-NLS-1$ <|endfocus|> Assert.assertNotNull(cap2); CAP cap3 = textField.inputText("test"); //$NON-NLS-1$ Assert.assertNotNull(cap3); CAP cap4 = textField.insertTextAfterIndex("test", 1); //$NON-NLS-1$ Assert.assertNotNull(cap4); CAP cap5 = textField.insertTextBeforeAfterPattern( "test", "pattern", Operator.equals, true); //$NON-NLS-1$//$NON-NLS-2$ Assert.assertNotNull(cap5); CAP cap6 = textField.replaceText("test"); //$NON-NLS-1$ Assert.assertNotNull(cap6); CAP cap7 = textField.selectAll(); Assert.assertNotNull(cap7); CAP cap8 = textField.selectPattern("test", Operator.equals); //$NON-NLS-1$
<|startcomment|> Now that you removed the addChild from this class, you have no guarantee that all children will be ITmfTrace anymore, except, that for now, it is the case. You should use the getChildren(ITmfTrace.class) here instead (and everywhere else) or you'll get a ClassCastException in 2 years from now ;-) <|endcomment|>  public void run() { while (!executorIsShutdown()) { if (!getIndexer().isIndexing()) { ITmfTimestamp startTimestamp = TmfTimestamp.BIG_CRUNCH; ITmfTimestamp endTimestamp = TmfTimestamp.BIG_BANG; <|startfocus|> for (final ITmfEventProvider child : getChildren()) { final ITmfTrace trace = (ITmfTrace) child; <|endfocus|> if (trace.getStartTime().compareTo(startTimestamp) < 0) { startTimestamp = trace.getStartTime(); } if (trace.getStreamingInterval() != 0 && trace.getEndTime().compareTo(endTimestamp) > 0) { endTimestamp = trace.getEndTime(); } } if (safeTimestamp != null && (lastSafeTimestamp == null || safeTimestamp.compareTo(lastSafeTimestamp) > 0)) { timeRange = new TmfTimeRange(startTimestamp, safeTimestamp); lastSafeTimestamp = safeTimestamp; } else { timeRange = null; } safeTimestamp = endTimestamp; if (timeRange != null) { final TmfTraceRangeUpdatedSignal signal =
<|startcomment|> Same remark as for the previous similar change. <|endcomment|>  * dimension of nodes. * </p> * * FIXME to terminate. * * @author ymortier */ public class InlineEdgeLayoutProvider extends DefaultLayoutProvider { /** The default padding. */ private static final Insets DEFAULT_PADDING = new Insets(30, 30, 10, 30); /** * Map each Connection with its {@link MoveEdgeDescriptor} instance. */ <|startfocus|> protected Map connectionsToMoveEdgeDescriptor = new WeakHashMap<ConnectionEditPart, MoveEdgeDescriptor>(); <|endfocus|> /** The side to use. */ private int side; /** The position of the first edge. */ private int start; /** <code>true</code> if the height of nodes can be changed. */ private boolean changeNodeHeight; /** <code>true</code> if the width of nodes can be changed. */ private boolean changeNodeWidth; /** The padding. */ private Insets paddings = InlineEdgeLayoutProvider.DEFAULT_PADDING; /** * The alignment ({@link PositionConstants#HORIZONTAL} or * {@link PositionConstants#VERTICAL} or {@link PositionConstants#NONE}).
<|startcomment|> curly braces are unnecessary for single statement blocks inside JGit code <|endcomment|>  String requestUri, String contextPath) { String pathInfo = requestUri.substring(contextPath.length()) .replaceAll("/{2,}", "/"); if (pathInfo.startsWith(servletPath)) { int servletPathLength = servletPath.length(); pathInfo = pathInfo.substring(servletPathLength); // Corner case: when servlet path & request path match exactly // (without trailing '/'), then pathinfo is null. if (pathInfo.isEmpty() && servletPathLength > 0) { return null; } } else { return null; <|startfocus|> } <|endfocus|> return pathInfo;
<|startcomment|> Technically, 2 hashcodes from non-equal elements could be equal, the probability is very very low but still... <|endcomment|>  } /** * Test the hashcode */ @Test public void hashcodeTest() { EnumDeclaration a = new EnumDeclaration(IntegerDeclaration.INT_8_DECL); a.add(0, 1, "hello"); a.add(2, 3, "kitty"); EnumDeclaration b = new EnumDeclaration(IntegerDeclaration.createDeclaration(1, false, 1, ByteOrder.BIG_ENDIAN, Encoding.ASCII, "", 8)); assertEquals(b.hashCode(), fixture.hashCode()); <|startfocus|> assertNotEquals(a.hashCode(), fixture.hashCode()); <|endfocus|> } /** * Test the equals */ @Test public void equalsTest() { EnumDeclaration a = new EnumDeclaration(IntegerDeclaration.INT_8_DECL); EnumDeclaration b = new EnumDeclaration(IntegerDeclaration.INT_8_DECL); b.add(2, 19, "hi"); EnumDeclaration c = new EnumDeclaration(IntegerDeclaration.INT_32B_DECL); EnumDeclaration d = new EnumDeclaration(IntegerDeclaration.INT_8_DECL); assertNotEquals(a, null); assertNotEquals(a, new Object()); assertNotEquals(a, b); assertNotEquals(a, c); assertNotEquals(b, c);
<|startcomment|> shrubbery <|endcomment|>  * @version 1.0 * @author Matthew khouzam */ public class CtfTmfTrace extends TmfTrace implements ITmfEventParser, ITmfTraceProperties, ITmfPersistentlyIndexable, ITmfTraceWithPreDefinedEvents, AutoCloseable { // ------------------------------------------- // Constants // ------------------------------------------- /** * Default cache size for CTF traces */ protected static final int DEFAULT_CACHE_SIZE = 50000; /** * Event aspects available for all CTF traces */ private static final @NonNull Collection<ITmfEventAspect> CTF_ASPECTS = <|startfocus|> NonNullUtils.checkNotNull(ImmutableList.of( <|endfocus|> ITmfEventAspect.BaseAspects.TIMESTAMP, new CtfChannelAspect(), new CtfCpuAspect(), ITmfEventAspect.BaseAspects.EVENT_TYPE, ITmfEventAspect.BaseAspects.CONTENTS )); /** * The Ctf clock unique identifier field */ private static final String CLOCK_HOST_PROPERTY = "uuid"; //$NON-NLS-1$ private static final int CONFIDENCE = 10; // ------------------------------------------- // Fields // ------------------------------------------- private final Map<String, CtfTmfEventType> fContainedEventTypes =
<|startcomment|> we are not handling "timeout" anymore <|endcomment|> import org.kohsuke.args4j.Option; @Command(common = true, usage = "usage_LsRemote") class LsRemote extends TextBuiltin { @Option(name = "--timeout", metaVar = "metaVar_service", usage = "usage_abortConnectionIfNoActivity") int timeout = -1; @Argument(index = 0, metaVar = "metaVar_uriish", required = true) private String remote; @Override protected void run() throws Exception { <|startfocus|> LsRemoteCommand command = Git.lsRemoteRepository().setRemote(remote); <|endfocus|> TreeSet<Ref> refs = new TreeSet<Ref>(new Comparator<Ref>() { public int compare(Ref r1, Ref r2) { return r1.getName().compareTo(r2.getName()); } }); refs.addAll(command.call()); for (final Ref r : refs) { show(r.getObjectId(), r.getName()); if (r.getPeeledObjectId() != null) show(r.getPeeledObjectId(), r.getName() + "^{}"); //$NON-NLS-1$ } } @Override protected boolean requiresRepository() {
<|startcomment|> Should that be additionalLoadedRevisions? <|endcomment|>  { return getRevisions(ids, branchPoint, referenceChunk, prefetchDepth, loadOnDemand, null); } public List<CDORevision> getRevisions(List<CDOID> ids, CDOBranchPoint branchPoint, int referenceChunk, int prefetchDepth, boolean loadOnDemand, SyntheticCDORevision[] synthetics) { RevisionInfo[] infos = new RevisionInfo[ids.size()]; List<RevisionInfo> infosToLoad = createRevisionInfos(ids, branchPoint, prefetchDepth, loadOnDemand, infos); List<CDORevision> primaryLoadedRevisions = null; <|startfocus|> List<InternalCDORevision> additionalRevisions = null; <|endfocus|> if (infosToLoad != null) { additionalRevisions = loadRevisions(infosToLoad, branchPoint, referenceChunk, prefetchDepth); primaryLoadedRevisions = getResultsAndSynthetics(infosToLoad.toArray(new RevisionInfo[0]), null); } if (primaryLoadedRevisions != null && !primaryLoadedRevisions.isEmpty() || additionalRevisions != null && !additionalRevisions.isEmpty()) { List<CDORevision> additional = Collections.emptyList(); if (additionalRevisions != null && !additionalRevisions.isEmpty()) { additional = new ArrayList<CDORevision>(additionalRevisions); } 
<|startcomment|> checknotnull <|endcomment|>  String traceName = getName(); if (traceName.isEmpty()) { traceName = (resource != null) ? resource.getName() : new Path(path).lastSegment(); } if (fParser == null) { if (this instanceof ITmfEventParser) { fParser = (ITmfEventParser) this; } else { throw new TmfTraceException("Invalid trace parser"); //$NON-NLS-1$ } } super.init(traceName, type); /* Initialize the analysis modules */ <|startfocus|> @SuppressWarnings("null") @NonNull Class<? extends TmfTrace> className = this.getClass(); <|endfocus|> Map<String, IAnalysisModuleHelper> modules = TmfAnalysisManager.getAnalysisModules(className); for (IAnalysisModuleHelper helper : modules.values()) { try { IAnalysisModule module = helper.newModule(this); fAnalysisModules.put(module.getId(), module); } catch (TmfAnalysisException e) { Activator.logWarning("Could not initialize analysis module " + e.getMessage()); //$NON-NLS-1$ } } // register as VIP after super.init() because TmfComponent registers to signal manager there
<|startcomment|> Never handle exceptions like that. If you can't handle it, request user help, or rethrow it, thel log it via plugin activator. <|endcomment|>  try { if (Scenarios.isEclMode((Scenario) scenario.getNamedElement())) { IQ7NamedElement copy = scenario .getWorkingCopy(new NullProgressMonitor()); try { Scenario sc = (Scenario) copy.getNamedElement(); Scenarios.setTypeToTesla(sc, true); Scenarios.setTypeToEcl(sc); WriteAccessChecker writeAccessChecker = new WriteAccessChecker(); if (writeAccessChecker.makeResourceWritable(copy)) { copy.commitWorkingCopy(true, new NullProgressMonitor()); } } catch (CoreException e) { <|startfocus|> e.printStackTrace(); <|endfocus|> } finally { copy.discardWorkingCopy(); } return true; } } catch (ModelException e) { e.printStackTrace(); } return false;
<|startcomment|> same <|endcomment|>  if (copy instanceof ITestCase) { ((ITestCase) copy).setVerifications(references .toArray(new String[references.size()])); } else if (copy instanceof IQ7ProjectMetadata) { NamedElement namedElement = copy.getNamedElement(); if (namedElement instanceof ProjectMetadata) { ProjectMetadata meta = (ProjectMetadata) namedElement; meta.getVerifications().clear(); meta.getVerifications().addAll(references); } } <|startfocus|> WriteAccessChecker writeAccessChecker = new WriteAccessChecker(); if (writeAccessChecker.makeResourceWritable(copy)) { copy.commitWorkingCopy(true, new NullProgressMonitor()); } <|endfocus|> return new DeleteVerificationReferenceChange(getElement(), getVerification(), getVerificationId()); } finally { copy.discardWorkingCopy(); } } finally { pm.done(); } } } 
<|startcomment|> It's probably better to check variable for null before calling this method. <|endcomment|>  public boolean isEnvironmentVariable(ICdtVariable variable, ICConfigurationDescription cfg) { if(variable instanceof EnvironmentVariableSupplier.EnvVarMacro) return true; <|startfocus|> if (variable == null) return false; <|endfocus|> IVariableContextInfo info = getVariableContextInfo(cfg); ICdtVariable var = fEnvironmentMacroSupplier.getVariable(variable.getName(), info); if(var != null && variablesEqual(var, variable)) return true; return false;
<|startcomment|> Wrong name <|endcomment|>  * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Genevive Bastien - Initial API and implementation *******************************************************************************/ package org.eclipse.tracecompass.analysis.os.linux.core.tests; import java.io.IOException; import java.net.URL; import org.eclipse.core.runtime.FileLocator; import org.eclipse.core.runtime.IPath; import org.eclipse.core.runtime.Path; import org.eclipse.core.runtime.Plugin; import org.osgi.framework.BundleContext; /** <|startfocus|> * Activator for the lttng2.kernel.core.tests plugin <|endfocus|> * * @author Genevive Bastien */ public class Activator extends Plugin { // ------------------------------------------------------------------------ // Attributes // ------------------------------------------------------------------------ /** * The plug-in ID */ public static final String PLUGIN_ID = "org.eclipse.tracecompass.analysis.linux.core.tests"; //$NON-NLS-1$ /** * The shared instance */ private static Activator PLUGIN; // ------------------------------------------------------------------------ // Constructors // ------------------------------------------------------------------------ /** * The constructor */ public Activator() { } // ------------------------------------------------------------------------ // Accessors // ------------------------------------------------------------------------ /**
<|startcomment|> Why not adding this in the above search of view, when notifier is instanceof View? <|endcomment|>  if (notifier instanceof EObject) { if (notifier instanceof View) { view = (View) notifier; // For Style and LayoutConstraint } else if (((EObject) notifier).eContainer() instanceof View) { view = (View) ((EObject) notifier).eContainer(); } } if (view != null) { if (view.eContainer() instanceof View && (CombinedFragment.compartmentNotationPredicate().apply(view) || Operand.compartmentNotationPredicate().apply(view))) { view = (View) view.eContainer(); } <|startfocus|> Option<ISequenceElement> sequenceElementOption = ISequenceElementAccessor.getISequenceElement(view); isSequenceElement = sequenceElementOption.some(); <|endfocus|> } return isSequenceElement;
<|startcomment|> Please add 2015 into the range of years. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2012, 2014 Obeo and others. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation * Stefan Dirix - bug 441172 *******************************************************************************/ package org.eclipse.emf.compare.merge; import static com.google.common.base.Predicates.in; import static com.google.common.collect.Iterables.any; import static org.eclipse.emf.compare.utils.EMFComparePredicates.fromSide; import static org.eclipse.emf.compare.utils.EMFComparePredicates.hasConflict; import static org.eclipse.emf.compare.utils.EMFComparePredicates.isDiffOnEOppositeOf; import com.google.common.base.Optional; import com.google.common.collect.Iterables; import com.google.common.collect.Iterators; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Set; import org.eclipse.emf.common.util.Monitor; import org.eclipse.emf.compare.Conflict;
<|startcomment|> Use (StringUtil.isEmpty(elementName)) instead that ckeck if your String is null or empty instead (elementName == null || "".equals(elementName)) <|endcomment|>  public IStatus validate(IValidationContext ctx) { IStatus status = null; EObject target = ctx.getTarget(); for (EObject content : target.eContents()) { if (content instanceof IdentifiedElement && !(content instanceof Group || content instanceof ViewpointSpec)) { String elementName = ((IdentifiedElement) content).getName(); <|startfocus|> if (elementName == null || "".equals(elementName)) { <|endfocus|> status = ctx.createFailureStatus(getPath(content) + ERROR_MESSAGE); } } } if (status == null) { status = ctx.createSuccessStatus(); } return status;
<|startcomment|> Useless cast to boolean asthe Runnable is typed with Boolean. <|endcomment|>  CustomSiriusEditor treeEditor = (CustomSiriusEditor) odesignEditor.getReference().getEditor(false); Image treeItemImageExpected = imageComposer.getImageOfEditPlugin(treeEditor.getAdapterFactory(), (EObject) treeItem.widget.getData()); setResult(ImageEquality.areEqualImages(treeItemImageExpected, treeItemImageDisplay)); } }); } }; treeItem.widget.getDisplay().syncExec(runnable); <|startfocus|> assertTrue("A red cross must appear on the image of the node mapping.", ((Boolean) runnable.getResult()).booleanValue()); <|endfocus|>
<|startcomment|> Add Javadoc for this API interface <|endcomment|> ***************************************************************************** * Copyright (c) 2013 THALES GLOBAL SERVICES. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.common.tools.api.util; <|startfocus|> <|endfocus|> public interface SiriusCrossReferenceAdapter { /** * Disable the resolution of the proxy. */ void disableResolveProxy(); /** * Enable the resolution of the proxy. */ void enableResolveProxy(); } 
<|startcomment|> I think that this method should be always here for maitenance branch. No=? <|endcomment|>  unloadResource(); if (disposeEditingDomainOnClose) { // To remove remaining resource like environment:/viewpoint for (Resource resource : new ArrayList<Resource>(resourceSet.getResources())) { resource.unload(); resourceSet.getResources().remove(resource); } } // Notify that the session is closed. notifyListeners(SessionListener.CLOSED); SessionManager.INSTANCE.remove(this); if (semanticResourcesUpdater != null) { semanticResourcesUpdater.dispose(); semanticResourcesUpdater = null; } if (semanticResources != null) { semanticResources.clear(); <|startfocus|> } <|endfocus|> saver.dispose(); if (disposeEditingDomainOnClose) { transactionalEditingDomain.dispose(); doDisposePermissionAuthority(resourceSet); } mainDAnalysis = null;
<|startcomment|> Would be simpler as: return Arrays.asList(Action.RELOAD); <|endcomment|>  private List<Action> handleChangesCanceled(Session session, Resource resource, ResourceStatus newStatus) { <|startfocus|> final List<Action> actions = Lists.newArrayList(); actions.add(Action.RELOAD); return actions; <|endfocus|>
<|startcomment|> Currently, this API is intended to make branch modifications not search for artifacts. I would recommend adding a convenience "andIsHeirarchicalRootArtifact" to the queryBuilder api. So this call would be made using the ArtifactQuery API not the OrcsBranch API <|endcomment|>  CreateBranchData branchData = branchDataFactory.createCopyTxBranchData(branch, author, fromTransaction, associatedArtifact); return createBranch(branchData); } @Override public Callable<BranchReadable> createPortBranch(IOseeBranch branch, ArtifactReadable author, ITransaction fromTransaction, ArtifactReadable associatedArtifact) throws OseeCoreException { CreateBranchData branchData = branchDataFactory.createPortBranchData(branch, author, fromTransaction, associatedArtifact); return createBranch(branchData); } <|startfocus|> @SuppressWarnings("unchecked") @Override public ArtifactReadable getDefaultHierarchyRootArtifact(IOseeBranch branch) { return queryFactory.fromBranch(branch).andIds(CoreArtifactTokens.DefaultHierarchyRoot).getResults().getExactlyOne(); } <|endfocus|> } 
<|startcomment|> dead code to remove <|endcomment|>  protected void doExecute() { // add content to resource rsMainComponent.getContents().add(componentRoot); rsFragComponent.getContents().add(component1); // add resources to session session.addSemanticResource(fileMainComponentUri, new NullProgressMonitor()); <|startfocus|> //session.addSemanticResource(fileFragComponentUri, new NullProgressMonitor()); <|endfocus|> // save session session.save(new NullProgressMonitor());
<|startcomment|> It is hard to guess what this is supposed to be. Rename to SOURCE_FILE_NAME or P2_IU_XML? <|endcomment|>  || PackagingType.TYPE_ECLIPSE_TEST_PLUGIN.equals(packaging)) { return "META-INF/MANIFEST.MF"; } else if (PackagingType.TYPE_ECLIPSE_FEATURE.equals(packaging)) { return "feature.xml"; } else if (PackagingType.TYPE_ECLIPSE_APPLICATION.equals(packaging)) { return project.getArtifactId() + ".product"; } else if (PackagingType.TYPE_ECLIPSE_REPOSITORY.equals(packaging)) { return project.getArtifactId(); } else if (PackagingType.TYPE_P2_IU.equals(packaging)) { <|startfocus|> return IU.P2_IU; <|endfocus|> } return "<unknown packaging=" + packaging + ">";
<|startcomment|> Wrong method name. <|endcomment|> <|startfocus|> public void testTreeGlobalRefreshWithF5Shortcut() { <|endfocus|> int nbLines = dTable.getLines().size(); tableEditorBot.setFocus(); tableEditorBot.bot().tree().getAllItems()[0].select(); doLineDeletionWithDELShortcut(tableRepresentation.getTree()); assertEquals(nbLines - 1, dTable.getLines().size());
<|startcomment|> dein name <|endcomment|> import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Link; /** * This class defines a Control which is used for displaying {@link org.eclipse.emf.ecore.EStructuralFeature * EStructuralFeature}s which have a reference. * <|startfocus|> * @author Eugen Neufeld <|endfocus|> * */ public class LinkControlSWTRenderer extends SimpleControlSWTControlSWTRenderer { /** * @param vElement * @param viewContext * @param factory */ public LinkControlSWTRenderer(VControl vElement, ViewModelContext viewContext, SWTRendererFactory factory) { super(vElement, viewContext, factory); } private Composite linkComposite; private Link hyperlink; private Label imageHyperlink; /** * The {@link ComposedAdapterFactory} used by the control. */ private ComposedAdapterFactory composedAdapterFactory; private ECPModelElementChangeListener modelElementChangeListener; private Label unsetLabel;
<|startcomment|> Add a HACK todo with a reference to the open bug. <|endcomment|>  if (isDisposed) { throw new IllegalStateException(THE_VIEW_MODEL_CONTEXT_WAS_ALREADY_DISPOSED); } if (modelChangeListener == null) { throw new IllegalArgumentException(MODEL_CHANGE_LISTENER_MUST_NOT_BE_NULL); } if (parentContext == null) { // TODO performance // needed to make sure, all data operations are done before any validation etc provided by services happens if (VDomainModelReference.class.isInstance(modelChangeListener)) { domainModelChangeListener.add(0, modelChangeListener); <|startfocus|> } else { <|endfocus|> int positionToInsert = -1; for (int i = 0; i < domainModelChangeListener.size(); i++) { final ModelChangeListener listener = domainModelChangeListener.get(i); if (modelChangeListener.getClass().isInstance(listener)) { positionToInsert = i; break; } } if (positionToInsert == -1) { domainModelChangeListener.add(modelChangeListener); } else { domainModelChangeListener.add(positionToInsert, modelChangeListener); } } } else { parentContext.registerDomainChangeListener(modelChangeListener); } } @Override
<|startcomment|> So we treat 4.5.0 as equal to 4.05.0, but not v4.5.0? I wonder if we should just compare the orgVersions. What do you think? <|endcomment|> <|startfocus|> public boolean equals(Object obj) { <|endfocus|> if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } RepositoryVersion other = (RepositoryVersion) obj; if (major == null) { if (other.major != null) { return false; } } else if (!major.equals(other.major)) { return false; } if (micro == null) { if (other.micro != null) { return false; } } else if (!micro.equals(other.micro)) { return false; } if (minor == null) { if (other.minor != null) { return false; } } else if (!minor.equals(other.minor)) { return false; } if (qualifier == null) { if (other.qualifier != null) { return false; } } else if (!qualifier.equals(other.qualifier)) { return false; } return true;
<|startcomment|> I think we don't need an enum value and a Hook class per hook, instead we could add a name to each hook class and get rid of the enum. <|endcomment|> <|startfocus|> public Hook getHookType() { return Hook.PRE_COMMIT; <|endfocus|>
<|startcomment|> If it is possible that the editor control is disposed here, it might also be possible that it is null. So I would add getEditorControl() != null && ... And please make every && condition on a new line for better readability. Not your fault, just for better readability. <|endcomment|>  public void run() { <|startfocus|> if (!getEditorControl().isDisposed() && KeyPressCommitRunnable.this.toCommit != null && KeyPressCommitRunnable.this.toCommit.equals(getEditorValue())) { <|endfocus|> commit(MoveDirectionEnum.NONE, false); }
<|startcomment|> You can use return checkNotNull(Collections.EMPTY_LIST); The EMPTY_* static definitions do some sort of type inference, whereas the older .empty*() methods don't. <|endcomment|>  } @Override public String[] getSessionNames(IProgressMonitor monitor) throws ExecutionException { return new String[0]; } @Override public ISessionInfo getSession(String sessionName, IProgressMonitor monitor) throws ExecutionException { return NullSessionInfo.INSTANCE; } @Override public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException { return new SnapshotInfo(EMPTY_STRING); } @Override public List<IBaseEventInfo> getKernelProvider(IProgressMonitor monitor) throws ExecutionException { <|startfocus|> return checkNotNull(new ArrayList<IBaseEventInfo>()); <|endfocus|> } @Override public List<IUstProviderInfo> getUstProvider() throws ExecutionException { return checkNotNull(new ArrayList<IUstProviderInfo>()); } @Override public List<IUstProviderInfo> getUstProvider(IProgressMonitor monitor) throws ExecutionException { return checkNotNull(new ArrayList<IUstProviderInfo>()); } @Override public ISessionInfo createSession(ISessionInfo sessionInfo, IProgressMonitor monitor) throws ExecutionException { return NullSessionInfo.INSTANCE; } @Override public void destroySession(String sessionName, IProgressMonitor monitor) throws ExecutionException { } @Override
<|startcomment|> Typo : collabsing -> collapsing <|endcomment|>  expandDTreeItemCmd.append(new DTreeItemExpansionChangeCommand(globalContext, domain, dTreeItem, monitor, true)); if (!Platform.getPreferencesService().getBoolean(SiriusPlugin.ID, SiriusPreferencesKeys.PREF_AUTO_REFRESH.name(), false, null)) { SiriusCommand result = new SiriusCommand(domain); result.getTasks().add(new RefreshTreeElementTask(dTreeItem)); expandDTreeItemCmd.append(result); } commandStack.execute(expandDTreeItemCmd); } else { <|startfocus|> monitor.beginTask("Tree item collabsing", 1); <|endfocus|> Command collapseDTreeItemCmd = new DTreeItemExpansionChangeCommand(globalContext, domain, dTreeItem, monitor, false); commandStack.execute(collapseDTreeItemCmd); } } finally { monitor.done(); } } } 
<|startcomment|> No french comment in code ... <|endcomment|>  assertEquals(1, semanticResources.size()); // 2 - Check LocalResourceCollector Resource resourcelib = semanticResources.iterator().next(); Method method = DAnalysisSessionImpl.class.getDeclaredMethod("collectAllReferencedResources", Resource.class); method.setAccessible(true); Collection<Resource> allReferencedResources = (Collection<Resource>) method.invoke(sessionLibrary, resourcelib); UnmodifiableIterator<LocalResourceCollector> lcrIt = Iterators.filter(resourcelib.getResourceSet().eAdapters().iterator(), LocalResourceCollector.class); <|startfocus|> assertTrue("Le LocalResourceCollector n'est pas mis sur le resourceSet", lcrIt.hasNext()); <|endfocus|> LocalResourceCollector lcr = lcrIt.next(); assertEquals(0, allReferencedResources.size()); // TestsUtil.synchronizationWithUIThread(); // --------- Library session checks -------- // 1 - Check that control occurs on ConsumerProject EList<Resource> controlledResourcesInConsumer = ((DAnalysisSessionEObjectImpl) session).getControlledResources(); assertEquals(1, controlledResourcesInConsumer.size()); assertTrue(controlledResourcesInConsumer.get(0).toString().contains("lib_P1")); Collection<Resource> semanticResourcesInConsumer = session.getSemanticResources(); assertEquals(2, semanticResourcesInConsumer.size()); 
<|startcomment|> "a {@link IProgressMonitor} to give progression" <|endcomment|>  } } finally { monitor.done(); } return this; } /** * Expand all root items of the DTree. * * @return this user interaction * */ public DTreeUserInteraction expand() { return expand(new NullProgressMonitor()); } /** * Expand all root items of the DTree. * * @return this user interaction * * @param monitor <|startfocus|> * the progress monitor <|endfocus|> */ public DTreeUserInteraction expand(IProgressMonitor monitor) { try { monitor.beginTask("Tree item expanding", tree.getOwnedTreeItems().size()); for (DTreeItem child : tree.getOwnedTreeItems()) { if (!child.isExpanded()) { new DTreeItemUserInteraction(child, ctx).expand(new SubProgressMonitor(monitor, 1)); } else { monitor.worked(1); } } } finally { monitor.done(); } return this; } } 
<|startcomment|> Use comma as separator : http://www.eclipse.org/legal/copyrightandlicensenotice.php <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007-2015 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.business.internal.session.danalysis; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.Iterator; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.resource.Resource; import org.eclipse.emf.transaction.RunnableWithResult; import org.eclipse.emf.transaction.TransactionalEditingDomain; import org.eclipse.emf.transaction.util.TransactionUtil; import org.eclipse.sirius.business.api.dialect.DialectManager; import org.eclipse.sirius.business.api.helper.SiriusHelper; import org.eclipse.sirius.business.api.helper.SiriusUtil; import org.eclipse.sirius.business.api.query.DRepresentationQuery; import org.eclipse.sirius.business.api.query.RepresentationDescriptionQuery; import org.eclipse.sirius.business.api.session.CustomDataConstants;
<|startcomment|> uncontrol <|endcomment|>  assertEquals(1, resReferencingLib.size()); assertTrue(resReferencingLib.iterator().next().getURI().toString().contains(SEMANTIC_MODEL_CONSUMER)); // ###################################### // B - Uncontrol the package SiriusUncontrolCommand unControlCmd = new SiriusUncontrolCommand(packageToControl, true, true, new NullProgressMonitor()); TransactionUtil.getEditingDomain(mainPackage).getCommandStack().execute(unControlCmd); // --------- Library session checks -------- <|startfocus|> // 1 - Check that control occurs on LibraryProject <|endfocus|> URI libModelUri = URI.createPlatformResourceURI("/" + LIBRARY_PROJECT + "/" + SEMANTIC_MODEL_LIB, true); assertEquals(libModelUri, packageToControl.eResource().getURI()); controlledResources = ((DAnalysisSessionEObjectImpl) sessionLibrary).getControlledResources(); assertEquals(0, controlledResources.size()); semanticResources = sessionLibrary.getSemanticResources(); assertEquals(1, semanticResources.size()); //check models tag for (final DAnalysis analysis : ((DAnalysisSessionImpl) sessionLibrary).allAnalyses()) { assertTrue(analysis.getModels().size()==1); } // 2 - Check LocalResourceCollector
<|startcomment|> typo: parameter <|endcomment|>  * The ID for this state system * @param startTime * The start time of the state system and backend * @return The state system backend */ public static IStateHistoryBackend createInMemoryBackend(String ssid, long startTime) { return new InMemoryBackend(ssid, startTime); } /** * Create a new backend using a History Tree. This backend stores all its * intervals on disk. * <|startfocus|> * By specifying a 'queueSize' paramter, the implementation that runs in a <|endfocus|> * separate thread can be used. * * @param ssid * The state system's id * @param stateFile * The filename/location where to store the state history (Should * end in .ht) * @param providerVersion * Version of of the state provider. We will only try to reopen * existing files if this version matches the one in the * framework. * @param startTime * The earliest time stamp that will be stored in the history
<|startcomment|> please add a short description of the purpose of this class as javadoc <|endcomment|> import org.eclipse.egit.core.synchronize.dto.GitSynchronizeDataSet; import org.eclipse.egit.core.test.GitTestCase; import org.eclipse.egit.core.test.TestRepository; import org.eclipse.jgit.api.Git; import org.eclipse.jgit.api.Status; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.team.core.mapping.IMergeContext; import org.eclipse.team.core.mapping.IResourceMappingMerger; import org.eclipse.team.core.mapping.ResourceMappingMerger; import org.eclipse.team.core.subscribers.SubscriberScopeManager; import org.junit.Before; <|startfocus|> <|endfocus|> public abstract class ModelTestCase extends GitTestCase { protected static final String SAMPLE_FILE_EXTENSION = SampleModelProvider.SAMPLE_FILE_EXTENSION; @Before public void setUp() throws Exception { super.setUp(); IContentType textType = Platform.getContentTypeManager() .getContentType("org.eclipse.core.runtime.text"); textType.addFileSpec(SAMPLE_FILE_EXTENSION, IContentType.FILE_EXTENSION_SPEC); } protected RevCommit setContentsAndCommit(TestRepository testRepository, IFile targetFile, String newContents, String commitMessage) throws Exception { targetFile.setContents( new ByteArrayInputStream(newContents.getBytes()),
<|startcomment|> 2015 THALES GLOBAL SERVICES and others. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2012 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.table.business.internal.metamodel.spec; import java.util.Collection; import org.eclipse.emf.common.util.EList; import org.eclipse.emf.ecore.InternalEObject; import org.eclipse.emf.ecore.util.EcoreEList; import org.eclipse.sirius.table.business.internal.metamodel.operations.DColumnOperations; import org.eclipse.sirius.table.metamodel.table.DCell; import org.eclipse.sirius.table.metamodel.table.DTableElementSynchronizer; import org.eclipse.sirius.table.metamodel.table.TablePackage; import org.eclipse.sirius.table.metamodel.table.description.TableMapping; import org.eclipse.sirius.table.metamodel.table.impl.DTargetColumnImpl; import org.eclipse.sirius.viewpoint.description.RepresentationElementMapping; /** * Specialization of DTargetColumn. * * @author cbrun */
<|startcomment|> Create a constant. <|endcomment|>  protected void refreshAppliedStereotypesPropertiesInBrace(IPapyrusNodeUMLElementFigure figure) { String toDisplayInBrace = helper.getStereotypePropertiesInBrace(hostView); <|startfocus|> if (!"".equals(toDisplayInBrace)) { <|endfocus|> figure.setStereotypePropertiesInBrace(toDisplayInBrace); } else { figure.setStereotypePropertiesInBrace(null); }
<|startcomment|> You can add to the top of the file (note the 'static') import static org.junit.Assert.assertEquals; and then remove org.junit.Assert everywhere in the file <|endcomment|>  /** Test Un-supported List type - we expect an Exception */ @Test(expected = Exception.class) public void testUnsupportedListType() throws Exception { PersistentListParameter<Float> persistentFloatList = m_persistentSettingsManager1.getNewListParameter(Float.class, "Float Parameter", false, new ArrayList<Float>()); } /** Test persisting one String value */ @Test public void testPersistentParamString() throws Exception { // no value persisted yet - should return default <|startfocus|> org.junit.Assert.assertEquals(DEFAULT_STRING, m_stringParam.value()); <|endfocus|> // set a value String randomString = getRandomString(); m_stringParam.set(randomString); // get cached value org.junit.Assert.assertEquals(randomString, m_stringParam.value()); // force re-read from storage org.junit.Assert.assertEquals(randomString, m_stringParam.value(true)); // set a different value randomString = getRandomString(); m_stringParam.set(randomString); // get cached value org.junit.Assert.assertEquals(randomString, m_stringParam.value()); // force re-read from storage
<|startcomment|> Strange wording for describing an interface. <|endcomment|>  * Copyright (c) 2015 Obeo. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.common.tools.api.interpreter; import java.util.Set; /** <|startfocus|> * An instance which is being notified if the classpath of some project did <|endfocus|> * change. * * @author Cedric Brun <cedric.brun@obeo.fr> */ public interface ClasspathChangeCallback { /** * Called by the {@link ClassLoading} when some projects have been * updated in a way which might the classpath might have changed. * * @param updatedProjects * a set of project names which have been changed. */ void classpathChanged(Set<String> updatedProjects); } 
<|startcomment|> Should we add tool.getExtraSourceMappings() ? <|endcomment|>  * EdgeCreationDescription EClass in the diagram.ecore metamodel and to * complete the AbstractInterpretedExpressionQuery to make it able to * find specific variables for concrete types. */ Map<String, VariableType> availableVariables = super.getAvailableVariables(); if (getToolContext().some()) { EObject operationContext = getToolContext().get(); if (operationContext instanceof EdgeCreationDescription) { EdgeCreationDescription tool = (EdgeCreationDescription) operationContext; <|startfocus|> declareEdgeSourceTargets(availableVariables, tool.getEdgeMappings()); <|endfocus|> } if (operationContext instanceof ReconnectEdgeDescription) { ReconnectEdgeDescription tool = (ReconnectEdgeDescription) operationContext; declareEdgeSourceTargets(availableVariables, tool.getMappings()); availableVariables.put("otherEnd", VariableType.fromString(DIAGRAM_EDGE_TARGET_TYPE)); availableVariables.put("edgeView", VariableType.fromString(DIAGRAM_D_EDGE_TYPE)); Collection<String> possibleSources = Lists.newArrayList(); for (EdgeMapping eMapping : tool.getMappings()) { collectSemanticElementType(possibleSources, eMapping); } if (possibleSources.size() > 0) { VariableType sourceTypes = VariableType.fromStrings(possibleSources);
<|startcomment|> is leading capital letter allowed in method names? <|endcomment|> <|startfocus|> private static RGB RGBfromAttributes(Attributes attributes) { <|endfocus|> int r = Integer.parseInt(attributes.getValue(R_ATTR)); int g = Integer.parseInt(attributes.getValue(G_ATTR)); int b = Integer.parseInt(attributes.getValue(B_ATTR)); return new RGB(r, g, b);
<|startcomment|> The comment on the 2 previous lines is now irrelevant, remove it. <|endcomment|>  if (isInterruptedOrCanceled(monitor)) { demandResolvingAndUnloadingPoolShutdown(); return; } // check extension point for dependencies Collection<URI> uriCollection = dependencyProviderRegistry.getDependencies(uri); lock.lock(); try { monitor.setWorkRemaining(1000); for (URI currentUri : uriCollection) { if (resolvedResources.add(currentUri) && currentlyResolving.add(currentUri)) { <|startfocus|> // Regardless of the amount of progress reported so far, use 0.1% of the space remaining // in the monitor to process the next node. <|endfocus|> ListenableFuture<?> future = resolvingPool.submit(new RemoteResourceResolver(resourceSet, currentUri, monitor)); Futures.addCallback(future, new ResolvingFutureCallback(monitor, currentUri)); } } } finally { lock.unlock(); }
<|startcomment|> item <|endcomment|>  public Rectangle run() { <|startfocus|> TableItem r = t.getItem(row); Rectangle bounds = r.getBounds(col); Point p = t.toDisplay(bounds.x, bounds.y); <|endfocus|> Rectangle rect = new Rectangle(p.x, p.y, bounds.width, bounds.height); return rect;
<|startcomment|> Point outside of image <|endcomment|>  public List<RGB> sample(List<Point> samplePoints) { for (Point p : samplePoints) { if (!getBounds().contains(p)) { <|startfocus|> throw new IllegalArgumentException("Pixel outside of picture"); <|endfocus|> } } List<RGB> retVal = new ArrayList<>(samplePoints.size()); for (Point p : samplePoints) { retVal.add(getPixel(p.x, p.y)); } return retVal;
<|startcomment|> I think "default:" isn't needed since there's no other stage <|endcomment|>  || !resource.getProject().isAccessible()) { continue; } switch (entry.getStage()) { case DirCacheEntry.STAGE_1: baseCache.setVariant(resource, IndexResourceVariant.create(repository, entry)); break; case DirCacheEntry.STAGE_2: sourceCache.setVariant(resource, IndexResourceVariant.create(repository, entry)); break; case DirCacheEntry.STAGE_3: remoteCache.setVariant(resource, IndexResourceVariant.create(repository, entry)); break; case DirCacheEntry.STAGE_0: // Skipped on purpose (no conflict) default: <|startfocus|> break; <|endfocus|> } } baseTree = new GitCachedResourceVariantTree(baseCache); sourceTree = new GitCachedResourceVariantTree(sourceCache); remoteTree = new GitCachedResourceVariantTree(remoteCache); roots = new LinkedHashSet<IResource>(); roots.addAll(baseCache.getRoots()); roots.addAll(sourceCache.getRoots()); roots.addAll(remoteCache.getRoots()); knownResources = new LinkedHashSet<IResource>(); knownResources.addAll(baseCache.getKnownResources()); knownResources.addAll(sourceCache.getKnownResources()); knownResources.addAll(remoteCache.getKnownResources()); } 
<|startcomment|> @author <a href="maxime.porhel@obeo.fr">Maxime Porhel</a> <|endcomment|>  *******************************************************************************/ package org.eclipse.sirius.diagram.business.internal.metamodel.operations; import java.util.Collection; import java.util.HashSet; import org.eclipse.sirius.common.tools.api.util.EObjectCouple; import org.eclipse.sirius.diagram.AbstractDNode; import org.eclipse.sirius.diagram.DNode; import org.eclipse.sirius.diagram.business.internal.metamodel.description.operations.AbstractNodeMappingSpecOperations; import org.eclipse.sirius.diagram.description.AbstractNodeMapping; import org.eclipse.sirius.viewpoint.description.RepresentationElementMapping; /** * Common operations for {@link AbstractDNode} spec classes. * <|startfocus|> * @author mporhel <|endfocus|> */ public final class AbstractDNodeSpecOperations { /** * Avoid instantiation. */ private AbstractDNodeSpecOperations() { // empty. } /** * Refresh the border nodes of the given {@link AbstractDNode}. * * @param adn * the {@link AbstractDNode} whose bordered nodes need to be * refreshed. */ public static void refreshBorderNodes(AbstractDNode adn) { /* * Update bordering nodes */ final Collection<EObjectCouple> managedBorderingNodes = new HashSet<EObjectCouple>();
<|startcomment|> Initialise the variable out of body otherwise a variable is created for each iteration <|endcomment|>  public Image stereotypeIconToDisplay() { String stereotypespresentationKind = AppliedStereotypeHelper.getAppliedStereotypePresentationKind((View) getHost().getModel()); if (stereotypespresentationKind == null) { <|startfocus|> return null; <|endfocus|> } if (stereotypespresentationKind.equals(UMLVisualInformationPapyrusConstant.ICON_STEREOTYPE_PRESENTATION) || stereotypespresentationKind.equals(UMLVisualInformationPapyrusConstant.TEXT_ICON_STEREOTYPE_PRESENTATION)) { // retrieve the first stereotype in the list of displayed stereotype String stereotypesToDisplay = AppliedStereotypeHelper.getStereotypesToDisplay((View) getHost().getModel()); StringTokenizer tokenizer = new StringTokenizer(stereotypesToDisplay, ","); if (tokenizer.hasMoreTokens()) { String firstStereotypeName = tokenizer.nextToken(); Stereotype stereotype = getUMLElement().getAppliedStereotype(firstStereotypeName); return Activator.getIconElement(getUMLElement(), stereotype, false); } } return null;
<|startcomment|> We don't need to force "the given URI" to be part of the return. That's actually counter-intuitive too, since a given file is not a "dependency" of itself. It doesn't cost much to us to include it afterwards, so there's no need to dump that responsibility on implementers. <|endcomment|>  * @return {@code true} if the {@link IDependencyProvider} can provide dependencies for the given * {@code uri}, {@code false} otherwise. */ boolean apply(URI uri); /** * Determines the dependencies of the given {@code uri}. * * @param uri * The {@link URI} for which additional dependencies may be determined. <|startfocus|> * @return A collection of the calculated dependencies including the given {@code uri}. If no dependency * is determined an empty list is returned. <|endfocus|> */ Collection<URI> getDependencies(URI uri); } 
<|startcomment|> The parameter must be final <|endcomment|> <|startfocus|> public Command getAddCommand(Object value) { <|endfocus|> if (value instanceof IPapyrusProfileDefinition) { return new DefineProfileCommand((TransactionalEditingDomain) editingDomain, (IPapyrusProfileDefinition) value, profile); } return super.getAddCommand(value);
<|startcomment|> Collection<?> ? <|endcomment|>  if(m2!=null){ String name = todo+"From"+sourceClass; m2.invoke(myTodo, new Object[] {name}); } //Adding the new Object to the Target EStructuralFeature esfOwned = targetElement.eClass().getEStructuralFeature("owned"+todo);//$NON-NLS-1$ if(esfOwned.getUpperBound()==-1){ if ( targetElement.eGet(esfOwned) instanceof Collection){ <|startfocus|> ((Collection)targetElement.eGet(esfOwned)).add(myTodo); <|endfocus|> } else{ targetElement.eSet(esfOwned, myTodo); } } } catch (NoSuchMethodException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (SecurityException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InvocationTargetException e) {
<|startcomment|> null == is preferably used <|endcomment|>  public void setDefaultEditor(final IDirectEditorExtensionPoint extensionPoint) { // Find in preferences a direct editor IAbstractDirectEditor directEditor = getDirectEditorByExtensionPoint(extensionPoint); <|startfocus|> if (directEditor == null) { <|endfocus|> // Try in modified Default Editor directEditor = getDefaultDirectEditor(extensionPoint); } // If no direct Editor corresponds, one is created as key of the Map if (directEditor == null) { IEmbeddedEditorFactory factory = IEmbeddedEditorFactory.eINSTANCE; IDirectEditor editor = getDirectEditor(extensionPoint); if (editor == null) { editor = factory.createDirectEditor(); editor.setObjectToEdit(extensionPoint.getObjectToEdit()); } if (extensionPoint.getAdditionalConstraint() != null) { IConstraint constraint = factory.createConstraint(); constraint.setLabel(extensionPoint.getAdditionalConstraint().getLabel()); editor.getConstraints().add(constraint); directEditor = constraint; } else { directEditor = editor; } } modifiedDefaultEditor.put(directEditor, extensionPoint.getLanguage()); 
<|startcomment|> it* <|endcomment|>  * *****************************************************************************/ package org.eclipse.papyrus.uml.diagram.common.stereotype.display; import org.eclipse.gmf.runtime.notation.View; import org.eclipse.papyrus.uml.diagram.common.stereotype.display.helper.StereotypeDisplayConstant; import org.eclipse.uml2.uml.Property; import org.eclipse.uml2.uml.Stereotype; /** * This interface provides the View of the Stereotype Structure <|startfocus|> * If the view doesn't exist i creates the node thanks to the {@link IStereotypeViewFactory } Class. <|endfocus|> * It should never return null; * * @author Cline JANSSENS * */ public interface IStereotypeViewProvider { /** * Get the Property View for a specific location * * @param property * The UML property for the View to be created * @param stereotype * The UML Stereotype for which the property is required * @param location * The property location can be: * <ul> * <li>{@link StereotypeDisplayConstant#STEREOTYPE_COMMENT_LOCATION}</li> * <li>{@link StereotypeDisplayConstant#STEREOTYPE_COMPARTMENT_LOCATION}</li>
<|startcomment|> I think we could get rid of both the constant and the local variable and just write e.g. 2 instead of offset+1. <|endcomment|>  } @Test public void testAbandonChange() throws Exception { String message1 = "abandon, time: " + System.currentTimeMillis(); //$NON-NLS-1$ ChangeDetail changeDetail = reviewHarness.getClient().abandon(reviewHarness.getShortId(), 1, message1, new NullProgressMonitor()); reviewHarness.retrieve(); assertThat(changeDetail, notNullValue()); assertThat(changeDetail.getChange().getStatus(), is(Status.ABANDONED)); List<ChangeMessage> messages = changeDetail.getMessages(); <|startfocus|> int offset = COMMENT_OFFSET; assertThat(messages.size(), is(offset + 1)); ChangeMessage lastMessage = messages.get(offset + 0); <|endfocus|> assertThat(lastMessage.getAuthor().get(), is(1000001)); assertThat(lastMessage.getMessage(), endsWith("Abandoned\n\n" + message1)); assertThat(getReview().getState(), is(ReviewStatus.ABANDONED)); List<IComment> comments = getReview().getComments(); assertThat(comments.size(), is(offset + 1)); IComment lastComment = comments.get(offset + 0); assertThat(lastComment.getAuthor().getDisplayName(), is("tests"));
<|startcomment|> private final :) <|endcomment|> import org.eclipse.tracecompass.internal.ctf.core.trace.StreamInputPacketIndex; /** * A CTF Stream output writer. Reads the packets of a given CTFStreamInput and * writes packets that are within a given time range to output stream file. * * @author Bernd Hufmann * @since 1.0 */ public class CTFStreamOutputWriter { // ------------------------------------------------------------------------ // Attributes // ------------------------------------------------------------------------ // Stream input when copying stream from an input // It is @Nullable for future implementations that doesn't use an input stream <|startfocus|> @Nullable final private CTFStreamInput fStreamInput; @NonNull final private CTFStreamPacketOutputWriter fStreamPacketOutputWriter; @NonNull final private File fOutFile; <|endfocus|> // ------------------------------------------------------------------------ // Constructors // ------------------------------------------------------------------------ /** * Constructs a StreamInput. * * @param streamInput * The stream to which this StreamInput belongs to. * @param file * The output trace directory. * @throws CTFException * If a reading or writing error occurs */
<|startcomment|> We should put a comment that we want to go to the backend for complex structs to handle pointers. Without it, the code you removed may come back some day. <|endcomment|>  protected void handleSuccess() { getData().getValue(formatCxt, rm); <|startfocus|> <|endfocus|>
<|startcomment|> these lines are too wide, we use http://git.eclipse.org/c/egit/egit.git/tree/tools/eclipse-JGit-Format.xml <|endcomment|>  public boolean performFinish() { <|startfocus|> EasymportJob job = new EasymportJob(this.selectRootPage.getSelectedRootDirectory(), this.selectRootPage.getSelectedWorkingSets(), this.selectRootPage.isConfigureAndDetectNestedProject()); EasymportJobReportDialog dialog = new EasymportJobReportDialog(getShell(), job); <|endfocus|> job.schedule(); if (this.selectRootPage.isConfigureAndDetectNestedProject()) { dialog.open(); } return true;
<|startcomment|> Worth throwing ISE or something if you exit this loop without finding the slot in the table? That would mean this method is called with a stale Slot, which is indeed an illegal state (considering the class is not threadsafe). <|endcomment|>  private void removeFromTable(Slot e) { int tableIdx = hash(e.offset); Slot p = table[tableIdx]; if (p == e) { table[tableIdx] = e.tableNext; return; } for (; p != null; p = p.tableNext) { if (p.tableNext == e) { p.tableNext = e.tableNext; return; } <|startfocus|> } <|endfocus|>
<|startcomment|> How should we handle this? <|endcomment|>  HttpPost request = new HttpPost(baseUrl() + bugUrl); request.setHeader(CONTENT_TYPE, APPLICATION_JSON); request.setHeader(ACCEPT, APPLICATION_JSON); try { // set form parameters String gsonString = "{\"Bugzilla_token\":\"" + token.getToken() + "\"" + getGSonFieldsForNew(taskData) + "}"; StringEntity requestEntity = new StringEntity(gsonString); request.setEntity(requestEntity); } catch (UnsupportedEncodingException e) { <|startfocus|> // TODO Auto-generated catch block e.printStackTrace(); <|endfocus|> } return request;
<|startcomment|> checkNotNull is good enough for that. <|endcomment|>  pos = i; break; } } byte[] bytes = (pos != -1) ? (Arrays.copyOf(fContent, pos)) : fContent; return new String(bytes); } StringBuilder b = new StringBuilder(); b.append('['); Joiner.on(", ").appendTo(b, Arrays.asList(fContent)); //$NON-NLS-1$ b.append(']'); <|startfocus|> String string = b.toString(); if( string == null){ throw new IllegalStateException("toString returned null"); //$NON-NLS-1$ } return string; <|endfocus|>
<|startcomment|> (nit) indentation went awry <|endcomment|>  final String UNNORMALIZED = "target/"; final byte[] UNNORMALIZED_BYTES = Constants.encode(UNNORMALIZED); try (ObjectInserter oi = db.newObjectInserter()) { final ObjectId linkid = oi.insert(Constants.OBJ_BLOB, UNNORMALIZED_BYTES, 0, UNNORMALIZED_BYTES.length); dce.add(new DirCacheEditor.PathEdit("link") { @Override public void apply(DirCacheEntry ent) { ent.setFileMode(FileMode.SYMLINK); ent.setObjectId(linkid); ent.setLength(UNNORMALIZED_BYTES.length); } }); assertTrue(dce.commit()); <|startfocus|> } <|endfocus|> new Git(db).commit().setMessage("Adding link").call(); new Git(db).reset().setMode(ResetType.HARD).call(); DirCacheIterator dci = new DirCacheIterator(db.readDirCache()); FileTreeIterator fti = new FileTreeIterator(db); // self-check assertEquals("link", fti.getEntryPathString()); assertEquals("link", dci.getEntryPathString()); // test assertFalse(fti.isModified(dci.getDirCacheEntry(), true, db.newObjectReader())); } /**
<|startcomment|> Please add some comments at the different steps to be able to follow the test better: import trace, create trace name, open events editor and do basic validation of table content <|endcomment|> <|startfocus|> public void testGzipImport() { <|endfocus|> openImportWizard(); selectImportFromArchive(fGzipTrace.getAbsolutePath()); selectFolder(ROOT_FOLDER); SWTBotCheckBox checkBox = fBot.checkBox(Messages.ImportTraceWizard_CreateLinksInWorkspace); assertFalse(checkBox.isEnabled()); SWTBotCombo comboBox = fBot.comboBoxWithLabel(Messages.ImportTraceWizard_TraceType); comboBox.setSelection("Test trace : TMF Tests"); importFinish(); /* * Remove .gz extension */ assertNotNull(fGzipTrace); String name = fGzipTrace.getName(); assertNotNull(name); assertTrue(name.length() > 3); String traceName = name.substring(0, name.length() - 3); assertNotNull(traceName); assertFalse(traceName.isEmpty()); IPath expectedElementPath = new Path(traceName); SWTBotView projectExplorer = fBot.viewById(IPageLayout.ID_PROJECT_EXPLORER); projectExplorer.setFocus(); projectExplorer.bot().tree().expandNode(PROJECT_NAME, true); SWTBotUtils.openEditor(fBot, PROJECT_NAME, expectedElementPath); SWTBotUtils.waitForJobs(); SWTBotTable editor = fBot.activeEditor().bot().table();
<|startcomment|> I don't think this is a special key-word. It's the label shown in the Help System, so it shouldn't be ignored. This is exactly the kind of string we'd want translated. <|endcomment|>  public String getLabel() { <|startfocus|> return "Javadoc documents"; //$NON-NLS-1$ <|endfocus|>
<|startcomment|> This should be a switch. <|endcomment|>  for (IRemoteConnection target : remoteServicesManager.getAllRemoteConnections()) { if (supportsTarget(descriptor, target)) { targets.add(target); } } return targets; } boolean supportsTarget(ILaunchDescriptor descriptor, IRemoteConnection target) throws CoreException { String descriptorTypeId = getDescriptorTypeId(descriptor.getType()); for (LaunchConfigProviderInfo provider : configProviders.get(descriptorTypeId)) { try { <|startfocus|> Ternary supports = provider.getProvider().supports(descriptor, target); if (supports == Ternary.TRUE) { <|endfocus|> return true; } if (supports == Ternary.FALSE) { return false; } } catch (Throwable e) { Activator.log(e); } // otherwise continue } return false; } public IRemoteConnection getActiveLaunchTarget() { return activeLaunchTarget; } /** * Sets preferred target for launch descriptor * @param desc * @param target * @throws CoreException */ public void setLaunchTarget(ILaunchDescriptor desc, IRemoteConnection target) throws CoreException { if (desc == activeLaunchDesc) { setActiveLaunchTarget(target);
<|startcomment|> There is a high potential of NPE with concatenated calls. <|endcomment|>  protected TransactionalEditingDomain getTableEditingDomain() {// Duplicated from NatTableModelManager ServicesRegistry registry = null; <|startfocus|> if(null != getTableManager().getTable().eResource()){ <|endfocus|> try { registry = ServiceUtilsForEObject.getInstance().getServiceRegistry(getTableManager().getTable()); return registry.getService(TransactionalEditingDomain.class); } catch (final ServiceException e) { Activator.log.error(Messages.NattableModelManager_ServiceRegistryNotFound, e); } } return null;
<|startcomment|> Extract this to local variable. <|endcomment|>  public int compare(Object o1, Object o2) { <|startfocus|> WorkspaceFileObject fileObject1 = (WorkspaceFileObject) o1; WorkspaceFileObject fileObject2 = (WorkspaceFileObject) o2; return Integer.valueOf(fileObject1.getCount()).compareTo(Integer.valueOf(fileObject2.getCount())); <|endfocus|>
<|startcomment|> same <|endcomment|>  // If node is hidden, exit immediately. if (TmfBaseColumnDataProvider.HIDDEN_FOLDER_LEVELS.contains(node.getName())) { return; } // Otherwise, get percentage and draw bar and text if // applicable. double percentage = columnDataList.get(event.index).getPercentageProvider().getPercentage(node); // The item is selected. if ((event.detail & SWT.SELECTED) > 0) { <|startfocus|> // Draws our own background to avoid overwriting the // bar. <|endfocus|> event.gc.fillRectangle(event.x, event.y, event.width, event.height); event.detail &= ~SWT.SELECTED; } // Drawing the percentage text // if events are present in top node // and the current node is not the top node // and if is total or partial events column. // If not, exit the method. if (!((event.index == TmfBaseColumnDataProvider.StatsColumn.TOTAL.getIndex() || event.index == TmfBaseColumnDataProvider.StatsColumn.PARTIAL.getIndex()) && node != node.getTop())) {
<|startcomment|> same here, shouldn't need to add <|endcomment|>  Long uuid = newFeature.getUuid(); if (uuid == null || uuid <= 0) { uuid = Lib.generateArtifactIdAsInt(); } AtsChangeSet changes = (AtsChangeSet) atsServer.getStoreService().createAtsChangeSet("Create new Insertion Feature", atsServer.getUserService().getCurrentUser()); ArtifactReadable insertionFeatureArt = (ArtifactReadable) changes.createArtifact(AtsArtifactTypes.InsertionFeature, newFeature.getName(), GUID.create(), uuid); <|startfocus|> changes.add(insertionFeatureArt); <|endfocus|> changes.relate(insertion, AtsRelationTypes.InsertionToInsertionFeature_InsertionFeature, insertionFeatureArt); changes.execute(); return getInsertionFeature(insertionFeatureArt);
<|startcomment|> This is adding several fields and functions. That is fine because I think it would work. However, I'd like to propose an alternative, which I think also works. You can decided which you prefer -- feel free to go with your current implementation if you feel it is better. In my own workspace I usually enable this feature by changing CppCodeGenerator to avoid the call to ChangeTracker.prune. You could do the same by checking the flag at that point (line 182 in the current master). I haven't looked deeper into the implementation, but skipping that one function call has enabled this same functionality for me -- i.e., it seems work. <|endcomment|> import org.eclipse.emf.transaction.TransactionalEditingDomain; import org.eclipse.emf.transaction.util.TransactionUtil; import org.eclipse.papyrus.codegen.base.codesync.ChangeObject; import org.eclipse.papyrus.codegen.base.codesync.ManageChangeEvents; import org.eclipse.papyrusrt.codegen.CodeGenPlugin; import org.eclipse.papyrusrt.codegen.cpp.CppCodeGenerator; import org.eclipse.papyrusrt.codegen.cpp.CppCodePattern; import org.eclipse.papyrusrt.codegen.cpp.CppProjectGenerator; import org.eclipse.papyrusrt.codegen.xtumlrt.trans.UML2xtumlrtModelTranslator; @SuppressWarnings("nls") public class UMLRTGenerator { <|startfocus|> private static boolean forceGeneration = false; <|endfocus|> public static void setForceGeneration( boolean force ) { forceGeneration = force; } public static IStatus generate( List<EObject> elements, String top ) { UML2xtumlrtModelTranslator translator = new UML2xtumlrtModelTranslator(); CppCodePattern cpp = new CppCodePattern(); CppCodeGenerator codegen = new CppCodeGenerator( cpp, translator ); codegen.setTop( top ); if (forceGeneration) codegen.getChangeTracker().resetAll(); final List<ChangeObject> changes = new ArrayList<ChangeObject>();
<|startcomment|> consider renaming attrref for readability (camel-case) <|endcomment|>  String line; try { line = reader.readLine(); while (line != null) { Matcher matcher = ATTRIBUTE_PATTERN.matcher(line); if (matcher.matches()) { // attribute definitions matches the // whole line. String key = matcher.group(1); String value = matcher.group(2); if (value != null) { value = value.trim(); } attributes.put(key, value); } else { <|startfocus|> Matcher attrref = ATTRIBUTE_TOKEN_PATTERN.matcher(line); <|endfocus|> int offset = 0; while (attrref.find()) { String postfix = line.substring(offset, attrref.start()); if (postfix.endsWith("\\")) { // attribute ref was quoted processedMarkup.append(postfix.substring(0, postfix.length()-1)); offset = attrref.start(); } else { processedMarkup.append(postfix); String key = attrref.group(1); String value = attributes.get(key); if (value == null) { value = attrref.group(0); } processedMarkup.append(value);
<|startcomment|> No, not for addCommand. The caller runs this if push cert is enabled, but the client didn't send a push cert. <|endcomment|>  public void addCommand(String rawLine) { <|startfocus|> received = true; <|endfocus|> commands.add(parseCommand(chomp(rawLine))); rawCommands.append(rawLine);
<|startcomment|> 2015 <|endcomment|>  <|startfocus|> * Copyright (c) 2010, 2017 THALES GLOBAL SERVICES <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - Initial API and implementation */ package org.eclipse.sirius.tests.swtbot.support.api.editor; import java.util.Iterator; import java.util.List; import java.util.concurrent.atomic.AtomicBoolean; import org.eclipse.core.runtime.IAdaptable; import org.eclipse.draw2d.FigureCanvas; import org.eclipse.draw2d.IFigure; import org.eclipse.draw2d.Label; import org.eclipse.draw2d.LightweightSystem; import org.eclipse.draw2d.geometry.Point; import org.eclipse.draw2d.text.TextFlow; import org.eclipse.gef.EditPart; import org.eclipse.gef.GraphicalEditPart; import org.eclipse.gef.GraphicalViewer; import org.eclipse.sirius.diagram.ui.tools.api.figure.SiriusWrapLabel; import org.eclipse.sirius.tests.swtbot.support.api.widget.SWTBotSiriusFigureCanvas; import org.eclipse.swt.widgets.Canvas;
<|startcomment|> no need for empty public constructor <|endcomment|>  *******************************************************************************/ package org.eclipse.mylyn.internal.wikitext.asciidoc.core; import java.io.IOException; import java.io.StringReader; import java.util.HashMap; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.eclipse.mylyn.wikitext.core.util.LocationTrackingReader; /** * Preprocessor for Asciidoc. Picks up :val: attribute definitions and replace them when {val} occurs. * * @author Max Rydahl Andersen */ public class AsciiDocPreProcessor { <|startfocus|> public AsciiDocPreProcessor() { } <|endfocus|> static final private Pattern ATTRIBUTE_PATTERN = Pattern.compile("^:(.*?):(.*)"); //$NON-NLS-1$ // TODO: handle escape static final private Pattern ATTRIBUTE_TOKEN_PATTERN = Pattern.compile("(?:\\{(.*?)\\})"); //$NON-NLS-1$ public String process(String markupContent) { Map<String, String> attributes = new HashMap<String, String>(); StringBuilder processedMarkup = new StringBuilder(markupContent.length()); LocationTrackingReader reader = new LocationTrackingReader(new StringReader(markupContent)); String line; try {
<|startcomment|> Maybe we should exit early if the classes are different? Then you can avoid all checks of class2 below. <|endcomment|>  if ((value1 == null) && (value2 == null)) { return true; } if ((value1 == null) || (value2 == null)) { return false; } /* From here on we are sure both values are not null */ /* * First we need to check if the field type is an [] array, in which * case equals() won't match them. */ Class<?> class1 = value1.getClass(); Class<?> class2 = value2.getClass(); <|startfocus|> if (class1.isArray() && class2.isArray()) { <|endfocus|> if (class1.equals(int[].class) && class2.equals(int[].class)) { return Arrays.equals((int[]) value1, (int[]) value2); } else if (class1.equals(float[].class) && class2.equals(float[].class)) { return Arrays.equals((float[]) value1, (float[]) value2); } else if (class1.equals(double[].class) && class2.equals(double[].class)) {
<|startcomment|> isEmpty()? <|endcomment|>  public Object getPropertyValue(Object id) { ITmfEventField field = (ITmfEventField) id; <|startfocus|> if (field.getFields().size() > 0) { <|endfocus|> return new ContentPropertySource(field); } return field.getFormattedValue();
<|startcomment|> Missing final identifier <|endcomment|> <|startfocus|> protected CompletionProposal buildProposal(String proposal, ContentAssistContext context) { <|endfocus|> String prefix = context.getPrefix(); return new CompletionProposal(proposal, context.getOffset() - prefix.length(), prefix.length(), proposal.length());
<|startcomment|> add author <|endcomment|> *************************************************************************** * Copyright (c) 2015 CEA LIST and others. * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: <|startfocus|> * CEA LIST - Initial API and implementation <|endfocus|> * *****************************************************************************/ package org.eclipse.papyrus.uml.diagram.activity.dnd.behavior; import java.util.LinkedList; import java.util.List; import org.eclipse.emf.ecore.EObject; import org.eclipse.gef.EditPart; import org.eclipse.gef.Request; import org.eclipse.gef.commands.Command; import org.eclipse.gef.commands.CompoundCommand; import org.eclipse.gmf.runtime.common.core.command.CompositeCommand; import org.eclipse.gmf.runtime.common.core.command.ICommand; import org.eclipse.gmf.runtime.diagram.ui.commands.CommandProxy; import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy; import org.eclipse.gmf.runtime.diagram.ui.requests.ArrangeRequest; import org.eclipse.gmf.runtime.diagram.ui.requests.CreateViewRequest;
<|startcomment|> -1 The exception should be somehow handled or at least logged. <|endcomment|>  } // try get the image-location from the image-providers Collection<IImageProvider> imageProviders = ExtensionManager.getSingleton() .getImageProvidersForDiagramTypeProviderId(providerId); for (IImageProvider imageProvider : imageProviders) { String imageFilePath = imageProvider.getImageFilePath(imageId); if (imageFilePath != null) { if (imageFilePath.startsWith("bundleentry://")) { try { URL imageFileUrl = new URL(imageFilePath); imageDescriptor = ImageDescriptor.createFromURL(imageFileUrl); <|startfocus|> } catch (MalformedURLException e) { <|endfocus|> } } else { String pluginId = imageProvider.getPluginId(); if (pluginId != null) { // try to create Image from ImageDescriptor (initialize // the ImageRegistry on the fly) imageDescriptor = AbstractUIPlugin.imageDescriptorFromPlugin(pluginId, imageFilePath); } } break; } } if (imageDescriptor == null) { imageDescriptor = ImageDescriptor.getMissingImageDescriptor(); } imageDescriptor = fixImageDescriptor(imageDescriptor); imageRegistry.put(registryKey, imageDescriptor); return imageDescriptor;
<|startcomment|> Since there is some data structure for the submit, it would be nice to be able to distinguish the purpose of each. For example, this structure is: The SubmitInput entity contains information for submitting a change. <|endcomment|> ***************************************************************************** * Copyright (c) 2015 Ericsson * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ericsson - initial API and implementation *******************************************************************************/ package org.eclipse.egerrit.core.rest; /** * Data model object for <a <|startfocus|> * href="https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#submit-input">SubmitInput</a> and <a * href="https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#submit-input">SubmitInput</a>. <|endfocus|> */ public class SubmitInput { // Whether the request should wait for the merge to complete. // If false the request returns immediately after the change has been added to the merge queue and the caller cant // know whether the change could be merged successfully. private boolean wait_for_merge; /** * @return the wait_for_merge */
<|startcomment|> Should be 2005, 2015 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2005, 2012 IBM Corporation and others. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * IBM Corporation - initial API and implementation * Code 9 Corporation - ongoing enhancements * Brock Janiczak <brockj@tpg.com.au> - bug 191545 * Jacek Pospychala <jacek.pospychala@pl.ibm.com> - bug 221998 * Steven Spungin <steven@spungin.tv> - Bug 408727 *******************************************************************************/ package org.eclipse.pde.internal.core.builders; import java.io.File; import java.io.FilenameFilter; import java.util.*; import java.util.regex.Matcher; import java.util.regex.Pattern; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.xpath.*; import org.eclipse.core.resources.*; import org.eclipse.core.runtime.*; import org.eclipse.jdt.core.*; import org.eclipse.jface.text.BadLocationException; import org.eclipse.jface.text.IDocument;
<|startcomment|> Missing Assert.assertNotNull on braceList <|endcomment|>  List<View> list = testHelper.getAllLabel(elementView); Assert.assertEquals("There should have as many Labels as applied Stereotypes", expectedNumbersOfLabels, list.size()); // Check that there is as many compartment as appliedStereotypes. List<View> compartmentList = testHelper.getAllCompartment(elementView); Assert.assertEquals("There should have as many Comaprtment as applied Stereotypes", expectedNumbersOfCompartment, compartmentList.size()); // Check that there is as many brace as appliedStereotypes. <|startfocus|> List<View> braceList = testHelper.getAllBraceCompartment(elementView); Assert.assertEquals("There should have as many Brace Compartments as applied Stereotypes", expectedNumbersOfBrace, braceList.size()); <|endfocus|> // Check that there is only one comment by view. List<View> comment = testHelper.getAllComment(elementView); Assert.assertEquals("There should have only one Comment shape by View", expectedNumbersOfComment, comment.size());
<|startcomment|> StringBuilder is preferably used <|endcomment|>  protected void setElementAndTest(String objectName, Class<? extends NamedElement> classType) { // Initialize data for test case // Calculate EditPart editPart = editorFixture.findEditPart(objectName, classType); Assert.assertNotNull("The found editPart is null", editPart); // Get the Enumeration view <|startfocus|> Assert.assertTrue("The model of " + objectName + " should be a View", editPart.getModel() instanceof View); <|endfocus|> elementView = (View) editPart.getModel(); Assert.assertNotNull("The view of the edit Part" + objectName + " is not present", elementView); // Get the Semantic Element Assert.assertTrue(elementView.getElement() instanceof Element); element = (Element) elementView.getElement(); Assert.assertTrue("The element is a UML Named Element", element instanceof NamedElement); Assert.assertEquals("Element is not the one expected", objectName, ((NamedElement) element).getName()); 
<|startcomment|> Fits into previous line. <|endcomment|>  public void run() { <|startfocus|> // TODO do we need to type the source as // well? <|endfocus|> @SuppressWarnings("unchecked") K source = (K) event.getSource(); if (event.type == SimplePropertyEvent.CHANGE) { notifyIfChanged(source); } else if (event.type == SimplePropertyEvent.STALE) { boolean wasStale = !staleKeys.isEmpty(); staleKeys.add(source); if (!wasStale) fireStale(); }
<|startcomment|> These 6 lines and L288-295 Appear to be identical. You can extract them outside the if (OS.SWT_PADD...) statments and only keep the imageHandle code in the if-statment. <|endcomment|>  * unselected. */ groupHandle = OS.gtk_radio_menu_item_new (0); if (groupHandle == 0) error (SWT.ERROR_NO_HANDLES); OS.g_object_ref (groupHandle); OS.g_object_ref_sink (groupHandle); long /*int*/ group = OS.gtk_radio_menu_item_get_group (groupHandle); if (OS.GTK3) { <|startfocus|> menuItemHasBoxAsChild = true; if (OS.SWT_PADDED_MENU_ITEMS) { handle = OS.gtk_radio_menu_item_new (group); if (handle == 0) error (SWT.ERROR_NO_HANDLES); <|endfocus|> labelHandle = OS.gtk_accel_label_new (buffer); if (labelHandle == 0) error (SWT.ERROR_NO_HANDLES); boxHandle = gtk_box_new (OS.GTK_ORIENTATION_HORIZONTAL, false, 6); if (boxHandle == 0) error (SWT.ERROR_NO_HANDLES); imageHandle = OS.gtk_image_new (); if (imageHandle == 0) error (SWT.ERROR_NO_HANDLES); break; } else { handle = OS.gtk_radio_menu_item_new (group);
<|startcomment|> In that case, it's better to use FluentIterable.filter since Iterables.filter creates a FluentIterable anyway. <|endcomment|>  protected List<Section> getScrolledCompositeSections() { List<Section> sections = new ArrayList<Section>(); if (scrolledComposite.getChildren().length != 0 && scrolledComposite.getChildren()[0] instanceof Composite) { Composite sectionContainer = (Composite) scrolledComposite.getChildren()[0]; <|startfocus|> sections = Lists.newArrayList(Iterables.filter(Arrays.asList(sectionContainer.getChildren()), Section.class)); <|endfocus|> } return sections;
<|startcomment|> save time in lastStartTime <|endcomment|>  try { status = statusInterval.getStateValue().unboxInt(); } catch (StateValueTypeException e) { e.printStackTrace(); } if (lastEndTime != time && lastEndTime != -1) { eventList.add(new TimeEvent(entry, lastEndTime, time - lastEndTime)); } if (!statusInterval.getStateValue().isNull()) { eventList.add(new TimeEvent(entry, time, duration, status)); } else { eventList.add(new NullTimeEvent(entry, time, duration)); <|startfocus|> } <|endfocus|> lastEndTime = time + duration; } } catch (AttributeNotFoundException | TimeRangeException e) { Activator.getDefault().logError(e.getMessage()); } return eventList; } /** * Returns a value corresponding to the selected entry. * * Used in conjunction with synchingToTime to change the selected entry. If * one of these methods is overridden in child class, then both should be. * * @param time * The currently selected time
<|startcomment|> all public methods must have a header <|endcomment|>  * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ericsson - initial API and implementation *******************************************************************************/ package org.eclipse.egerrit.ui.editors.model; import org.eclipse.egerrit.core.rest.CommentInfo; import org.eclipse.jface.text.source.Annotation; public class GerritCommentAnnotation extends Annotation { private CommentInfo comment; private String formattedComment; <|startfocus|> <|endfocus|> public GerritCommentAnnotation(CommentInfo comment, String formattedComment) { this.comment = comment; this.formattedComment = formattedComment; } @Override public String getText() { return formattedComment; } public CommentInfo getComment() { return comment; } } 
<|startcomment|> remove unused code <|endcomment|>  newArtifact.setName(reqName); newArtifact.persist(trans); trans.execute(); } else { artifact.setSoleAttributeFromString( TokenFactory.createAttributeType(0x5000000000002003L, "Door Req Name"), reqName); artifact.setSoleAttributeFromString( TokenFactory.createAttributeType(0x0000000000002006, "Door Req URL"), url); artifact.setName(reqName); artifact.persist(trans); trans.execute(); } } } catch (OseeCoreException e) { <|startfocus|> // this.nodeDisplayNamesnotAdded.add(this.name); <|endfocus|> MessageDialog.openError(PlatformUI.getWorkbench().getDisplay().getActiveShell(), "Error", e.getMessage()); } 
<|startcomment|> Is this what you want? <|endcomment|>  * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Alexandre Montplaisir - Initial API and implementation *******************************************************************************/ package org.eclipse.tracecompass.analysis.os.linux.core.latency; import java.io.Serializable; import java.util.Map; import org.eclipse.tracecompass.common.core.NonNullUtils; import org.eclipse.tracecompass.segmentstore.core.ISegment; import com.google.common.collect.ImmutableMap; /** <|startfocus|> * @author efficios * @since 1.0 <|endfocus|> */ public class SystemCall implements ISegment { private static final long serialVersionUID = 1554494342105208730L; /** * @author efficios * */ public static class InitialInfo implements Serializable { private static final long serialVersionUID = -5009710718804983721L; private final long fStartTime; private final String fName; private final Map<String, String> fArgs; /** * @param startTime * Start time of the system call * @param name * Name of the system call * @param arguments * Arguments of the system call
<|startcomment|> Can we change order? Looks more natural with @var Type $variable <|endcomment|>  IRegion selectionLineInfo = document .getLineInformation(selectionStartLine); int selectionLineLength = selectionLineInfo.getLength(); String selectionLineText = document.get(selectionLineOffset, selectionLineLength); Matcher nonSpaceMatch = noneSpacePattern.matcher(selectionLineText); StringBuilder varTypeHint = new StringBuilder(); // $NON-NLS-1$ if (nonSpaceMatch.find()) { varTypeHint.append( selectionLineText.substring(0, nonSpaceMatch.start())); } varTypeHint.append("/* @var "); //$NON-NLS-1$ <|startfocus|> varTypeHint.append(varName); varTypeHint.append(" "); //$NON-NLS-1$ <|endfocus|> varTypeHint.append(typeName); varTypeHint.append(" */"); //$NON-NLS-1$ varTypeHint.append(TextUtilities.getDefaultLineDelimiter(document)); return new InsertEdit(selectionLineOffset, varTypeHint.toString()); } /** * Creates the dialog to select type */ private SelectionDialog createTypeDialog() { IDLTKUILanguageToolkit languageToolkit = PHPUILanguageToolkit .getInstance(); String languageName = languageToolkit.getCoreToolkit() .getLanguageName(); 
<|startcomment|> case <|endcomment|>  exceptions = { @Throw(type = NullPointerException.class, value = "Thrown if the current String or \"b\" is null.") } ) // @formatter:on public Boolean startsWith(String self, String b) { return Boolean.valueOf(self.startsWith(b)); } // @formatter:off @Documentation( <|startfocus|> value = "Returns true if the current String is equals to the String \"b\" without considering casing in the comparison.", <|endfocus|> params = { @Param(name = "self", value = "The current String"), @Param(name = "b", value = "The String to compare with the current String") }, result = "<code>true</code> if the current String is equal to the string \"b\", without considering casing, <code>false</code> otherwise.", exceptions = { @Throw(type = NullPointerException.class, value = "Thrown if the current String or \"b\" is null.") } ) // @formatter:on public Boolean equalsIgnoreCase(String self, String b) {
<|startcomment|> While the analyis runs (can take a long time) we can keep seeing the viewer data of the previously selected trace. Should we call updateModel(null) to clear the viewer in the meantime? <|endcomment|>  * or run analysis if not completed * * @param analysis * Latency analysis module */ public void setData(@Nullable LatencyAnalysis analysis) { if (analysis == null) { return; } ISegmentStore<ISegment> results = analysis.getResults(); // If results are not null, then analysis is completed and model can be // updated if (results != null) { updateModel(LatencyViewerUtils.storeAndGet(results)); return; <|startfocus|> } <|endfocus|> LatencyViewerUtils.runAnalysis(fListener); } // ------------------------------------------------------------------------ // Signal handlers // ------------------------------------------------------------------------ /** * @param signal * Different opened trace (on which latency analysis as already * been performed) has been selected */ @TmfSignalHandler public void traceSelected(TmfTraceSelectedSignal signal) { LatencyAnalysis analysis = LatencyViewerUtils.getAnalysisFromSignal(signal); setData(analysis); } /** * @param signal * New trace (on which latency analysis has not been performed) * is opened */ @TmfSignalHandler public void traceOpened(TmfTraceOpenedSignal signal) {
<|startcomment|> change syscalls to maybe segments or data, this won't be specific to the syscalls analysis <|endcomment|> import org.eclipse.tracecompass.segmentstore.core.ISegment; import org.eclipse.tracecompass.segmentstore.core.ISegmentStore; /** * End of latency analysis listener for latency viewers * * @author France Lapointe Nguyen * @since 1.1 */ public interface LatencyAnalysisListener { /** * Called at the end of the latency analysis * * @param activeAnalysis * latency analysis that is running * * @param syscalls * results of the latency analysis */ <|startfocus|> void onComplete(LatencyAnalysis activeAnalysis, ISegmentStore<ISegment> syscalls); <|endfocus|> } 
<|startcomment|> There is only one "reference" in a comparison : the object with which we're comparing another for equality. o1 : the object to compare for equality. o2 : the reference object with which to compare. <|endcomment|>  } return result; } }; } else { result = new Service(publicMethod, this); } return result; } // @formatter:off @Documentation( value = "Indicates whether the object <code>o1</code> is the same as the object <code>o2</code>. For more " + "information refer to the Object#equals(Object) method.", params = { <|startfocus|> @Param(name = "o1", value = "The reference object to compare"), <|endfocus|> @Param(name = "o2", value = "The reference object with which to compare") }, result = "true</code> if the object <code>o1</code> is the same as the object <code>o2</code>, " + "<code>false</code> otherwise", examples = { @Example(expression = "'Hello'.equals('World')", result = "false"), @Example(expression = "'Hello'.equals('Hello')", result = "true") } ) // @formatter:on public Boolean equals(Object o1, Object o2) {
<|startcomment|> Labels aren't sentences ending with periods. <|endcomment|> import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Group; import org.eclipse.ui.IWorkbench; import org.eclipse.ui.IWorkbenchPreferencePage; /** * Refactor service preferences page * * @author Gabriel Pascual * */ public class RefactorPreferencesPage extends PreferencePage implements IWorkbenchPreferencePage, IPropertyChangeListener { /** The Constant PREFERENCES_DESCRIPTION. */ <|startfocus|> private static final String PREFERENCES_DESCRIPTION = "Preferences for the refactoring resolution."; <|endfocus|> /** The Constant REFACTORING_TITLE_PAGE. */ private static final String REFACTORING_TITLE_PAGE = "Refactoring Preferences"; /** The Constant USER_INTERATION_LABEL. */ private static final String USER_INTERATION_LABEL = "Activate user interaction."; /** The Constant SCOPE_GROUP_LABEL. */ private static final String SCOPE_GROUP_LABEL = "Scope"; /** The preference fields. */ private Map<String, FieldEditor> preferenceFields = new HashMap<String, FieldEditor>(); /** The scope group. */ private Group scopeGroup; 
<|startcomment|> wrong Activator, use org.eclipse.egit.gitflow.ui.Activator <|endcomment|> ***************************************************************************** * Copyright (C) 2015, Max Hohenegger <eclipse@hohenegger.eu> * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.egit.gitflow.ui.internal; import java.net.MalformedURLException; import java.net.URL; <|startfocus|> import org.eclipse.egit.ui.Activator; <|endfocus|> import org.eclipse.jface.resource.ImageDescriptor; /** * Icons for Gitflow integration. */ public class UIIcons { /** Decoration for initialized Gitflow repository. */ public final static ImageDescriptor OVR_GITFLOW; /** base URL */ public final static URL base; static { base = init(); OVR_GITFLOW = map("ovr/staged_renamed.gif"); //$NON-NLS-1$ } private static ImageDescriptor map(final String icon) { if (base != null) try { return ImageDescriptor.createFromURL(new URL(base, icon)); } catch (MalformedURLException mux) {
<|startcomment|> Set the comparator (potentially null) first, then return if null. Is there a way to make sure it is in fact an ISegment comparator, to avoid class cast exception? <|endcomment|>  public void setSortOrder(@Nullable Comparator<?> comparator) { if (comparator == null) { return; } <|startfocus|> fComparator = (Comparator<ISegment>) comparator; <|endfocus|> final TableViewer tableViewer = fTableViewer; if (tableViewer == null) { return; } Arrays.sort(fSegmentArray, fComparator); tableViewer.refresh();
<|startcomment|> Redundant <|endcomment|> import org.eclipse.core.databinding.observable.value.AbstractObservableValue; import org.eclipse.core.databinding.observable.value.IObservableValue; import org.eclipse.core.databinding.observable.value.IValueChangeListener; import org.eclipse.core.databinding.observable.value.ValueChangeEvent; /** * @since 3.2 * */ public class AggregateObservableValue extends AbstractObservableValue<Object> { private IObservableValue<Object>[] observableValues; private String delimiter; private boolean updating = false; private String currentValue; <|startfocus|> private IValueChangeListener<Object> listener = new IValueChangeListener<Object>() { <|endfocus|> @Override public void handleValueChange(ValueChangeEvent<? extends Object> event) { if (!updating) { fireValueChange(Diffs.createValueDiff(currentValue, doGetValue())); } } }; /** * @param observableValues * @param delimiter */ public AggregateObservableValue(IObservableValue<Object>[] observableValues, String delimiter) { this.observableValues = observableValues; this.delimiter = delimiter; for (int i = 0; i < observableValues.length; i++) { observableValues[i].addValueChangeListener(listener); } doGetValue();
<|startcomment|> Looks really strange. Why not use boolean hasRepo = haveRepositories(resources); return hasRepo; ? <|endcomment|>  IResource resource = AdapterUtils.adapt(firstElement, IResource.class); if (resource instanceof IFile || resource instanceof IFolder) { RepositoryMapping m = RepositoryMapping.getMapping(resource); if (m != null) return testRepositoryProperties(m.getRepository(), args); } } else if ("resourcesAllInRepository".equals(property)) { //$NON-NLS-1$ IStructuredSelection selection = getStructuredSelection(collection); IResource[] resources = SelectionUtils .getSelectedResources(selection); <|startfocus|> Set<Repository> repositories = getRepositoriesOfResources(resources); return !repositories.contains(null); <|endfocus|> } return false;
<|startcomment|> Instead of having a comment before the assert you could set a assert message. <|endcomment|>  assertEquals(oldD2DSize.width, newD2DSize2.width); assertEquals(oldD2DSize.height, newD2DSize2.height); assertEquals(oldGMFSize.width, newGMFSize2.width); // assertEquals(oldGMFSize.height, newGMFSize2.height); if (part instanceof IDiagramContainerEditPart || part instanceof IDiagramListEditPart) { assertTrue(((AbstractDiagramElementContainerEditPart) part).getPrimaryShape() instanceof GradientRoundedRectangle); assertNull(((AbstractDiagramElementContainerEditPart) part).getBackgroundFigure()); // Alpha drop shadow has been recreated. <|startfocus|> assertTrue(((AbstractDiagramElementContainerEditPart) part).getMainFigure().getBorder() instanceof AlphaDropShadowBorder); <|endfocus|> } } private Dimension getSize(Node gmfNode) { Size size = (Size) gmfNode.getLayoutConstraint(); return new Dimension(size.getWidth(), size.getHeight()); } private Dimension getSize(IFigure figure) { return new Dimension(figure.getSize()); } private void setImage(String imagePath) { SWTBotText text = bot.text(); text.setFocus(); text.setText(imagePath); ICondition done = new OperationDoneCondition(); bot.button("OK").click();
<|startcomment|> add distribution statement <|endcomment|>  * Created on Aug 24, 2015 * <|startfocus|> * PLACE_YOUR_DISTRIBUTION_STATEMENT_RIGHT_HERE */ <|endfocus|> package org.eclipse.osee.ats.dsl.integration.internal; import static org.junit.Assert.fail; import static org.mockito.Mockito.when; import java.util.ArrayList; import java.util.List; import org.eclipse.osee.ats.api.user.IAtsUser; import org.eclipse.osee.ats.api.user.IAtsUserService; import org.eclipse.osee.ats.api.workdef.IAtsRuleDefinition; import org.eclipse.osee.ats.api.workdef.RuleEventType; import org.eclipse.osee.ats.api.workdef.RuleLocations; import org.eclipse.osee.ats.dsl.ModelUtil; import org.eclipse.osee.ats.dsl.atsDsl.AtsDsl; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.mockito.Matchers; import org.mockito.Mock; import org.mockito.MockitoAnnotations; /** * Test case for {@link ConvertAtsDslToRuleDefinition} * * @author Mark Joy */ public class ConvertAtsDslToRuleDefinitionTest { // @formatter:off @Mock IAtsUserService userService; @Mock IAtsUser user; // @formatter:on 
<|startcomment|> @papyrus.req <|endcomment|> import org.eclipse.uml2.uml.Class; import org.eclipse.uml2.uml.Comment; import org.eclipse.uml2.uml.Model; import org.eclipse.uml2.uml.UMLFactory; import org.eclipse.uml2.uml.util.UMLUtil.StereotypeApplicationHelper; import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; /** * A test case for the model object '<em><b>Stakeholder</b></em>'. <|startfocus|> * See the requirement <b>{@req org.eclipse.papyrus.sysml14#Req012}</b>. <|endfocus|> * <p> * The following features are tested: * <ul> * <li>{@link org.eclipse.papyrus.sysml.modelelements.StakeholderTest#testGetConcern <em>Concern</em>}</li> * </ul> * </p> */ public class StakeholderTest extends AbstractPapyrusTest { protected static final String THIS_IS_THE_BODY_OF_COMMENT2 = "this is the body of comment2"; protected static final String THIS_IS_THE_BODY_OF_COMMENT1 = "this is the body of comment1"; @Rule public final HouseKeeper houseKeeper = new HouseKeeper(); 
<|startcomment|> , 2015 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2010 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.tree.ui.tools.internal.editor.actions; import java.lang.reflect.InvocationTargetException; import org.eclipse.core.runtime.IProgressMonitor; import org.eclipse.jface.action.IAction; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.dialogs.ProgressMonitorDialog; import org.eclipse.jface.operation.IRunnableWithProgress; import org.eclipse.jface.viewers.ISelection; import org.eclipse.sirius.business.api.dialect.command.RefreshRepresentationsCommand; import org.eclipse.sirius.tree.ui.provider.Messages; import org.eclipse.sirius.tree.ui.tools.internal.editor.DTreeEditor; import org.eclipse.sirius.ui.business.api.action.RefreshActionListenerRegistry; import org.eclipse.sirius.viewpoint.SiriusPlugin; import org.eclipse.swt.widgets.Shell; import org.eclipse.ui.IEditorActionDelegate;
<|startcomment|> Should be a template. <|endcomment|>  public ShiftDirectSubExecutionsOperation(ISequenceEvent parent, int deltaY) { <|startfocus|> super(Messages.ShiftDirectSubExecutionsOperation_operationName + deltaY); <|endfocus|> this.parent = Preconditions.checkNotNull(parent); this.deltaY = deltaY;
<|startcomment|> I do not see method with this signature ? <|endcomment|>  } /** * Set labels to update according to a connectionEditPart (all labels of * this connection will be update). This method must be used if the edge * figure is updated (through feedback) during the move. Indeed, in this * case, we can not use the figure to retrieve the old points.<BR> * This method must be called after having called the <|startfocus|> * {@link #setNewPointList(PointList, org.eclipse.draw2d.ConnectionAnchor, org.eclipse.draw2d.ConnectionAnchor)} * of {@link #setNewPointList(PointList, Point, Point)} method. <|endfocus|> * * @param connectionEditPart * The connection from which to get the potential three labels to * update * @param originalPoints * The points of the edge before the move. */ public void setLabelsToUpdate(org.eclipse.gef.ConnectionEditPart connectionEditPart, PointList originalPoints) { oldBendPointsList = originalPoints; setLabelsToUpdate(connectionEditPart); } /**
<|startcomment|> not sure why do we need update ruler if setting the new state above was not successful. <|endcomment|>  * @since 3.10 */ public void setWordWrap(boolean newWordWrapStatus) { if (!isWordWrapSupported() || newWordWrapStatus == fIsWordWrapActivated) return; fIsWordWrapActivated = newWordWrapStatus; ISourceViewer viewer= getSourceViewer(); if (viewer != null && !isBlockSelectionModeEnabled()) { StyledText styledText= viewer.getTextWidget(); if (styledText != null) { styledText.setWordWrap(newWordWrapStatus); } } <|startfocus|> if (fVerticalRuler != null) { fVerticalRuler.update(); } <|endfocus|> } } 
<|startcomment|> No need for monitor.done() <|endcomment|>  : new String[] {"clean"}; //$NON-NLS-1$ AntRunner runner = new AntRunner(); runner.setBuildFileLocation(scriptFile.getAbsolutePath()); runner.setExecutionTargets(targets); runner.run(subMonitor.newChild(1)); } catch (FactoryConfigurationError e) { } catch (ParserConfigurationException e) { } catch (CoreException e) { } catch (IOException e) { } finally { if (scriptFile != null && scriptFile.exists()) { scriptFile.delete(); } <|startfocus|> monitor.done(); <|endfocus|> }
<|startcomment|> 2015 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2009 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.ui.tools.internal.properties; import java.util.Collection; import java.util.HashSet; import org.eclipse.sirius.diagram.ui.provider.Messages; import org.eclipse.sirius.diagram.ui.tools.internal.commands.ActivateRulesCommand; import org.eclipse.sirius.diagram.ui.tools.internal.commands.DeactivateRulesCommand; import org.eclipse.sirius.viewpoint.description.validation.ValidationRule; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Label; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; /** * This Property section shows currently activated validation rules and helps in
<|startcomment|> Can be removed <|endcomment|>  PDEModelUtility.modifyModel(new ModelModification(project) { @Override protected void modifyModel(IBaseModel model, IProgressMonitor monitor) throws CoreException { if (model instanceof IBundlePluginModelBase) inspectManifest((IBundlePluginModelBase) model, monitor); if (monitor.isCanceled()) { fCanceled = true; return; } if (model instanceof IPluginModelBase) inspectXML((IPluginModelBase) model, monitor); if (monitor.isCanceled()) { fCanceled = true; return; } } }, monitor); <|startfocus|> monitor.done(); <|endfocus|>
<|startcomment|> Use the two-argument constructor <|endcomment|>  if (fElements.size() == 1 && fElements.keySet().iterator().next() instanceof IProject) { if (!getArguments().getUpdateReferences()) return null; return createManifestChange(pm); } return super.createChange(pm); } protected Change createManifestChange(IProgressMonitor monitor) throws CoreException { IFile manifest = PDEProject.getManifest(fProject); if (manifest.exists()) { <|startfocus|> SubMonitor subMonitor = SubMonitor.convert(monitor, "", 4); //$NON-NLS-1$ <|endfocus|> try { String newText = fElements.get(fProject); CompositeChange result = new CompositeChange(PDEUIMessages.ContainerRenameParticipant_renameBundleId); IBundle bundle = BundleManifestChange.getBundle(manifest, subMonitor.newChild(1)); if (bundle != null) { BundleTextChangeListener listener = new BundleTextChangeListener(((BundleModel) bundle.getModel()).getDocument()); bundle.getModel().addModelChangedListener(listener); BundleSymbolicNameHeader header = (BundleSymbolicNameHeader) bundle.getManifestHeader(Constants.BUNDLE_SYMBOLICNAME); if (header != null) {
<|startcomment|> Two-arg constructor <|endcomment|>  private boolean provideJavaClasses(ImportPackageObject pkg, IProgressMonitor monitor) { try { IProject project = fModel.getUnderlyingResource().getProject(); if (!project.hasNature(JavaCore.NATURE_ID)) return false; <|startfocus|> SubMonitor subMonitor = SubMonitor.convert(monitor, "", 1); //$NON-NLS-1$ <|endfocus|> IJavaProject jProject = JavaCore.create(project); SearchEngine engine = new SearchEngine(); IJavaSearchScope searchScope = PluginJavaSearchUtil.createSeachScope(jProject); Requestor requestor = new Requestor(); String packageName = pkg.getName(); engine.search( SearchPattern.createPattern(packageName, IJavaSearchConstants.PACKAGE, IJavaSearchConstants.REFERENCES, SearchPattern.R_EXACT_MATCH), new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, searchScope, requestor, subMonitor.newChild(1)); if (requestor.foundMatches()) return true; } catch (CoreException e) { } return false;
<|startcomment|> Use the 2-argument constructor. <|endcomment|>  * @param project destination project of the import * @param model model representing the plugin to import * @param monitor progress monitor * @return a mapping of libraries to source locations to use in the classpath * @throws CoreException if there is a problem completing the import */ private Map<String, IPath> importAsBinary(IProject project, IPluginModelBase model, IProgressMonitor monitor) throws CoreException { <|startfocus|> try { SubMonitor subMonitor = SubMonitor.convert(monitor, "", 4); //$NON-NLS-1$ <|endfocus|> // Import the plug-in content File srcFile = new File(model.getInstallLocation()); if (isJARd(model)) { PluginImportHelper.copyArchive(srcFile, project.getFile(srcFile.getName()), subMonitor.newChild(1)); } else { PluginImportHelper.importContent(new File(model.getInstallLocation()), project.getFullPath(), FileSystemStructureProvider.INSTANCE, null, subMonitor.newChild(1)); } // Import source from known source locations Map<String, IPath> sourceMap = importSourceArchives(project, model, IMPORT_BINARY, subMonitor.newChild(1));
<|startcomment|> s/form/from/ <|endcomment|>  // File format follows AmazonS3.Keys: // # // # Required entries: // # // accesskey = your-amazon-access-key # default AmazonS3.Keys // secretkey = your-amazon-secret-key # default AmazonS3.Keys // test.bucket = your-bucket-for-testing # custom keys, for this test String HOME_CONFIG_FILE = System.getProperty("user.home") + File.separator + "jgit-s3-config.properties"; } /** <|startfocus|> * Find test properties form various sources in order of priority. <|endfocus|> */ static class TestProps implements TestKeys, AmazonS3.Keys { static boolean haveEnvVar(String name) { return System.getenv(name) != null; } static boolean haveEnvVarFile(String name) { return haveEnvVar(name) && new File(name).exists(); } static boolean haveSysProp(String name) { return System.getProperty(name) != null; } static boolean haveSysPropFile(String name) { return haveSysProp(name) && new File(name).exists(); } 
<|startcomment|> Lines 1068-1088 are redundant. <|endcomment|>  protected IFolder getFolder(IResource resource) { <|startfocus|> if (resource instanceof IFolder) { return (IFolder) resource; } <|endfocus|> return Adapters.getAdapter(resource, IFolder.class, true);
<|startcomment|> Move this to after ePackage.getNsUri() check? <|endcomment|>  private void add(EPackage ePackage) { if (ePackage!=null) { <|startfocus|> URI uri = EcoreUtil.getURI(ePackage); if(ePackage.getNsURI() != null){ <|endfocus|> if (!packageURIs.contains(uri)) { packageURIs.add(uri); listWidget.add(ePackage.getNsURI()); setPageComplete(true); getContainer().updateButtons(); } } else{ //ePackage.getNsURI() = null MessageDialog.openError(getShell(), "No 'Ns URI' set", "The EPackage you selected has no 'Ns URI' set! This is a general EMF requirement."); setPageComplete(false); getContainer().updateButtons(); } } 
<|startcomment|> are these extra braces needed? <|endcomment|>  continue; } } else if ("font-style".equals(rule.name)) { //$NON-NLS-1$ if (rule.value.equalsIgnoreCase("bold") || rule.value.equalsIgnoreCase("italic")) { //$NON-NLS-1$ //$NON-NLS-2$ continue; } <|startfocus|> } else if ("text-decoration".equals(rule.name) && rule.value.equalsIgnoreCase("underline")) { { continue; } <|endfocus|> } ruleIt.remove(); } } if ("font".equalsIgnoreCase(element.nodeName())) { //$NON-NLS-1$ String color = element.attr("color"); //$NON-NLS-1$ if (color != null && color.trim().length() > 0) { if (rules == null) { rules = new ArrayList<CssRule>(1); } rules.add(new CssRule("color", color.trim(), 0, 0, 0, 0)); //$NON-NLS-1$ } } if (rules != null) { for (CssRule rule : rules) {
<|startcomment|> use only isInstance and remove isSuperTypeOf <|endcomment|>  final List<EObject> result = Lists.newArrayList(); if (isMany) { if (child instanceof Collection<?>) { result.addAll(eAllContentsVisitCollectionChild((Collection<?>)child, type, features)); } else { throw new IllegalStateException("don't know what to do with " + child.getClass()); } } else if (child instanceof EObject) { <|startfocus|> if (type.isSuperTypeOf(((EObject)child).eClass())) { result.add((EObject)child); } else if (type.isInstance(child)) { result.add((EObject)child); <|endfocus|> } result.addAll(eAllContents((EObject)child, type, features)); } return result;
<|startcomment|> s/uses/use/ <|endcomment|>  } /** * JetS3t compatibility reference: <a href= * "https://bitbucket.org/jmurty/jets3t/src/156c00eb160598c2e9937fd6873f00d3190e28ca/src/org/jets3t/service/security/EncryptionUtil.java"> * EncryptionUtil.java</a> * <p> * Note: EncryptionUtil is inadequate: * <li>EncryptionUtil.isCipherAvailableForUse checks encryption only which <|startfocus|> * "always works", but in JetS3t both encryption and decryption uses non-IV <|endfocus|> * aware algorithm parameters for all PBE specs, which breaks in case of AES * <li>that means that only non-IV algorithms will work round trip in * JetS3t, such as PBEWithMD5AndDES and PBEWithSHAAndTwofish-CBC * <li>any AES based algorithms such as "PBE...With...And...AES" will not * work, since they need proper IV setup */ static class ObjectEncryptionJetS3tV2 extends WalkEncryption { static final String JETS3T_VERSION = "2"; //$NON-NLS-1$ 
<|startcomment|> Please use comprehensible names <|endcomment|>  fragmentDi = addToProject(TEST_DATA_PATH, testProject1, iProject, "case002/commit2/fragment.di", ""); fragmentNotation = addToProject(TEST_DATA_PATH, testProject1, iProject, "case002/commit2/fragment.notation", ""); fragmentUml = addToProject(TEST_DATA_PATH, testProject1, iProject, "case002/commit2/fragment.uml", ""); repository.addAllAndCommit("2nd-commit"); repository.checkoutBranch(MASTER); } @Test <|startfocus|> public void test1() throws Exception { setupRepositoryTest1(); <|endfocus|> Comparison comparison = compare(MASTER, BRANCH_1, modelNotation); EList<Diff> differences = comparison.getDifferences(); ResourceAttachmentChange umlChange = null; ResourceAttachmentChange notationChange = null; ResourceAttachmentChange diChange = null; for (Diff diff : Iterables.filter(differences, ResourceAttachmentChange.class)) { ResourceAttachmentChange change = (ResourceAttachmentChange)diff; if (change.getResourceURI().endsWith(UML_EXTENSION)) { umlChange = change; } else if (change.getResourceURI().endsWith(NOTATION_EXTENSION)) { notationChange = change; } else { diChange = change;
<|startcomment|> LatencyScatterView? <|endcomment|>  private static final String BUNDLE_NAME = "org.eclipse.tracecompass.internal.analysis.os.linux.ui.views.latency.messages"; //$NON-NLS-1$ /** * Time vs Duration */ public static @Nullable String LatencyScatterView_title; /** * Time */ public static @Nullable String LatencyScatterView_xAxis; /** * Duration */ public static @Nullable String LatencyScatterView_yAxis; /** * Name of the compacting job */ <|startfocus|> public static @Nullable String LatencyTableViewer_compactTitle; <|endfocus|> /** * Name of the duration column */ public static @Nullable String LatencyTableViewer_duration; /** * Name of the end time column */ public static @Nullable String LatencyTableViewer_endTime; /** * Name of the start time column */ public static @Nullable String LatencyTableViewer_startTime; /** * Title of the scatter graph */ public static @Nullable String LatencyView_title; /** * Title of the x axis of the scatter graph */
<|startcomment|> Please put useful javadoc! <|endcomment|> kage org.eclipse.emf.compare.rcp.graph; import org.eclipse.emf.common.util.URI; import org.eclipse.emf.compare.graph.IGraph; import org.eclipse.emf.compare.graph.IGraphView; /** <|startfocus|> * Interface. <|endfocus|> * * @author <a href="mailto:mathieu.cartaud@obeo.fr">Mathieu Cartaud</a> * @since 2.4 */ public interface IGraphConsumer { /** * Set a new instance of an URI resource Graph. * * @param graph * The URI resource graph */ void setGraph(IGraph<URI> graph); /** * Return the ID used to identify this specific URI resource Graph. * * @return the consumer id */ String getGraphConsumerId(); /** * Return the read only version of the URI resource Graph. * * @return the URI resource ReadOnlyGraph */ IGraphView<URI> getDependencyGraph(); } 
<|startcomment|> could add comment // equivalent to "[0.5.0,)" for clarification of shorthand notation for ranges <|endcomment|>  public void rangesStillIncludingVersionShouldBeUnchanged() { String from = "1.0.0"; String to = "1.1.0"; <|startfocus|> <|endfocus|> String originalRange1 = "0.5.0"; assertEquals(originalRange1, defaultStrategy.computeNewVersionRange(originalRange1, from, to)); String originalRange2 = "[0.5.0,1.1.0]"; assertEquals(originalRange2, defaultStrategy.computeNewVersionRange(originalRange2, from, to)); String originalRange3 = "[0.0.0,1.1.0]"; assertEquals(originalRange3, defaultStrategy.computeNewVersionRange(originalRange3, from, to));
<|startcomment|> EXPORT_ICON_FILE? <|endcomment|> import org.eclipse.swt.widgets.Shell; import org.eclipse.tracecompass.internal.lttng2.control.ui.Activator; import org.eclipse.tracecompass.internal.lttng2.control.ui.views.messages.Messages; /** * Dialog box for collecting parameter for loading a session. * * @author Bernd Hufmann */ public class SaveDialog extends Dialog implements ISaveDialog { // ------------------------------------------------------------------------ // Constants // ------------------------------------------------------------------------ /** The icon file for this dialog box. */ <|startfocus|> public static final String IMPORT_ICON_FILE = "icons/elcl16/export_button.png"; //$NON-NLS-1$ <|endfocus|> // ------------------------------------------------------------------------ // Constants // ------------------------------------------------------------------------ /** * The dialog composite. */ private Composite fDialogComposite = null; private Button fForceButton = null; private boolean fIsForce = true; // ------------------------------------------------------------------------ // Constructors // ------------------------------------------------------------------------ /** * Constructor * * @param shell * - a shell for the display of the dialog */ public SaveDialog(Shell shell) { super(shell); setShellStyle(SWT.RESIZE | getShellStyle()); } @Override
<|startcomment|> Here we give the edge the "Network" type. Probably because it is always the case, for now, but shouldn't we check the type of the vertical edges and pass it? <|endcomment|>  if (inV != null && nextH != null) { TmfVertex next = nextH.getVertexTo(); TmfEdge nextV = next.getEdge(EdgeDirection.OUTGOING_VERTICAL_EDGE); if (nextV != null) { TmfVertex src = inV.getVertexFrom(); TmfVertex dst = nextV.getVertexTo(); /* unlink */ node.removeEdge(EdgeDirection.INCOMING_VERTICAL_EDGE); next.removeEdge(EdgeDirection.OUTGOING_VERTICAL_EDGE); <|startfocus|> src.linkVertical(dst).setType(EdgeType.NETWORK); <|endfocus|> } } } }
<|startcomment|> Integer.toString(getType()), 2 times <|endcomment|>  doc = DLTKLaunchingPlugin.getDocument(); } catch (ParserConfigurationException e) { IStatus status = new Status( IStatus.ERROR, DLTKLaunchingPlugin.getUniqueIdentifier(), ScriptLaunchConfigurationConstants.ERR_INTERNAL_ERROR, LaunchingMessages.RuntimeBuildpathEntry_An_exception_occurred_generating_runtime_classpath_memento_8, e); throw new CoreException(status); } Element node = doc.createElement("runtimeBuildpathEntry"); //$NON-NLS-1$ doc.appendChild(node); <|startfocus|> node.setAttribute("type", (Integer.valueOf(getType())).toString()); //$NON-NLS-1$ <|endfocus|> node.setAttribute( "path", (Integer.valueOf(getBuildpathProperty())).toString()); //$NON-NLS-1$ switch (getType()) { case PROJECT: node.setAttribute("projectName", getPath().lastSegment()); //$NON-NLS-1$ break; case ARCHIVE: IResource res = getResource(); if (res == null) { node.setAttribute("externalArchive", getPath().toString()); //$NON-NLS-1$ } else { node.setAttribute(
<|startcomment|> Move LBA from work def name <|endcomment|> import org.eclipse.osee.ats.core.workflow.ITeamWorkflowProvidersLazy; import org.eclipse.osee.framework.core.util.XResultData; import org.eclipse.osee.framework.jdk.core.type.OseeCoreException; import org.junit.Before; import org.junit.Test; import org.mockito.Matchers; import org.mockito.Mock; import org.mockito.MockitoAnnotations; /** * Test case for {@link AtsWorkDefinitionAdminImpl} * * @author Donald G. Dunne */ public class AtsWorkDefinitionAdminImplTest { private static final String MyPeerToPeerWorkDefId = "myPeerToPeerWorkDef"; <|startfocus|> private static final String MyTaskWorkDefId = "WorkDef_Task_Lba_Test_Review"; <|endfocus|> // @formatter:off @Mock IAtsTeamDefinition topTeamDef; @Mock IAtsTeamDefinition projTeamDef; @Mock IAtsTeamDefinition featureTeamDef; @Mock IAtsWorkItemService workItemService; @Mock IAtsWorkDefinitionService workDefinitionService; @Mock IAtsWorkDefinitionStore workDefinitionStore; @Mock IAtsActionableItem actionableItem; @Mock IAtsPeerToPeerReview peerReview; @Mock XResultData resultData; @Mock IAtsTeamWorkflow teamWf; @Mock IAtsWorkDefinition defaultPeerToPeerWorkDef;
<|startcomment|> 2015 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2010 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.table.ui.tools.internal.editor.provider; import org.eclipse.emf.edit.ui.action.EditingDomainActionBarContributor; import org.eclipse.jface.action.IToolBarManager; import org.eclipse.sirius.table.ui.tools.internal.editor.AbstractDTableEditor; import org.eclipse.sirius.table.ui.tools.internal.editor.DTableCrossEditor; import org.eclipse.sirius.table.ui.tools.internal.editor.DTableViewerManager; import org.eclipse.sirius.table.ui.tools.internal.editor.action.EditorCreateLineMenuAction; import org.eclipse.sirius.table.ui.tools.internal.editor.action.EditorCreateTargetColumnMenuAction; import org.eclipse.sirius.table.ui.tools.internal.editor.action.PrintAction; import org.eclipse.sirius.ui.business.api.session.SessionEditorInput; import org.eclipse.sirius.ui.tools.internal.editor.AbstractDTableViewerManager;
<|startcomment|> 2015 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2009 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.ui.tools.internal.print; import java.io.File; import java.util.Iterator; import java.util.List; import org.eclipse.core.runtime.IPath; import org.eclipse.gmf.runtime.common.ui.services.editor.EditorService; import org.eclipse.gmf.runtime.diagram.core.preferences.PreferencesHint; import org.eclipse.gmf.runtime.diagram.core.util.ViewUtil; import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart; import org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramRootEditPart; import org.eclipse.gmf.runtime.diagram.ui.internal.DiagramUIPlugin; import org.eclipse.gmf.runtime.diagram.ui.internal.editparts.PageBreakEditPart; import org.eclipse.gmf.runtime.diagram.ui.internal.properties.WorkspaceViewerProperties;
<|startcomment|> @since tag Wording is a bit awkward (midnight coding :-). Maybe just "The BitmapIndex for this BitmapBuilder" <|endcomment|>  * returned. If the bitmap index is null, false is returned. * * @param bitmapIndex * the bitmap index to check if it is completely contained * inside of the current bitmap. * @return {@code true} if the bitmap index was a complete match. */ boolean removeAllOrNone(PackBitmapIndex bitmapIndex); /** @return the number of elements in the bitmap. */ int cardinality(); <|startfocus|> /** The BitmapIndex this BitmapBuilder is based on values from. */ <|endfocus|> BitmapIndex getBitmapIndex(); } } 
<|startcomment|> These comments should be removed <|endcomment|>  public void testExpCompWithAndWithoutClientCompact() { createExtendableComposite(TEXT1, TITLE_TWIST | ExpandableComposite.COMPACT); <|startfocus|> // createClient(); NO CLIENT <|endfocus|> Rectangle bounds1 = update(); createClient(); Rectangle bounds2 = update(); assertEquals(bounds1, bounds2);
<|startcomment|> So, I've noticed this in some areas but with Java >= 1.7 this shows up as a warning because it's become redundant. I see you've done it the new way in other areas so maybe this is just a force of habit :) <|endcomment|> import java.util.Map; public class CreateVMPageModel extends BaseDatabindingModel { public static final String VM_NAME = "VMName"; public static final String BOX_NAME = "boxName"; public static final String VM_FILE = "VMFile"; public static final String BOX_LOC_MODE = "boxLocMode"; public static final String ENVIRONMENT = "environment"; private String vmName; private String vmFile; private String boxName; private boolean boxLocMode; <|startfocus|> private Map<String, String> environment = new HashMap<String, String>(); <|endfocus|> public String getVMName() { return vmName; } public String getBoxName() { return boxName; } public String getVMFile() { return vmFile; } public Map<String, String> getEnvironment() { return environment; } public boolean getBoxLocMode() { return boxLocMode; } public void setVMName(final String vmName) { firePropertyChange(VM_NAME, this.vmName, this.vmName = vmName); } public void setBoxName(final String boxName) {
<|startcomment|> modification <|endcomment|>  // borderSizeComputationExpression of Container equals to "0" by "1". If // the expression is not "0" (default value), we let the borderSize // unchanged. if (loadedVersion.compareTo(MIGRATION_VERSION) < 0) { // The Sirius 3.1.3 maintenance version already contains the // complete migration. // Full migration is required for version in [0.0.0, 3.1.0[ <|startfocus|> // Manual complementary migration might be required for version in [3.1.0, 3.1.3[ <|endfocus|> if (loadedVersion.compareTo(INITIAL_MIGRATION_VERSION) < 0) { // Full migration migrateBorderSizeComputationExpressions(group); } else if (loadedVersion.compareTo(ALREADY_MIGRATED_VERSION) < 0) { // Do nothing: // first level of container mappings have been migrated. // sub container mappings were with the previous version of the // migration but in Sirius 3.1.0, specifier might have // explicitly added styles with a 0 pix border: the migration // cannot take the decision to do the migration or not. } else {
<|startcomment|> extract "" as EMPTY_STRING please? <|endcomment|>  TmfFilterTraceTypeNode node = (TmfFilterTraceTypeNode) element; label = "WITH " + node.getNodeName() + ' ' + (node.getName() != null ? node.getName() : Messages.FilterTreeLabelProvider_TraceTypeHint); //$NON-NLS-1$ } else if (element instanceof TmfFilterAndNode) { TmfFilterAndNode node = (TmfFilterAndNode) element; <|startfocus|> label = (node.isNot() ? NOT : "") + node.getNodeName(); //$NON-NLS-1$ <|endfocus|> } else if (element instanceof TmfFilterOrNode) { TmfFilterOrNode node = (TmfFilterOrNode) element; label = (node.isNot() ? NOT : "") + node.getNodeName(); //$NON-NLS-1$ } else if (element instanceof TmfFilterContainsNode) { TmfFilterContainsNode node = (TmfFilterContainsNode) element; label = (node.isNot() ? NOT : "") + //$NON-NLS-1$ (node.getEventAspect() != null ? node.getAspectLabel(false) : Messages.FilterTreeLabelProvider_AspectHint) +
<|startcomment|> why this is commented ? <|endcomment|> import org.eclipse.papyrus.junit.utils.rules.PapyrusEditorFixture; import org.eclipse.papyrus.junit.utils.rules.PluginResource; import org.eclipse.papyrus.uml.diagram.common.editparts.ClassEditPart; import org.eclipse.uml2.uml.Classifier; import org.eclipse.uml2.uml.Generalization; import org.junit.Assert; import org.junit.Before; import org.junit.Rule; import org.junit.Test; /** * The Class Bug476873_MoveCommandTest. */ @PluginResource("/resources/476873/uml.di") <|startfocus|> // @ShowView(value = "org.eclipse.papyrus.views.modelexplorer.modelexplorer") <|endfocus|> public class Bug476873_MoveCommandTest extends AbstractPapyrusTest { /** The name of the source class of the generalizations. */ private static final String NAME_CLASS_1 = "Class1"; /** The name of the target class of the generalizations. */ private static final String NAME_CLASS_3 = "Class3"; /** The name of the diagram used for testing. */ private static final String NAME_DIAGRAM = "ClassDiagram"; /** The Papyrus editor fixture. */ @Rule public final PapyrusEditorFixture papyrusEditorFixture = new PapyrusEditorFixture(); 
<|startcomment|> can we save the exception by logging it with logError("msg", e); <|endcomment|>  for (int i = 1; i < timeZones.length; i++) { TimeZone tz = null; try { tz = TimeZone.getTimeZone(timeZones[i]); timeZoneIntervals[i][0] = tz.getDisplayName(); timeZoneIntervals[i][1] = tz.getID(); } catch (NullPointerException e) { <|startfocus|> Activator.getDefault().logInfo("TimeZone " + timeZones[i] + " does not exist."); //$NON-NLS-1$ //$NON-NLS-2$ <|endfocus|> } } fCombo = new ComboFieldEditor(ITmfTimePreferencesConstants.TIME_ZONE, "Time Zone", timeZoneIntervals, fPage); //$NON-NLS-1$ fCombo.setPreferenceStore(fPreferenceStore); fCombo.load(); fCombo.setPropertyChangeListener(this); // Date and Time section fDateTimeFields = new RadioGroupFieldEditor( ITmfTimePreferencesConstants.DATIME, "Date and Time format", 3, fDateTimeFormats, fPage, true); //$NON-NLS-1$ fDateTimeFields.setPreferenceStore(fPreferenceStore); fDateTimeFields.load(); fDateTimeFields.setPropertyChangeListener(this); // Sub-second section
<|startcomment|> "staged" would be then "state" <|endcomment|>  */ public class ResourceState implements IResourceState { /** * Flag indicating whether or not the resource is tracked */ private boolean tracked; /** * Flag indicating whether or not the resource is ignored */ private boolean ignored; /** * Flag indicating whether or not the resource has changes that are not * staged */ private boolean dirty; /** * Staged state of the resource */ <|startfocus|> private Staged staged = Staged.NOT_STAGED; <|endfocus|> /** * Flag indicating whether or not the resource has merge conflicts */ private boolean conflicts; /** * Flag indicating whether or not the resource is assumed valid */ private boolean assumeValid; @Override public boolean isTracked() { return tracked; } @Override public boolean isIgnored() { return ignored; } @Override public boolean isDirty() { return dirty; } @Override public Staged staged() { return staged; } @Override public boolean hasConflicts() { return conflicts;
<|startcomment|> CCombo is a platform agnostic widget, meaning we can't use GTK specific code here. Instead there is: if (SWT.getPlatform().equals("gtk")) { } The same applies for CLabel, CoolBar, and CTable as well -- these are all platform agnostic widgets. <|endcomment|> public Point computeSize (int wHint, int hHint, boolean changed) { checkWidget (); <|startfocus|> boolean visible = getVisible(); if (OS.GTK3 && !visible) { setVisible(true); } <|endfocus|> int width = 0, height = 0; String[] items = list.getItems (); GC gc = new GC (text); int spacer = gc.stringExtent (" ").x; //$NON-NLS-1$ int textWidth = gc.stringExtent (text.getText ()).x; for (int i = 0; i < items.length; i++) { textWidth = Math.max (gc.stringExtent (items[i]).x, textWidth); } gc.dispose (); Point textSize = text.computeSize (SWT.DEFAULT, SWT.DEFAULT, changed); Point arrowSize = arrow.computeSize (SWT.DEFAULT, SWT.DEFAULT, changed); Point listSize = list.computeSize (SWT.DEFAULT, SWT.DEFAULT, changed); int borderWidth = getBorderWidth (); height = Math.max (textSize.y, arrowSize.y);
<|startcomment|> Revert ? <|endcomment|>  Point clipboardSelection; // x and y are start and end caret offsets of previous selection int selectionAnchor; // position of selection anchor. 0 based offset from beginning of text Point doubleClickSelection; // selection after last mouse double click boolean editable = true; boolean wordWrap = false; // text is wrapped automatically boolean visualWrap = false; // process line breaks inside logical lines (inserted by BidiSegmentEvent) <|startfocus|> boolean doubleClickEnabled = true; // see getDoubleClickEnabled <|endfocus|> boolean overwrite = false; // insert/overwrite edit mode int textLimit = -1; // limits the number of characters the user can type in the widget. Unlimited by default. Map<Integer, Integer> keyActionMap = new HashMap<>(); Color background = null; // workaround for bug 4791 Color foreground = null; // Clipboard clipboard; int clickCount; int autoScrollDirection = SWT.NULL; // the direction of autoscrolling (up, down, right, left) int autoScrollDistance = 0; int lastTextChangeStart; // cache data of the
<|startcomment|> The vast majority of the changes in this file are due to formatting changes, it makes it difficult to review. Could you avoid formatting changes? <|endcomment|>  private static final int A1_EDGECHANGES_NB = 3 * A1_EDGECHANGE1_NB; private static final int A1_ELTCHANGE1_NB = 1; private static final int A1_ELTCHANGES_NB = 8 * A1_ELTCHANGE1_NB; private static final int A1_ASSOCHANGE1_NB = 14; private static final int A1_ASSOCHANGES_NB = 3 * A1_ASSOCHANGE1_NB; <|startfocus|> private static final int A1_DIFFS_NB = A1_PKGNODECHANGES_NB + A1_CLASSNODECHANGES_NB + A1_LISTNODECHANGES_NB + A1_EDGECHANGES_NB + A1_ELTCHANGES_NB + A1_ASSOCHANGES_NB; <|endfocus|> private static final int A2_ADD_PKGNODE1_NB = 14; private static final int A2_MOVE_NODEA_NB = 4; private static final int A2_ADD_PKG1_NB = 1; private static final int A2_MOVE_A_NB = 1; private static final int A2_DIFFS_NB = A2_ADD_PKGNODE1_NB + A2_MOVE_NODEA_NB + A2_ADD_PKG1_NB + A2_MOVE_A_NB; 
<|startcomment|> You can make this an "else" after the "if (forEditor)" block. <|endcomment|>  private void createActions(boolean forEditor) { fRenameAction = new CRenameAction(); fRenameAction.setActionDefinitionId(ICEditorActionDefinitionIds.RENAME_ELEMENT); fAllActions.add(fRenameAction); <|startfocus|> if (!forEditor) { fDeleteAction = new CDeleteAction(); fDeleteAction.setActionDefinitionId(ActionFactory.DELETE.getId()); fAllActions.add(fDeleteAction); } <|endfocus|> if (forEditor) { fExtractConstantAction= new ExtractConstantAction(); fExtractConstantAction.setActionDefinitionId(ICEditorActionDefinitionIds.EXTRACT_CONSTANT); fAllActions.add(fExtractConstantAction); fExtractLocalVariableAction= new ExtractLocalVariableAction(); fExtractLocalVariableAction.setActionDefinitionId(ICEditorActionDefinitionIds.EXTRACT_LOCAL_VARIABLE); fAllActions.add(fExtractLocalVariableAction); fExtractFunctionAction = new ExtractFunctionAction(); fExtractFunctionAction.setActionDefinitionId(ICEditorActionDefinitionIds.EXTRACT_FUNCTION); fAllActions.add(fExtractFunctionAction); fToggleFunctionAction = new ToggleFunctionAction(); fToggleFunctionAction.setActionDefinitionId(ICEditorActionDefinitionIds.TOGGLE_FUNCTION); fAllActions.add(fToggleFunctionAction); } fHideMethodAction = new HideMethodAction(); fHideMethodAction.setActionDefinitionId(ICEditorActionDefinitionIds.HIDE_METHOD);
<|startcomment|> Remove non-javadoc <|endcomment|>  public static final String PREF_PATH = "path"; //$NON-NLS-1$ public static final String PREF_VALIDATION_ERROR_LEVEL = "validationErrorLevel"; //$NON-NLS-1$ public static final String PREF_MISSING_UNBIND_METHOD_ERROR_LEVEL = "validationErrorLevel.missingImplicitUnbindMethod"; //$NON-NLS-1$ public static final String DEFAULT_PATH = "OSGI-INF"; //$NON-NLS-1$ // The shared instance private static Activator plugin; private DSAnnotationPreferenceListener dsPrefListener; <|startfocus|> /* * (non-Javadoc) * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext) */ <|endfocus|> @Override public void start(BundleContext context) throws Exception { super.start(context); plugin = this; dsPrefListener = new DSAnnotationPreferenceListener(); } /* * (non-Javadoc) * @see org.eclipse.ui.plugin.AbstractUIPlugin#stop(org.osgi.framework.BundleContext) */ @Override public void stop(BundleContext context) throws Exception { dsPrefListener.dispose(); plugin = null; super.stop(context); } /**
<|startcomment|> 2015 THALES GLOBAL SERVICES and others. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2010, 2014 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.tests.unit.api.diagramintegrity; import org.eclipse.sirius.business.api.dialect.command.RefreshRepresentationsCommand; import org.eclipse.sirius.common.tools.api.interpreter.EvaluationException; public class MoveSemanticElementTest extends DiagramIntegrityTestCase { /* * Check that the corresponding diagram is properly modified if an element * is moved in the semantic model. */ public void testDiagramIntegrityWhenMovingSemanticElement() { int eltCount = -1; // build the semantic model with an element Para under the chapter. addTinySection(); addNote(); // create a diagram based on my semantic model (simple.docbook) myRepresentation = createRepresentation("evoluate view"); 
<|startcomment|> 2015 THALES GLOBAL SERVICES and others. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2010, 2014 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.tests.unit.contribution; import static org.eclipse.sirius.tests.unit.contribution.OptionAssert.assertHasExactValue; import static org.eclipse.sirius.tests.unit.contribution.OptionAssert.assertHasNoValue; import java.util.Map; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.EcoreFactory; import org.eclipse.sirius.business.internal.contribution.ReferenceResolver; import org.eclipse.sirius.business.internal.contribution.SiriusReferenceResolver; import org.eclipse.sirius.common.tools.api.interpreter.CompoundInterpreter; import org.eclipse.sirius.common.tools.api.interpreter.IInterpreter; import org.eclipse.sirius.description.contribution.ComputedEObjectReference; import org.eclipse.sirius.description.contribution.ContributionFactory; import org.eclipse.sirius.description.contribution.DirectEObjectReference; import org.eclipse.sirius.description.contribution.EObjectReference;
<|startcomment|> The system property is called "git_repo" and not "-Dgit_repo" <|endcomment|>  * is used. * * @param args * each element in the array must be a valid git command line, * e.g. "git branch -h" * @throws Exception */ public static void main(String[] args) throws Exception { String repoPath = System.getProperty("git_repo"); if (repoPath == null) { repoPath = "."; System.out.println( <|startfocus|> "System property '-Dgit_repo' not specified, using current directory: " <|endfocus|> + new File(repoPath).getAbsolutePath()); } try (Repository db = new FileRepository(repoPath + "/.git")) { for (String cmd : args) { List<String> result = execute(cmd, db); for (String line : result) { System.out.println(line); } } } } public static List<String> execute(String str, Repository db) throws Exception { try { return IO.readLines(new String(rawExecute(str, db))); } catch (Die e) {
<|startcomment|> year <|endcomment|> **************************************************************************** <|startfocus|> * Copyright (c) 2015 Ericsson <|endfocus|> * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.analysis.timing.ui.views.segmentstore.density; import static org.eclipse.tracecompass.common.core.NonNullUtils.nullToEmptyString; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.concurrent.CompletableFuture; import org.eclipse.jdt.annotation.Nullable; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.graphics.RGB; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.tracecompass.analysis.timing.core.segmentstore.AbstractSegmentStoreAnalysisModule; import org.eclipse.tracecompass.analysis.timing.core.segmentstore.IAnalysisProgressListener; import org.eclipse.tracecompass.analysis.timing.ui.views.segmentstore.HumanReadableTimeFormat; import org.eclipse.tracecompass.common.core.NonNullUtils;
<|startcomment|> Not needed. <|endcomment|>  public void setInput(Object input) { if (input instanceof CommentAnnotationHoverInput) { this.annotationInput = (CommentAnnotationHoverInput) input; // clear the composite in case we are re-using it for (Control control : composite.getChildren()) { control.dispose(); } currentPopupDialog = this; <|startfocus|> commentList = new ArrayList<IComment>(); for (CommentAnnotation annotation : Iterables.filter(annotationInput.getAnnotations(), CommentAnnotation.class)) { if (reviewItem == null) { if (annotation instanceof CommentAnnotation) { <|endfocus|> if (annotation.getComment().getItem() instanceof IReviewItem) { reviewItem = (IReviewItem) annotation.getComment().getItem(); } } if (range == null) { List<ILocation> locations = annotation.getComment().getLocations(); if (!locations.isEmpty()) { ILocation location = locations.get(0); if (location instanceof ILineLocation) { range = new LineRange(((ILineLocation) location).getRangeMin(), 1); } } } 
<|startcomment|> , which generates less network bandwidth use, but provides looser consistency on the replica. <|endcomment|>  FOLLOWER; } /** How this replica wants to receive Ketch commit operations. */ public enum CommitMethod { /** All references are pushed to the peer as standard Git. */ ALL_REFS, /** Only {@code refs/txn/committed} is written/updated. */ TXN_COMMITTED; } /** When does this replica commit? */ public enum CommitSpeed { /** Send commit immediately, may run concurrently with next proposal. */ FAST, <|startfocus|> /** Batch commit with next proposal. */ <|endfocus|> BATCHED; } /** Current state of this remote. */ public enum State { /** Leader has not yet contacted the replica. */ UNKNOWN, /** Replica is behind the consensus. */ LAGGING, /** Replica matches the consensus. */ CURRENT, /** Replica has a different (or unknown) history. */ DIVERGENT, /** Replica's history contains the leader's history. */ AHEAD, /** Connectivity with the replica is not working. */ OFFLINE; } private final KetchLeader leader; private final String name;
<|startcomment|> This is assigned to a local variable, set to null, and then the local variable is passed around to all the other methods. Why not just pass it into the start() method and get rid of the member variable and setTree() method? <|endcomment|> import org.eclipse.jgit.transport.ReceiveCommand; /** Aggregates and sends user {@link Proposal}s. */ class ProposalRound extends Round { private final List<Proposal> todo; private RefTree queuedTree; ProposalRound(KetchLeader leader, LogId head, List<Proposal> todo) { super(leader, head); this.todo = todo; } void setTree(RefTree tree) { this.queuedTree = tree; } void start() throws IOException { <|startfocus|> RefTree tree = queuedTree; queuedTree = null; <|endfocus|> for (Proposal p : todo) { p.notifyState(RUNNING); } begin(tree); } private void begin(@Nullable RefTree tree) throws IOException { try { ObjectId id; try (Repository git = leader.openRepository()) { id = insertProposals(git, tree); } acceptAsync(id); } catch (NoOp e) { for (Proposal p : todo) { p.success(); } leader.lock.lock(); try { leader.nextRound(); } finally { leader.lock.unlock(); } } catch (IOException e) {
<|startcomment|> Not used? <|endcomment|>  super(client, "/bug/attachment/" + taskData.getValue() + "?include_fields=data", null); this.taskData = taskData; } @Override protected InputStream parseFromJson(InputStreamReader in) { TypeToken<InputStream> type = new TypeToken<InputStream>() { }; return new GsonBuilder().registerTypeAdapter(type.getType(), new JSonTaskDataDeserializer()) .create() .fromJson(in, type.getType()); } <|startfocus|> BugzillaRestTaskSchema taskSchema = BugzillaRestTaskSchema.getDefault(); <|endfocus|> private class JSonTaskDataDeserializer implements JsonDeserializer<InputStream> { @Override public InputStream deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { JsonElement aa = ((JsonObject) json.getAsJsonObject().get("attachments")).get(taskData.getValue()); JsonPrimitive xxxx = aa.getAsJsonObject().get("data").getAsJsonPrimitive(); InputStream is = new ByteArrayInputStream(xxxx.getAsString().getBytes()); return new Base64InputStream(is); 
<|startcomment|> s/n/name/ n is always an index <|endcomment|>  if (e.getKey() instanceof LogId) { LogId k = (LogId) e.getKey(); if (k.isBefore(committedId)) { delete(cmds, e.getValue()); i.remove(); } } } } private static void delete(List<ReceiveCommand> cmds, List<ReceiveCommand> createCmds) { <|startfocus|> for (ReceiveCommand c : createCmds) { ObjectId id = c.getNewId(); String n = c.getRefName(); cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n)); <|endfocus|> } } private void nextPush() { LogId c = leader.getCommitted(); if (equals(txnAccepted, c) && !equals(txnCommitted, c)) { commitAsync(c, leader.isIdle()); } if (queued.isEmpty() || !running.isEmpty() || waitingForRetry()) { return; } // Collapse all queued requests into a single request. Map<String, ReceiveCommand> cmdMap = new HashMap<>(); for (ReplicaPushRequest req : queued) {
<|startcomment|> nit: s/Request/A request/ <|endcomment|>  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.internal.ketch; import java.util.Collection; import java.util.Map; import org.eclipse.jgit.annotations.Nullable; import org.eclipse.jgit.lib.Ref; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.transport.ReceiveCommand; /** <|startfocus|> * Request made to a replica, and its result. <|endfocus|> * <p> * Implementors of {@link KetchReplica} must populate the command result fields, * {@link #setRefs(Map)}, and call one of * {@link #setException(Repository, Throwable)} or {@link #done(Repository)} to * finish processing. */ public class ReplicaPushRequest { private final KetchReplica replica; private final Collection<ReceiveCommand> commands; private Map<String, Ref> refs; private Throwable exception; /** * Construct a new push request for a replica. * * @param replica
<|startcomment|> Should probably be targetEObject (the iteration variable) instead of target (the method parameter). <|endcomment|>  private IStatus getStatus(IEvaluationResult evaluationResult) { Object result = evaluationResult.getValue(); <|startfocus|> String defaultMessage = this.getDefaultMessage(result); String message = defaultMessage; <|endfocus|> Diagnostic diagnostic = evaluationResult.getDiagnostic(); int statusCode = this.getStatusCodeFromDiagnostic(diagnostic); IStatus status = new Status(statusCode, Activator.PLUGIN_ID, message); if (Diagnostic.OK != diagnostic.getSeverity() && diagnostic.getChildren().size() > 0) { MultiStatus multiStatus = new MultiStatus(Activator.PLUGIN_ID, statusCode, message, null); List<Diagnostic> children = diagnostic.getChildren(); for (Diagnostic childDiagnostic : children) { int childStatusCode = this.getStatusCodeFromDiagnostic(childDiagnostic); String childMessage = childDiagnostic.getMessage(); IStatus childStatus = new Status(childStatusCode, Activator.PLUGIN_ID, childMessage); multiStatus.add(childStatus); } status = multiStatus; } return status;
<|startcomment|> The copyright year, now needs to be updated to 2016 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2008, 2015 QNX Software Systems and others. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * QNX Software Systems - Initial API and implementation * Windriver and Ericsson - Updated for DSF * IBM Corporation * Ericsson - Added support for Mac OS * Ericsson - Added support for post-mortem trace files * Abeer Bagul (Tensilica) - Allow to better override GdbLaunch (bug 339550) * Anton Gorenkov - Need to use a process factory (Bug 210366) * Marc Khouzam (Ericsson) - Cleanup the launch if it is cancelled (Bug 374374) * Marc-Andre Laperle - Bug 382462 * Marc Khouzam (Ericsson - Show GDB version in debug view node label (Bug 455408) *******************************************************************************/ package org.eclipse.cdt.dsf.gdb.launching; import java.util.concurrent.CancellationException;
<|startcomment|> Why exclude BugzillaRestValidateRequest and BugzillaRestUnauthenticatedGetRequest here whereas BugzillaRestAuthenticatedPostRequest overrides this method? Might as well just have all 3 override it. <|endcomment|>  protected abstract HttpRequestBase createHttpRequestBase(String url); protected HttpRequestBase createHttpRequestBase() { HttpRequestBase request = createHttpRequestBase(createHttpRequestURL()); return request; } protected String baseUrl() { String url = getClient().getLocation().getUrl(); if (!url.endsWith("/rest.cgi")) { url += "/rest.cgi"; } return url; } protected String getUrlSuffix() { <|startfocus|> return ""; //$NON-NLS-1$ <|endfocus|> } protected String createHttpRequestURL() { String bugUrl = getUrlSuffix(); LoginToken token = ((BugzillaRestHttpClient) getClient()).getLoginToken(); if (token != null && bugUrl.length() > 0) { if (!bugUrl.endsWith("?")) { //$NON-NLS-1$ bugUrl += "&"; //$NON-NLS-1$ } bugUrl += "token=" + token.getToken(); //$NON-NLS-1$ } else { String apiKey = ((BugzillaRestHttpClient) getClient()).getApiKey();
<|startcomment|> That is not correct. It is the row index of the cell to copy to. see getPasteValue() Javadoc <|endcomment|>  temp = calculateDateDiff(cells[rowArrayIndex][i], cells[rowArrayIndex][i - 1], configRegistry); if (temp == null || !temp.equals(diff)) { return null; } } return diff * columnDiff; } } return null; } /** * Calculate the row difference between the cell row index and the initial * row index. * * @param currentCell * The current cell to manage. * @param toRow <|startfocus|> * The initial row index. <|endfocus|> * @return The difference as integer. */ protected int getRowDiff(final ILayerCell currentCell, final int toRow) { return toRow - currentCell.getRowIndex(); } /** * Calculate the column difference between the cell column index and the * initial column index. * * @param currentCell * The current cell to manage. * @param toColumn * The initial column index. * @return The difference as integer. */
<|startcomment|> Should always be in a finally. <|endcomment|>  contentType = mapper.getContentType(); } if (mapper.getFileName() != null) { filename = mapper.getFileName(); } if (mapper.isPatch() != null) { isPatch = mapper.isPatch(); } } Assert.isNotNull(bugReportID); Assert.isNotNull(source); Assert.isNotNull(contentType); ByteArrayOutputStream outb = new ByteArrayOutputStream(); InputStream is; try { is = source.createInputStream(null); IOUtils.copy(is, outb); <|startfocus|> is.close(); <|endfocus|> } catch (CoreException | IOException e) { throw new BugzillaRestException( "BugzillaRestPostNewAttachment.createHttpRequestBase could not get stream form source", e); } if (description == null) { throw new BugzillaRestException(new CoreException(new Status(IStatus.WARNING, BugzillaRestCore.ID_PLUGIN, "Description required when submitting attachments"))); } Base64 base64 = new Base64(); String dataBase64 = base64.encodeAsString(outb.toByteArray()); try {
<|startcomment|> missing whitespace :( <|endcomment|>  super.createPartControl(parent); // add "Check active" Button to TimeGraphFilterDialog super.getTimeGraphCombo().addTimeGraphFilterCheckActiveButton( new ControlFlowCheckActiveProvider(Messages.ControlFlowView_checkActiveLabel, Messages.ControlFlowView_checkActiveToolTip)); // add "Uncheck inactive" Button to TimeGraphFilterDialog super.getTimeGraphCombo().addTimeGraphFilterUncheckInactiveButton( new ControlFlowCheckActiveProvider(Messages.ControlFlowView_uncheckInactiveLabel, Messages.ControlFlowView_uncheckInactiveToolTip)); super.getTimeGraphCombo().addSelectionListener(event -> { <|startfocus|> ControlFlowEntry entry = (ControlFlowEntry)event.getSelection(); <|endfocus|> broadcast(new TmfThreadSelectedSignal(event.getSource(), entry.getThreadId(), entry.getTrace())); });
<|startcomment|> use Long.valueOf() instead of new Long() - always for performance reasons <|endcomment|>  public Long getUuid() { <|startfocus|> return new Long(artifactObject.getArtId()); <|endfocus|>
<|startcomment|> Please use our new 4.6 API: Adapters.adapt <|endcomment|>  public Object execute(ExecutionEvent arg0) { IProject project = null; ISelection selection = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getSelectionService().getSelection(); if (selection instanceof IStructuredSelection) { Object item = ((IStructuredSelection)selection).getFirstElement(); <|startfocus|> if (item instanceof IProject) { project = (IProject)item; } else if (item instanceof IAdaptable) { project = ((IAdaptable)item).getAdapter(IProject.class); } <|endfocus|> } if (project == null) { return null; } SmartImportWizard wizard = new SmartImportWizard(); wizard.setInitialImportSource(project.getLocation().toFile()); // inherit workingSets Set<IWorkingSet> workingSets = new HashSet<>(); for (IWorkingSet workingSet : PlatformUI.getWorkbench().getWorkingSetManager().getWorkingSets()) { for (IAdaptable element : workingSet.getElements()) { if (project.getAdapter(element.getClass()) == element) { workingSets.add(workingSet); } } } wizard.setInitialWorkingSets(workingSets);
<|startcomment|> Consider using error logging instead of println <|endcomment|>  results.add((T) createFromFactory(artifact)); } } } addtoResultsWithNullCheck(allResults, results); return results; } @SuppressWarnings("unchecked") private <T> T createFromFactory(ArtifactId artifact) { return (T) services.getConfigItemFactory().getConfigObject(artifact); } private <T> void addtoResultsWithNullCheck(Set<T> allResults, Collection<? extends T> configObjects) { if (configObjects.contains(null)) { <|startfocus|> System.err.println("Null found in results."); <|endfocus|> } else { allResults.addAll(configObjects); } } private boolean isArtifactTypeMatch(ArtifactId artifact, IArtifactType artType) { if (artType == null) { return true; } if (services.getArtifactResolver().isOfType(artifact, artType)) { return true; } return false; } public abstract void queryAndNotExists(IRelationTypeSide relationTypeSide); public abstract void queryAndExists(IRelationTypeSide relationTypeSide); public abstract void queryAndIsOfType(IArtifactType artifactType); 
<|startcomment|> non nls <|endcomment|>  public void run() { try { Shell shell = Display.getDefault().getActiveShell(); if (shell != null) { MessageBox messageBox = new MessageBox(shell, SWT.ICON_INFORMATION | SWT.OK); <|startfocus|> messageBox.setMessage("Reversed to new UML model in reversed_models/ folder of project " + project.getName()); <|endfocus|> messageBox.open(); } } catch (Exception e) { Activator.log.error(e); } 
<|startcomment|> @since 4.3 <|endcomment|>  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.util.io; import java.io.InputStream; import java.io.OutputStream; import org.eclipse.jgit.attributes.Attributes; import org.eclipse.jgit.lib.CoreConfig.StreamType; import org.eclipse.jgit.treewalk.TreeWalk.OperationType; import org.eclipse.jgit.treewalk.WorkingTreeOptions; /** * Convenience utility used to create input and output stream wrappers depending * on {@link StreamType} * <|startfocus|> * @since 4.2 <|endfocus|> */ public final class StreamTypeUtil { private StreamTypeUtil() { } /** * Convenience method used to detect if CRLF conversion has been configured * using the * <ul> * <li>global repo options</li> * <li>global attributes</li> * <li>info attributes</li> * <li>working tree .gitattributes</li> * * @param op * @param options * @param attrs * @return the stream conversion {@link StreamType} to be performed for the * selected {@link OperationType} */
<|startcomment|> remove unnecessary checks <|endcomment|>  public boolean hasVariable(final String identifier) { <|startfocus|> if (identifier == null || identifier.isEmpty()) return false; <|endfocus|> return getVariable(identifier) != null;
<|startcomment|> If i get this right we are creating a FileBasedChangePackage for so that the above temp file is the temp file of the newly created cp. Is this correct? However move code to util class? <|endcomment|>  * @return the file based change package as an {@link Optional} */ public Optional<FileBasedChangePackage> getFileBasedChangePackage(String proxyId) { final File file = proxyIdToCompletedChangePackages.get(proxyId); if (file == null) { return Optional.absent(); } final FileBasedChangePackage cp = VersioningFactory.eINSTANCE.createFileBasedChangePackage(); final String substring = file.getAbsolutePath().substring(0, file.getAbsolutePath().length() - ".temp".length()); //$NON-NLS-1$ <|startfocus|> cp.setFilePath(substring); <|endfocus|> return Optional.of(cp); } /** * Removes the completed change package matching the given ID. * * @param proxyId * the ID of the change package proxy */ public void clearCompleted(final String proxyId) { proxyIdToCompletedChangePackages.remove(proxyId); } } 
<|startcomment|> Select Git Flow feature branches <|endcomment|> import static org.eclipse.jface.dialogs.IDialogConstants.OK_LABEL; import java.util.ArrayList; import java.util.List; import org.eclipse.jface.dialogs.MessageDialog; import org.eclipse.jface.viewers.DoubleClickEvent; import org.eclipse.jface.viewers.IDoubleClickListener; import org.eclipse.jface.viewers.ISelectionChangedListener; import org.eclipse.jface.viewers.SelectionChangedEvent; import org.eclipse.jface.viewers.TreeViewer; import org.eclipse.jgit.lib.Ref; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Shell; /** <|startfocus|> * Select Git Flow branches. * <|endfocus|> */ public class FeatureBranchSelectionDialog extends MessageDialog { private List<Ref> selected = new ArrayList<>(); private FilteredBranchesWidget filteredFeatures; /** * @param parentShell * @param nodes * @param title * @param message * @param featurePrefix */ public FeatureBranchSelectionDialog(Shell parentShell, List<Ref> nodes, String title, String message, String featurePrefix) { super(parentShell, title, null, message, MessageDialog.QUESTION, new String[] { OK_LABEL, CANCEL_LABEL }, 0);
<|startcomment|> I would use a less "negative" name, e.g. "eclipse.show.wrapByDefaultPreference". <|endcomment|>  private boolean isWordWrapPreferenceAllowed() { <|startfocus|> return Boolean.getBoolean("eclipse.workaround.bug488162"); //$NON-NLS-1$ <|endfocus|>
<|startcomment|> Please replace remaining "unknown" <|endcomment|>  * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Mickael Istria (Red Hat Inc.) - extracted from IDE.getEditorDescription *******************************************************************************/ package org.eclipse.ui.internal.ide; import org.eclipse.ui.IEditorDescriptor; import org.eclipse.ui.IEditorRegistry; import org.eclipse.ui.ide.IUnassociatedEditorStrategy; /** <|startfocus|> * Strategy for unknown file types: <|endfocus|> * <ol> * <li>The operating system is consulted to determine if an in-place component * editor is available (e.g. OLE editor on Win32 platforms).</li> * <li>The operating system is consulted to determine if an external editor is * available.</li> * <li>The workbench editor registry is consulted to determine if the default * text editor is available.</li></li> * </ol>
<|startcomment|> Unecessary code <|endcomment|>  * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.business.internal.metamodel.description.spec; import org.eclipse.sirius.common.tools.api.util.MessageTranslator; import org.eclipse.sirius.diagram.description.impl.EdgeMappingImportImpl; /** * Customization of {@link EdgeMappingImportImpl}. * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ public class EdgeMappingImportSpec extends EdgeMappingImportImpl { <|startfocus|> /** * {@inheritDoc} */ <|endfocus|> @Override public String getLabel() { return MessageTranslator.INSTANCE.getMessage(super.getLabel()); } } 
<|startcomment|> same <|endcomment|>  // Slider Right Slider sliderRight = new Slider(sliderComposite, SWT.HORIZONTAL); gridData = new GridData(); gridData.horizontalAlignment = GridData.FILL; gridData.verticalAlignment = GridData.BEGINNING; gridData.grabExcessHorizontalSpace = true; gridData.grabExcessVerticalSpace = false; sliderRight.setLayoutData(gridData); right.setHorizontalScroller(new SliderScroller(sliderRight)); } <|startfocus|> <|endfocus|> /** * @see org.eclipse.papyrus.infra.nattable.manager.table.AbstractNattableWidgetManager#addClickSortConfiguration(org.eclipse.nebula.widgets.nattable.NatTable) * * @param natTable */ @Override protected void addClickSortConfiguration(NatTable natTable) { natTable.addConfiguration(new TreeTableClickSortConfiguration()); } /** * @see org.eclipse.papyrus.infra.nattable.manager.table.NattableModelManager#updateToggleActionState() * */ @Override protected void updateToggleActionState() { super.updateToggleActionState(); // update hierarchic table display style DisplayStyle style = TableHelper.getTableDisplayStyle(this); final ICommandService commandService = EclipseCommandUtils.getCommandService(); if (commandService != null) { 
<|startcomment|> Do we need 2 of these nodes? We could just have one, like before, and no root node, since the TaskRepository and TaskRepositoryV2 are different. <|endcomment|>  writeVersion1(repositories); writeVersion2(repositories); handler.endElement("", "root", "root"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ handler.endDocument(); } private void writeVersion2(Collection<TaskRepository> repositories) throws IOException, SAXException { AttributesImpl rootAttributes = new AttributesImpl(); rootAttributes.addAttribute("", TaskRepositoriesExternalizer.ATTRIBUTE_VERSION, //$NON-NLS-1$ <|startfocus|> TaskRepositoriesExternalizer.ATTRIBUTE_VERSION, "", "2"); //$NON-NLS-1$ //$NON-NLS-2$ <|endfocus|> handler.startElement("", TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORIES, //$NON-NLS-1$ TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORIES, rootAttributes); for (TaskRepository repository : new ArrayList<TaskRepository>(repositories)) { AttributesImpl ieAttributes = new AttributesImpl(); addAttribute(ieAttributes, IRepositoryConstants.PROPERTY_CONNECTOR_KIND, repository.getConnectorKind()); addAttribute(ieAttributes, IRepositoryConstants.PROPERTY_URL, repository.getUrl()); handler.startElement("", TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORYV2, //$NON-NLS-1$ TaskRepositoriesExternalizer.ELEMENT_TASK_REPOSITORYV2, ieAttributes); 
<|startcomment|> is this change needed? <|endcomment|>  setFollowFileRenames(true); initRevPool(false); remaining = -1; } private void initRevPool(boolean reverse) { if (queue != null) throw new IllegalStateException(); if (revPool != null) revPool.close(); if (reverse) revPool = new ReverseWalk(getRepository()); else revPool = new RevWalk(getRepository()); SEEN = revPool.newFlag("SEEN"); //$NON-NLS-1$ reader = revPool.getObjectReader(); <|startfocus|> treeWalk = new TreeWalk(getRepository(), reader); <|endfocus|> treeWalk.setRecursive(true); } /** @return repository being scanned for revision history. */ public Repository getRepository() { return repository; } /** @return path file path being processed. */ public String getResultPath() { return resultPath.getPath(); } /** * Difference algorithm to use when comparing revisions. * * @param algorithm * @return {@code this} */ public BlameGenerator setDiffAlgorithm(DiffAlgorithm algorithm) { diffAlgorithm = algorithm; return this; } /**
<|startcomment|> What would be the difference between this and getSymbolInfo(address).getFunctionName()? Unless we turn this into a static method, as mentioned previously. <|endcomment|>  * an {@link TmfTrace} into human readable strings. * * @author Robert Kiss * @since 2.0 * @see ISymbolProviderFactory * */ public interface ISymbolProvider { /** * Return the symbol text corresponding to the given address or null if * there is no such symbol * * @param address * the address of the symbol * @return the symbol text or null if the symbol cannot be found */ <|startfocus|> public @Nullable String getSymbolText(long address); <|endfocus|> /** * Return additional information regarding the symbol from the given address * or null if the symbol cannot be found * * @param address * the address of the symbol * @return the symbol {@link ITmfCallsite} information or null if the symbol * cannot be found */ public @Nullable ITmfCallsite getSymbolInfo(long address); /** * Create the {@link ISymbolProviderPreferencePage} that can be used to * configure this {@link ISymbolProvider} *
<|startcomment|> could be final <|endcomment|>  * * Contributors: * Robert Kiss - Initial API and implementation *******************************************************************************/ package org.eclipse.tracecompass.tmf.ui.symbols; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jface.preference.PreferencePage; /** * Abstract implementation of the {@link ISymbolProviderPreferencePage}. Instead * of implementing the interface one should extend this class. * * @author Robert Kiss * @since 2.0 */ public abstract class AbstractSymbolProviderPreferencePage extends PreferencePage implements ISymbolProviderPreferencePage { <|startfocus|> private @NonNull ISymbolProvider provider; <|endfocus|> /** * Create a new instance that knows how to configure the given provider * * @param provider * the {@link ISymbolProvider} to configure */ public AbstractSymbolProviderPreferencePage(@NonNull ISymbolProvider provider) { this.provider = provider; setTitle(provider.getTrace().getName()); noDefaultAndApplyButton(); } /* * (non-Javadoc) * * @see * org.eclipse.tracecompass.tmf.ui.symbols.ISymbolProviderPreferencePage# * getSymbolProvider() */ @Override
<|startcomment|> Duplicated line above (SetMergeable) <|endcomment|>  toRefresh.getMessages().clear(); toRefresh.getMessages().addAll(newChangeInfo.getMessages()); toRefresh.getPermitted_labels().clear(); toRefresh.getPermitted_labels().addAll(newChangeInfo.getPermitted_labels()); toRefresh.setStatus(newChangeInfo.getStatus()); toRefresh.setSubject(newChangeInfo.getSubject()); toRefresh.getActions().clear(); toRefresh.getActions().addAll(newChangeInfo.getActions()); <|startfocus|> toRefresh.setTopic(newChangeInfo.getTopic()); toRefresh.setMergeable(newChangeInfo.isMergeable()); <|endfocus|> mergeRevisions(toRefresh, newChangeInfo);
<|startcomment|> Remove extra blank line (or just ctrl-shift-f this file). <|endcomment|> ******************************************************************** * Copyright (c) 2016 Polytechnique de Montral * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Samuel Gagnon - Initial implementation **********************************************************************/ package org.eclipse.tracecompass.analysis.os.linux.core.kernelmemoryusage; <|startfocus|> <|endfocus|> import static org.eclipse.tracecompass.common.core.NonNullUtils.checkNotNull; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.tracecompass.analysis.os.linux.core.kernelanalysis.KernelTidAspect; import org.eclipse.tracecompass.analysis.os.linux.core.trace.IKernelAnalysisEventLayout; import org.eclipse.tracecompass.internal.analysis.os.linux.core.Activator; import org.eclipse.tracecompass.statesystem.core.ITmfStateSystemBuilder; import org.eclipse.tracecompass.statesystem.core.exceptions.AttributeNotFoundException; import org.eclipse.tracecompass.statesystem.core.statevalue.ITmfStateValue; import org.eclipse.tracecompass.statesystem.core.statevalue.TmfStateValue; import org.eclipse.tracecompass.tmf.core.event.ITmfEvent; import org.eclipse.tracecompass.tmf.core.statesystem.AbstractTmfStateProvider;
<|startcomment|> missing return javadoc <|endcomment|> import org.eclipse.papyrusrt.umlrt.profile.UMLRealTime.RTMessageKind; import org.eclipse.uml2.uml.Interface; import org.eclipse.uml2.uml.Operation; /** * Specialization of the Operation as message in message sets, but specific to message sets with kind=IN */ public class OperationAsMessageInEditHelperAdvice extends AbstractEditHelperAdvice { /** * @see org.eclipse.gmf.runtime.emf.type.core.edithelper.AbstractEditHelperAdvice#approveRequest(org.eclipse.gmf.runtime.emf.type.core.requests.IEditCommandRequest) <|startfocus|> * * @param request * @return <|endfocus|> */ @Override public boolean approveRequest(IEditCommandRequest request) { boolean approve = false; if (request instanceof CreateElementRequest) { // check container. EObject container = ((CreateElementRequest) request).getContainer(); // When creating a parameter, the container is an Operation and the element type is the specific one created if (container instanceof Operation && ElementTypeRegistry.getInstance().getType(IRealTimeConstants.PARAMATER_CREATION_WITH_UI_ID).equals(((CreateElementRequest) request).getElementType())) { approve = true; } 
<|startcomment|> nls missing <|endcomment|>  * */ public class ParameterControlEditor extends AbstractListEditor implements SelectionListener, DisposeListener { /** * Icon for the delete button */ private static final String DELETE_BUTTON_ICON = "/icons/Delete_12x12.gif"; /** * Icon for the Add button */ private static final String ADD_BUTTON_ICON = "/icons/Add_12x12.gif"; /** * Icon for the Down button */ <|startfocus|> private static final String DOWN_BUTTON_ICON = "/icons/Down_12x12.gif"; <|endfocus|> /** * Icon for the Up button */ private static final String UP_BUTTON_ICON = "/icons/Up_12x12.gif"; /** * Command provider for the Operation */ private IElementEditService provider = ElementEditServiceUtils.getCommandProvider(UMLElementTypes.Operation_3102); /** * A Composite containing the different control buttons * (Add, remove, ...) */ protected Composite controlsSection; /** * The Add control */ protected Button add; /** * The Remove control */
<|startcomment|> cej@a4t here <|endcomment|> *************************************************************************** * Copyright (c) 2016 CEA LIST and others. * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: <|startfocus|> * CEA LIST - Initial API and implementation <|endfocus|> * *****************************************************************************/ package org.eclipse.papyrusrt.umlrt.tooling.tables.configurations; import org.eclipse.nebula.widgets.nattable.edit.editor.ICellEditor; import org.eclipse.nebula.widgets.nattable.edit.gui.AbstractDialogCellEditor; import org.eclipse.papyrus.infra.nattable.celleditor.AbstractOpenDialogCellEditorButtonAction; import org.eclipse.papyrus.infra.nattable.celleditor.AbstractPapyrusStyledTextCellEditor; import org.eclipse.papyrus.infra.nattable.manager.table.ITableAxisElementProvider; import org.eclipse.papyrus.infra.nattable.model.nattable.Table; import org.eclipse.papyrus.uml.nattable.config.UMLSingleReferenceTextualCellEditorWithButtonConfiguration; import org.eclipse.papyrus.uml.nattable.manager.cell.editor.UMLReferenceTextWithCompletionCellEditor; import org.eclipse.papyrus.uml.nattable.messages.Messages; import org.eclipse.papyrusrt.umlrt.tooling.tables.editors.cell.ParameterTypeCellEditor; 
<|startcomment|> Unneeded import. Please remove <|endcomment|>  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.treewalk; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import java.io.File; import java.io.IOException; <|startfocus|> import java.io.PrintWriter; <|endfocus|> import java.security.MessageDigest; import org.eclipse.jgit.api.Git; import org.eclipse.jgit.dircache.DirCache; import org.eclipse.jgit.dircache.DirCacheCheckout; import org.eclipse.jgit.dircache.DirCacheEditor; import org.eclipse.jgit.dircache.DirCacheEditor.PathEdit; import org.eclipse.jgit.dircache.DirCacheEntry; import org.eclipse.jgit.dircache.DirCacheIterator; import org.eclipse.jgit.errors.CorruptObjectException; import org.eclipse.jgit.errors.IncorrectObjectTypeException; import org.eclipse.jgit.errors.MissingObjectException; import org.eclipse.jgit.junit.JGitTestUtil; import org.eclipse.jgit.junit.RepositoryTestCase; import org.eclipse.jgit.lib.*; import org.eclipse.jgit.revwalk.RevCommit;
<|startcomment|> 2016 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2007, 2015 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.ui.tools.api.figure; import java.text.MessageFormat; import org.eclipse.core.runtime.IConfigurationElement; import org.eclipse.draw2d.Border; import org.eclipse.draw2d.IFigure; import org.eclipse.sirius.common.tools.api.util.StringUtil; import org.eclipse.sirius.diagram.BundledImage; import org.eclipse.sirius.diagram.BundledImageShape; import org.eclipse.sirius.diagram.internal.queries.BundledImageExtensionQuery; import org.eclipse.sirius.diagram.ui.provider.DiagramUIPlugin; import org.eclipse.sirius.diagram.ui.tools.api.color.ColorManager; import org.eclipse.sirius.viewpoint.RGBValues; import org.eclipse.swt.graphics.Color; import org.w3c.dom.Document; import org.w3c.dom.Element; /**
<|startcomment|> @noimplement This interface is not intended to be implemented by clients. <|endcomment|>  * * Contributors: * Simon Scholz <simon.scholz@vogella.com> - initial API and implementation ******************************************************************************/ package org.eclipse.core.databinding.observable; import java.util.function.Consumer; import java.util.function.Supplier; import org.eclipse.core.internal.databinding.observable.SideEffectFactory; /** * A factory to create {@link ISideEffect} objects, which are applied to the * given {@link Consumer} in {@link ISideEffectFactory#create(Consumer)}. * * @since 1.6 <|startfocus|> * <|endfocus|> */ public interface ISideEffectFactory { /** * @param sideEffectConsumer * {@link Consumer}, which is usually obtained by passing in an * {@link ICompositeSideEffect} * @return {@link ISideEffectFactory} * @see ICompositeSideEffect */ static ISideEffectFactory create(Consumer<ISideEffect> sideEffectConsumer) { return new SideEffectFactory(sideEffectConsumer); } /** * Creates a new {@link ISideEffect} on the default {@link Realm} but does * not run it immediately. Callers are responsible for invoking
<|startcomment|> Add a comment that the persistent property store is per view id <|endcomment|>  /** * Abstract class to manage information about a view for an XML analysis * * @author Jean-Christian Kouame * */ public abstract class AbstractXmlViewInfo { private final String fViewId; /** * Constructor * * @param viewId * The ID of the view */ public AbstractXmlViewInfo(String viewId) { fViewId = viewId; } /** <|startfocus|> * Get this view property section from the settings <|endfocus|> * * @return The property section */ protected IDialogSettings getPersistentPropertyStore() { IDialogSettings settings = Activator.getDefault().getDialogSettings(); IDialogSettings section = settings.getSection(fViewId); if (section == null) { section = settings.addNewSection(fViewId); if (section == null) { throw new IllegalStateException(); } } return section; } /** * Set the data for this view and retrieves from it the parameter the view needs * * @param data * A string of the form "param1" +
<|startcomment|> Right, I will change it. <|endcomment|> <|startfocus|> public ILaunchConfiguration getConfiguration() { <|endfocus|> return fConfiguration;
<|startcomment|> Better to use String.isEmpty()? <|endcomment|>  oldStructuredDocumentRegions); } catch (Exception ex) { Logger.logException(ex); this.refresh = true; handleRefresh(); } finally { setActive(null); } // checkForReinit(); return; } JSONModelNotifier notifier = getModelNotifier(); boolean isChanging = notifier.isChanging(); if (!isChanging) notifier.beginChanging(); JSONModelParser parser = getModelParser(); setActive(parser); try { /* workaround for https://bugs.eclipse.org/bugs/show_bug.cgi?id=486860 */ <|startfocus|> if(event.getDeletedText().equals("")) <|endfocus|> parser.replaceStructuredDocumentRegions( newStructuredDocumentRegions, oldStructuredDocumentRegions); else { this.refresh = true; handleRefresh(); } } catch (Exception ex) { if (ex.getClass().equals( StructuredDocumentRegionManagementException.class)) { Logger.traceException(TRACE_PARSER_MANAGEMENT_EXCEPTION, ex); } else { Logger.logException(ex); } this.refresh = true; handleRefresh(); } finally { setActive(null); if (!isChanging) { notifier.endChanging(); handleRefresh(); } } 
<|startcomment|> Maybe we should add a special case here for the singleton no-op side effect? That one will show up fairly often and it would never need to be part of a composite. <|endcomment|>  public void add(ISideEffect sideEffect) { <|startfocus|> sideEffects.add(sideEffect); <|endfocus|>
<|startcomment|> tralala <|endcomment|>  try { IMarker draftMarker = workspaceFile.createMarker("org.eclipse.egerrit.ui.commentMarker"); draftMarker.setAttribute(IMarker.LINE_NUMBER, element.getLine()); draftMarker.setAttribute(IMarker.MESSAGE, element.getMessage()); draftMarker.setAttribute("commentInfo", element); draftMarker.setAttribute("gerritClient", fGerritClient); draftMarker.setAttribute("isDraft", true); } catch (CoreException e) { logger.debug("Failed to create marker", e); //$NON-NLS-1$ <|startfocus|> } finally { i++; <|endfocus|> } } }
<|startcomment|> I have a trace where the trace name contains a string of a thread that I'm searching. Because of that it will find the string in each row. So, not useful when trying to find that particular thread. Maybe we should not search in the trace column because it's the same for all threads (per trace). What do you think? <|endcomment|>  public boolean matches(Pattern pattern) { if(pattern.matcher(getName()).find()) { return true; } if(pattern.matcher(Integer.toString(fThreadId)).find()) { return true; } if(pattern.matcher(Integer.toString(fParentThreadId)).find()) { return true; } if ( pattern.matcher(Utils.formatTime(getStartTime(), TimeFormat.CALENDAR, Resolution.NANOSEC)).find()) { return true; } <|startfocus|> if ( pattern.matcher(fTrace.getName()).find()) { <|endfocus|> return true; } // should be birthtime return pattern.matcher(Integer.toString(fThreadQuark)).find();
<|startcomment|> not needed <|endcomment|> <|startfocus|> protected void createMainControl(Composite parent, EEFTabbedPropertySheetPage tabbedPropertySheetPage) { EEFTabbedPropertySheetWidgetFactory widgetFactory = tabbedPropertySheetPage.getWidgetFactory(); <|endfocus|> widgetFactory.createLabel(parent, "", SWT.NONE); //$NON-NLS-1$ this.label = widgetFactory.createLabel(parent, ""); //$NON-NLS-1$ widgetFactory.createLabel(parent, "", SWT.NONE); //$NON-NLS-1$ widgetFactory.paintBordersFor(parent); GridData nameData = new GridData(GridData.FILL_HORIZONTAL); this.label.setLayoutData(nameData); this.controller = new EEFControllersFactory().createLabelController(this.description, this.variableManager, this.interpreter);
<|startcomment|> final <|endcomment|> <|startfocus|> public void createControls(Composite parent) { <|endfocus|> super.createControls(parent); this.treeViewer.setComparator(new ViewerComparator(new StringComparator()));// should always be string element
<|startcomment|> final <|endcomment|>  private static Group createGroup(final Composite parent, final String name) { <|startfocus|> Group group = new Group(parent, SWT.NONE); <|endfocus|> group.setText(name); GridLayout layout = new GridLayout(1, true); layout.marginHeight = 5; layout.marginWidth = 5; group.setLayout(layout); GridData data = new GridData(SWT.FILL, SWT.FILL, true, true); group.setLayoutData(data); return group;
<|startcomment|> final <|endcomment|>  } return false; } /** * This allows to check if this is a tree table. * * @param tableConfiguration The table configuration. * @return <code>true</code> if this is a tree table, <code>false</code> otherwise. */ public static final boolean isTreeTable(final TableConfiguration tableConfiguration) { <|startfocus|> TableDisplayStyle style = (TableDisplayStyle) tableConfiguration.getStyle(NattablestylePackage.eINSTANCE.getTableDisplayStyle()); if (style != null) { <|endfocus|> final DisplayStyle displayStyle = style.getDisplayStyle(); return DisplayStyle.HIERARCHIC_MULTI_TREE_COLUMN.equals(displayStyle) || DisplayStyle.HIERARCHIC_SINGLE_TREE_COLUMN.equals(displayStyle); } return false; } /** * This allows to check if the tree table contains a single column for the row header. * * @param tableConfiguration The table configuration. * @return <code>true</code> if this is a single column, <code>false</code> otherwise. */ public static final boolean isSingleColumnTreeTable(final TableConfiguration tableConfiguration) {
<|startcomment|> These lines are explicitly there to handle core.filemode==false situations. Before this change it was guaranteed that this lines are only executed when core.filemode==false. Now you changed the condition and these tests are also executed when core.filemode==true. It's not harmful because we know non if these if clauses become true. But to clarify this I suggest to make it explicit: if (!getOptions().isFileMode()) { ... these two if clauses } ... <|endcomment|>  switch (diff) { case DIFFER_BY_TIMESTAMP: if (forceContentCheck) // But we are told to look at content even though timestamps // tell us about modification return contentCheck(entry, reader); else // We are told to assume a modification if timestamps differs return true; case SMUDGED: // The file is clean by timestamps but the entry was smudged. // Lets do a content check return contentCheck(entry, reader); case EQUAL: <|startfocus|> if (mode == FileMode.SYMLINK.getBits()) { return contentCheck(entry, reader); } <|endfocus|> return false; case DIFFER_BY_METADATA: if (mode == FileMode.SYMLINK.getBits()) return contentCheck(entry, reader); return true; default: throw new IllegalStateException(MessageFormat.format( JGitText.get().unexpectedCompareResult, diff.name())); } } /** * Get the file mode to use for the current entry when it is to be updated * in the index. * * @param indexIter
<|startcomment|> an <|endcomment|>  list.add(defaultParent); } for (TimeGraphEntry entry : list) { buildStatusEvents(trace, (CriticalPathEntry) entry); } workerEntries.put(worker, list); } private @Nullable TmfGraph getGraph(final ITmfTrace trace) { CriticalPathModule module = Iterables.<@Nullable CriticalPathModule> getFirst( TmfTraceUtils.getAnalysisModulesOfClass(trace, CriticalPathModule.class), null); if (module == null) { <|startfocus|> throw new IllegalStateException("View requires a analysis module"); //$NON-NLS-1$ <|endfocus|> } module.schedule(); if (!module.waitForCompletion()) { return null; } final TmfGraph graph = module.getCriticalPath(); return graph; } public @Nullable List<ILinkEvent> getLinkList(long startTime, long endTime) { Object current = fCurrentObject; if (current == null) { return null; } /* * Critical path typically has relatively few links, so we calculate * and save them all, but just return those in range */ List<ILinkEvent> links = linkMap.get(current);
<|startcomment|> You will need to synchronize access to fListeners since you access it on the DSF executor here but on an another thread in the methods above. <|endcomment|> <|startfocus|> public void eventDispatched(IRegisterChangedDMEvent e) { for (IAddressInfoUpdateListener listener : fListeners) { listener.handleAddressInfoUpdate(EventType.VALUE_CHANGED, null); <|endfocus|> }
<|startcomment|> Should be "synchronized" too, like we do in other getInstance() methods <|endcomment|> <|startfocus|> public static IKernelAnalysisEventLayout getInstance() { IKernelAnalysisEventLayout inst = INSTANCE; <|endfocus|> if (inst == null) { inst = new DefaultEventLayout(); INSTANCE = inst; } return inst;
<|startcomment|> I think "throws Exception" is unnecessary <|endcomment|>  appContext.set(Realm.class, DisplayRealm.getRealm(d)); appContext.set(UISynchronize.class, new UISynchronize() { @Override public void syncExec(Runnable runnable) { d.syncExec(runnable); } @Override public void asyncExec(Runnable runnable) { d.asyncExec(runnable); } }); LogReaderService logReaderService = appContext.get(LogReaderService.class); logReaderService.addLogListener(listener); ems = appContext.get(EModelService.class); } @After <|startfocus|> public void tearDown() throws Exception { <|endfocus|> LogReaderService logReaderService = appContext.get(LogReaderService.class); logReaderService.removeLogListener(listener); if (wb != null) { wb.close(); } appContext.dispose(); } private boolean isPartOnTop(MContext context) { if (context.getContext() != null) { Object object = context.getContext().get(IWorkbench.ON_TOP); return Boolean.TRUE.equals(object); } return false; } @Test public void test_PartOnTop() { MApplication application = ems.createModelElement(MApplication.class); MWindow window = ems.createModelElement(MWindow.class);
<|startcomment|> since is not needed <|endcomment|>  private TreeLabelProvider fFilterLabelProvider; private int fAutoExpandLevel = ALL_LEVELS; /** The default column index for sorting */ private int fInitialSortColumn = 0; /** The default column index for sorting */ private int fCurrentSortColumn = 0; /** The current sort direction */ private int fSortDirection = SWT.DOWN; /** Flag to indicate to reveal selection */ private volatile boolean fIsRevealSelection = false; <|startfocus|> /** * Action for the find command * @since 2.0 */ <|endfocus|> private static final ShowFindDialogAction FIND_ACTION = new ShowFindDialogAction(); /** The fine action handler */ private static ActionHandler fFindActionHandler; /** * Define what to do when a part is activated * * @param part * The new active part * @since 2.0 */ public void partActivated(IWorkbenchPart part) { FIND_ACTION.partActivated(part); } // ------------------------------------------------------------------------ // Classes // ------------------------------------------------------------------------ private interface ITimeGraphWrapper { 
<|startcomment|> Not needed <|endcomment|>  length = docLen - offset; try { durty = new DirtyRegion(offset, length, type, doc.get(offset, length)); } catch (BadLocationException e) { String info = "dr: [" + offset + ":" + length + "] doc: [" + docLen + "] "; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ <|startfocus|> IStatus status= new Status(IStatus.ERROR, JavaScriptUI.ID_PLUGIN, IStatus.OK, info, e); //$NON-NLS-1$ <|endfocus|> JavaScriptPlugin.getDefault().getLog().log(status); } } return durty;
<|startcomment|> Why is the equals needed here? <|endcomment|>  public void setInstallLocation(File installLocation) { <|startfocus|> if (installLocation != null && !installLocation.equals(fInstallLocation)) { fInstallLocation= installLocation; } <|endfocus|>
<|startcomment|> Unnecessary blank line. <|endcomment|>  ******************************************************************************/ package org.eclipse.core.internal.databinding.observable.sideeffect; import java.util.ArrayList; import java.util.List; import java.util.function.Consumer; import org.eclipse.core.databinding.observable.ISideEffect; import org.eclipse.core.databinding.observable.Realm; import org.eclipse.core.databinding.observable.sideeffect.ICompositeSideEffect; import org.eclipse.core.runtime.Assert; /** * Implementation of the ICompositeSideEffect. * * @since 1.6 * */ public final class CompositeSideEffect implements ICompositeSideEffect { private List<ISideEffect> sideEffects; <|startfocus|> private int pauseCount; <|endfocus|> private boolean isDisposed; private Realm realm; /** * List of dispose listeners. Null if empty. */ private List<Consumer<ISideEffect>> disposeListeners; /** * Default constructor of an CompositeSideEffect. */ public CompositeSideEffect() { realm = Realm.getDefault(); sideEffects = new ArrayList<>(); } private void checkRealm() { Assert.isTrue(realm.isCurrent(), "This operation must be run within the observable's realm"); //$NON-NLS-1$ } @Override
<|startcomment|> Unnecessary blank line. <|endcomment|>  ******************************************************************************/ package org.eclipse.core.internal.databinding.observable.sideeffect; import java.util.function.Consumer; import java.util.function.Supplier; import org.eclipse.core.databinding.observable.ISideEffect; import org.eclipse.core.databinding.observable.Realm; import org.eclipse.core.databinding.observable.sideeffect.ISideEffectFactory; /** * A factory to create {@link ISideEffect} objects, which are applied to the * given {@link Consumer} in {@link ISideEffectFactory#createFactory(Consumer)}. * * @since 3.3 <|startfocus|> * <|endfocus|> */ public final class SideEffectFactory implements ISideEffectFactory { private Consumer<ISideEffect> sideEffectConsumer; /** * Creates a new factory which will pass all created side-effects to the * given {@link Consumer}. * * @param sideEffectConsumer * {@link Consumer}, where the {@link ISideEffect} objects, which * are created by this factory are passed to. */ public SideEffectFactory(Consumer<ISideEffect> sideEffectConsumer) { this.sideEffectConsumer = sideEffectConsumer; } @Override public ISideEffect createPaused(Runnable runnable) {
<|startcomment|> out of curiosity, why is this public? <|endcomment|> <|startfocus|> public void compile(ICompilationUnit[] sourceUnits, boolean lastRound) { <|endfocus|> this.stats.startTime = System.currentTimeMillis(); try { // build and record parsed units reportProgress(Messages.compilation_beginningToCompile); if (this.annotationProcessorManager == null) { beginToCompile(sourceUnits); } else { ICompilationUnit[] originalUnits = sourceUnits.clone(); // remember source units in case a source type collision occurs try { beginToCompile(sourceUnits); if (!lastRound) { processAnnotations(); } if (!this.options.generateClassFiles) { // -proc:only was set on the command line return; } } catch (SourceTypeCollisionException e) { backupAptProblems(); reset(); // a generated type was referenced before it was created // the compiler either created a MissingType or found a BinaryType for it // so add the processor's generated files & start over, // but remember to only pass the generated files to the annotation processor int originalLength = originalUnits.length;
<|startcomment|> Exchange <|endcomment|>  modelSetFixture.getPageManager().openPage(diagram); View diagramView = DiagramUtils.findShape(diagram, semanticElement); if (diagramView == null) { diagramView = DiagramUtils.findEdge(diagram, semanticElement); } if (diagramView == null) { Iterator<?> iterator = diagram.eAllContents(); while (null == diagramView && iterator.hasNext()) { Object object = iterator.next(); if (object instanceof View) { diagramView = DiagramUtils.findShape((View) object, semanticElement); <|startfocus|> if (diagramView == null) { <|endfocus|> diagramView = DiagramUtils.findEdge((View) object, semanticElement); } } } } assertNotNull(diagramView); IGraphicalEditPart semanticEP = DiagramUtils.findEditPartforView(modelSetFixture.getEditor(), diagramView, IGraphicalEditPart.class); assertNotNull(semanticEP); return semanticEP;
<|startcomment|> Likewise here. <|endcomment|>  Number num = value.numericalValue(); assertNotNull(num); assertEquals(expectedValue, num.longValue()); } protected void assertEvaluationEquals(IValue expectedValue) throws Exception { IValue value = getValue(); assertEquals(expectedValue, value); } protected void assertEvaluationEquals(String expectedValue) throws Exception { IValue value = getValue(); CStringValue cstrValue = (CStringValue) value; assertEquals(expectedValue, cstrValue.cStringValue()); } protected void assertEvaluationEquals(double expectedValue) throws Exception { <|startfocus|> IValue value = getValue(); <|endfocus|> FloatingPointValue floatingPointValue = (FloatingPointValue) value; assertEquals(expectedValue, floatingPointValue.numericalValue().doubleValue(), 0.001); } private IValue getValue() throws Exception { ICPPASTInitializerClause point = getPoint(); ICPPEvaluation evaluation = point.getEvaluation(); return evaluation.getValue(point); } protected ICPPASTInitializerClause getPoint() throws Exception { IASTTranslationUnit tu = strategy.getAst(0); IASTSimpleDeclaration declaration = (IASTSimpleDeclaration) tu.getChildren()[tu.getChildren().length - 1];
<|startcomment|> Indentation is off. <|endcomment|>  StringBuilder finalResult = new StringBuilder(rootMessage); IStatus[] statuses = getStatus().getChildren(); if (statuses != null) { for (int i=0; i < statuses.length; i++) { String childMessage = statuses[i].getMessage().trim(); // Avoid root message duplication if (!childMessage.equals(rootMessage)) { <|startfocus|> finalResult.append(CRLF).append(CRLF).append(i+1).append(PARENTHESES).append(childMessage); <|endfocus|> } } } detailComputed(null, finalResult.toString());
<|startcomment|> should be no need for a code comment here if the test method is named appropriately <|endcomment|>  String html = parseToHtml("======== This is not a title (7)"); assertEquals(html, "<p>======== This is not a title (7)</p>"); } public void testEqStyleHeaderNoTitleWith10eq() { String html = parseToHtml("=========== This is not a title (10)"); assertEquals(html, "<p>=========== This is not a title (10)</p>"); } /* * equals-style headers with phrase modifiers */ @Test <|startfocus|> public void testEqStyleHeaderLevel2WithItalic() { <|endfocus|> //Bug 492301 String text = "=== This _is_ true!"; String html = parseToHtml(text.toString()); assertEquals("<h3>This <em>is</em> true!</h3>", html); } @Test public void testEqStyleHeaderLevel3WithCode() { //Bug 492301 String text = "==== The `HelloWorld` class"; String html = parseToHtml(text.toString()); assertEquals("<h4>The <code>HelloWorld</code> class</h4>", html); } /*
<|startcomment|> It needs to be possible to cancel the blocking call when system call analysis is cancelled. Otherwise the the current thread is dependent on the KernelTidAspect to return and this might not happen due to some error. To do that you need a cancel method to the KernelTidAspect. This would require that the KernelTidAspect is not a singleton anymore because the resolve could be technically called from several threads. <|endcomment|>  super.handleData(event); IKernelAnalysisEventLayout layout = fLayout; if (layout == null) { IKernelTrace trace = (IKernelTrace) event.getTrace(); layout = trace.getKernelEventLayout(); fLayout = layout; } final String eventName = event.getType().getName(); if (eventName.startsWith(layout.eventSyscallEntryPrefix()) || eventName.startsWith(layout.eventCompatSyscallEntryPrefix())) { /* This is a system call entry event */ <|startfocus|> Integer tid = KernelTidAspect.INSTANCE.resolve(event, true); <|endfocus|> if (tid == null) { // no information on this event/trace ? return; } /* Record the event's data into the intial system call info */ // String syscallName = fLayout.getSyscallNameFromEvent(event); long startTime = event.getTimestamp().getValue(); String syscallName = eventName.substring(layout.eventSyscallEntryPrefix().length()); Map<String, String> args = event.getContent().getFieldNames().stream() .collect(Collectors.toMap(Function.identity(),
<|startcomment|> When we reply "Done", should we start the sentence with an upper case letter as "Done" and not "done" ? Also, If I have a typo, I cannot re-select the dialog to fix it, I need to use the comment edition from the compare editor <|endcomment|>  * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ericsson - initial API and implementation *******************************************************************************/ package org.eclipse.egerrit.ui.editors; public class MarkerAttributes { public static String COMMENT_INFO = "commentInfo"; //$NON-NLS-1$ public static String FILE_INFO = "fileInfo"; //$NON-NLS-1$ public static String GERRIT_CLIENT = "gerritClient"; //$NON-NLS-1$ <|startfocus|> public static String IS_DRAFT = "isDraft"; <|endfocus|> public static String MESSAGE = "message"; //$NON-NLS-1$ } 
<|startcomment|> @Nullable ? <|endcomment|>  /** * @return true if the request is still active */ boolean isRunning(); /** * @return true if the request is completed */ boolean isCompleted(); /** * @return true if the request has failed */ boolean isFailed(); /** * @return true if the request was cancelled */ boolean isCancelled(); /** * @return get the cause of failure, or null * @since 2.0 */ <|startfocus|> Throwable getFailCause(); <|endfocus|> // ------------------------------------------------------------------------ // Data handling // ------------------------------------------------------------------------ /** * Process the piece of data * * @param event * The trace event to process */ void handleData(@NonNull ITmfEvent event); // ------------------------------------------------------------------------ // Request notifications // ------------------------------------------------------------------------ /** * Request processing start notification */ void handleStarted(); /** * Request processing completion notification */ void handleCompleted(); /** * Request successful completion notification */ void handleSuccess(); /**
<|startcomment|> why is a disk a string? and javadoc/author <|endcomment|> ***************************************************************************** * Copyright (c) 2016 EfficiOS Inc., Philippe Proulx * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.provisional.analysis.lami.core.types; <|startfocus|> <|endfocus|> class LamiDisk extends LamiString { public LamiDisk(String value) { super(value); } } 
<|startcomment|> Update comment to reflect the fact that the function now returns IValue. <|endcomment|>  if (isInvalidValue(val)) return IntegralValue.UNKNOWN; return val; } public static IValue evaluateBinaryTypeIdExpression(IASTBinaryTypeIdExpression.Operator operator, IType type1, IType type2, IASTNode point) { IValue val = applyBinaryTypeIdOperator(operator, type1, type2, point); if (isInvalidValue(val)) return IntegralValue.UNKNOWN; return val; } /** * Computes the canonical representation of the value of the expression. <|startfocus|> * Returns a {@code Number} for numerical values or {@code null}, otherwise. * @throws UnknownValueException <|endfocus|> */ private static IValue evaluate(IASTExpression exp) { if (exp == null) return IntegralValue.UNKNOWN; if (exp instanceof IASTArraySubscriptExpression) { return IntegralValue.UNKNOWN; } if (exp instanceof IASTBinaryExpression) { return evaluateBinaryExpression((IASTBinaryExpression) exp); } if (exp instanceof IASTCastExpression) { // must be ahead of unary return evaluate(((IASTCastExpression) exp).getOperand()); } if (exp instanceof IASTUnaryExpression) { return evaluateUnaryExpression((IASTUnaryExpression) exp); }
<|startcomment|> is Process capitalized or not? be consistent. <|endcomment|>  * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.provisional.analysis.lami.core.aspect; import java.util.Comparator; import org.eclipse.jdt.annotation.Nullable; import org.eclipse.tracecompass.internal.provisional.analysis.lami.core.module.LamiTableEntry; import org.eclipse.tracecompass.internal.provisional.analysis.lami.core.types.LamiData; import org.eclipse.tracecompass.internal.provisional.analysis.lami.core.types.LamiProcess; /** <|startfocus|> * Aspect for Process names <|endfocus|> * * @author Philippe Proulx */ public class LamiProcessNameAspect extends LamiTableEntryAspect { private final int fColIndex; /** * Constructor * * @param colName * Column name * @param colIndex * Column index */ public LamiProcessNameAspect(String colName, int colIndex) { super(colName + " (" + Messages.LamiAspect_Name +')', null); //$NON-NLS-1$ fColIndex = colIndex; } @Override public boolean isContinuous() { return false; } @Override
<|startcomment|> This is provisional. It needs javadoc. <|endcomment|>  * Copyright (c) 2015 EfficiOS Inc., Alexandre Montplaisir * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.provisional.analysis.lami.core.types; import static org.eclipse.tracecompass.common.core.NonNullUtils.nullToEmptyString; import org.eclipse.jdt.annotation.Nullable; class LamiBoolean extends LamiData { <|startfocus|> <|endfocus|> private final boolean fValue; public LamiBoolean(boolean value) { fValue = value; } public boolean getValue() { return fValue; } @Override public @Nullable String toString() { return (fValue ? nullToEmptyString(Messages.LamiBoolean_Yes) : nullToEmptyString(Messages.LamiBoolean_No)); } } 
<|startcomment|> 20116 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2015 EfficiOS Inc., Alexandre Montplaisir <|endfocus|> * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.provisional.analysis.lami.ui.views; import static org.eclipse.tracecompass.common.core.NonNullUtils.checkNotNull; import static org.eclipse.tracecompass.common.core.NonNullUtils.nullToEmptyString; import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Set; import java.util.function.Predicate; import java.util.stream.Collectors; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable; import org.eclipse.jface.action.Action; import org.eclipse.jface.action.IAction; import org.eclipse.jface.action.IMenuManager; import org.eclipse.jface.action.IToolBarManager; import org.eclipse.jface.action.Separator; import org.eclipse.jface.viewers.ArrayContentProvider;
<|startcomment|> "may always" is a superposition of quantic states. It either always has a parent, or may have a parent... <|endcomment|>  * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.provisional.analysis.lami.core.types; /** * Lami 'disk partition' value. * <|startfocus|> * A disk partition can be "sda2". It may always has a parent disk. <|endfocus|> * * @author Philippe Proulx */ class LamiDiskPartition extends LamiString { public LamiDiskPartition(String value) { super(value); } } 
<|startcomment|> of the X axis <|endcomment|>  * * @return The aspects for the Y axis */ protected List<LamiTableEntryAspect> getYAxisAspects() { List<LamiTableEntryAspect> yAxisAspects = new ArrayList<>(); for (String colName : getChartModel().getYSeriesColumns()) { yAxisAspects.add(checkNotNull(getAspectFromName(getResultTable().getTableClass().getAspects(), colName))); } return yAxisAspects; } /** <|startfocus|> * Get a list of all the aspect of the Y axis. <|endfocus|> * * @return The aspects for the Y axis */ protected List<LamiTableEntryAspect> getXAxisAspects() { List<LamiTableEntryAspect> xAxisAspects = new ArrayList<>(); for (String colName : getChartModel().getXSeriesColumns()) { xAxisAspects.add(checkNotNull(getAspectFromName(getResultTable().getTableClass().getAspects(), colName))); } return xAxisAspects; } /** * Set the ITitle object text to a substring of canonicalTitle that when * rendered in the chart will fit maxPixelLength.
<|startcomment|> Please avoid calling findImplicitlyCalledConstructor() twice (once in hasImplicitlyCalledCtor(), and once here). It's an expensive operation. <|endcomment|>  public ICPPEvaluation getInitializerEvaluation() { ICPPASTDeclarator declarator = (ICPPASTDeclarator)findDeclarator(); if(declarator != null) { IASTInitializer initializer = declarator.getInitializer(); <|startfocus|> if(hasImplicitlyCalledCtor(declarator)) { ICPPConstructor constructor = (ICPPConstructor)CPPSemantics.findImplicitlyCalledConstructor(declarator); <|endfocus|> ICPPEvaluation[] arguments = EvalConstructor.extractArguments(initializer, constructor); return new EvalConstructor(getType(), constructor, arguments, declarator); } else if(initializer instanceof IASTEqualsInitializer) { IASTEqualsInitializer equalsInitializer = (IASTEqualsInitializer)initializer; ICPPEvaluationOwner evalOwner = (ICPPEvaluationOwner)equalsInitializer.getInitializerClause(); return evalOwner.getEvaluation(); } else if(initializer instanceof ICPPASTInitializerList) { ICPPEvaluationOwner evalOwner = (ICPPEvaluationOwner)initializer; return evalOwner.getEvaluation(); } else if(initializer instanceof ICPPASTConstructorInitializer) { ICPPASTConstructorInitializer ctorInitializer = (ICPPASTConstructorInitializer)initializer; ICPPEvaluationOwner evalOwner = (ICPPEvaluationOwner)ctorInitializer.getArguments()[0]; return evalOwner.getEvaluation(); } else if(initializer == null) { return null; } } return EvalFixed.INCOMPLETE;
<|startcomment|> Why catch Throwable and not just ResourceException? <|endcomment|>  try { IMarker marker = getResource().createMarker(ID_MARKER_LANDMARK); if (marker != null && range != null) { marker.setAttribute(IMarker.CHAR_START, range.getOffset()); marker.setAttribute(IMarker.CHAR_END, range.getOffset() + range.getLength()); marker.setAttribute(IMarker.MESSAGE, Messages.LandmarkMarkerManager_Mylyn_Landmark); marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_INFO); markerMap.put(node, marker.getId()); } <|startfocus|> } catch (Throwable t) { <|endfocus|> StatusHandler.log(new Status(IStatus.ERROR, JavaUiBridgePlugin.ID_PLUGIN, "Could not create add landmark markers", t)); //$NON-NLS-1$ } } }; return runnable; } } catch (JavaModelException e) { StatusHandler .log(new Status(IStatus.ERROR, JavaUiBridgePlugin.ID_PLUGIN, "Could not update marker", e)); //$NON-NLS-1$ } } } return null;
<|startcomment|> // ------------------------------- // Listeners // ------------------------------- <|endcomment|>  /* * Generate initial array of Color to enable per point color change * on selection in the future */ ArrayList<Color> colors = new ArrayList<>(); for (int i = 0; i < series.getXSeries().length; i++) { Color color = ((ILineSeries) series).getSymbolColor(); colors.add(checkNotNull(color)); } ((ILineSeries) series).setSymbolColors(colors.toArray(new Color[colors.size()])); } } <|startfocus|> /** * Listeners */ <|endfocus|> private final class HoveringCrossListener implements MouseMoveListener { @Override public void mouseMove(@Nullable MouseEvent e) { if (e == null) { return; } ISeries[] series = getChart().getSeriesSet().getSeries(); @Nullable Point closest = null; double closestDistance = -1.0; for (ISeries oneSeries : series) { ILineSeries lineSerie = (ILineSeries) oneSeries; for (int i = 0; i < lineSerie.getXSeries().length; i++) { Point dataPoint = lineSerie.getPixelCoordinates(i); 
<|startcomment|> Add a comment saying why this is 1 (because the first argument is the function's evaluation). <|endcomment|>  public static ActivationRecord createActivationRecord(ICPPParameter[] parameters, ICPPEvaluation[] arguments, ICPPEvaluation implicitThis, IASTNode point) { <|startfocus|> ActivationRecord record = new ActivationRecord(parameters, implicitThis); <|endfocus|> int j = 1; for(ICPPParameter param : parameters) { if (param.isParameterPack() || isSpecializedParameterPack(param)) { // The parameter pack consumes all remaining arguments. int paramPackLen = arguments.length - j; ICPPEvaluation[] values = new ICPPEvaluation[paramPackLen]; IType[] types = new IType[paramPackLen]; for(int i = 0; i < paramPackLen; i++) { ICPPEvaluation arg = arguments[j+i]; values[i] = arg; types[i] = arg.getType(null); } IValue paramPackValue = new CompositeValue(null, values); IType paramPackType = new ParameterPackType(types); EvalFixed paramPack = new EvalFixed(paramPackType, ValueCategory.PRVALUE, paramPackValue); record.update(param, paramPack); break; } else { if (j < arguments.length) { ICPPEvaluation argument = maybeApplyConversion(arguments[j++], param.getType(), point);
<|startcomment|> null -> context.getPoint() <|endcomment|>  public static IValue getConditionDeclValue(ExecSimpleDeclaration conditionDeclExec, ActivationRecord record, ConstexprEvaluationContext context) { ICPPBinding declaredBinding = ((ExecDeclarator)conditionDeclExec.getDeclaratorExecutions()[0]).getDeclaredBinding(); conditionDeclExec.executeForFunctionCall(record, context.recordStep()); <|startfocus|> return record.getVariable(declaredBinding).computeForFunctionCall(record, context).getValue(null); <|endfocus|>
<|startcomment|> getStructuredItemContentProviderElements to respect the pattern <|endcomment|>  return getAdapter(self, IStructuredItemContentProvider.class); } public List<?> getStructuredItemContentProviderElements(EObject self) { IStructuredItemContentProvider scp = getStructuredItemContentProvider(self); if (scp != null) { return new ArrayList<>(scp.getElements(self)); } else { return null; } } // Services from ITreeItemContentProvider public ITreeItemContentProvider getTreeContentProvider(EObject self) { return getAdapter(self, ITreeItemContentProvider.class); } <|startfocus|> public List<?> getTreeContentProviderChildren(EObject self) { <|endfocus|> ITreeItemContentProvider tp = getTreeContentProvider(self); if (tp != null) { return new ArrayList<>(tp.getChildren(self)); } else { return null; } } public boolean hasTreeContentProviderChildren(EObject self) { ITreeItemContentProvider tp = getTreeContentProvider(self); if (tp != null) { return tp.hasChildren(self); } else { return false; } } public Object getTreeContentProviderParent(EObject self) { ITreeItemContentProvider tp = getTreeContentProvider(self); if (tp != null) { return tp.getParent(self);
<|startcomment|> no longer accurate, maybe 'don't display unit'? <|endcomment|>  fChart.getAxisSet().getXAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); fChart.getAxisSet().getYAxis(0).getTick().setForeground(Display.getDefault().getSystemColor(SWT.COLOR_BLACK)); /* Set X label 90 degrees */ fChart.getAxisSet().getXAxis(0).getTick().setTickLabelAngle(90); /* Refresh the titles to fit the current chart size */ refreshDisplayTitles(); <|startfocus|> fToolBar = createChartToolBar(); <|endfocus|> fChart.addDisposeListener(e -> { /* Dispose resources of this class */ LamiXYChartViewer.super.dispose(); });
<|startcomment|> Suggest we follow the *InPixel method approach here too: - Rename current method to getPathDataInPixels() - Create a new method getPathData() which will perform the AutoScaleDown operation <|endcomment|> public PathData getPathData() { <|startfocus|> if (isDisposed()) SWT.error(SWT.ERROR_GRAPHIC_DISPOSED); <|endfocus|> long /*int*/ copy = Cairo.cairo_copy_path(handle); if (copy == 0) SWT.error(SWT.ERROR_NO_HANDLES); cairo_path_t path = new cairo_path_t(); Cairo.memmove(path, copy, cairo_path_t.sizeof); byte[] types = new byte[path.num_data]; float[] pts = new float[path.num_data * 6]; int typeIndex = 0, ptsIndex = 0; if (path.num_data > 0) { int i = 0; double[] points = new double[6]; cairo_path_data_t data = new cairo_path_data_t(); while (i < path.num_data) { long /*int*/ offset = path.data + i * cairo_path_data_t.sizeof; Cairo.memmove(data, offset, cairo_path_data_t.sizeof); switch (data.type) { case Cairo.CAIRO_PATH_MOVE_TO: types[typeIndex++] = SWT.PATH_MOVE_TO;
<|startcomment|> You have the Folder, so you also have the URI: EcoreUtil.getURI(folder) <|endcomment|>  createHeaderContents(self); Label label = new Label(self, SWT.NONE); label.setText("New Child:"); CreationMenuRegistry creationMenuInstance = CreationMenuRegistry.getInstance(); List<Folder> rootFolders = creationMenuInstance.getRootFolder(); for (Folder folder : rootFolders) { boolean applied = folder.isVisible(); Button checkbox = new Button(self, SWT.CHECK); <|startfocus|> String folderId = creationMenuInstance.getFolderId(folder); String name = folderId.substring(0, folderId.indexOf("."));//$NON-NLS-1$ checkbox.setText(name); checkbox.setToolTipText(folderId); <|endfocus|> checkbox.setSelection(applied); final Folder theFolder = folder; checkbox.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { boolean applied = ((Button) e.widget).getSelection(); folders.put(theFolder, applied); } }); checkboxes.put(folder, checkbox); } createFooterContents(self); return null;
<|startcomment|> Could you please fix 'Line is longer than 80 charachters' problem? There are some places to format? <|endcomment|>  public void rcClickIncrement(final Integer count, final int mouseButton) { <|startfocus|> final BasicArrowButton incrementButton = findArrowButton("Spinner.nextButton"); <|endfocus|> getRobot().click(incrementButton, null, ClickOptions.create().setClickCount(count).setMouseButton(mouseButton), 50, false, 50, false);
<|startcomment|> There should be a space after the comma. <|endcomment|>  public void test_getMaximum() { spinner.setMaximum(1000); assertEquals(spinner.getMaximum(),1000); spinner.setMinimum(100); spinner.setMaximum(99); <|startfocus|> assertEquals(spinner.getMaximum(),1000); <|endfocus|>
<|startcomment|> Don't call cancel, just return <|endcomment|>  try { if (validateURL(monitor)) { completeURLValidation(validConnection(monitor)); } else { if (!ok.isDisposed()) { Utils.displayInformation(null, DIALOG_TITLE, INVALID_MESSAGE); } } } catch (URISyntaxException e) { setProgress(monitor, 100); if (!ok.isDisposed()) { //The dialogue is still present, so job is still running Utils.displayInformation(shell, DIALOG_TITLE, e.getLocalizedMessage()); } <|startfocus|> this.cancel(); <|endfocus|> } catch (EGerritException e) { setProgress(monitor, 100); if (!ok.isDisposed()) { //The dialogue is still present, so job is still running Utils.displayInformation(shell, DIALOG_TITLE, e.getLocalizedMessage()); } this.cancel(); } return Status.OK_STATUS;
<|startcomment|> Done <|endcomment|>  protected IStatus run(IProgressMonitor monitor) { // Set total number of work units monitor.beginTask(Messages.GerritServerDialog_30, 100); <|startfocus|> try { <|endfocus|> if (validateURL(monitor)) { completeURLValidation(validConnection(monitor)); } else { if (!ok.isDisposed()) { Utils.displayInformation(null, DIALOG_TITLE, INVALID_MESSAGE); } } } catch (URISyntaxException e) { setProgress(monitor, 100); if (!ok.isDisposed()) { //The dialogue is still present, so job is still running Utils.displayInformation(shell, DIALOG_TITLE, e.getLocalizedMessage()); } this.cancel(); } catch (EGerritException e) { setProgress(monitor, 100); if (!ok.isDisposed()) { //The dialogue is still present, so job is still running Utils.displayInformation(shell, DIALOG_TITLE, e.getLocalizedMessage()); } this.cancel(); } return Status.OK_STATUS;
<|startcomment|> excludedEvents <|endcomment|>  * @param isKernel * - true if kernel domain else false * @param filterExpression * - a filter expression * @param excludeEvents * - list of events to exclude * @param monitor * - a progress monitor * @throws ExecutionException * If the command fails for some reason */ <|startfocus|> public abstract void enableEvents(CommandParameter param, List<String> eventNames, boolean isKernel, String filterExpression, List<String> excludeEvents, IProgressMonitor monitor) throws ExecutionException; <|endfocus|> /** * Enables all syscall events. * * @param param * - a parameter instance with data for the command execution * @param monitor * - a progress monitor * @throws ExecutionException * If the command fails for some reason */ public abstract void enableSyscalls(CommandParameter param, IProgressMonitor monitor) throws ExecutionException; /** * Enables a dynamic probe. * * @param param * - a parameter instance with data for the command execution * @param eventName
<|startcomment|> Same here, why using ArrayList<>? <|endcomment|> <|startfocus|> public static ArrayList<State> getStates(Region region) { ArrayList<State> states = new ArrayList<>(); <|endfocus|> for (Vertex vertex : region.getSubvertices()) { if (vertex instanceof State) { states.add((State) vertex); } } return states;
<|startcomment|> Please add a parameter to the ArrayList instance <|endcomment|>  public Collection<Profile> getWorkspaceProfiles() { <|startfocus|> Collection<Profile> profiles = new ArrayList<>(); <|endfocus|> try { profiles = index.getIndex().get().values(); } catch (InterruptedException | ExecutionException e) { Activator.log.error(e); } return profiles;
<|startcomment|> This must be done before super.teadDown() as it clean all variables (included oldFont that will be set to null). <|endcomment|>  * */ public class CompartmentsCreationTest extends AbstractCompartmentTest { private String oldFont; /** * {@inheritDoc} */ @Override protected void onSetUpAfterOpeningDesignerPerspective() throws Exception { super.onSetUpAfterOpeningDesignerPerspective(); oldFont = changeDefaultFontName("Comic Sans MS"); } /** * {@inheritDoc} */ @Override protected void tearDown() throws Exception { super.tearDown(); if (oldFont != null) { changeDefaultFontName(oldFont); <|startfocus|> } <|endfocus|> } /** * Ensures that containers displays correctly its children in a horizontal * stack. */ public void testChildrenPresentationsInHorizontalStack() { childrenPresentationTest(HORIZONTAL_STACK_REPRESENTATION_NAME, HORIZONTAL_STACK_REPRESENTATION_INSTANCE_NAME, ContainerLayout.HORIZONTAL_STACK); } /** * Ensures that containers displays correctly its children in a vertical * stack. */ public void testChildrenPresentationsInVerticalStack() { childrenPresentationTest(VERTICAL_STACK_REPRESENTATION_NAME, VERTICAL_STACK_REPRESENTATION_INSTANCE_NAME, ContainerLayout.VERTICAL_STACK); } 
<|startcomment|> The other query in Sirius are not singleton classes. The DView parameter in getLoadedRepresentations should be given in the constructor "new DViewQuery(dView).getLoadedRepresentations()". <|endcomment|>  * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.business.api.query; import java.util.List; import org.eclipse.sirius.viewpoint.DRepresentation; import org.eclipse.sirius.viewpoint.DRepresentationDescriptor; import org.eclipse.sirius.viewpoint.DView; import com.google.common.collect.Lists; /** * A class aggregating all the queries (read-only!) having a {@link DView} as a * starting point. * * @author lfasani */ public final class DViewQuery { <|startfocus|> private DViewQuery() { <|endfocus|> } /** * Get the {@link DRepresentation}s which are already loaded in the dView * resourceSet. * * @param dView * the {@link DView} to query. * @return the loaded {@link DRepresentation}s */ public static List<DRepresentation> getLoadedRepresentations(DView dView) { List<DRepresentation> representations = Lists.newArrayList(); for (DRepresentationDescriptor repDescriptor : dView.getOwnedRepresentationDescriptors()) { DRepresentation representation = repDescriptor.getRepresentation(); if (representation != null) {
<|startcomment|> I think you meant to put an else statement here. Also, this patch has introduced a new issue. :( Scrolling a tree manually doesn't update the topItem anymore. If you use this snippet: https://github.com/ericwill/SWT-snippets/blob/b254fcddfd8d0bc447e453d70f368a493ca8af11/src/testsnippets/Bug495909_topItemTree.java It has some corner cases. Scrolling should print the topItem for every scroll event. In this case it stays the same value as the last topItem set. <|endcomment|>  } } else { if (topItem == null) { // if topItem isn't set and there is nothing selected, topItem is the first item on the Tree TreeItem item = null; long /*int*/ iter = OS.g_malloc (OS.GtkTreeIter_sizeof()); if (OS.gtk_tree_model_get_iter_first (modelHandle, iter)) { item = _getItem (iter); } OS.g_free (iter); return item; } else { return topItem; } } <|startfocus|> } <|endfocus|> // Use GTK method to get topItem if there has been changes to the vAdjustment long /*int*/ [] path = new long /*int*/ [1]; OS.gtk_widget_realize (handle); if (!OS.gtk_tree_view_get_path_at_pos (handle, 1, 1, path, null, null, null)) return null; if (path [0] == 0) return null; TreeItem item = null; long /*int*/ iter = OS.g_malloc (OS.GtkTreeIter_sizeof());
<|startcomment|> What is a marker on a pattern level? On one hand, I don't know what it might mean; on the other hand, markers are often used to represent error markers in the user interface... <|endcomment|>  public static final String TRANSITIVE_CLOSURE_ONLY_IN_POSITIVE_COMPOSITION = "Transitive closure of %s is currently only allowed in simple positive pattern calls (no negation or aggregation)."; public static final String UNUSED_PRIVATE_PATTERN_MESSAGE = "The pattern '%s' is never used locally."; public static final String RECURSIVE_PATTERN_CALL = "Recursive pattern call: %s"; <|startfocus|> public static final String INVALID_MARKER_MESSAGE = "Marker can only be used in min or sum aggregator context."; <|endfocus|> @Inject private PatternAnnotationProvider annotationProvider; @Inject private IJvmModelAssociations associations; @Inject private ITypeSystem typeSystem; @Inject private ITypeInferrer typeInferrer; @Inject private IBatchTypeResolver typeResolver; @Inject private IResourceScopeCache cache; @Inject private LiveShadowedResourceDescriptions resourceDescriptions; @Inject private IQualifiedNameProvider nameProvider; @Inject private IContainer.Manager containerManager; @Inject private IExpectedPackageNameProvider packageNameProvider; @Check public void checkValueReference(VariableValue value) { if (value.isMarked()) { EObject current = value; boolean rightContext = false; 
<|startcomment|> distro <|endcomment|>  * Created on May 20, 2016 * <|startfocus|> * PLACE_YOUR_DISTRIBUTION_STATEMENT_RIGHT_HERE */ <|endfocus|> package org.eclipse.osee.orcs.core.internal.tuple; import org.eclipse.osee.framework.core.data.BranchId; import org.eclipse.osee.framework.jdk.core.type.OseeCoreException; import org.eclipse.osee.orcs.core.ds.TupleData; import org.eclipse.osee.orcs.core.ds.TupleDataFactory; public class TupleFactory { private final TupleDataFactory tupleDataFactory; public TupleFactory(TupleDataFactory tupleDataFactory) { this.tupleDataFactory = tupleDataFactory; } public TupleData createTuple2(Long tupleTypeId, BranchId branch, Long e1, Long e2) throws OseeCoreException { return tupleDataFactory.createTuple2Data(tupleTypeId, branch, e1, e2); } public TupleData createTuple3(Long tupleTypeId, BranchId branch, Long e1, Long e2, Long e3) throws OseeCoreException { return tupleDataFactory.createTuple3Data(tupleTypeId, branch, e1, e2, e3); } 
<|startcomment|> when is it different ? same question below <|endcomment|>  * @param root * the path to the LFS directory. Most of the times this will be * "<repo>/.git/lfs" */ public LfsUtil(Path root) { this.root = root; } /** * @return the path to the LFS directory */ public Path getLfsRoot() { return root; } /** <|startfocus|> * @return the path to the temp directory used by LFS. Most of the times * this will be "<repo>/.git/lfs/tmp" <|endfocus|> */ public Path getLfsTmpDir() { if (tmpDir == null) { tmpDir = root.resolve("tmp"); } return tmpDir; } /** * @return the path to the object directory used by LFS. Most of the times * this will be "<repo>/.git/lfs/objects" */ public Path getLfsObjDir() { if (objDir == null) { objDir = root.resolve("objects"); } return objDir; } /** * @param id
<|startcomment|> Is there a special reason for not combining this with another OR with the above if statement? <|endcomment|>  public void handleLifecycleEvent(SaveablesLifecycleEvent event) { if (currentPart == null || event.getEventType() != SaveablesLifecycleEvent.DIRTY_CHANGED) { return; } Saveable[] saveables = event.getSaveables(); for (Saveable saveable : saveables) { if (new DefaultSaveable(PropertySheet.this).equals(saveable)) { return; } <|startfocus|> } <|endfocus|> if (event.getSource() instanceof SaveablesList) { SaveablesList saveablesList = (SaveablesList) event.getSource(); for (Saveable saveable : saveables) { IWorkbenchPart[] parts = saveablesList.getPartsForSaveable(saveable); for (IWorkbenchPart part : parts) { if (PropertySheet.this.currentPart == part) { firePropertyChange(IWorkbenchPartConstants.PROP_DIRTY); return; } } } }
<|startcomment|> "null" must be first <|endcomment|>  commit(); } }); } }; timer.schedule(currentValidateTask, delay); } if (targetValidator != null) { IStatus status = targetValidator.validate(text.getText()); updateStatus(status); } if (modelValidator != null) { IStatus status = modelValidator.validate(text.getText()); updateStatus(status); if (binding == null) { update(); } } <|startfocus|> if (modelProperty != null) { // Bug 433169: The widget may be used without an Observable Value (setValue + getValue) if (modelProperty.getValue() != null) { <|endfocus|> if (!isReadOnly() && !modelProperty.getValue().toString().equals(text.getText())) { text.setBackground(EDIT); } else { text.setBackground(DEFAULT); } } else { if (text.getText().equals("")) { text.setBackground(DEFAULT); } else { text.setBackground(EDIT); } } }
<|startcomment|> to delete <|endcomment|> import org.eclipse.papyrus.infra.emf.types.advices.values.SetValuesAdviceFactory; import org.eclipse.papyrus.infra.emf.types.advices.values.SetValuesAdvicePackage; import org.eclipse.papyrus.infra.widgets.editors.MultipleReferenceEditor; import org.eclipse.swt.widgets.Composite; /** * A {@link MultipleReferenceEditor} for {@link StereotypeToApply}. */ public class FeaturesToSetMultipleEditor extends AbstractCustomMultipleEditor { /** * Constructor. */ public FeaturesToSetMultipleEditor(final Composite parent, final int style) { super(parent, style); } /** <|startfocus|> * <br> <|endfocus|> * {@inheritDoc} * * @see org.eclipse.papyrus.infra.widgets.editors.MultipleValueEditor#addAction() */ @Override protected void addAction() { // The feature EReference feature = SetValuesAdvicePackage.eINSTANCE.getSetValuesAdviceConfiguration_FeaturesToSet(); // The container EObject container = (EObject) getContextElement(); FeatureToSet newObject = SetValuesAdviceFactory.eINSTANCE.createFeatureToSet(); // Execute the add addNewObject(feature, container, newObject); // Refresh getViewer().refresh(); // Select new object
<|startcomment|> remove duplicate author <|endcomment|> ***************************************************************************** * Copyright (c) 2016 Boeing. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Boeing - initial API and implementation *******************************************************************************/ package org.eclipse.osee.orcs.search; import java.util.function.BiConsumer; <|startfocus|> /** * @author Angel Avila */ <|endfocus|> import org.eclipse.osee.framework.core.data.BranchId; import org.eclipse.osee.framework.core.data.Tuple2Type; /** * @author Angel Avila */ public interface TupleQuery { <E1, E2> Iterable<E2> getTuple2(Tuple2Type<E1, E2> tupleType, BranchId branchId, E1 e1); <E1, E2> Iterable<Long> getTuple2Raw(Tuple2Type<E1, E2> tupleType, BranchId branchId, E1 e1); 
<|startcomment|> static import <|endcomment|>  context.set(Bundle.class, bundle); context.set(IDEWorkflow.CTX_BUNDLE_STATE_LOCATION, Platform.getStateLocation(bundle)); context.set(ILogEventsQueue.class, IIdeFactory.eINSTANCE.createLogEventsQueue()); context.set(LogListener.class.getName(), new LogListenerCreationFunction()); LogListener listener = context.get(LogListener.class); Platform.addLogListener(listener); final IEventBroker broker = context.get(IEventBroker.class); context.set(CTX_SERVERS, new SettingsPersistingRegistryServersCreationFunction()); <|startfocus|> context.set(IDEWorkflow.CTX_NEEDINFO_PROVIDERS, new ExtenstionPointNeedinfoProvidersCreationFunction()); <|endfocus|> context.set(MylynNotificationsSupport.class, make(MylynNotificationsSupport.class, context)); context.set(UploadReportsScheduler.class, new UploadReportsScheduler() { @Override public void send(ILogEventGroup group, IProgressMonitor monitor) { super.send(group, monitor); broker.post(IDEWorkflow.TOPIC_NEW_SERVER_RESPONSES, group); } }); context.set(IDEWorkflow.class, ContextInjectionFactory.make(IDEWorkflow.class, context)); IDEWorkflow workflow = context.get(IDEWorkflow.class); context.set(ImageRegistry.class.getName(), new ImageRegistryCreationFunction()); context.set(ReviewDialog.class.getName(), new ReviewDialogCreationFunction()); 
<|startcomment|> We put Ericsson instead of the individual name <|endcomment|> ***************************************************************************** * Copyright (c) 2016 Ericsson * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: <|startfocus|> * Marc Khouzam - Initial API and implementation <|endfocus|> *******************************************************************************/ package org.eclipse.egerrit.internal.core.command; import org.apache.http.client.methods.HttpGet; import org.eclipse.egerrit.internal.core.GerritRepository; import org.eclipse.egerrit.internal.model.AccountInfo; /** * The command: GET /accounts/?q=Joh&n=5 * <p> * https://gerrit-review.googlesource.com/Documentation/rest-api-accounts.html#suggest-account */ public class SuggestAccountCommand extends BaseCommand<AccountInfo[]> { /** * Construct a suggest account command * * @param gerritRepository * the gerrit repository */ public SuggestAccountCommand(GerritRepository gerritRepository) { super(gerritRepository, AuthentificationRequired.NO, HttpGet.class, AccountInfo[].class);
<|startcomment|> This is scoped to the enum, so something like REQUIRE_MATCHING, ALLOW_MISMATCH would work fine. <|endcomment|>  */ public static boolean isWildcard(final String s) { return s != null && s.contains("*"); //$NON-NLS-1$ } /** Does this specification ask for forced updated (rewind/reset)? */ private boolean force; /** Is this specification actually a wildcard match? */ private boolean wildcard; enum wildcardmode { WILD_CARD_MATCH, WILD_CARD_ALLOW_MISMATCH } /** Whether a wildcard is allowed on one side but not the other. */ <|startfocus|> private wildcardmode allowMismatchedWildcards; <|endfocus|> /** Name of the ref(s) we would copy from. */ private String srcName; /** Name of the ref(s) we would copy into. */ private String dstName; /** * Construct an empty RefSpec. * <p> * A newly created empty RefSpec is not suitable for use in most * applications, as at least one field must be set to match a source name. */ public RefSpec() { force = false; wildcard = false; srcName = Constants.HEAD;
<|startcomment|> this should probably be on a calledfunction basis. <|endcomment|>  * Segment store */ private final ISegmentStore<@NonNull ISegment> fStore = new ArrayListStore<>(); /** * Listeners */ private final ListenerList fListeners = new ListenerList(ListenerList.IDENTITY); /** * The Trace's root functions list */ private final List<CalledFunction> fRootFunctions = new ArrayList<>(); /** * The sub attributes of a certain thread */ private List<Integer> fCurrentQuarks = Collections.emptyList(); <|startfocus|> private Object fSymbol = new Object(); <|endfocus|> /** * Default constructor */ public CallGraphAnalysis() { super(); } @Override public @NonNull String getHelpText() { String msg = Messages.CallGraphAnalysis_Description; return (msg != null) ? msg : super.getHelpText(); } @Override public @NonNull String getHelpText(@NonNull ITmfTrace trace) { return getHelpText(); } @Override public boolean canExecute(ITmfTrace trace) { /* * FIXME: change to !Iterables.isEmpty(getDependentAnalyses()) when
<|startcomment|> This whole thing about guessing the worst-case tick label length is a bit clunky, but for now, you should add two digits when it's TimeFormat.RELATIVE for the " s". <|endcomment|>  numDigits += 10; } else if (timeRange < 10000000) { // HH:11:222:333__ numDigits += 6; } } else { long sec = time1 / SEC_IN_NS; numDigits = Long.toString(sec).length(); int thousandGroups = (numDigits - 1) / 3; numDigits += thousandGroups; numDigits += 12; // .000 000 000 if (fTimeProvider.getTimeFormat() == TimeFormat.CYCLES) { <|startfocus|> numDigits += Messages.Utils_ClockCyclesUnit.length(); <|endfocus|> } } return numDigits;
<|startcomment|> I do not like this defaulting logic. It does make sense if this is a LSH parsed by the LS backend from the query hints provided by the engine. But it makes no sense if this LSH is used as a builder by an end user wanting to customize the hints of a query. Even if a specific hint value is not set in the customization, we cannot be sure that the engine will use the static default, which could be overridden by engine-specific options or the query specification. I suggest removing the defaulting logic from the getters. Perhaps the defaulting logic in the backend can be achieved by extracting some of the logic of ViatraQueryEngineImpl.overrideKnownHints() into a public static method, which the LS backend can use to combine the parsed LSH with LSH.getDefault(). <|endcomment|>  public boolean isUseBase() { <|startfocus|> if (useBase == null){ return getDefault().useBase; } <|endfocus|> return useBase;
<|startcomment|> Consider adding a static method to Display that does this. <|endcomment|>  try { for (int i=0; i<types.length; i++) { if (event.type == SWT.None) return; if (types [i] == event.type) { Listener listener = listeners [i]; if (listener != null) { try { listener.handleEvent (event); } catch (RuntimeException runtimeException) { Display display = Display.getCurrent(); if (display == null) { throw runtimeException; } <|startfocus|> display.getExceptionHandler().accept(runtimeException); <|endfocus|> } } } } } finally { boolean compact = level < 0; level -= level >= 0 ? 1 : -1; if (compact && level == 0) { int index = 0; for (int i=0; i<types.length; i++) { if (types [i] != 0) { types [index] = types [i]; listeners [index] = listeners [i]; index++; } } for (int i=index; i<types.length; i++) { types [i] = 0;
<|startcomment|> To avoid null checks every time, you can extract to a local variable and use that variable instead. It is safer to do so with fields, especially if they are not final. Here, the field will be final so it's less necessary, but it makes the compiler happy. <|endcomment|>  public void finish() { /* Aggregate X consumer if needed */ <|startfocus|> if (fXAggregator != null) { fSeries.stream().map(s -> s.getXConsumer()).forEach(checkNotNull(fXAggregator)::accept); <|endfocus|> } /* Aggregate Y consumer if needed */ if (fYAggregator != null) { fSeries.stream().map(s -> s.getYConsumer()).forEach(checkNotNull(fYAggregator)::accept); }
<|startcomment|> It's unusual to receive a Stream in parameter. You want to describe a set of descriptors, but the Stream itself, if consumed in the method, cannot be reused afterwards. There is no guarantee the exact same stream will be re-used after the check. This whole class is weird... The "set of descriptors" could be its own object, and that could track the state like areNumerical(), areTimestamp() etc. <|endcomment|> <|startfocus|> public DescriptorsInformation(Stream<IDataChartDescriptor<?, ?>> descriptors) { <|endfocus|> /* Visit each descriptor for checking if they share the same type */ DescriptorTypeVisitor visitor = new DescriptorTypeVisitor(); descriptors.forEach(desc -> desc.accept(visitor)); /* Make sure there was at least one descriptor */ if (visitor.checkIfType(DescriptorType.NONE)) { throw new IllegalArgumentException("No descriptor were given."); //$NON-NLS-1$ } /* Make sure each descriptor have the same type */ if (visitor.checkIfType(DescriptorType.MULTIPLE)) { throw new IllegalArgumentException("Each descriptor must be the same type."); //$NON-NLS-1$ } /* Check what are the type of the descriptors */ if (visitor.checkIfType(DescriptorType.NUMERICAL)) { fAreDescriptorsNumerical = true; if (visitor.checkIfType(DescriptorType.DURATION)) { fAreDescriptorsDuration = true; fAreDescriptorsTimestamp = false; } else if (visitor.checkIfType(DescriptorType.TIMESTAMP)) { fAreDescriptorsDuration = false; fAreDescriptorsTimestamp = true; } else { fAreDescriptorsDuration = false;
<|startcomment|> > surcharged surcharg? ;) The word you're looking for is "overloaded" here. <|endcomment|>  private Number fMin; private Number fMax; // ------------------------------------------------------------------------ // Constructors // ------------------------------------------------------------------------ /** * Constructor with a default non null predicate. * * @param resolver * The resolver that maps values */ public NumericalConsumer(IDataResolver<?, ?> resolver) { fResolver = checkNotNull(INumericalResolver.class.cast(resolver)); fPredicate = Objects::nonNull; fMin = fResolver.getMaxValue(); fMax = fResolver.getMinValue(); } /** <|startfocus|> * Surcharged constructor with a predicate. <|endfocus|> * * @param resolver * The resolver that maps values * @param predicate * The predicate for testing values */ public NumericalConsumer(IDataResolver<?, ?> resolver, Predicate<@Nullable Number> predicate) { fResolver = checkNotNull(INumericalResolver.class.cast(resolver)); fPredicate = predicate; fMin = fResolver.getMaxValue(); fMax = fResolver.getMinValue(); } // ------------------------------------------------------------------------ // Overriden methods // ------------------------------------------------------------------------ @Override public boolean test(Object obj) {
<|startcomment|> final <|endcomment|>  * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html */ package org.eclipse.epp.internal.logging.aeri.ide.processors; import org.apache.commons.lang3.StringUtils; import org.eclipse.core.runtime.IStatus; import org.eclipse.e4.core.contexts.IEclipseContext; import org.eclipse.epp.internal.logging.aeri.ide.IProcessorDescriptor; import org.eclipse.epp.logging.aeri.core.IReportProcessor; import com.google.common.annotations.VisibleForTesting; public abstract class PlatformDetailsSectionProcessor extends CachingStringProcessor implements IReportProcessor { <|startfocus|> public String sectionTitle; <|endfocus|> public PlatformDetailsSectionProcessor(IProcessorDescriptor descriptor, String sectionTitle) { super(descriptor); this.sectionTitle = sectionTitle; } @Override @VisibleForTesting protected String doAnalyze() { String configuration = ConfigurationInfo.getConfiguration("Platform Details"); int sectionStart = configuration.indexOf(sectionTitle); if (sectionStart == -1) { return ""; } // omit the title sectionStart += sectionTitle.length(); // end = begin of next section
<|startcomment|> Are you keeping all the elements you have consumed here? For instance, all the segments in the segment store would be kept for each serie? If so, why? There can be very many such elements and the idea of streaming them is to avoid having to keep them all in an array. They could be garbage-collected after being consumed. <|endcomment|>  public void accept(Object obj) { /* Make sure every consumer can consume their value */ if (!fXConsumer.test(obj) || !fYConsumer.test(obj)) { return; } /* Consume the value for each consumer */ fXConsumer.accept(obj); fYConsumer.accept(obj); <|startfocus|> /* Add the object to the list of consumed objects */ <|endfocus|> fConsumedElements.add(obj);
<|startcomment|> typo: hoverProvder <|endcomment|> import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Platform; import org.eclipse.core.runtime.Status; import org.eclipse.core.runtime.content.IContentType; import org.eclipse.core.runtime.content.IContentTypeManager; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.jface.text.ITextHover; import org.eclipse.jface.text.source.ISourceViewer; import org.eclipse.ui.IEditorInput; import org.eclipse.ui.PlatformUI; /** * Text hover registry that manages the detectors <|startfocus|> * contributed by the <code>org.eclipse.ui.workbench.texteditor.hoverProvder</code> extension point for <|endfocus|> * targets contributed by the <code>org.eclipse.ui.workbench.texteditor.hyperlinkDetectorTargets</code> extension point. * * @since 3.11 */ public final class TextHoverRegistry { private static final String EXTENSION_POINT_ID = GenericEditorPlugin.BUNDLE_ID + ".hoverProviders"; //$NON-NLS-1$ private Map<IConfigurationElement, TextHoverExtension> extensions = new HashMap<>(); private boolean outOfSync = true; private static class TextHoverExtension { private static final String CONTENT_TYPE_ATTRIBUTE = "contentType"; //$NON-NLS-1$
<|startcomment|> Please clarify here how the returned hints relate to "default" and "override" hints. <|endcomment|>  * @since 0.9 * @noimplement This interface is not intended to be implemented by clients, except in the org.eclipse.viatra.query.runtime plugin. */ public interface IQueryBackendHintProvider { /** * Suggests query evaluation hints regarding a query. * @return non-null map of option keys and values * @deprecated use {@link #getQueryEvaluationHint(PQuery)} instead */ @Deprecated Map<String, Object> getHints(PQuery query); /** <|startfocus|> * Suggests query evaluation hints regarding a query. <|endfocus|> * @since 1.4 */ QueryEvaluationHint getQueryEvaluationHint(PQuery query); /** * A default implementation that just returns the hints embedded in the query, without overriding. * @deprecated Use a ViatraQueryEngine instead */ public static final IQueryBackendHintProvider DEFAULT = new IQueryBackendHintProvider() { @Override public Map<String, Object> getHints(PQuery query) { final QueryEvaluationHint embeddedHints = query.getEvaluationHints(); if (embeddedHints != null && embeddedHints.getBackendHints() != null)
<|startcomment|> need nls markers in this file <|endcomment|>  public static StyledString parse(final String lineText) { final StyledString result = new StyledString(); // looking for blocks of characters starting with 'ESC[xxm' (where 'xx' // is // a color code) // and optionally ending with 'ESC[0m' final Pattern colorSequencePattern = Pattern <|startfocus|> .compile("\\x1b\\[(?<colorcode>\\d{1,2})m(?<content>.*)"); <|endfocus|> final Matcher colorSequenceMatcher = colorSequencePattern .matcher(lineText); int lastColorSequencePosition = 0; int lastColorSequenceCode = 0; // default color (Black) while (colorSequenceMatcher.find(lastColorSequencePosition)) { final int currentColorSequenceStartPosition = colorSequenceMatcher .start(); final String colorCode = colorSequenceMatcher.group("colorcode"); // catch-up with initial in-between content that has no specific // color code boundaries or with the last color sequence position if (lastColorSequencePosition < currentColorSequenceStartPosition) { final String inbetweenContent = lineText.substring( lastColorSequencePosition, currentColorSequenceStartPosition); if (!inbetweenContent.isEmpty()) {
<|startcomment|> , 2016 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2012 THALES GLOBAL SERVICES. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.ui.business.internal.migration; import java.util.ArrayList; import java.util.List; import org.eclipse.emf.ecore.EClassifier; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.EPackage; import org.eclipse.emf.ecore.EStructuralFeature; import org.eclipse.gmf.runtime.notation.Diagram; import org.eclipse.sirius.business.api.migration.AbstractRepresentationsFileMigrationParticipant; import org.eclipse.sirius.business.api.query.DViewQuery; import org.eclipse.sirius.diagram.DDiagram; import org.eclipse.sirius.diagram.ui.business.api.query.DDiagramGraphicalQuery; import org.eclipse.sirius.ext.base.Option; import org.eclipse.sirius.viewpoint.DAnalysis; import org.eclipse.sirius.viewpoint.DRepresentation; import org.eclipse.sirius.viewpoint.DView; import org.osgi.framework.Version; /**
<|startcomment|> of a <|endcomment|>  if (potentialExplicitDetachment || potentialImplicitDetachment) { return input.getFeature() instanceof EReference && ((EReference) input.getFeature()).isContainment(); } return false; } }; /** * Filter {@link Notification}s which are not an attachment. An attachment * is : an EObject being removed from the reference it is contained in. */ public static final Predicate<Notification> IS_ATTACHMENT = new Predicate<Notification>() { /** * {@inheritDoc} <|startfocus|> */ <|endfocus|> public boolean apply(Notification input) { if (input.getEventType() == Notification.ADD || input.getEventType() == Notification.ADD_MANY || input.getEventType() == Notification.SET) { // The input.getNewValue() check required to make IS_ATTACHMENT // and IS_DETACHMENT mutually exclusive. return input.getFeature() instanceof EReference && ((EReference) input.getFeature()).isContainment() && input.getNewValue() != null; } return false; } }; /** * A predicate to ignore DSemanticDecorator references in the dangling
<|startcomment|> This documentation must have inherited doc only if this function is an override <|endcomment|>  /** * {@inheritDoc} * * @see org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.IStyledLabelProvider#getStyledText(java.lang.Object) * * @since 3.0 */ @Override default StyledString getStyledText(final Object element) { return new StyledString(getText(element)); } /** * {@inheritDoc} * <|startfocus|> * @see org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.IStyledLabelProvider#getStyledText(java.lang.Object) * * @since 3.0 <|endfocus|> */ default StyledString getStyledText(final Object element, final ETypedElement eTypedElement) { return new StyledString(getText(element, eTypedElement)); } } 
<|startcomment|> Remove see <|endcomment|>  this.parentCategory = parentCategory; this.category = category; } /* (non-Javadoc) * @see org.eclipse.pde.core.IWritable#write(java.lang.String, java.io.PrintWriter) */ public void write(String indent, PrintWriter writer) { category.write(indent, writer); } /* * For retaining selectiong in the tree, when modyfing or moving features, * SiteFeatureAdapter are equal if features are equal (same ID and version) <|startfocus|> * * @see java.lang.Object#equals(java.lang.Object) <|endfocus|> */ public boolean equals(Object obj) { if (obj instanceof SiteCategoryDefinitionAdapter) { SiteCategoryDefinitionAdapter otherAdapter = (SiteCategoryDefinitionAdapter) obj; String id = category.getName(); String id2 = otherAdapter.category.getName(); boolean sameCategory = id != null && id2 != null && id.equals(id2); boolean sameParentCategory = otherAdapter.parentCategory != null && parentCategory != null ? otherAdapter.category.equals(parentCategory) : true; return sameCategory && sameParentCategory; } return super.equals(obj); } 
<|startcomment|> remove commented code <|endcomment|>  * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Ericsson - initial API and implementation *******************************************************************************/ package org.eclipse.egerrit.internal.dashboard.ui.commands.table; import org.eclipse.core.commands.ExecutionEvent; import org.eclipse.core.commands.ExecutionException; import org.eclipse.egerrit.internal.ui.editors.CheckoutRevision; /** * This class implements a handler to checkout the latest branch of the selected review */ <|startfocus|> //public class CheckoutRevisionHandler extends AbstractHandler { <|endfocus|> public class CheckoutRevisionHandler extends DashboardFactoryHandler { @Override public Object execute(ExecutionEvent event) throws ExecutionException { // Execute the checkout if we have the information if (getChangeInfo() != null && getGerritClient() != null) { CheckoutRevision checkoutRevision = new CheckoutRevision(getRevision(), getGerritClient()); checkoutRevision.run(); } return null; } @Override public void setEnabled(Object evaluationContext) { super.setEnabled(evaluationContext); if (getChangeInfo() == null) { setBaseEnabled(false); return; } }
<|startcomment|> as above <|endcomment|>  * @since 4.5 */ public static FilterCommandFactory registerCommand(String commandName, FilterCommandFactory fact) { if (fact == null) return commandRegistry.remove(commandName); else return commandRegistry.put(commandName, fact); } /** * Checks whether some {@link FilterCommandFactory} is registered for a * certain command name * * @param commandName * the name for which the registry should be checked <|startfocus|> * @return <code>true</code> if some factory was registered for the name <|endfocus|> * @since 4.5 */ public static boolean isRegistered(String commandName) { return commandRegistry.containsKey(commandName); } /** * Creates a new {@link FilterCommand} for the given name. A factory has to * be registered for the name in advance. * * @param commandName * The name for which a new {@link FilterCommand} should be * created * @param db * the repository this command should work on * @param in
<|startcomment|> an <|endcomment|>  // The outputstream into which the filtered content should be copied private OutputStream out; private LfsUtil lfsUtil; // the size of the original content private long size = 0; // a temporary file into which the original content is written. When no // errors occur this file will be renamed to the mediafile private Path tmpFile; /** * @param db * the repository * @param in <|startfocus|> * a {@link InputStream} providing the original content <|endfocus|> * @param out * the {@link OutputStream} into which the content of the pointer * file should be written. That's the content which will be add * to the git repository * @throws IOException * when the creation of the temporary file fails or when no * {@link OutputStream} for this file can be created */ public CleanFilter(Repository db, InputStream in, OutputStream out) throws IOException { super(in, out);
<|startcomment|> Please avoid whitespace additions into the codebase. <|endcomment|>  disposedIntentionally = true; Consumer<RuntimeException> oldHandler = Display.getCurrent ().getRuntimeExceptionHandler (); try { final List<RuntimeException> handledExceptions = new ArrayList<> (); // Register an exception handler similar to the one used by the workbench, which doesn't // propogate exceptions Display.getCurrent ().setRuntimeExceptionHandler (exception -> { handledExceptions.add(exception); }); final int[] listenerInvocations = new int[1]; control.addDisposeListener (e -> { listenerInvocations[0]++; }); <|startfocus|> <|endfocus|> control.addDisposeListener (e -> { throw new RuntimeException("Test exception handling"); }); control.addDisposeListener (e -> { listenerInvocations[0]++; }); try { control.dispose (); } catch (RuntimeException e) { fail("The exception in the listener should have been logged, not passed along to the caller"); } assertTrue (control.isDisposed ()); assertEquals (2, listenerInvocations[0]); assertEquals (1, handledExceptions.size ()); } finally {
<|startcomment|> Move this comment below the variable declaration. <|endcomment|>  * @see <a href="http://www.eclipse.org/swt/">Sample code and further information</a> * @noextend This class is not intended to be subclassed by clients. */ public class Button extends Control { String text = "", message = ""; Image image, image2, disabledImage; ImageList imageList; boolean ignoreMouse, grayed; <|startfocus|> int buttonBackground = -1; // we need our own field, because setting Control.background causes 1-2 colored pixels around the button. <|endfocus|> int buttonBackgroundAlpha = 255; static final int MARGIN = 4; static final int CHECK_WIDTH, CHECK_HEIGHT; static final int ICON_WIDTH = 128, ICON_HEIGHT = 128; static /*final*/ boolean COMMAND_LINK = false; static final long /*int*/ ButtonProc; static final TCHAR ButtonClass = new TCHAR (0, "BUTTON", true); static { long /*int*/ hBitmap = OS.LoadBitmap (0, OS.OBM_CHECKBOXES); if (hBitmap == 0) { CHECK_WIDTH = OS.GetSystemMetrics (OS.IsWinCE ? OS.SM_CXSMICON : OS.SM_CXVSCROLL);
<|startcomment|> we should just use this call. If the workbench is not initialized yet, we probably do sometiong wrong. <|endcomment|>  GitTraceLocation.getTrace().trace( GitTraceLocation.REPOSITORYCHANGESCANNER.getLocation(), "Trying to cancel " + rcs.getName() + " job"); //$NON-NLS-1$ //$NON-NLS-2$ rcs.setReschedule(false); rcs.cancel(); if (GitTraceLocation.REPOSITORYCHANGESCANNER.isActive()) GitTraceLocation.getTrace().trace( GitTraceLocation.REPOSITORYCHANGESCANNER.getLocation(), <|startfocus|> "Trying to cancel " + refreshJob.getName() + " job"); //$NON-NLS-1$ //$NON-NLS-2$ <|endfocus|> refreshJob.cancel(); rcs.join(); refreshJob.join(); if (GitTraceLocation.REPOSITORYCHANGESCANNER.isActive()) GitTraceLocation.getTrace().trace( GitTraceLocation.REPOSITORYCHANGESCANNER.getLocation(), "Jobs terminated"); //$NON-NLS-1$ if (resourceManager != null) { resourceManager.dispose(); resourceManager = null; } super.stop(context); plugin = null; } @Override protected void saveDialogSettings() { KnownHosts.store(); super.saveDialogSettings(); } /** * @return the {@link RepositoryUtil} instance */
<|startcomment|> we should be closing these streams, maybe this should be in a try-with-resource block. <|endcomment|>  } @Override protected List<TaskData> parseFromJson(InputStreamReader in) throws BugzillaRestException { TypeToken<List<TaskData>> type = new TypeToken<List<TaskData>>() { }; return new GsonBuilder().registerTypeAdapter(type.getType(), new JSonTaskDataDeserializer()) .create() .fromJson(in, type.getType()); } @Override protected List<TaskData> doProcess(CommonHttpResponse response, IOperationMonitor monitor) throws IOException, BugzillaRestException { <|startfocus|> BufferedInputStream is = new BufferedInputStream(response.getResponseEntityAsStream()); <|endfocus|> InputStreamReader in = new InputStreamReader(is); throwExeptionIfRestError(is, in); return parseFromJson(in); } @Override protected void doValidate(CommonHttpResponse response, IOperationMonitor monitor) throws IOException, BugzillaRestException { int statusCode = response.getStatusCode(); if (statusCode != 400 && statusCode != 200) { if (statusCode == HttpStatus.SC_NOT_FOUND) { throw new BugzillaRestResourceNotFoundException( NLS.bind("Requested resource ''{0}'' does not exist", response.getRequestPath())); }
<|startcomment|> 4.6 <|endcomment|>  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.lfs; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import org.eclipse.jgit.lfs.lib.LongObjectId; /** * Class which represents the lfs folder hierarchy inside a .git folder * <|startfocus|> * @since 4.5 <|endfocus|> */ public class Lfs { private Path root; private Path objDir; private Path tmpDir; /** * @param root * the path to the LFS media directory. Will be "<repo>/.git/lfs" */ public Lfs(Path root) { this.root = root; } /** * @return the path to the LFS directory */ public Path getLfsRoot() { return root; } /** * @return the path to the temp directory used by LFS. Will be * "<repo>/.git/lfs/tmp"
<|startcomment|> Using this instead of a primitive boolean exposes the risk of an NPE. Unless there's a good reason (I don't see one), prefer primitive types. <|endcomment|>  * * Contributors: * Obeo - Initial API and implementation */ package org.eclipse.sirius.tests.swtbot.support.api.condition; import org.eclipse.swtbot.swt.finder.waits.DefaultCondition; import org.eclipse.swtbot.swt.finder.widgets.SWTBotCheckBox; /** * Condition validating a checkbox status (checked or unchecked). * * @author <a href="mailto:steve.monnier@obeo.fr">Steve Monnier</a> */ public class CheckboxStatusCondition extends DefaultCondition { private SWTBotCheckBox checkBox; <|startfocus|> private Boolean expectedToBeChecked; <|endfocus|> /** * Constructor. * * @param checkBox * the checkbox to validate the status. * * @param expectedToBeChecked * true if expected to be checked, false otherwise. */ public CheckboxStatusCondition(SWTBotCheckBox checkBox, Boolean expectedToBeChecked) { this.checkBox = checkBox; this.expectedToBeChecked = expectedToBeChecked; } /** * {@inheritDoc} */ public boolean test() throws Exception { return this.checkBox.isChecked() == this.expectedToBeChecked; } /**
<|startcomment|> Preconditions.checkState(credentials != null) <|endcomment|>  VersionResponse versionResponse = new BugzillaRestUnauthenticatedGetRequest<VersionResponse>(client, "/version", //$NON-NLS-1$ new TypeToken<VersionResponse>() { }).run(monitor); return new BugzillaRestVersion(versionResponse.getVersion()); } public boolean validate(IOperationMonitor monitor) throws BugzillaRestException { RepositoryLocation location = getClient().getLocation(); if (location.getBooleanPropery(IBugzillaRestConstants.REPOSITORY_USE_API_KEY)) { UserCredentials credentials = location.getCredentials(AuthenticationType.REPOSITORY); <|startfocus|> if (credentials == null) { throw new IllegalStateException("Authentication requested without valid credentials"); //$NON-NLS-1$ } <|endfocus|> String url = MessageFormat.format("/valid_login?login={0}&api_key={1}", //$NON-NLS-1$ new Object[] { credentials.getUserName(), location.getProperty(IBugzillaRestConstants.REPOSITORY_API_KEY) }); BooleanResult response = new BugzillaRestUnauthenticatedGetRequest<BooleanResult>(client, url, new TypeToken<BooleanResult>() { }).run(monitor); return response.getResult(); } else { LoginToken validateResponse = new BugzillaRestLoginRequest(client).run(monitor);
<|startcomment|> Do we need to add this type to types list? <|endcomment|>  */ public class UMLRTUIElementTypesEnumerator extends AbstractElementTypeEnumerator implements IUMLRTUIElementTypes { /** * Creation element-type for protocol message parameter, with prompt for type. */ public static final IHintedType PROTOCOL_MESSAGE_PARAMETER_CREATION_WITH_UI = (IHintedType) getElementType(PROTOCOL_MESSAGE_PARAMETER_CREATION_WITH_UI_ID); private static final List<IHintedType> types = ImmutableList.of(PROTOCOL_MESSAGE_PARAMETER_CREATION_WITH_UI); public static final IHintedType EXTERNAL_PORT_CREATION_WITH_UI = (IHintedType) getElementType(EXTERNAL_PORT_CREATION_WITH_UI_ID); <|startfocus|> <|endfocus|> /** * Returns all of the specific UI element types for UML-RT. * * @return all of the specific UI element types for UML-RT */ public static List<IHintedType> getAllUITypes() { return types; } } 
<|startcomment|> should we be doing something better here? Should this fail the test or something like that? <|endcomment|>  protected void runChild(final FrameworkMethod method, RunNotifier notifier) { Description description = describeChild(method); if (isIgnored(method)) { notifier.fireTestIgnored(description); } else { Object test = null; try { test = new ReflectiveCallable() { @Override protected Object runReflectiveCall() throws Throwable { return createTest(); } }.run(); } catch (Throwable e) { <|startfocus|> // TODO Auto-generated catch block e.printStackTrace(); <|endfocus|> } boolean skipped = false; if (test != null) { List<TestRule> testRules = getTestRules(test); for (TestRule testRule : testRules) { Class<? extends TestRule> klass = testRule.getClass(); klass.getCanonicalName(); if ("org.eclipse.mylyn.commons.sdk.util.ConditionalIgnoreRule" .equals(klass.getCanonicalName())) { Statement statement = testRule.apply(null, description); if (statement != null) { skipped = true; break; } } } } if (skipped) {
<|startcomment|> Please move the static import after the comment so imports are in one place. <|endcomment|>  * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * IBM Corporation - initial API and implementation * Lars Vogel <Lars.Vogel@vogella.com> - Bug 502845 *******************************************************************************/ package org.eclipse.swt.snippets; <|startfocus|> import static org.eclipse.swt.events.SelectionListener.*; <|endfocus|> /* * CCombo example snippet: create a CCombo (read-only, flat) * * For a list of all SWT example snippets see * http://www.eclipse.org/swt/snippets/ */ import org.eclipse.swt.*; import org.eclipse.swt.custom.*; import org.eclipse.swt.layout.*; import org.eclipse.swt.widgets.*; public class Snippet39 { public static void main(String[] args) { Display display = new Display(); Shell shell = new Shell(display); shell.setLayout(new GridLayout()); 
<|startcomment|> I think this gets the latest copy of the review which will be returned by the getReview() call below. <|endcomment|>  //Check and make sure the reviewer was added. This wont block the execution of removing the reviewer though if it fails assertReviewerResult(addReviewerResult, null, userid); //The "removeReviewers" method takes in a single string id rather than a list. String reviewer = "admin"; ReviewerResult removeReviewerResult = reviewHarness.getClient().removeReviewers(reviewHarness.getShortId(), reviewer, new NullProgressMonitor()); <|startfocus|> /* Not quite sure if I need to call this again. It seems to be some sort 'producer consumer' type * design that I couldn't quite figure out. It sets a listener that waits for.....something to do with the tests */ <|endfocus|> reviewHarness.retrieve(); //assertThat(/*Some assert that checks whether there was a bad http response*/); //Check if the approvals is empty after we remove the reviewer assertThat(getReview().getReviewerApprovals().isEmpty(), is(true)); } @Test public void testAddReviewersByEmail() throws Exception {
<|startcomment|> Unneeded additional indent. <|endcomment|>  shell.setText("Spinner with float values"); shell.setLayout(new GridLayout()); final Spinner spinner = new Spinner(shell, SWT.NONE); // allow 3 decimal places spinner.setDigits(3); // set the minimum value to 0.001 spinner.setMinimum(1); // set the maximum value to 20 spinner.setMaximum(20000); // set the increment value to 0.010 spinner.setIncrement(10); // set the seletion to 3.456 spinner.setSelection(3456); <|startfocus|> spinner.addSelectionListener(widgetSelectedAdapter(e -> { <|endfocus|> int selection = spinner.getSelection(); int digits = spinner.getDigits(); System.out.println("Selection is " + (selection / Math.pow(10, digits))); })); shell.setSize(200, 200); shell.open(); while (!shell.isDisposed ()) { if (!display.readAndDispatch ()) display.sleep (); } display.dispose ();
<|startcomment|> I think we should have a test that adds multiple reviewers and then removes some of them, but not all of them. That way we know it's not removing all reviewers or something like that. <|endcomment|>  assertThat(getReview().getReviewerApprovals().isEmpty(), is(true)); //Need a user and not the review owner List<String> reviewers = Arrays.asList(new String[] { "admin" }); int userid = 1000000; //user id for admin ReviewerResult reviewerResult = reviewHarness.getClient().addReviewers(reviewHarness.getShortId(), reviewers, new NullProgressMonitor()); reviewHarness.retrieve(); assertReviewerResult(reviewerResult, null, userid); } @Test <|startfocus|> public void testRemoveAddedReviewers() throws Exception { <|endfocus|> assertThat(getReview().getReviewerApprovals().isEmpty(), is(true)); //Make sure theres no reviewers List<String> reviewers = Arrays.asList(new String[] { "admin" }); int userid = 1000000; //user id for admin ReviewerResult addReviewerResult = reviewHarness.getClient().addReviewers(reviewHarness.getShortId(), reviewers, new NullProgressMonitor()); reviewHarness.retrieve(); assertReviewerResult(addReviewerResult, null, userid); String reviewer = "admin"; ReviewerResult removeReviewerResult = reviewHarness.getClient().removeReviewer(reviewHarness.getShortId(),
<|startcomment|> api_key_enabled will always be true due to the conditional ignore rule, this if else should be removed. <|endcomment|>  location.setProxy(null); location.setCredentialsStore(new InMemoryCredentialsStore()); location.setCredentials(AuthenticationType.REPOSITORY, new UserCredentials("tests@mylyn.eclipse.org", "")); location.setProperty(IBugzillaRestConstants.REPOSITORY_USE_API_KEY, Boolean.toString(true)); location.setProperty(IBugzillaRestConstants.REPOSITORY_API_KEY, "wvkz2SoBMBQEKv6ishp1j7NY1R9l711g5w2afXc6"); BugzillaRestClient client; client = new BugzillaRestClient(location, connector); assertNotNull(client.getClient()); <|startfocus|> if (!Boolean.parseBoolean(actualFixture.getProperty("api_key_enabled"))) { <|endfocus|> thrown.expect(BugzillaRestException.class); thrown.expectMessage("The API key you specified is invalid"); client.validate(new NullOperationMonitor()); } else { assertEquals(true, client.validate(new NullOperationMonitor())); } } @Test @ConditionalIgnoreRule.ConditionalIgnore(condition = MustRunOnApikeyRule.class) public void testInvalidApikeyValidate() throws BugzillaRestException { RepositoryLocation location = new RepositoryLocation(); location.setUrl(actualFixture.getRepositoryUrl()); location.setProxy(null); location.setCredentialsStore(new InMemoryCredentialsStore());
<|startcomment|> Can you please place the test annotation after the javadoc, not before? <|endcomment|> import org.eclipse.ui.PlatformUI; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class IDEWorkbenchAdvisorTest { private Display display = null; @Before public void setUp() { assertNull(display); display = PlatformUI.createDisplay(); assertNotNull(display); } @After public void tearDown() throws Exception { while (display.readAndDispatch()) { ; } display.dispose(); assertTrue(display.isDisposed()); display = null; } <|startfocus|> @Test <|endfocus|> /** * Workbench shutdown should not deadlock when invoked from workspace * operation * * Regression test for bug 501404 Timeout annotation parameter can't be * used, as it makes test to be executed in non-UI thread. * */ public void testShutdownWithLockedWorkspace() throws TimeoutException { IDEWorkbenchAdvisor advisor = new IDEWorkbenchAdvisor() { @Override public void postStartup() { super.postStartup(); ISchedulingRule rule = ResourcesPlugin.getWorkspace().getRoot(); display.asyncExec(() -> {
<|startcomment|> is it intentional to introduce this protected method and introduce new API, or is it needed only for testing? For testing the case whether the adapter is null you don't need this... <|endcomment|> <|startfocus|> protected void initTitle(EObject model) { <|endfocus|> updateTitle(model); model.eAdapters().add(headerAdapter = new FormTitleAdapter(model));
<|startcomment|> as it is a user message you could say that 5 sub node are expected (as you did when empty node is expected). Idem for other occurences of this message <|endcomment|>  SWTBotTreeItem[] treeItem = odesignEditor.bot().tree().getAllItems(); assertEquals("There should be only one group node under resource node", 1, treeItem.length); // Level1 SWTBotTreeItem resourceItem = treeItem[0]; assertEquals("There should be only one viewpoint node under group node", resourceItem.getItems().length); // Level2 SWTBotTreeItem groupItem = resourceItem.getItems()[0]; <|startfocus|> assertEquals("The level 2 node should be expanded with 6 sub items", 6, groupItem.getItems().length); <|endfocus|> // Level3 SWTBotTreeItem viewpointItem = groupItem.getItems()[0]; assertEquals("The level 3 node should be expanded with 7 sub items", 7, viewpointItem.getItems().length); SWTBotTreeItem viewpointItem2 = groupItem.getItems()[2]; assertEquals("The level 3 node should be expanded with 4 sub items", 4, viewpointItem2.getItems().length); // Level4 // We check without expanding the level 4 node that we have only one // sub node corresponding to the empty node.
<|startcomment|> Same as enclosing type. Remove. <|endcomment|>  /** * Sets whether this breakpoint is to be treated as a trigger point for the * workspace. If it is a trigger point, then the <code>TRIGGERPOINT</code> * attribute on this breakpoint's marker is set to <code>true</code>. * * @param trigger whether this breakpoint is to be treated as trigger point * for the workspace * @exception CoreException if unable to set the associated attribute on * this breakpoint's underlying marker. <|startfocus|> * @since 3.11 <|endfocus|> */ public void setTriggerPoint(boolean trigger) throws CoreException; } 
<|startcomment|> Doesn't work either for me. The text is now not inside the checkbox, but has no padding at all, so looks not OK. <|endcomment|>  } if ((style & SWT.TOGGLE) != 0 && isChecked()) { pixel = getDifferentColor(buttonBackground); } RECT rect = new RECT (); OS.SetRect (rect, nmcd.left+2, nmcd.top+2, nmcd.right-2, nmcd.bottom-2); long /*int*/ brush = OS.CreateSolidBrush(pixel); OS.FillRect(nmcd.hdc, rect, brush); OS.DeleteObject(brush); } if (customForegroundDrawing()) { <|startfocus|> int radioOrCheckTextPadding = DPIUtil.autoScaleUp(16); <|endfocus|> int left = nmcd.left + 2; // subtract border int right = nmcd.right - 2; // subtract border if (image != null) { GCData data = new GCData(); data.device = display; GC gc = GC.win32_new (nmcd.hdc, data); int margin = computeLeftMargin(); int imageWidth = image.getBoundsInPixels().width; left += (imageWidth + MARGIN); // for SWT.RIGHT_TO_LEFT right and left are inverted 
<|startcomment|> Dangerous, you want this to clamp to Int.MaxValue() and never be negative. <|endcomment|>  // Go to the top of the table tableViewer.getTable().setTopIndex(0); // Reset selected row tableViewer.setSelection(StructuredSelection.EMPTY); if (dataInput == null) { tableViewer.setInput(null); tableViewer.setItemCount(0); return; } addPackListener(); tableViewer.setInput(dataInput); SegmentStoreContentProvider contentProvider = (SegmentStoreContentProvider) getTableViewer().getContentProvider(); <|startfocus|> tableViewer.setItemCount((int) contentProvider.getSegmentCount()); <|endfocus|> }
<|startcomment|> (2) <|endcomment|>  */ public interface IHTNode<E extends IHTObject> { /** * The type of node */ enum NodeType { /** * Core node, which is a "front" node, at any level of the tree except * the bottom-most one. It has children, and may have extensions. */ CORE, /** * Leaf node, which is a node at the last bottom level of the tree. It * cannot have any children or extensions. */ <|startfocus|> LEAF; <|endfocus|> /** * Determine a node type by reading a serialized byte. * * @param rep * The byte representation of the node type * @return The corresponding NodeType * @throws IOException * If the NodeType is unrecognized */ public static NodeType fromByte(byte rep) throws IOException { switch (rep) { case 1: return CORE; case 2: return LEAF; default: throw new IOException(); } } /**
<|startcomment|> Here only half the segments should go in <|endcomment|>  PerformanceMeter pMiterate1 = perf.createPerformanceMeter(distributionName + " First Iteration: " + fName); PerformanceMeter pMinsertion2 = perf.createPerformanceMeter(distributionName + " Second Insertion: " + fName); PerformanceMeter pMiterate2 = perf.createPerformanceMeter(distributionName + " Second Iteration: " + fName); for (int i = 0; i < DEFAULT_LOOP_COUNT; i++) { fSegStore.clear(); pMinsertion1.start(); <|startfocus|> populate(size, fuzz, fSegStore, getSegmentStoreSize()); <|endfocus|> pMinsertion1.stop(); pMiterate1.start(); iterate(fSegStore); pMiterate1.stop(); pMinsertion2.start(); populate(size, fuzz, fSegStore, getSegmentStoreSize()); pMinsertion2.stop(); pMiterate2.start(); iterate(fSegStore); pMiterate2.stop(); } pMinsertion1.commit(); pMiterate1.commit(); pMinsertion2.commit(); pMiterate2.commit();
<|startcomment|> nit: should be package-private instead of private to avoid synthetic accessor. <|endcomment|>  * <p> * Wraps another OutputStream to prevent interrupts during writes from being * visible to the {@code dst} OutputStream. This works around buggy or difficult * OutputStream implementations like JSch that cannot gracefully handle an * interrupt during write. * <p> * This stream creates a minimal buffer to store written bytes before handing * off the buffer to {@code dst}. */ public class IsolatedOutputStream extends OutputStream { <|startfocus|> private final Copier copier; private final ReentrantLock lock; private final Condition writeReady; private final Condition writeDone; <|endfocus|> private final byte[] buffer = new byte[4096]; private int len; private boolean flush; private boolean close; private boolean pending; private IOException err; /** * Wraps an OutputStream. * * @param dst * stream to send all writes to. */ public IsolatedOutputStream(OutputStream dst) { lock = new ReentrantLock(); writeReady = lock.newCondition(); writeDone = lock.newCondition(); copier = new Copier(dst); copier.start();
<|startcomment|> 2016 ;) <|endcomment|> <|startfocus|> * Copyright (C) 2014, Google Inc. <|endfocus|> * and other copyright owners as documented in the project's IP log. * * This program and the accompanying materials are made available * under the terms of the Eclipse Distribution License v1.0 which * accompanies this distribution, is reproduced below, and is * available at http://www.eclipse.org/org/documents/edl-v10.php * * All rights reserved. * * Redistribution and use in source and binary forms, with or * without modification, are permitted provided that the following * conditions are met: * * - Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * - Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution. * * - Neither the name of the Eclipse Foundation, Inc. nor the
<|startcomment|> Can this be moved up before the other stuff in this block? <|endcomment|>  if (revision != null) { try (Git sub = new Git(subRepo)) { sub.checkout().setName(findRef(revision, subRepo)) .call(); } subRepo.close(); git.add().addFilepattern(name).call(); } for (CopyFile copyfile : copyfiles) { copyfile.copy(); git.add().addFilepattern(copyfile.dest).call(); } <|startfocus|> if (!linkfiles.isEmpty()) { throw new UnsupportedOperationException( JGitText.get().nonBareLinkFilesNotSupported); } <|endfocus|> } } private static String findRef(String ref, Repository repo) throws IOException { if (!ObjectId.isId(ref)) { Ref r = repo.exactRef(R_REMOTES + DEFAULT_REMOTE_NAME + "/" + ref); //$NON-NLS-1$ if (r != null) return r.getName(); } return ref; } } 
<|startcomment|> Why packageFragmentRoot2? Suggest naming this "root". <|endcomment|>  for (IJavaElement javaElement : javaElements) { addAllCus(result, javaElement); } return result.toArray(new ICompilationUnit[result.size()]); } private static void addAllCus(HashSet<ICompilationUnit> collector, IJavaElement javaElement) throws JavaModelException { switch (javaElement.getElementType()) { case IJavaElement.JAVA_PROJECT: IJavaProject javaProject= (IJavaProject) javaElement; IPackageFragmentRoot[] packageFragmentRoots= javaProject.getPackageFragmentRoots(); <|startfocus|> for (IPackageFragmentRoot packageFragmentRoot2 : packageFragmentRoots) addAllCus(collector, packageFragmentRoot2); <|endfocus|> return; case IJavaElement.PACKAGE_FRAGMENT_ROOT: IPackageFragmentRoot packageFragmentRoot= (IPackageFragmentRoot) javaElement; if (packageFragmentRoot.getKind() != IPackageFragmentRoot.K_SOURCE) return; IJavaElement[] packageFragments= packageFragmentRoot.getChildren(); for (IJavaElement packageFragment2 : packageFragments) addAllCus(collector, packageFragment2); return; case IJavaElement.PACKAGE_FRAGMENT: IPackageFragment packageFragment= (IPackageFragment) javaElement; collector.addAll(Arrays.asList(packageFragment.getCompilationUnits())); return; case IJavaElement.COMPILATION_UNIT:
<|startcomment|> add your name and the bug number <|endcomment|>  * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Vincent Lorenzo (CEA LIST) vincent.lorenzo@cea.fr - Initial API and implementation * Christian W. Damus (CEA) - bug 402525 * Christian W. Damus (CEA) - bug 430880 <|startfocus|> * Dirk Fauth <dirk.fauth@googlemail.com> - Bug 488234 <|endfocus|> * *****************************************************************************/ package org.eclipse.papyrus.infra.nattable.manager.table; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Map; import org.eclipse.core.runtime.IAdaptable; import org.eclipse.emf.common.command.Command; import org.eclipse.emf.common.notify.Notification; import org.eclipse.emf.ecore.EObject; import org.eclipse.emf.ecore.EStructuralFeature; import org.eclipse.emf.edit.ui.dnd.LocalTransfer; import org.eclipse.emf.transaction.NotificationFilter; import org.eclipse.emf.transaction.ResourceSetChangeEvent;
<|startcomment|> open question: should not this code be in DRepresentationDescriptorItemProvider or do we want the disabled icon only displayed in Sirius navigator explorer? <|endcomment|>  // Let eclipse look for file and project icons + nature // decoration img = sessionLabelProvider.getImage(element); } catch (IllegalStateException e) { // This can happen when trying to get the label of a CDOObject // which // Transaction has just been closed // Nothing to do, null will returned } catch (NullPointerException e) { // This can happen when trying to get the label of a CDOObject // which transaction has just been closed // Nothing to do, null will returned } <|startfocus|> } else if (element instanceof IFile) { <|endfocus|> IFile file = (IFile) element; if (new IFileQuery(file).isSemanticResourceOfOpenedSession()) { // Add "Sirius Modeling" overlay on this semantic file. String fileExtension = file.getFileExtension(); // Create a key to store/restore the image in image registry of // SiriusEditPlugin String imgKey = fileExtension + "Decorated"; // Get the existing image (if any) img = SiriusEditPlugin.getPlugin().getImageRegistry().get(imgKey);
<|startcomment|> Hmm, the returned "unmodifiable" list is a view of the original list - not a copy - as suggested in the issue description. So, if the original list changes the view will reflect this an the concurrency issues should still exist! I suggest using: new ArrayList<>(getElementsInGroup(...)) to get an actual copy. (same issue below) <|endcomment|>  public Object getDataValueByPosition(final int columnPosition, final int rowPosition, LabelStack labelStack, boolean calculateInBackground) { if (labelStack.hasLabel(GROUP_BY_OBJECT)) { GroupByObject groupByObject = (GroupByObject) this.treeData.getDataAtIndex(rowPosition); final IGroupBySummaryProvider<T> summaryProvider = getGroupBySummaryProvider(labelStack); if (summaryProvider != null) { <|startfocus|> final List<T> children = Collections.unmodifiableList(getElementsInGroup(groupByObject)); <|endfocus|> return this.valueCache.getCalculatedValue( columnPosition, rowPosition, new GroupByValueCacheKey(columnPosition, rowPosition, groupByObject), calculateInBackground, new ICalculator() { @Override public Object executeCalculation() { return summaryProvider.summarize(columnPosition, children); } }); } } return super.getDataValueByPosition(columnPosition, rowPosition);
<|startcomment|> final <|endcomment|> <|startfocus|> protected void tryInsertAtNode(E interval, int indexOfNode) { N targetNode = getLatestBranch().get(indexOfNode); <|endfocus|> /* Verify if there is enough room in this node to store this interval */ if (interval.getSizeOnDisk() > targetNode.getNodeFreeSpace()) { /* Nope, not enough room. Insert in a new sibling instead. */ addSiblingNode(indexOfNode, getSiblingStart(interval, targetNode)); tryInsertAtNode(interval, getLatestBranch().size() - 1); return; } /* Make sure the interval time range fits this node */ if (interval.getStart() < targetNode.getNodeStart()) { /* * No, this interval starts before the startTime of this node. We * need to check recursively in parents if it can fit. */ tryInsertAtNode(interval, indexOfNode - 1); return; } /* * Ok, there is room, and the interval fits in this time slot. Let's add * it. */ targetNode.add(interval); updateEndTime(interval);
<|startcomment|> which kind of listener ? <|endcomment|>  */ void unregisterModelChangeListener(); /** * Returns the editing domain. * * @return The editing domain * * @since 1.7.0 */ EditingDomain getEditingDomain(); /** * Registers a listener to notify when model elements are locked or unlocked. * * @param listener * the listener to invoke when elements are locked on unlocked. */ void addLockStatusChangedListener(IConsumer<Collection<LockStatusChangeEvent>> listener); /** <|startfocus|> * Unregisters the given listener. <|endfocus|> * * @param listener * The listener to unregister */ void removeLockStatusChangedListener(IConsumer<Collection<LockStatusChangeEvent>> listener); /** * Returns the current locking status of an element. * * @param obj * the element. * @return the current lock status of the element. */ LockStatus geLockStatus(EObject obj); /** * Attempts to take an exclusive lock on the specified elements. Callers should not assume the elements are actually
<|startcomment|> updateButtons instead? <|endcomment|> <|startfocus|> private void enableButtons(boolean enable) { <|endfocus|> fDeleteButton.setEnabled(enable); fExportButton.setEnabled(enable); fEditButton.setEnabled(enable);
<|startcomment|> projectConfiguration -> buildConfiguration <|endcomment|> kage org.eclipse.jdt.internal.core; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; import org.eclipse.core.resources.IBuildConfiguration; import org.eclipse.core.resources.IDynamicReferenceProvider; import org.eclipse.core.resources.IProject; import org.eclipse.core.resources.IWorkspaceRoot; import org.eclipse.core.runtime.CoreException; import org.eclipse.jdt.core.IJavaProject; import org.eclipse.jdt.core.JavaCore; public class DynamicProjectReferences implements IDynamicReferenceProvider { @Override <|startfocus|> public List<IProject> getDependentProjects(IBuildConfiguration projectConfiguration) throws CoreException { IProject input = projectConfiguration.getProject(); <|endfocus|> IJavaProject javaProject = JavaCore.create(input); if (javaProject instanceof JavaProject) { JavaProject project = (JavaProject) javaProject; String[] required = project.projectPrerequisites(project.getResolvedClasspath()); IWorkspaceRoot wksRoot = input.getWorkspace().getRoot(); return Arrays.stream(required).sorted().map(name -> wksRoot.getProject(name)).collect(Collectors.toList()); } return Collections.emptyList(); } } 
<|startcomment|> The year is obsolete already :P <|endcomment|>  private static StringBuilder appendCopyright(StringBuilder builder) { builder.append("/**").append(System.lineSeparator()); //$NON-NLS-1$ <|startfocus|> builder.append(" * Copyright (c) 2016 Obeo.").append(System.lineSeparator()); //$NON-NLS-1$ <|endfocus|> builder.append(" * All rights reserved. This program and the accompanying materials").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" * are made available under the terms of the Eclipse Public License v1.0").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" * which accompanies this distribution, and is available at").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" * http://www.eclipse.org/legal/epl-v10.html").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" *").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" * Contributors:").append(System.lineSeparator()); //$NON-NLS-1$ builder.append(" * Obeo - initial API and implementation").append(System.lineSeparator()); //$NON-NLS-1$
<|startcomment|> Could we consider here that a null Port is a non valid RTPort? This would avoid null tests (that are already performed in the getFacade() operation). <|endcomment|>  public static boolean isConnectedInside(Port port) { <|startfocus|> UMLRTPort rt = (port == null) ? null : UMLRTPort.getInstance(port); <|endfocus|> return (rt != null) && rt.isConnectedInside();
<|startcomment|> If shouldSchedule() and shouldRun() are overridden, the if is not necessary here. <|endcomment|>  .getLocation(), "Stopped rescheduling " + getName() + "job"); //$NON-NLS-1$ //$NON-NLS-2$ } return createErrorStatus(UIText.Activator_scanError, e); } finally { monitor.done(); } if (GitTraceLocation.REPOSITORYCHANGESCANNER.isActive()) { GitTraceLocation.getTrace().trace( GitTraceLocation.REPOSITORYCHANGESCANNER.getLocation(), "Rescheduling " + getName() + " job"); //$NON-NLS-1$ //$NON-NLS-2$ } <|startfocus|> if (doReschedule) { schedule(interval); } <|endfocus|> return Status.OK_STATUS;
<|startcomment|> Overridden <|endcomment|>  super.setFont(f); List<TextFlow> textFlowList = findTextFlowChildList(page); int i = 0; for (TextFlow nextTextFlow : textFlowList) { if (i == myStyles.size()) { // make code more robust break; } nextTextFlow.setFont(calculateCurrentFont(myStyles.get(i))); i++; } } } /** * {@inheritDoc} * <|startfocus|> * Override to refresh text after set of font and font color to be take into account. <|endfocus|> * * @see org.eclipse.draw2d.Figure#setForegroundColor(org.eclipse.swt.graphics.Color) */ @Override public void setForegroundColor(final Color fg) { super.setForegroundColor(fg); // Refresh text. if (!useHtmlRenderer() || htmlRenderer == null) { if (page != null) { page.removeAll(); generateBlockForText(text, page); } } } /** * @see HTMLCornerBentFigure.setFont() for using * * @param parent * @return TextFlow childs list
<|startcomment|> missing @since 4.7 tag for new API method <|endcomment|>  throw new ConnectException(ce.getMessage() + " " + host); //$NON-NLS-1$ } } /** * Extract a HTTP header from the response. * @param c connection the header should be obtained from. * @param headerField the header name * @return the header value * @throws IOException * communications error prevented obtaining the header. */ <|startfocus|> public static String responseHeader(final HttpConnection c, final String headerField) throws IOException { return c.getHeaderField(headerField); <|endfocus|> } /** * Determine the proxy server (if any) needed to obtain a URL. * * @param proxySelector * proxy support for the caller. * @param u * location of the server caller wants to talk to. * @return proxy to communicate with the supplied URL. * @throws ConnectException * the proxy could not be computed as the supplied URL could not * be read. This failure should never occur. */
<|startcomment|> I think you can ask the PackRevIdx for the offset of this object and the next object in the pack, subtract them to compute the length of this object, and accumulate that for a size estimate. Hold the PackRevIdx up above alongside the PackIndex as its not free on a per-object basis. <|endcomment|>  pw.setReuseDeltaCommits(true); pm.beginTask(JGitText.get().findingGarbage, objectsBefore()); for (DfsPackFile oldPack : packsBefore) { PackIndex oldIdx = oldPack.getPackIndex(ctx); for (PackIndex.MutableEntry ent : oldIdx) { pm.update(1); ObjectId id = ent.toObjectId(); if (pool.lookupOrNull(id) != null || anyPackHas(id)) continue; int type = oldPack.getObjectType(ctx, ent.getOffset()); <|startfocus|> pw.addObject(pool.lookupAny(id, type)); <|endfocus|> } } pm.endTask(); if (0 < pw.getObjectCount()) writePack(UNREACHABLE_GARBAGE, pw, pm, 0 /* unknown pack size */); } } private boolean anyPackHas(AnyObjectId id) { for (ObjectIdSet packedObjs : newPackObj) if (packedObjs.contains(id)) return true; return false; } private static boolean isHead(Ref ref) { return ref.getName().startsWith(Constants.R_HEADS); } private static boolean isTag(Ref ref) {
<|startcomment|> Looks like the second sentence is a leftover. <|endcomment|>  * A file is "up to date" if its content is known to be in sync with the index. A file * is not up to date if there is any possibility that its content might be out of sync with the * index. */ public class FileStateCache { private final Map<String, Boolean> fileStateCache = new HashMap<>(); /** <|startfocus|> * Returns true if the file at the given path is in sync with the index. Returns true if the file is in sync. * Returns false if the file might be out-of-sync. Returns null if its status is unknown. <|endfocus|> * * @param location an absolute path on the filesystem */ public Boolean isUpToDate(String location) { synchronized (this.fileStateCache) { return this.fileStateCache.get(location); } } /** * Returns the cache for the given {@link Nd} instance. * * @return the cache for the given {@link Nd}. Creates one if it doesn't exist yet. */
<|startcomment|> Simplify this: UNLOAD_PATH_PATTERN = Pattern.compile("^/unload/(.+)$"); - Constant name: there are no adapters involved here - Inline PATH_PREFIX, constant is not used anywhere else - Use everything after the slash until the end as uiSessionId - uiSessionId must consist of at least one character. <|endcomment|>  * * @see Session.js * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon} * @since 6.1 */ @Order(5040) public class UnloadRequestHandler extends AbstractUiServletRequestHandler { private static final Logger LOG = LoggerFactory.getLogger(UnloadRequestHandler.class); <|startfocus|> public static final String PATH_PREFIX = "unload"; public static final Pattern PATTERN_UNLOAD_ADAPTER_RESOURCE_PATH = Pattern.compile("^/" + PATH_PREFIX + "/([^/]*)$"); <|endfocus|> @Override public boolean handlePost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { final String pathInfo = req.getPathInfo(); final Matcher matcher = PATTERN_UNLOAD_ADAPTER_RESOURCE_PATH.matcher(pathInfo); if (!matcher.matches()) { return false; } final String uiSessionId = matcher.group(1); if (StringUtility.hasText(uiSessionId)) { handleUnloadRequest(req, resp, uiSessionId); return true; } else { return false; } } 
<|startcomment|> annotate this instead <|endcomment|>  public ScatterStringConsumer(IStringResolver<Object> resolver) { fResolver = resolver; <|startfocus|> fMap = checkNotNull(HashBiMap.create()); <|endfocus|>
<|startcomment|> Refer alpha field based on currentDeviceZoom, since this flow could be called on 200% zoom level as well. <|endcomment|> public static Image cocoa_new(Device device, int type, NSImage nsImage) { Image image = new Image(device); image.type = type; image.handle = nsImage; <|startfocus|> image.alphaInfo_100 = image.new AlphaInfo(); <|endfocus|> return image;
<|startcomment|> remove commented out line <|endcomment|>  protected MIRegisterGroupDMC addRegisterGroup(IMIContainerDMContext container, String groupName, String registerName) { MIRegisterGroupDMC registerGroup = new MIRegisterGroupDMC(gdbRegisters, container, 1, groupName); MIRegisterDMC rgFoo = new MIRegisterDMC(gdbRegisters, registerGroup, 1, registerName); <|startfocus|> // gdbRegisters.getRegisterGroups(container, newDataRequestMonitor()); <|endfocus|> gdbRegisters.addRegisterGroup(container, registerGroup.getName(), array(rgFoo), newRequestMonitor()); return registerGroup;
<|startcomment|> rename to 'entry' <|endcomment|>  private void takeSnapshot(Map<String, FileSummary> snapshot, File rootLocation, boolean skip) { FileSummary summary = new FileSummary(rootLocation); if (!skip && !rootLocation.getName().equals(SNAPSHOT_FILE_NAME)) { snapshot.put(rootLocation.getAbsolutePath(), summary); } if (!rootLocation.isDirectory()) { return; } File[] entries = rootLocation.listFiles(); if (entries == null) { return; } <|startfocus|> for (File entrie : entries) { takeSnapshot(snapshot, entrie, false); <|endfocus|> }
<|startcomment|> Simpler: ArrayList<T> result = new ArrayList<>(collection); <|endcomment|>  synchronized(_path) { for (Map.Entry<FactoryContainer, Attributes> entry : getReversed(_path.entrySet())) { Attributes attr = entry.getValue(); if (attr.isEnabled()) { Attributes attrClone = new Attributes(attr); map.put(entry.getKey(), attrClone); } } } return map; } private static <T> List<T> getReversed(Collection<T> collection) { <|startfocus|> ArrayList<T> result = new ArrayList<>(); result.addAll(collection); <|endfocus|> Collections.reverse(result); return result; } /** * @return a copy of the path */ public Map<FactoryContainer, Attributes> getAllContainers() { Map<FactoryContainer, Attributes> map = new LinkedHashMap<>(_path.size()); synchronized (_path) { for (Map.Entry<FactoryContainer, Attributes> entry : getReversed(_path.entrySet())) { map.put(entry.getKey(), new Attributes(entry.getValue())); } } return map; } /** * A word of warning: this equals() method does not canonicalize factory
<|startcomment|> 2017 <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2010, 2016 Ericsson, cole Polytechnique de Montral, and others <|endfocus|> * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Alexandre Montplaisir - Initial API and implementation * Loc Prieur-Drevon - Adapt to SegmentStore *******************************************************************************/ package org.eclipse.tracecompass.internal.segmentstore.core.segmentHistoryTree; import java.io.File; import java.io.IOException; import java.nio.channels.ClosedChannelException; import java.util.Collection; import java.util.Comparator; import java.util.Deque; import java.util.Iterator; import java.util.LinkedList; import java.util.NoSuchElementException; import java.util.PriorityQueue; import org.eclipse.jdt.annotation.NonNull; import org.eclipse.jdt.annotation.Nullable; import org.eclipse.tracecompass.internal.provisional.datastore.core.condition.RangeCondition; import org.eclipse.tracecompass.internal.provisional.datastore.core.historytree.HTNode; import org.eclipse.tracecompass.internal.provisional.datastore.core.historytree.IHTNode;
<|startcomment|> Redundant empty lines to be removed <|endcomment|>  boolean moveAllowed = true; while (moveAllowed && iterator.hasNext()) { Entry<?, ?> entrySet = (Entry<?, ?>) iterator.next(); if (entrySet.getKey() instanceof MessageOccurrenceSpecification) { MessageOccurrenceSpecification mos = (MessageOccurrenceSpecification) entrySet.getKey(); EObject container = mos.eContainer(); if (null != container && container != req.getTargetContainer()) { moveAllowed = false; } } } if (!moveAllowed) { moveCommand = UnexecutableCommand.INSTANCE; } <|startfocus|> <|endfocus|> return moveCommand;
<|startcomment|> final <|endcomment|> <|startfocus|> private PreferencesHint checkDiagramWorkenchPart(IEditorPart editorPart) { <|endfocus|> PreferencesHint preferencesHint = null; if (editorPart instanceof IDiagramWorkbenchPart) { RootEditPart rootEditPart = ((IDiagramWorkbenchPart) editorPart) .getDiagramGraphicalViewer().getRootEditPart(); if (rootEditPart instanceof IDiagramPreferenceSupport) { preferencesHint = ((IDiagramPreferenceSupport) rootEditPart) .getPreferencesHint(); } } return preferencesHint;
<|startcomment|> Doing the "instanceof" test first would avoid calling the more costly "super": return editPart instanceof IDiagramElementEditPart && super.shouldBeDecorated(editPart); <|endcomment|> <|startfocus|> boolean shouldBeDecorated = super.shouldBeDecorated(editPart); return shouldBeDecorated && editPart instanceof IDiagramElementEditPart; <|endfocus|> } /** * Get the decoration image.<br> * * @param editPart * the edit part to get the decoration image from * @return <code>null</code> if no image found. */ @Override
<|startcomment|> Add contributor and bug number Other initializers should be checked also <|endcomment|> *************************************************************************** * Copyright (c) 2009 Atos Origin. * * * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: <|startfocus|> * Atos Origin - Initial API and implementation <|endfocus|> * *****************************************************************************/ package org.eclipse.papyrus.uml.diagram.activity.preferences; import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer; import org.eclipse.gmf.runtime.diagram.ui.preferences.AppearancePreferencePage; import org.eclipse.gmf.runtime.diagram.ui.preferences.ConnectionsPreferencePage; import org.eclipse.gmf.runtime.diagram.ui.preferences.DiagramsPreferencePage; import org.eclipse.gmf.runtime.diagram.ui.preferences.PrintingPreferencePage; import org.eclipse.gmf.runtime.diagram.ui.preferences.RulerGridPreferencePage; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.papyrus.uml.diagram.activity.part.UMLDiagramEditorPlugin; /** * @generated */ public class DiagramPreferenceInitializer extends AbstractPreferenceInitializer { /** * @generated */ @Override public void initializeDefaultPreferences() {
<|startcomment|> nit: missing comma after. Same in other methods below. <|endcomment|>  assertEquals(expected, paths); } @Test public void testTopNotPath() throws IOException { List<String> expected = Arrays.asList("a.txt", "sub1.txt", "sub2"); TreeFilter tf = PathFilter.create("sub1"); List<String> paths = getMatchingPathsFlat(treeId, NotTreeFilter.create(tf)); assertEquals(expected, paths); } private List<String> getMatchingPaths(final ObjectId treeId, TreeFilter tf) throws IOException { <|startfocus|> return _getMatchingPaths(treeId,tf, true); <|endfocus|> } private List<String> getMatchingPathsFlat(final ObjectId treeId, TreeFilter tf) throws IOException { return _getMatchingPaths(treeId,tf, false); } private List<String> _getMatchingPaths(final ObjectId treeId, TreeFilter tf, boolean recursive) throws IOException { TreeWalk tw = new TreeWalk(db); tw.setFilter(tf); tw.setRecursive(recursive); tw.addTree(treeId); List<String> paths = new ArrayList<>(); while(tw.next()) { paths.add(tw.getPathString()); } return paths; } 
<|startcomment|> Should add the new columns here also so they have capitalized header. <|endcomment|>  buttonPanel.setLayout(new GridLayout()); GridDataFactory.fillDefaults().grab(false, false).applyTo(buttonPanel); // property names of the Person class String[] propertyNames = { "firstName", "lastName", "gender", "married", "birthday" }; // mapping from property to label, needed for column header labels Map<String, String> propertyToLabelMap = new HashMap<String, String>(); propertyToLabelMap.put("firstName", "Firstname"); <|startfocus|> propertyToLabelMap.put("lastName", "Lastname"); <|endfocus|> IColumnPropertyAccessor<Person> columnPropertyAccessor = new ExtendedReflectiveColumnPropertyAccessor<Person>( propertyNames); List<Person> values = PersonService.getPersons(30); final EventList<Person> eventList = GlazedLists.eventList(values); TransformedList<Person, Person> rowObjectsGlazedList = GlazedLists.threadSafeList(eventList); // use the SortedList constructor SortedList<Person> sortedList = new SortedList<Person>(rowObjectsGlazedList, null); // wrap the SortedList with the FilterList FilterList<Person> filterList = new FilterList<Person>(sortedList); 
<|startcomment|> It seems the value should be obtained from the platform instead of hard-coded. This might break depending on the platform the test is run on and/or the version of Eclipse used (for example if SWT detects a HiDPI screen and uses a larger defaut size). <|endcomment|> import org.eclipse.swtbot.swt.finder.widgets.SWTBotTree; import org.junit.Test; /** * Test Style description item. Test automatic refresh and manual refresh. Test * undo/redo after each test type Test opening and closing model or editor to * verify that all changes are effective * * @author jdupont */ public class TreeItemStyleDescriptionTest extends AbstractTreeSiriusSWTBotGefTestCase { /** <|startfocus|> * The runtime font size. */ private static final int RUNTIME_FONT_SIZE = 9; /** <|endfocus|> * Sirius Specific Model. */ private static final String VSM = "ecore.odesign"; /** * */ private static final String ODESIGN = "platform:/resource/DesignerTestProject/" + VSM; /** * Test repository. */ private static final String DATA_UNIT_DIR = "data/unit/tree/"; /** * Session file. */ private static final String SESSION_FILE = "tree.aird"; /** * UML File. */ private static final String ECORE_FILE = "tree.ecore"; /**
<|startcomment|> should it be internationalized like others buttons? <|endcomment|>  Composite subComposite = toolkit.createComposite(parent, SWT.NONE); subComposite.setLayout(GridLayoutFactory.fillDefaults().margins(0, 0).create()); subComposite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false)); Composite buttonsComposite = toolkit.createComposite(subComposite, SWT.NONE); FillLayout buttonsLayout = new FillLayout(SWT.BEGINNING); buttonsLayout.spacing = 5; buttonsComposite.setLayout(buttonsLayout); <|startfocus|> addButton(buttonsComposite, "New...", () -> { //$NON-NLS-1$ <|endfocus|> new NewWizardAction(PlatformUI.getWorkbench().getActiveWorkbenchWindow()).run(); }); addButton(buttonsComposite, Messages.UI_SessionEditor_models_button_newSemanticModel, () -> { AddModelDependencyAction addModelDependencyAction = new AddModelDependencyAction(session); addModelDependencyAction.run(); }); removeSemanticModelOrRepresentationButton = addButton(buttonsComposite, Messages.UI_SessionEditor_models_button_removeSemanticModel, () -> { if (theTreeViewer != null) { final IStructuredSelection selection = (IStructuredSelection) theTreeViewer.getSelection(); Collection<?> selectedObjects = selection.toList(); if (!selectedObjects.isEmpty()) {
<|startcomment|> This won't work well if PLUGINS_NOT_IN_SCRIPT_VERSION contains the last plugin as we'll end up with a , at the end. In fact, this is what is happening now :-) But after testing it with a comma at the end of the plugin list, it seems to work fine so we can just leave the comma there to simplify this code <|endcomment|>  // Write all plug-in names for (int i =0; i < pluginList.size(); i++) { String pluginName = pluginList.get(i); if (PLUGINS_NOT_IN_SCRIPT_VERSION.contains(pluginName)) { continue; } r.write(pluginName); // Add start level if necessary if (PLUGINS_WITH_START_LEVEL.containsKey(pluginName)) { r.write(PLUGINS_WITH_START_LEVEL.get(pluginName)); } <|startfocus|> if (i != pluginList.size() - 1) { r.write(','); } <|endfocus|> } r.write('\n'); r.write("osgi.configuration.cascaded=false\n"); //$NON-NLS-1$ r.write("osgi.bundles.defaultStartLevel=4\n"); //$NON-NLS-1$ } catch (IOException e) { e.printStackTrace(); System.exit(1); }
<|startcomment|> wrong author <|endcomment|>  } /** * {@inheritDoc} * * @see org.eclipse.core.databinding.observable.AbstractObservable#dispose() */ @Override public synchronized void dispose() { viewer.removeSelectionChangedListener(selectionAdapter); super.dispose(); } private void resetAllMapping(final SelectedMapping[] allMapping) { for (final SelectedMapping selectedMapping : allMapping) { selectedMapping.setSelected(false); } } /** * Selection adapter for the combo. * <|startfocus|> * @author saklechr <|endfocus|> * */ private class SingleEnumSelectionAdapter implements ISelectionChangedListener { @Override public void selectionChanged(SelectionChangedEvent event) { final SelectedMapping mapping = (SelectedMapping) ((IStructuredSelection) event.getSelection()) .getFirstElement(); if (mapping == null) { return; } final SelectedMapping[] allMapping = (SelectedMapping[]) viewer.getInput(); resetAllMapping(allMapping); mapping.setSelected(!mapping.isSelected()); viewer.getCCombo().setText(getComboText((SelectedMapping[]) viewer.getInput())); viewer.update(mapping, null);
<|startcomment|> this could be null <|endcomment|>  switch (index) { case 0: if (AttachmentUtil.isContext(attachment)) { text.append(Messages.AttachmentTableLabelProvider_Task_Context); } else if (attachment.isPatch()) { text.append(Messages.AttachmentTableLabelProvider_Patch); } else { text.append(" " + attachment.getFileName()); //$NON-NLS-1$ } break; case 1: if (attachment.getDescription() != null) { text.append(attachment.getDescription()); } break; case 2: <|startfocus|> Long length = attachment.getLength(); <|endfocus|> if (length < 0) { text.append("-"); //$NON-NLS-1$ } text.append(sizeFormatter.format(length)); break; case 3: String autherText = (attachment.getAuthor() != null) ? attachment.getAuthor().toString() : ""; //$NON-NLS-1$ String[] autherPart = autherText.split(" <"); //$NON-NLS-1$ text.append(autherPart[0] + " ", StyledString.COUNTER_STYLER); //$NON-NLS-1$ if (autherPart.length > 1) {
<|startcomment|> information <|endcomment|>  * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.diagram.ui.tools.api.decoration; import org.eclipse.draw2d.IFigure; import org.eclipse.sirius.viewpoint.description.DecorationDistributionDirection; import org.eclipse.sirius.viewpoint.description.Position; import org.eclipse.swt.graphics.Image; /** <|startfocus|> * Simple POJO that contains informations needed to display decoration. <|endfocus|> * * @author <a href="mailto:laurent.fasani@obeo.fr">Laurent Fasani</a> */ public class DecorationDescriptor { /** * Display priority. */ public enum DisplayPriority { /** * Highest priority. */ HIGH_PRIORITY(0), /** * Normal priority. */ NORMAL_PRIORITY(1); private final int value; DisplayPriority(int value) { this.value = value; } public int getValue() { return value; } }; /** * Display priority. */ public enum DecorationType { /**
<|startcomment|> If the getDecorationDescriptors() can return null, it must be at least documented or better, return an optionnal list. Otherwise each implementation must return an empty list. <|endcomment|>  return; } if (editPart instanceof IDiagramElementEditPart) { Map<Position, List<DecorationDescriptor>> positionToDecorators = Maps.newHashMap(); List<DecorationDescriptor> decorationDescriptors = Lists.newArrayList(); for (SiriusDecorationDescriptorProvider decorationDescriptorProvider : decorationDescriptorProviders) { if (decorationDescriptorProvider.provides((IDiagramElementEditPart) editPart)) { <|startfocus|> List<DecorationDescriptor> decorationDescriptors2 = decorationDescriptorProvider.getDecorationDescriptors((IDiagramElementEditPart) editPart); if (decorationDescriptors2 != null) { decorationDescriptors.addAll(decorationDescriptors2); <|endfocus|> } } } if (editPart instanceof AbstractConnectionEditPart) { // put all decorations at the same central position positionToDecorators.put(Position.CENTER_LITERAL, decorationDescriptors); for (DecorationDescriptor decoDesc : decorationDescriptors) { decoDesc.setDistributionDirection(DecorationDistributionDirection.HORIZONTAL); } Map<Position, IFigure> figureAtPosition = computeGroupDecorationsFigure(positionToDecorators); addDecoration(getDecoratorTarget().addConnectionDecoration(figureAtPosition.get(Position.CENTER_LITERAL), 50, true)); } else { for (DecorationDescriptor decorationDescriptor : decorationDescriptors) { Position position = decorationDescriptor.getPosition();
<|startcomment|> The list of disabled trace types <|endcomment|>  configurationPreferences.put(TraceTypePreferences.TRACE_TYPE_PREFERENCE_KEY, value); configurationPreferences.flush(); } catch (BackingStoreException e) { Activator.logError("Failed to set the trace type preferences", e); //$NON-NLS-1$ } } private static IEclipsePreferences getEclipsePreference() { IEclipsePreferences configurationPreferences = ConfigurationScope.INSTANCE.getNode(Activator.PLUGIN_ID); return configurationPreferences; } /** * Get the preference value for the trace types * <|startfocus|> * @return The map containing the preferences value <|endfocus|> */ public static List<String> getPreferenceValue() { List<String> elements = new ArrayList<>(); IEclipsePreferences configurationPreferences = getEclipsePreference(); String joined = configurationPreferences.get(TraceTypePreferences.TRACE_TYPE_PREFERENCE_KEY, getDefaultValue()); Object splitted = Splitter.on(SEPARATOR).split(joined); if (splitted instanceof Iterable) { for (Object object : (Iterable<String>) splitted) { elements.add((String) object); } } return elements; } } 
<|startcomment|> change to IStructuredSelection <|endcomment|>  protected void assertSelectionEquals(String message, TestElement expected) { <|startfocus|> ISelection selection = fViewer.getStructuredSelection(); assertTrue(selection instanceof IStructuredSelection); IStructuredSelection expectedSelection = new StructuredSelection( expected); assertEquals("selectionEquals - " + message, selection, expectedSelection); <|endfocus|>
<|startcomment|> This could be a little tidier with tabs.values().forEach(ICodeSnippetTab::dispose); Similarly at line 233 <|endcomment|>  public void dispose() { choiceListener.dispose(); <|startfocus|> tabs.values().stream().forEach(t -> t.dispose()); <|endfocus|>
<|startcomment|> Is this to be added later? <|endcomment|>  /** the array of minor tick positions in pixels */ protected ArrayList<Integer> minorPositions; /** the scale */ protected IScaleProvider scale; private boolean ticksIndexBased; /** default: show max label */ private boolean showMaxLabel = true; /** default: show min label */ private boolean showMinLabel = true; /** * constructor * * @param scale */ <|startfocus|> public LinearScaleTicks2(IScaleProvider scale) { <|endfocus|> this.scale = scale; minorPositions = new ArrayList<Integer>(); } @Override public List<Integer> getPositions() { List<Integer> positions = new ArrayList<Integer>(); for (Tick t : ticks) positions.add((int) Math.round(t.getPosition())); return positions; } @Override public List<Boolean> getVisibilities() { List<Boolean> visibilities = new ArrayList<Boolean>(); for (int i = 0; i < ticks.size(); i++) { visibilities.add(true); } return visibilities; } @Override public List<String> getLabels() {
<|startcomment|> extract? <|endcomment|>  final TimeRangeCondition rc = TimeRangeCondition.forContinuousRange(start, end); return new Iterable<E>() { @Override public Iterator<@NonNull E> iterator() { return new Iterator<E>() { private boolean started = false; private PriorityQueue<SegmentTreeNode.Tuple<E>> queue = new PriorityQueue<>(getNodeCount(), Comparator.comparing(SegmentTreeNode.Tuple<E>::getSegment, order)); <|startfocus|> private PriorityQueue<E> intersecting = new PriorityQueue<>(2000, order); <|endfocus|> @Override public @NonNull E next() { if (hasNext()) { return intersecting.remove(); } throw new NoSuchElementException(); } @Override public boolean hasNext() { /* Iteration has not started yet */ if (!started) { SegmentTreeNode<E> rootNode = getRootNode(); /* * Add the root node with any segment for the tuple, * it will always be read. */ queue.add(new SegmentTreeNode.Tuple(new BasicSegment(0,0), rootNode.getSequenceNumber())); 
<|startcomment|> externalize <|endcomment|>  private static final ImageDescriptor SORT_BY_ID_REV_ICON = Activator.getDefault().getImageDescripterFromPath("icons/etool16/sort_num_rev.gif"); //$NON-NLS-1$ private final Action VIEW_BY_THREAD = new Action("Per thread", IAction.AS_RADIO_BUTTON) { @Override public void run() { fViewByThread = true; buildFlameGraph(fFlamegraphModule); } }; <|startfocus|> private final Action VIEW_AGGREGATE = new Action("Aggregate threads", IAction.AS_RADIO_BUTTON) { <|endfocus|> @Override public void run() { fViewByThread = false; buildFlameGraph(fFlamegraphModule); } }; private volatile boolean fViewByThread = true; private TimeGraphViewer fTimeGraphViewer; private FlameGraphContentProvider fTimeGraphContentProvider; private TimeGraphPresentationProvider fPresentationProvider; private ITmfTrace fTrace; private final @NonNull MenuManager fEventMenuManager = new MenuManager(); /** * A plain old semaphore is used since different threads will be competing * for the same resource. */ private final Semaphore fLock = new Semaphore(1); 
<|startcomment|> Need some javadoc; it's not obvious why we suddenly need to create new variables here. <|endcomment|>  * * Contributors: * Obeo - initial API and implementation *******************************************************************************/ package org.eclipse.sirius.table.ui.tools.internal.migration; import org.eclipse.emf.ecore.EObject; import org.eclipse.sirius.business.api.migration.AbstractVSMMigrationParticipant; import org.eclipse.sirius.table.metamodel.table.description.DescriptionFactory; import org.eclipse.sirius.table.metamodel.table.description.LabelEditTool; import org.eclipse.sirius.table.metamodel.table.description.TableVariable; import org.eclipse.sirius.table.metamodel.table.provider.Messages; import org.eclipse.sirius.table.tools.api.interpreter.IInterpreterSiriusTableVariables; import org.osgi.framework.Version; <|startfocus|> <|endfocus|> public class LabelEditToolVariableMigrationParticipant extends AbstractVSMMigrationParticipant { /** * The version for which this migration is added. */ public static final Version MIGRATION_VERSION = new Version("12.0.0.2017031200"); //$NON-NLS-1$ @Override public Version getMigrationVersion() { return MIGRATION_VERSION; } @Override public EObject updateCreatedObject(EObject newObject, String loadedVersion) { if (Version.parseVersion(loadedVersion).compareTo(MIGRATION_VERSION) < 0 && newObject instanceof LabelEditTool) {
<|startcomment|> Why is that good? <|endcomment|>  public void testCounter() { Logger logger = fLogger; assertNotNull(logger); <|startfocus|> // good <|endfocus|> TraceCompassLogUtils.traceCounter(logger, Level.FINER, "counter", "cats", 0); TraceCompassLogUtils.traceCounter(logger, Level.FINER, "counter", "cats", 10); // good TraceCompassLogUtils.traceCounter(logger, Level.FINER, "counter", "cats", 0); fStreamHandler.flush(); assertEquals("FINER: {\"ts\":0,\"ph\":\"C\",\"tid\":1,\"name\":\"counter\",\"args\":{\"cats\":0}}", fLog.getMessages().get(0)); assertEquals("FINER: {\"ts\":0,\"ph\":\"C\",\"tid\":1,\"name\":\"counter\",\"args\":{\"cats\":10}}", fLog.getMessages().get(1)); assertEquals("FINER: {\"ts\":0,\"ph\":\"C\",\"tid\":1,\"name\":\"counter\",\"args\":{\"cats\":0}}", fLog.getMessages().get(2));
<|startcomment|> Selection comes after MouseDown <|endcomment|>  tree.select(new int[] { 1 }); SWTBotText text = bot.textInGroup("Listeners"); bot.button("Clear").click(); tree.unselect(); assertEquals(0, tree.selectionCount()); //event.item should contain the item getting unselected, stateMask should reflect CTRL key <|startfocus|> assertEventMatches(text, "Selection [13]: SelectionEvent{Tree {} time=-550222256 data=null item=TreeItem {Node 2} detail=0 x=0 y=0 width=0 height=0 stateMask=0xc0000 text=null doit=true}"); <|endfocus|> assertEventMatches(text, "MouseDown [3]: MouseEvent{Tree {} time=-550222259 data=null button=1 stateMask=0x40000 x=0 y=0 count=1}"); assertEventMatches(text, "MouseUp [4]: MouseEvent{Tree {} time=-550222255 data=null button=1 stateMask=0xc0000 x=0 y=0 count=1}"); } @Test public void unselectsSingleSelectTree() throws Exception { try { tree.unselect(); fail("Expecting an exception"); } catch (Exception e) {
<|startcomment|> empty line <|endcomment|>  * */ public class DAxesFactory implements IAxesFactory { @Override public Axis createXAxis() { DAxis newAxis = new DAxis("X-Axis", false); newAxis.setOrientation(Orientation.HORIZONTAL); newAxis.setTickLabelSide(LabelSide.Primary); return newAxis; } @Override public Axis createYAxis() { DAxis newAxis = new DAxis("Y-Axis", true); newAxis.setOrientation(Orientation.VERTICAL); newAxis.setTickLabelSide(LabelSide.Primary); newAxis.setAutoScaleThreshold(0.1); return newAxis; } <|startfocus|> <|endfocus|> } 
<|startcomment|> Can be O(n), move fast exit up or remove, and set to 0. or some equivalent number. Maybe 1000, to avoid the initial resizes? <|endcomment|>  protected void updateData(final long start, final long end, int nb, @Nullable IProgressMonitor monitor) { // Third parameter is not used by implementation // Determine data that needs to be visible Iterable<@NonNull ISegment> data = fDisplayData; final int datasize = (nb == 0) ? Iterables.size(data) : nb; if (end == start) { return; <|startfocus|> } <|endfocus|> List<Double> xSeries = new ArrayList<>(datasize); List<Double> ySeries = new ArrayList<>(datasize); // For each visible segments, add start time to x value and duration // for y value Iterator<ISegment> modelIter = data.iterator(); while (modelIter.hasNext()) { ISegment segment = modelIter.next(); xSeries.add((double) (segment.getStart() - start)); ySeries.add((double) segment.getLength()); } setXAxis(Doubles.toArray(xSeries)); setSeries(Messages.SegmentStoreScatterGraphViewer_legend, Doubles.toArray(ySeries)); updateDisplay();
<|startcomment|> delete. <|endcomment|>  cache.flush(); } cache.setControls(children); } @Override protected Point computeSize(Composite composite, int wHint, int hHint, boolean flushCache) { updateCache(composite, flushCache); if (wHint == SWT.DEFAULT) { return computeSize(composite, wHint, hHint, maxNumColumns); } else if (wHint == MIN_SIZE) { return computeSize(composite, wHint, hHint, minNumColumns); } return computeSize(composite, wHint, hHint, -1); } /** * */ <|startfocus|> private Point computeSize(Composite parent, int wHint, int hHint, int ncolumns) { <|endfocus|> Control[] children = parent.getChildren(); int cwidth = 0; int cheight = 0; Point[] sizes = new Point[children.length]; int cwHint = SWT.DEFAULT; if (ncolumns != -1) { cwHint = wHint - leftMargin - rightMargin - (ncolumns - 1) * horizontalSpacing; if (cwHint <= 0) cwHint = 0; else cwHint /= ncolumns; } 
<|startcomment|> Please add a line for your change here: Tamas Borbas - Bug 515645 - Missing API to turn off auto refresh <|endcomment|>  * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Bug 336488 - DiagramEditor API * pjpaulin - Bug 352120 - Now uses IDiagramContainerUI interface * mwenz - Bug 433779 - DiagramBehaviour.setInput() is not extensible <|startfocus|> * mwenz - Bug 459386 - Refresh Connection when getDiagramBehavior().refreshRenderingDecorators(PEInstance) is called <|endfocus|> * * </copyright> * *******************************************************************************/ package org.eclipse.graphiti.ui.editor; import org.eclipse.draw2d.Figure; import org.eclipse.gef.EditPart; import org.eclipse.gef.GraphicalEditPart; import org.eclipse.graphiti.dt.IDiagramTypeProvider; import org.eclipse.graphiti.features.IDirectEditingInfo; import org.eclipse.graphiti.features.IFeatureProvider; import org.eclipse.graphiti.features.IUpdateFeature; import org.eclipse.graphiti.features.context.IUpdateContext; import org.eclipse.graphiti.features.context.impl.UpdateContext; import org.eclipse.graphiti.internal.pref.GFPreferences; import org.eclipse.graphiti.internal.util.T; import org.eclipse.graphiti.mm.pictograms.Diagram;
<|startcomment|> is there a getSoleAttributeValue to use without unnecessarily casting to string <|endcomment|>  public String getAtsId() { try { <|startfocus|> return services.getAttributeResolver().getSoleAttributeValueAsString(artifact, AtsAttributeTypes.AtsId, <|endfocus|> String.valueOf(getId())); } catch (OseeCoreException ex) { return null; }
<|startcomment|> null != resource <|endcomment|>  public void setContributions(final ArchitectureExtendedProviderDescriptor descriptor) { contributorID = descriptor.getContributionID(); Resource resource = loadResourceFromPreferences(new ResourceSetImpl()); <|startfocus|> if (resource != null) { <|endfocus|> // contribution have been redefined try { contributions = loadConfigurationModel(resource); } catch (IOException e) { Activator.log.error(e); } } else { contributions = descriptor.getDiagram().getPalettes(); }
<|startcomment|> volatile? <|endcomment|> import org.osgi.framework.Bundle; /** * Class for project elements of type analysis modules * * @author Genevive Bastien * @since 2.0 */ public class TmfAnalysisElement extends TmfProjectModelElement implements ITmfStyledProjectModelElement, IPropertySource2 { private static final Styler ANALYSIS_CANT_EXECUTE_STYLER = new Styler() { @Override public void applyStyles(TextStyle textStyle) { textStyle.strikeout = true; } }; private final @NonNull IAnalysisModuleHelper fAnalysisHelper; <|startfocus|> private boolean fCanExecute = true; <|endfocus|> private static final String ANALYSIS_PROPERTIES_CATEGORY = Messages.TmfAnalysisElement_AnalysisProperties; private static final String HELPER_PROPERTIES_CATEGORY = Messages.TmfAnalysisElement_HelperProperties; /** * Constructor * * @param name * Name of the analysis * @param resource * The resource * @param parent * Parent of the analysis * @param module * The analysis module helper * @since 2.0 */ protected TmfAnalysisElement(String name, IResource resource, TmfViewsElement parent, @NonNull IAnalysisModuleHelper module) {
<|startcomment|> Please use {} brackets for the if body <|endcomment|>  compPart.setLabel(originalPart.getLabel()); compPart.setTooltip(originalPart.getTooltip()); compPart.setIconURI(originalPart.getIconURI()); compPart.setCloseable(true); compPart.setContributionURI("bundleclass://org.eclipse.e4.ui.workbench.addons.swt/org.eclipse.e4.ui.workbench.addons.splitteraddon.SplitHost"); //$NON-NLS-1$ // Check if icon from MPart was overridden Object overriddenImage = originalPart.getTransientData().get(IPresentationEngine.OVERRIDE_ICON_IMAGE_KEY); <|startfocus|> if (overriddenImage != null) <|endfocus|> compPart.getTransientData().put(IPresentationEngine.OVERRIDE_ICON_IMAGE_KEY, overriddenImage); // Always remove the composite part from the model compPart.getTags().add(EPartService.REMOVE_ON_HIDE_TAG); return compPart;
<|startcomment|> Ok... that's a way to make sure the test passes without fixing anything... :p <|endcomment|>  public long getMinEnd() { <|startfocus|> return fMinEnd != null ? fMinEnd : getNodeStart() + 1; <|endfocus|>
<|startcomment|> Remove* <|endcomment|>  public boolean canExecute() { for (TmfAnalysisElement analysis : fContainedAnalyses) { if (analysis.canExecute()) { return true; } } return super.canExecute(); } /** * Add an analysis element that is combined in the compound element. * * @param element * analysis element to add */ public void addAnalyses(@NonNull TmfAnalysisElement element) { fContainedAnalyses.add(element); } /** <|startfocus|> * Add an analysis element that is combined in the compound element. <|endfocus|> * * @param element * analysis element to add */ public void removeAnalyses(@NonNull TmfAnalysisElement element) { fContainedAnalyses.remove(element); } // ------------------------------------------------------------------------ // Operations // ------------------------------------------------------------------------ /** * Gets the help message for this analysis * * @return The help message */ @Override public String getHelpMessage() { Set<String> messages = new HashSet<>(); for (TmfAnalysisElement analysis : fContainedAnalyses) { messages.add(analysis.getHelpMessage()); }
<|startcomment|> This exception is logged. To avoid confusion when one looks at the build console log, it _must_ have a message stating that this exception was thrown on purpose. <|endcomment|>  public String getMessage(IResource[] resources) { <|startfocus|> throw new RuntimeException(); <|endfocus|>
<|startcomment|> same here, contributor should be you <|endcomment|>  * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Eike Stepper - initial API and implementation *******************************************************************************/ package org.eclipse.emf.ecp.workspace.internal.ui; import org.eclipse.core.runtime.CoreException; import org.eclipse.core.runtime.IStatus; import org.eclipse.core.runtime.Plugin; import org.eclipse.core.runtime.Status; import org.eclipse.jface.resource.ImageDescriptor; import org.osgi.framework.BundleContext; /** * The activator class controls the plug-in life cycle. * <|startfocus|> * @author Eike Stepper <|endfocus|> */ public final class Activator extends Plugin { /** * The plug-in ID. */ public static final String PLUGIN_ID = "org.eclipse.emf.ecp.workspace.ui.rap"; //$NON-NLS-1$ private static Activator instance; /** * The constructor. */ public Activator() { } // BEGIN SUPRESS CATCH EXCEPTION @Override public void start(BundleContext context) throws Exception { super.start(context); instance = this; } @Override public void stop(BundleContext context) throws Exception { instance = null;
<|startcomment|> javadoc <|endcomment|>  // } } return this.listenFeatures; } /** * @see org.eclipse.papyrus.infra.emf.nattable.manager.axis.AbstractSynchronizedOnEStructuralFeatureAxisManager#verifyFeatureMultiplicity() * */ @Override protected void verifyFeatureMultiplicity() { // nothing to do } /** * @see org.eclipse.papyrus.infra.emf.nattable.manager.axis.AbstractSynchronizedOnEStructuralFeatureAxisManager#verifyValues() * */ @Override protected void verifyValues() { // nothing to do } <|startfocus|> // TODO : override init <|endfocus|> @Override protected List<Object> getFeaturesValue() { getListenFeatures();// for initialization final List<Object> values = new ArrayList<Object>(); for (final EObject source : getColumnSources()) { values.addAll(getListenFeatureValueFor(source)); } return values; } protected List<Object> getListenFeatureValueFor(final EObject listenObject) { // TODO : decide if we are working on EObject or on Object final List<Object> values = new ArrayList<Object>(); for (final TreeFillingConfigurationHelper current : this.map.values()) {
<|startcomment|> fTraceElements = new ArrayList<>(traces); ? spare yourself a copy or two <|endcomment|>  private SelectTracesOperation(TmfExperimentElement experimentElement, TmfTraceFolder parentTraceFolder, TmfTraceElement[] traces, List<IResource> resources, Map<String, TmfTraceElement> previousTraces, ITmfTimestamp startTimeRange, ITmfTimestamp endTimeRange) { fExperimentElement = experimentElement; fParentTraceFolder = parentTraceFolder; if (traces == null) { fTraceElements = null; } else { <|startfocus|> fTraceElements = new ArrayList<>(); fTraceElements.addAll(Arrays.asList(traces)); <|endfocus|> } fResources = resources; fPreviousTraces = previousTraces; fStartTimeRange = startTimeRange; fEndTimeRange = endTimeRange;
<|startcomment|> Should be "equalsIgnoreCase" :) <|endcomment|>  if (!processedTypes.add(superClass)) { continue; } Collection<IType> types = null; if (cache == null) { IDLTKSearchScope scope = SearchEngine.createSearchScope(type.getScriptProject()); IType[] superTypes = PHPModelAccess.getDefault().findTypes(superClass, MatchRule.EXACT, 0, Modifiers.AccNameSpace, scope, null); List<IType> list = new ArrayList<IType>(); for (IType superType : superTypes) { <|startfocus|> if (superClass.equals(PHPModelUtils.getFullName(superType))) { <|endfocus|> list.add(superType); } } types = fileNetworkFilter(type.getSourceModule(), list, null, monitor); } else { String namespaceName = null; int i = superClass.lastIndexOf(NamespaceReference.NAMESPACE_SEPARATOR); if (i != -1) { namespaceName = superClass.substring(0, i); superClass = superClass.substring(i + 1); } types = cache.getClassesOrInterfaces(type.getSourceModule(), superClass, namespaceName, monitor); } if (types != null) {
<|startcomment|> remove this tab, ctrl-shift-f should fix it. <|endcomment|>  } else if ("txt".equals(FilenameUtils.getExtension(fileName))) { //$NON-NLS-1$ results = FunctionNameMapper.mapFromNmTextFile(file); } // results is null if mapping file is invalid if (results != null) { MappingFile mappingFile = new MappingFile(file.getAbsolutePath(), isBinaryFile, results); List<MappingFile> mappingFiles = TmfTraceManager.getInstance().getCurrentTraceContext().getMappingFiles(); if (!mappingFiles.contains(mappingFile)) { <|startfocus|> mappingFiles.add(mappingFile); <|endfocus|> } } else { invalidFiles.add(fullPath); } } if (!invalidFiles.isEmpty()) { displayErrorMessage(invalidFiles); } fMappingTable.refresh();
<|startcomment|> the <|endcomment|>  private static void tryReadBoundsFile(TmfTraceElement traceElement, File boundsFile) { if (boundsFile.exists()) { /* * We have already read the start and end times for this trace, we <|startfocus|> * can get them from he supplementary file. <|endfocus|> */ try { byte[] bytes = Files.readAllBytes(boundsFile.toPath()); ByteBuffer readBuffer = ByteBuffer.allocate(2 * Long.BYTES); readBuffer.put(bytes); readBuffer.flip(); /* * If MIN_VALUE was written, then the bounds could not be read. */ long tmp = readBuffer.getLong(); if (tmp == Long.MIN_VALUE) { traceElement.setStartTime(TmfTimestamp.BIG_BANG); } else { traceElement.setStartTime(TmfTimestamp.fromNanos(tmp)); } tmp = readBuffer.getLong(); if (tmp == Long.MIN_VALUE) { traceElement.setEndTime(TmfTimestamp.BIG_BANG); } else { traceElement.setEndTime(TmfTimestamp.fromNanos(tmp)); } traceElement.refresh(); } catch (IOException e) { boundsFile.delete();
<|startcomment|> logger placeholder is only {}, not {0} <|endcomment|>  } return; } if (!ci.isInstanciable()) { if (LOG.isDebugEnabled()) { LOG.debug("Skipping bean candidate '{}' because it is not instanciable.", ci.name()); } return; } if (!(ci.hasNoArgsConstructor() || ci.hasInjectableConstructor())) { if (LOG.isDebugEnabled()) { <|startfocus|> LOG.debug("Skipping bean candidate '{0}' because it has no empty or injectable constructor().", ci.name()); <|endfocus|> } return; } try { collector.add(ci.resolveClass()); } catch (Exception ex) { LOG.warn("Could not resolve class [{}]", ci.name(), ex); }
<|startcomment|> again, waituntil next refresh should go into the viewer, or else someone is going to spend an hour debugging why queries take at least 500ms <|endcomment|>  long currentEnd = Math.max(ss.getStartTime(), start); if (currentEnd >= end) { return null; } long traceStart = Math.max(cpuFilter.getExperimentInterval().getStartTime(), ss.getStartTime()); long traceEnd = cpuFilter.getExperimentInterval().getEndTime(); long offset = filter.getOffset(); String selectedThread = ((AnalysisSelectedCpuQueryFilter) filter).getSelectedThread(); boolean complete = ss.waitUntilBuilt(BUILD_UPDATE_TIMEOUT); currentEnd = ss.getCurrentEndTime(); /* Initialize the data */ <|startfocus|> Map<String, Long> cpuUsageMap = fModule.getCpuUsageInRange(cpus, Math.max(start, traceStart), Math.min(end, traceEnd)); <|endfocus|> Map<String, String> totalEntries = new HashMap<>(); Map<String, double[]> temp = new HashMap<>(); temp.put(CpuUsage_Title, fillArrayWithZero(xvalues.length)); if (selectedThread != NOT_SELECTED) { temp.put(selectedThread, fillArrayWithZero(xvalues.length)); } for (Entry<String, Long> entry : cpuUsageMap.entrySet()) { /*
<|startcomment|> You need to check if callback is actually allocated, and throw an error if it is not. (e.g see above). like: if (keysChangedCallback == 0) error (SWT.ERROR_NO_MORE_CALLBACKS); <|endcomment|>  if (signalProc == 0) error (SWT.ERROR_NO_MORE_CALLBACKS); OS.gtk_widget_add_events (shellHandle, OS.GDK_PROPERTY_CHANGE_MASK); OS.g_signal_connect (shellHandle, OS.property_notify_event, signalProc, PROPERTY_NOTIFY); latinKeyGroup = findLatinKeyGroup (); keysChangedCallback = new Callback (this, "keysChangedProc", 2); //$NON-NLS-1$ keysChangedProc = keysChangedCallback.getAddress (); <|startfocus|> OS.g_signal_connect (OS.gdk_keymap_get_default (), OS.keys_changed_event, keysChangedProc, 0); <|endfocus|> } /** + * Determine key group of Latin layout + * @return Latin key group + */ protected int findLatinKeyGroup () { int result = 0; Map /*<Integer, Integer>*/ groupKeysCount = new HashMap (); long /*int*/ keymap = OS.gdk_keymap_get_default (); // count all key groups for Latin alphabet for (int keyval = OS.GDK_KEY_a; keyval <= OS.GDK_KEY_z; keyval++) { long /*int*/[] keys = new long /*int*/[1];
<|startcomment|> not very explicit argument why not interpretedExpToTest <|endcomment|>  * Test checking the variable types are correctly infered when validating a VSM. * * @author jmallet */ @RunWith(value = Parameterized.class) public class VSMVariableTypesValidationTest { /** * This VSM is conform to some specific conventions to make it easy to test the type analysis of variables in a VSM. */ private static final String ORG_ECLIPSE_SIRIUS_TESTS_JUNIT_DATA_UNIT_VSM_VALIDATE_VARIABLE_TYPES_ODESIGN = "/org.eclipse.sirius.tests.tree/data/unit/vsm/validateVariableTypeTree.odesign"; <|startfocus|> private InterpretedExpression underTest; <|endfocus|> public VSMVariableTypesValidationTest(InterpretedExpression expression) { this.underTest = expression; } @Parameters(name = "org.eclipse.sirius.tests.unit.tree.vsm.edit.VSMVariableTypesValidationTest.{index}: ({0})") public static Collection<Object[]> data() throws IOException { URI uri = URI.createPlatformPluginURI(ORG_ECLIPSE_SIRIUS_TESTS_JUNIT_DATA_UNIT_VSM_VALIDATE_VARIABLE_TYPES_ODESIGN, true); List<Object[]> parameters = Lists.newArrayList(); Group group = loadVSM(uri); if (group != null) {
<|startcomment|> could probably be removed. <|endcomment|>  TmfCommonXAxisModel model = extractModelFromChart(chart); String current = fGson.toJson(model); assertEquals(expected, current); /* Change time range where there is disks activity */ TmfSignalManager.dispatchSignal(new TmfWindowRangeUpdatedSignal(this, new TmfTimeRange(START_TIME, END_TIME))); WaitUtils.waitUntil(c -> c.getSeriesSet().getSeries().length > 0, chart, "No data available"); fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); <|startfocus|> UIThreadRunnable.syncExec(chartViewer::refresh); <|endfocus|> /* Test type, style and color of series */ verifyChartStyle(chart); /* Test data model*/ expected = FileUtils.read("resources/disk1-res50.json"); model = extractModelFromChart(chart); current = fGson.toJson(model); assertEquals(expected, current); fBot.waitUntil(ConditionHelpers.windowRange(new TmfTimeRange(START_TIME, END_TIME))); /* * Change Zoom and number of points */ chartViewer.setNbPoints(MORE_POINTS); fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); UIThreadRunnable.syncExec(chartViewer::refresh); 
<|startcomment|> what is this try finally for? <|endcomment|>  /* Test data model */ WaitUtils.waitUntil(json -> isChartDataValid(chart, json), "resources/disk1-res50.json", "Chart data is not valid"); /* Change Zoom and number of points */ chartViewer.setNbPoints(MORE_POINTS); /* Test type, style and color of series */ verifyChartStyle(chart); <|startfocus|> /* Test data model */ WaitUtils.waitUntil(json -> isChartDataValid(chart, json), "resources/disk2-res100.json", "Chart data is not valid"); } finally { } <|endfocus|> } private static boolean isChartDataValid(final Chart chart, String expectedJson) { /** * FIXME : Once CQ for Jackson is approved, use deserialization instead of * comparing strings */ String expected = FileUtils.read(expectedJson); TmfCommonXAxisModel model = extractModelFromChart(chart); String current = fGson.toJson(model); return expected.equals(current); } /** * From a SWT Chart, this method extract a {@link TmfCommonXAxisModel} that
<|startcomment|> Rename to char or character <|endcomment|>  private void pasteLiteral(Display display) { Clipboard clipboard = new Clipboard(display); TextTransfer textTransfer = TextTransfer.getInstance(); String clipboardText = (String) clipboard.getContents(textTransfer); clipboard.dispose(); if (clipboardText != null) { StringBuffer out = new StringBuffer(); char[] chars = clipboardText.toCharArray(); boolean lastWasBackslash = false; <|startfocus|> for (char c : chars) { if (c == '\\') { <|endfocus|> if (lastWasBackslash) { out.append(c); lastWasBackslash = false; } else { lastWasBackslash = true; } } else { out.append(c); } } txt_RegExp.insert(out.toString()); }
<|startcomment|> to make more readable for weird named branches "<h1>Features for the branch [%s]</h1>" <|endcomment|>  public String getViewTable() { StringBuilder html = new StringBuilder( "<!DOCTYPE html><html><head><style> table { border-spacing: 0px } th,td { padding: 3px; } </style></head><body>"); List<BranchViewData> views = this.getViews(); ApplicabilityQuery applicabilityQuery = orcsApi.getQueryFactory().applicabilityQuery(); for (BranchViewData branchView : views) { if (branchView.getBranch().equals(branch)) { <|startfocus|> html.append(String.format("<h1>Features for the %s branch</h1>", <|endfocus|> orcsApi.getQueryFactory().branchQuery().andId(branch).getResults().getExactlyOne().getName())); html.append("<table border=\"1\">"); List<ArtifactId> branchViews = branchView.getBranchViews(); List<ArtifactReadable> featureDefinitionArts = orcsApi.getQueryFactory().fromBranch(branch).andIsOfType( CoreArtifactTypes.FeatureDefinition).getResults().getList(); List<FeatureDefinitionData> featureDefinitionData = applicabilityQuery.getFeatureDefinitionData(featureDefinitionArts); 
<|startcomment|> (See previous comment for why we don't want to do this.) <|endcomment|>  public IStatus runOnAST(ILanguage lang, IASTTranslationUnit ast) throws CoreException { if (ast == null) { return navigateWithoutAst(); } int selectionStart = fTextSelection.getOffset(); int selectionLength = fTextSelection.getLength(); final IASTNodeSelector nodeSelector = ast.getNodeSelector(null); IASTName sourceName = nodeSelector.findEnclosingName(selectionStart, selectionLength); IName[] implicitTargets = findImplicitTargets(ast, nodeSelector, selectionStart, selectionLength); <|startfocus|> if (sourceName == null || implicitTargets.length > 0) { <|endfocus|> if (navigateViaCElements(fTranslationUnit.getCProject(), fIndex, implicitTargets)) return Status.OK_STATUS; } else { boolean found= false; final IASTNode parent = sourceName.getParent(); if (parent instanceof IASTPreprocessorIncludeStatement) { openInclude(((IASTPreprocessorIncludeStatement) parent)); return Status.OK_STATUS; } else if (parent instanceof ICPPASTTemplateId) { sourceName = (IASTName) parent; } NameKind kind = getNameKind(sourceName); IBinding b = sourceName.resolveBinding(); IBinding[] bindings = new IBinding[] { b }; if (b instanceof IProblemBinding) {
<|startcomment|> Add 2017 to copyright year. <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2016 Red Hat Inc. and others <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Sopot Cela (Red Hat Inc.) * Lucas Bullen (Red Hat Inc.) - [Bug 520004] respect tag hierarchy *******************************************************************************/ package org.eclipse.pde.internal.genericeditor.target.extension.autocomplete.processors; import java.util.ArrayList; import java.util.List; import org.eclipse.jface.text.contentassist.CompletionProposal; import org.eclipse.jface.text.contentassist.ICompletionProposal; import org.eclipse.pde.internal.genericeditor.target.extension.model.ITargetConstants; import org.eclipse.pde.internal.genericeditor.target.extension.model.LocationsNode; import org.eclipse.pde.internal.genericeditor.target.extension.model.Node; import org.eclipse.pde.internal.genericeditor.target.extension.model.TargetNode; import org.eclipse.pde.internal.genericeditor.target.extension.model.xml.Parser; /**
<|startcomment|> delete those line to cleanup <|endcomment|>  if (e.time - focusGainedAt < 100) { Display.getDefault().asyncExec(new Runnable() { public void run() { // set focus again to get a new focus lost event selectionMenu.getTableViewer().getTable().setFocus(); } }); } else { exitItem(); } } public void focusGained(FocusEvent e) { focusGainedAt = e.time; } }); // selectionMenu.addKeyListener(new NavigationMenuKeyListener(this)); <|startfocus|> // selectionMenu.addMouseTrackListener(new SelectionMenuMouseTrackListener(DefaultNavigationMenu.this, selectionMenu, subMenus, umlElement)); <|endfocus|>
<|startcomment|> Should be 3.14 (same as version in MANIFEST.MF) <|endcomment|> import org.eclipse.jface.text.Position; import org.eclipse.swt.custom.StyleRange; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.dialogs.FilteredResourcesSelectionDialog; import org.eclipse.ui.tests.harness.util.DisplayHelper; import org.eclipse.ui.tests.harness.util.UITestCase; /** * Tests that resources are highlighted to match user search input. See Bug * 519525, 520250, and 520251 for references. * <|startfocus|> * @since 3.0 <|endfocus|> */ public class ResourceItemLabelTest extends UITestCase { /** * Constructs a new instance of <code>ResourceItemlLabelTest</code>. * * @param name * The name of the test to be run. */ public ResourceItemLabelTest(String name) { super(name); } private IProject project; @Override protected void doSetUp() throws Exception { super.doSetUp(); project = ResourcesPlugin.getWorkspace().getRoot() .getProject(getClass().getName() + "_" + System.currentTimeMillis());
<|startcomment|> latest *supported* <|endcomment|>  * as a sequence of class body declarations. */ public static final int K_CLASS_BODY_DECLARATIONS = 0x04; /** * Kind constant used to request that the source be parsed * as a compilation unit. */ public static final int K_COMPILATION_UNIT = 0x08; /** <|startfocus|> * Creates a new object for creating a Java abstract syntax tree * (AST) following the specified set of API rules. * The parser will use the latest JLS level. * <|endfocus|> * @return new ASTParser instance * * @since 3.14 * @see ASTParser#ASTParser(int) */ public static ASTParser newParser() { return new ASTParser(AST.JLS_LATEST); } /** * Creates a new object for creating a Java abstract syntax tree * (AST) following the specified set of API rules. * * @param level the API level; one of the <code>.JLS*</code> level constants * declared on {@link AST} * @return new ASTParser instance
<|startcomment|> I think it should not be hidden. If it is hidden the user won't be able to see it in Eclipse after removing ".* resources" filter. With this it would be possible to delete the folder from within Eclipse (since we don't have another way implemented yet) <|endcomment|>  // TraceFileSystemElements SubMonitor archiveMonitor = SubMonitor.convert(subMonitor.newChild(ARCHIVE_OR_DIRECTORY_PROGRESS), 2); if (fKeepArchive) { fImportOptionFlags |= ImportTraceWizardPage.OPTION_KEEP_EXTRACTED_ARCHIVE; fImportOptionFlags |= ImportTraceWizardPage.OPTION_CREATE_LINKS_IN_WORKSPACE; IFolder extractedFolder = fTraceFolderElement.getProject().getResource().getFolder(EXTRACTED_ARCHIVE_FOLDER); if(!extractedFolder.exists()) { monitor = archiveMonitor.newChild(1); <|startfocus|> extractedFolder.create(IResource.HIDDEN, true, monitor); <|endfocus|> } destTempFolder = extractedFolder.getFolder(fFolderName); if (!destTempFolder.exists()) { monitor = archiveMonitor.newChild(1); destTempFolder.create(IResource.HIDDEN, true, monitor); } } // Extract selected files from source archive to temporary // folder extractArchiveContent(selectedFileSystemElements.iterator(), destTempFolder, archiveMonitor.newChild(1)); archiveMonitor.subTask(""); //$NON-NLS-1$ if (!selectedFileSystemElements.isEmpty()) { // Even if the files were extracted to temporary folder, they
<|startcomment|> use File.getPah() instead ? <|endcomment|> <|startfocus|> private static String pathToString(File more) { return more.toPath().toString().replace(File.separatorChar, '/'); <|endfocus|>
<|startcomment|> if (monitor.isCanceled()) { return; } <|endcomment|>  * yet, the list will be empty in that case. */ for (ITmfStateSystem ss : module.getStateSystems()) { complete &= ss.waitUntilBuilt(0); end = Long.max(end, ss.getCurrentEndTime()); getOrCreateStateSystemEntry(moduleEntry, ss); } } traceEntry.updateEndTime(end); long resolution = Long.max(1, (end - start) / getDisplayWidth()); zoomEntries(Utils.flatten(traceEntry), start, end, resolution, monitor); <|startfocus|> <|endfocus|> if (parentTrace == getTrace()) { synchronized (this) { setStartTime(Long.min(getStartTime(), start)); setEndTime(Long.max(getEndTime(), end)); } refresh(); } if (!complete) { try { Thread.sleep(ITERATION_WAIT); } catch (InterruptedException e) { Activator.getDefault().logError("Failed to wait", e); //$NON-NLS-1$ } } }
<|startcomment|> take care of white-space at line end (multiple times in file) <|endcomment|> import org.eclipse.uml2.uml.UMLPackage; /** * Auto-completion styled text * The main difference with {@link CompletionStyledTextStringEditor} is that * this editor isn't intended to binded in Papyrus Properties fwk */ public class AutoCompleteStyledTextStringEditor extends StyledTextStringEditor { private static final String CONTENT_ASSIST_COMMAND_ID = "org.eclipse.ui.edit.text.contentAssist.proposals"; //$NON-NLS-1$ /** * This wrapper provides a text field with completion */ private TextViewer wrapper; <|startfocus|> <|endfocus|> protected INameResolutionHelper nameResolutionHelper; private ContentAssistant assistant; private UMLReferenceContentAssistProcessor processor; /** * @return the nameResolutionHelper */ public INameResolutionHelper getNameResolutionHelper() { return nameResolutionHelper; } /** * Initial value for texte * * @param value */ @Override public void setValue(Object value) { if (value instanceof NamedElement) { super.setValue(((NamedElement) value).getName()); } super.setValue(value); } /** * 
<|startcomment|> isPhotonPlatformOrLater() would be more exact (same remark for isOxygenPlatform). The others "isJuno3" etc. are obsolete anyway, Sirius 6 will only support Oxygen & Photon. Only change the Photon one in this patch, we'll do a separate cleanup to remove the historical cruft. <|endcomment|> <|startfocus|> public static boolean isPhotonPlatform() { <|endfocus|> return checkUiWorkbenchVersion(Version.parseVersion(UI_WORKBENCH_PHOTON_START), null);
<|startcomment|> why define that templates are in a HashSet and not only a Set? Why use a HashMap and not a LinkedHashMap <|endcomment|>  * * @author Mat Hansen <mhansen@eclipsesource.com> * @since 1.15 * */ @Component(service = { TemplateProvider.class, TransientRuntimeTemplateProvider.class }) public class TransientRuntimeTemplateProvider implements TemplateProvider, TemplateCreator { /** * The priority of all templates provided by this provider. */ public static final int TRANSIENT_TEMPLATE_PRIORITY = BlankTemplateProvider.BLANK_TEMPLATE_PRIORITY + 1000; <|startfocus|> private final Map<EClass, HashSet<Template>> templates = new HashMap<EClass, HashSet<Template>>(); <|endfocus|> @Override public boolean canProvide(EObject eObject, EReference eReference) { return hasTemplateForType(eReference.getEReferenceType()); } /** * Checks whether the template provider has templates matching the given (super) type. * * @param superType the type to match for * @return true if templates exist */ protected boolean hasTemplateForType(EClass superType) { // if the given type is not abstract and we have a key for it, then we surely can provide a template
<|startcomment|> declare variable here <|endcomment|>  * @return The registered content service for the given viewer id. */ public synchronized INavigatorContentService findService(String aViewerId) { if(aViewerId == null || aViewerId.length() == 0) { return null; } INavigatorContentService contentService; for (Iterator<WeakReference<INavigatorContentService>> iter = registeredContentServices.iterator(); iter.hasNext();) { <|startfocus|> WeakReference ref = iter.next(); contentService = (INavigatorContentService) ref.get(); <|endfocus|> if (contentService == null) { iter.remove(); } else if (aViewerId.equals(contentService.getViewerId())) { return contentService; } } return null; } } 
<|startcomment|> This should use transitionMap instead. <|endcomment|>  public boolean containsFrom(final ActivationState state) { <|startfocus|> return transitions.stream().anyMatch(tr -> Objects.equals(tr.from, state)); <|endfocus|>
<|startcomment|> it does not implement anything, represents the description of maybe <|endcomment|> ***************************************************************************** * Copyright (c) 2018 Ericsson * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ package org.eclipse.tracecompass.internal.tmf.analysis.xml.core.module; import java.util.Set; import org.eclipse.jdt.annotation.NonNull; /** <|startfocus|> * Implements an xml analyses output <|endfocus|> * * @author Jean-Christian Kouame */ public class XmlOutputElement { private String fPath; private String fXmlElem; private String fId; private String fLabel; private Set<String> fAnalyses; /** * Constructor * * @param path * The xml file path * @param xmlElem * The xml output element type * @param id * The id of the xml outout * @param label * The xml output label * @param analyses * The analyses the output element applies to */
<|startcomment|> missing braces <|endcomment|>  walk.setRewriteParents(false); // exclude all remote ref's current state - no need to go // remote, we're only interested in our deltas. Map<String, Ref> rr = getRepository().getRefDatabase() .getRefs(Constants.R_REMOTES + (getRemoteName() == null ? Constants.DEFAULT_REMOTE_NAME : getRemoteName())); for (Ref r : rr.values()) { ObjectId oid = r.getPeeledObjectId(); if (oid == null) <|startfocus|> oid = r.getObjectId(); <|endfocus|> try { walk.markUninteresting(walk.parseCommit(oid)); } catch (IncorrectObjectTypeException e) { // Ignore all refs which are not commits } } // find all objects that changed, and find all LfsPointers in // there. walk.markStart(walk.parseCommit(up.getNewObjectId())); for (;;) { // walk all commits to populate objects if (walk.next() == null) break; } for (;;) { final RevObject obj = walk.nextObject();
<|startcomment|> 4.11 <|endcomment|>  */ public static final String OPTION_ALLOW_TIP_SHA1_IN_WANT = GitProtocolConstants.OPTION_ALLOW_TIP_SHA1_IN_WANT; /** * The client supports fetching objects that are reachable from a tip of a * ref that is allowed to fetch. * @since 4.1 */ public static final String OPTION_ALLOW_REACHABLE_SHA1_IN_WANT = GitProtocolConstants.OPTION_ALLOW_REACHABLE_SHA1_IN_WANT; /** * The client specified a filter expression. * <|startfocus|> * @since 4.10 <|endfocus|> */ public static final String OPTION_FILTER = GitProtocolConstants.OPTION_FILTER; private final RevWalk walk; /** All commits that are immediately reachable by a local ref. */ private RevCommitList<RevCommit> reachableCommits; /** Marks an object as having all its dependencies. */ final RevFlag REACHABLE; /** Marks a commit known to both sides of the connection. */ final RevFlag COMMON; /** Like {@link #COMMON} but means its also in {@link #pckState}. */ private final RevFlag STATE; 
<|startcomment|> 2018? <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2017 cole Polytechnique de Montral <|endfocus|> * * All rights reserved. This program and the accompanying materials are * made available under the terms of the Eclipse Public License v1.0 which * accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html *******************************************************************************/ @org.eclipse.jdt.annotation.NonNullByDefault package org.eclipse.tracecompass.incubator.internal.ftrace.core; 
<|startcomment|> We should avoid to instantiate this class just to reuse a runnable that execute just one line. <|endcomment|>  swtBotGefEditPart = paletteRootEditPartBot.children().iterator().next().children().get(0).children().get(1); assertEquals("The wrong tool is used.", "ToolEntryEditPart( Palette Entry (Zoom In) )", swtBotGefEditPart.part().toString()); EditPart part = swtBotGefEditPart.part(); final PaletteViewer viewer = (PaletteViewer) swtBotGefEditPart.part().getViewer(); final ToolEntry toolEntry = (ToolEntry) part.getModel(); <|startfocus|> DiagramMouseZoomTest diagramMouseZoomTest = new DiagramMouseZoomTest(); PaletteButtonActivation paletteButtonActivation = diagramMouseZoomTest.new PaletteButtonActivation(viewer, toolEntry); editor.bot().getDisplay().asyncExec(paletteButtonActivation); <|endfocus|> editor.drag(new Point(0, 0), new Point(176, 176)); checkExpected(diagramPart);
<|startcomment|> use existing constants <|endcomment|>  .getConnectionFactory().create(contentUrl, HttpSupport.proxyFor(ProxySelector.getDefault(), contentUrl)); contentServerConn.setRequestMethod(HttpSupport.METHOD_PUT); uploadAction.header.forEach( (k, v) -> contentServerConn.setRequestProperty(k, v)); if (contentUrl.getProtocol().equals("https") //$NON-NLS-1$ && !getRepository().getConfig().getBoolean("http", "sslVerify", true)) { //$NON-NLS-1$ //$NON-NLS-2$ HttpSupport.disableSslVerify(contentServerConn); } contentServerConn.setRequestProperty(HDR_ACCEPT_ENCODING, ENCODING_GZIP); <|startfocus|> contentServerConn.setDoOutput(true); <|endfocus|> Path path = lfs.getMediaFile(ptr.getOid()); if (!Files.exists(path)) { throw new IOException(MessageFormat .format(LfsText.get().missingLocalObject, path)); } try (OutputStream contentOut = contentServerConn .getOutputStream()) { long bytesCopied = Files.copy(path, contentOut); if (bytesCopied != o.size) { throw new IOException(MessageFormat.format( LfsText.get().wrongAmoutOfDataWritten,
<|startcomment|> missing braces <|endcomment|>  final TreeSet<Ref> set = new TreeSet<>(new Comparator<Ref>() { @Override public int compare(Ref o1, Ref o2) { // lexicographical ordering by name seems to be fine return o1.getName().compareTo(o2.getName()); } }); set.addAll(refs); if (HEAD != null) set.add(HEAD); final List<RefContentProposal> result = new ArrayList<>( set.size()); <|startfocus|> for (final Ref r : set) <|endfocus|> result.add(new RefContentProposal(localDb, r, HEAD == null)); return result;
<|startcomment|> Should this be a try-with-resources? Otherwise Git would be leaked if an exception is thrown. <|endcomment|>  bareProjects = new ArrayList<RepoProject>(); if (author == null) author = new PersonIdent(repo); if (callback == null) callback = new DefaultRemoteReader(); } else git = new Git(repo); ManifestParser parser = new ManifestParser( includedReader, path, branch, uri, groupsParam, repo); try { parser.read(inputStream); for (RepoProject proj : parser.getFilteredProjects()) { addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), <|startfocus|> proj.getLinkFiles(), <|endfocus|> proj.getGroups(), proj.getRecommendShallow()); } } catch (GitAPIException | IOException e) { throw new ManifestErrorException(e); } } finally { try { if (inputStream != null) inputStream.close(); } catch (IOException e) { // Just ignore it, it's not important. } } if (repo.isBare()) { DirCache index = DirCache.newInCore(); DirCacheBuilder builder = index.builder();
<|startcomment|> maybe it's ok to support only one pre-push hook ? <|endcomment|>  public static PrePushHook prePush(Repository repo, PrintStream outputStream) { try { <|startfocus|> // TODO: this breaks all use cases except LFS, as it assumes that // LFS is the only pre-push hook that could possibly be there. <|endfocus|> StoredConfig cfg = repo.getConfig(); if (cfg.getBoolean(ConfigConstants.CONFIG_FILTER_SECTION, "lfs", //$NON-NLS-1$ ConfigConstants.CONFIG_KEY_USEJGITBUILTIN, false)) { @SuppressWarnings("unchecked") Class<? extends PrePushHook> cls = (Class<? extends PrePushHook>) Class .forName("org.eclipse.jgit.lfs.LfsPrePushHook"); //$NON-NLS-1$ Constructor<? extends PrePushHook> constructor = cls .getConstructor(Repository.class, PrintStream.class); return constructor.newInstance(repo, outputStream); } } catch (Exception e) { // no problem :) no LFS support present } return new PrePushHook(repo, outputStream);
<|startcomment|> s <|endcomment|>  if (ss != null) { int quark = ss.optQuarkAbsolute(Attributes.THREADS, Integer.toString((int) status), Attributes.EXEC_NAME); if (quark != ITmfStateSystem.INVALID_ATTRIBUTE) { ITmfStateInterval nameInterval = ss.querySingleState(endTime, quark); Object processName = nameInterval.getValue(); if (processName instanceof String) { return new TimeGraphState(startTime, duration, (int) status, (String) processName); } } } <|startfocus|> return new TimeGraphState(startTime, duration, (int) status); <|endfocus|> } return new TimeGraphState(startTime, duration, s); } return new TimeGraphState(startTime, duration, Integer.MIN_VALUE); } @Override public TmfModelResponse<List<ITimeGraphArrow>> fetchArrows(TimeQueryFilter filter, @Nullable IProgressMonitor monitor) { return new TmfModelResponse<>(null, ITmfResponse.Status.COMPLETED, CommonStatusMessage.COMPLETED); } @Override public @NonNull String getId() { return ID; } @Override public TmfModelResponse<Map<String, String>> fetchTooltip(@NonNull SelectionTimeQueryFilter filter, @Nullable IProgressMonitor monitor) {
<|startcomment|> Please do the refactoring in a separate commit <|endcomment|>  EcoreUtil.resolveAll(view); if (viewIsResolved(view)) { return Optional.of(view); } if (view.getEcorePaths() == null) { throw new FileNotFoundException(path); } for (final String ecorePath : view.getEcorePaths()) { if (ResourcesPlugin.getWorkspace().getRoot().findMember(ecorePath) == null) { throw new FileNotFoundException(path); } EcoreHelper.registerEcore(ecorePath); registeredEcores.add(ecorePath); } <|startfocus|> final Optional<VView> reloadView = loadView(URI.createFileURI(path)); if (reloadView.isPresent() && !viewIsResolved(reloadView.get())) { EcoreUtil.resolveAll(reloadView.get()); <|endfocus|> } return reloadView; } /** * Check whether the given view has been resolved, i.e. whether it is a proxy or not * * @param view the {@link VView} to be checked * @return {@code true}, if the view is not a proxy, {@code false} otherwise */ public static boolean viewIsResolved(VView view) {
<|startcomment|> this missing white space? <|endcomment|>  // display int cpu = tcEvent.getValue(); if (cpu >= 0) { Map<String, String> retMap = new LinkedHashMap<>(1); retMap.put(Messages.ResourcesView_attributeCpuName, String.valueOf(cpu)); return retMap; } } // Check for type CPU else if (resourcesModel.getType().equals(Type.CPU) || resourcesModel.getType().equals(Type.CURRENT_THREAD)) { <|startfocus|> int status = tcEvent.getValue(); <|endfocus|> ITimeGraphDataProvider<? extends TimeGraphEntryModel> provider = BaseDataProviderTimeGraphView.getProvider((TimeGraphEntry) entry); if (provider != null) { return getTooltipForCpu(provider, model.getId(), hoverTime, status); } } } } return Collections.emptyMap(); } private static Map<String, String> getTooltipForCpu(ITimeGraphDataProvider<? extends TimeGraphEntryModel> provider, long id, long hoverTime, int status) { SelectionTimeQueryFilter filter = new SelectionTimeQueryFilter(Collections.singletonList(hoverTime), Collections.singleton(id));
<|startcomment|> I forget why this was needed, what happens if you try to copy a symlink with IResource.copy()? <|endcomment|>  SubMonitor subMon = SubMonitor.convert(mon, 1); if (isFileSystemSymbolicLink(resource) && !resource.exists()) { // Broken link try { Path linkPath = Paths.get(resource.getProject().getLocation().append(resource.getProjectRelativePath()).toOSString()); Files.delete(linkPath); subMon.worked(1); return; } catch (IOException e) { // do nothing ... try Resource.delete() below } } resource.delete(true, subMon); } /** <|startfocus|> * Copy the resource from the file system. <|endfocus|> * * @param resource * the resource in the workspace representing the link * @param destinationPath * the destination path, it's the project relative path * @param flags * update flags according to IResource.copy(). * Note for file system symbolic links only IResource.SHALLOW is supported * @param monitor * the progress monitor * @return the copied resource or null * @throws CoreException * if an error occurs */
<|startcomment|> In the code brought in by rebase, this is now taken care of in the @After. <|endcomment|>  copiedAsNewItem.contextMenu().menu("Open").click(); SWTBotImportWizardUtils.testEventsTable(fBot, RENAMED_AS_NEW_TRACE_NAME, CUSTOM_TEXT_LOG.getNbEvents(), CUSTOM_TEXT_LOG.getFirstEventTimestamp()); // Make sure that the traces have the correct link status (linked or not) testLinkStatus(copiedItem, true); testLinkStatus(copiedAsNewItem, false); fBot.closeAllEditors(); <|startfocus|> SWTBotUtils.clearTracesFolderUI(fBot, TRACE_PROJECT_NAME); <|endfocus|> } /** * Test renaming of traces that are created with file system symbolic links. * * @throws CoreException * If error happens * @throws TmfTraceImportException * If error happens */ @Test public void testRenameSymbolicLinks() throws CoreException, TmfTraceImportException { // Create File system symbolic link to traces importTraceAsSymlink(); SWTBotTreeItem traceItem = SWTBotUtils.getTraceProjectItem(fBot, SWTBotUtils.selectTracesFolder(fBot, TRACE_PROJECT_NAME), TRACE_NAME); fBot.viewByTitle(PROJECT_EXPLORER_VIEW_NAME).setFocus(); traceItem.doubleClick();
<|startcomment|> add a TODO to remove this and have a mechanism to let the provider know if the analysis is completed (like the ss) so that it can return the correct status? and to avoid exposing the analysis in the view? <|endcomment|>  } /** * Returns the segment store provider * * @param trace * The trace to consider * @return the segment store provider * @deprecated This method is not used anymore as the analysisId is passed in the constructor */ @Deprecated protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) { return null; } @Override protected @Nullable ITmfTreeDataProvider<@NonNull TmfTreeDataModel> getProvider(@NonNull ITmfTrace trace) { <|startfocus|> // Add the listener to teh analysis module: <|endfocus|> IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, fAnalysisId); if (!(module instanceof ISegmentStoreProvider)) { return null; } fSegmentProvider = (ISegmentStoreProvider) module; ((ISegmentStoreProvider) module).addListener(fListener); return DataProviderManager.getInstance().getDataProvider(trace, SegmentStoreScatterDataProvider.ID, fAnalysisId, ITmfTreeXYDataProvider.class); } @Override protected ITmfTreeColumnDataProvider getColumnDataProvider() { return () -> ImmutableList.of(
<|startcomment|> use <code>null</code> <|endcomment|>  } /** * @param display the display the color is from * @return the default color to use for displaying errors. * @see ColorRegistry#get(String) * @see JFacePreferences#ERROR_COLOR */ public static Color getErrorText(Display display) { return JFaceResources.getColorRegistry().get( JFacePreferences.ERROR_COLOR); } /** * @param display * the display the color is from <|startfocus|> * @return the default color to use for displaying hyperlinks, , or null if the * color definition does not exists. <|endfocus|> * @see ColorRegistry#get(String) * @see JFacePreferences#HYPERLINK_COLOR */ public static Color getHyperlinkText(Display display) { return JFaceResources.getColorRegistry().get( JFacePreferences.HYPERLINK_COLOR); } /** * @param display * the display the color is from * @return the default color to use for displaying active hyperlinks, or null if * the color definition does not exists. * @see ColorRegistry#get(String)
<|startcomment|> if (inputStream == null) { ... } ? <|endcomment|>  public InputStream getInputStream() { <|startfocus|> if (logToFile || logToStderr) { inputStream = new FilterInputStream(provider.getInputStream()) { <|endfocus|> @Override public int read(byte[] b, int off, int len) throws IOException { int bytes = super.read(b, off, len); byte[] payload = new byte[bytes]; System.arraycopy(b, off, payload, 0, bytes); if (logToStderr) { System.err.println(id + " to LSP4E:" + new String(payload)); //$NON-NLS-1$ } if (logToFile) { log("\n" + id + " to LSP4E:" + new String(payload)); //$NON-NLS-1$ //$NON-NLS-2$ } return bytes; } }; } else { inputStream = provider.getInputStream(); } return inputStream;
<|startcomment|> Maybe use !projectsToDelete.isEmpty()? <|endcomment|>  private void updateUI() { // The user has to select the delete checkbox before OK can be clicked getButton(IDialogConstants.OK_ID).setEnabled(shouldDeleteGitDir); deleteWorkDir.setEnabled(shouldDeleteGitDir); deleteWorkDirLabel.setEnabled(shouldDeleteGitDir); removeProjects .setEnabled(shouldDeleteGitDir && !shouldDeleteWorkingDir); <|startfocus|> if (shouldDeleteWorkingDir && projectsToDelete.size() > 0) { <|endfocus|> removeProjects.setSelection(true); shouldRemoveProjects = true; } if (shouldDeleteGitDir) setMessage( UIText.DeleteRepositoryConfirmDialog_DeleteRepositoryNoUndoWarning, IMessageProvider.WARNING); else setMessage(UIText.DeleteRepositoryConfirmDialog_DeleteRepositoryConfirmMessage); if (projectsViewer != null) { projectsViewer.getControl().setEnabled(shouldRemoveProjects); }
<|startcomment|> Please use !string.isEmpty(). <|endcomment|>  public void setOS(String os) { incrementSequenceNumber(); fOS = os; <|startfocus|> if (fRoot != null && os != null && os.length() > 0) { <|endfocus|> Element nlNode = TargetDefinitionDocumentTools.getChildElement(fRoot, TargetDefinitionPersistenceHelper.ENVIRONMENT, TargetDefinitionPersistenceHelper.OS); nlNode.setTextContent(os); } else { removeElement(TargetDefinitionPersistenceHelper.ENVIRONMENT, TargetDefinitionPersistenceHelper.OS); }
<|startcomment|> provisional API in public API <|endcomment|>  nullTimeEvent.setPropertyStatus(IItemProperties.fullAlpha(), false); eventList.add(nullTimeEvent); } } } /** * Compute the predicate for every property regexes * * @return A map of time event filters predicate by property * @since 4.0 */ @NonNullByDefault <|startfocus|> protected Map<String, BiPredicate<@NonNull IItem, @NonNull Function<@NonNull IItem, @NonNull Map<@NonNull String, @NonNull String>>>> computeRegexPredicate() { <|endfocus|> Multimap<@NonNull String, @NonNull String> regexes = getRegexes(); Map<@NonNull String, @NonNull BiPredicate<@NonNull IItem, @NonNull Function<@NonNull IItem, @NonNull Map<@NonNull String, @NonNull String>>>> predicates = new HashMap<>(); for (Map.Entry<String, Collection<String>> entry : regexes.asMap().entrySet()) { for (String regex : Objects.requireNonNull(entry.getValue())) { if (regex.isEmpty()) { continue; } @Nullable BiPredicate<IItem, Function<IItem, Map<String, String>>> predicate = getPredicate(regex);
<|startcomment|> Ternary operator <|endcomment|>  private void setInitialItemsForProperties(EObject eObject) { <|startfocus|> Diff diff = eObject instanceof Diff ? (Diff)eObject : null; <|endfocus|> ancestorPropertyAccessor.setInitialItem(diff); leftPropertyAccessor.setInitialItem(diff); rightPropertyAccessor.setInitialItem(diff);
<|startcomment|> The filter seems to disappear when the view is minimized and restored (it does not restore with the previous filter). <|endcomment|>  fView.restartZoomThread(); } } }); // support close on escape button getShell().addListener(SWT.Traverse, e -> { if (e.detail == SWT.TRAVERSE_ESCAPE) { fRegex = EMPTY_STRING; fFilterRegexes.clear(); fView.restartZoomThread(); } }); fView.addPaintListener(event -> { Shell shell = getShell(); if (shell == null || shell.isDisposed()) { return; } <|startfocus|> shell.setLocation(fView.getFilterBounds()); <|endfocus|> }); for (String label : fFilterRegexes) { createCLabels(parent, labels, label); } return parent;
<|startcomment|> private static final <|endcomment|> import org.eclipse.ui.part.FileEditorInput; import com.google.common.collect.Iterables; /** * This class implements a preference page for XML analyses * * @author Jean-Christian Kouame * */ public class XMLAnalysesManagerPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { private static final int BUTTON_CHECK_SELECTED_ID = IDialogConstants.CLIENT_ID; private static final int BUTTON_UNCHECK_SELECTED_ID = IDialogConstants.CLIENT_ID + 1; <|startfocus|> private final String XML_FILTER_EXTENSION = "*.xml"; //$NON-NLS-1$ <|endfocus|> private Table fAnalysesTable; private Button fDeleteButton; private Button fImportButton; private Button fExportButton; private Button fEditButton; private Label fInvalidFileLabel; private Label fEnabledFileLabel; @Override public void init(IWorkbench workbench) { } @Override protected Control createContents(Composite parent) { getShell().setText(Messages.ManageXMLAnalysisDialog_ManageXmlAnalysesFiles); Composite mainComposite = new Composite(parent, SWT.NONE); mainComposite.setLayout(new GridLayout(2, false)); Composite tableContainer = new Composite(mainComposite, SWT.NONE);
<|startcomment|> Please also add a pointer to the method I'd use to register my hook to be used. <|endcomment|>  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package org.eclipse.jgit.transport; /** * Hook to allow callers to be notified on Git protocol v2 requests. <|startfocus|> * <|endfocus|> * @since 5.0 */ public interface ProtocolV2Hook { /** * The default hook implementation that does nothing. */ static ProtocolV2Hook DEFAULT = new ProtocolV2Hook() { // No override. }; /** * @throws ServiceMayNotContinueException * @since 5.0 */ default void onCapabilities() throws ServiceMayNotContinueException { // Do nothing by default. } /** * @param req * the ls-refs request * @throws ServiceMayNotContinueException
<|startcomment|> Setting the aspect ratio here has no effect on the produced base64 string. (The aspect ratio is only used if you provide the image separate from the HTML. The framework then needs to inject it into the HTML itself. It will set the width and height attributes of the image based on the available space in the dialog. Setting it to '1' means that the image height is equal to the width.) <|endcomment|>  public TipImage getImage() { if (tipImage == null) { Bundle bundle = FrameworkUtil.getBundle(getClass()); try { <|startfocus|> tipImage = new TipImage(bundle.getEntry("icons/48/tips.png")).setAspectRatio(1); <|endfocus|> } catch (IOException ex) { getManager().log(new Status(IStatus.ERROR, bundle.getSymbolicName(), ex.getMessage(), ex)); } } return tipImage;
<|startcomment|> variable*s* <|endcomment|>  * * The java.io.tmpdir should not be used on MacOs (does not work for classpath-only jars) * * @param processTempFilesDir */ public void setProcessTempFilesDir(File processTempFilesDir) { this.processTempFilesDir = processTempFilesDir; } public File getProcessTempFilesDir() { return processTempFilesDir; } /** * Get the new envp. May have been modified to shorten the classpath * <|startfocus|> * @return environment variable in the format name=value or null <|endfocus|> */ public String[] getEnvp() { return envp; } /** * Get the new command line. Modified if command line or classpath argument were too long * * @return the command line (java executable + VM arguments + program arguments) */ public String[] getCmdLine() { return cmdLine.toArray(new String[cmdLine.size()]); } /** * The files that were created while shortening the path. They can be deleted once the process is terminated *
<|startcomment|> What FieldEditor.load() does is check the current value of the preference in the IPreferenceStore, and update the UI of the field editor widget to reflect that value. So, if you're setting the value via IPreferenceStore, as the previous version of this patch did, then you need to call FieldEditor.load() to get the new value to be reflected in the UI. If, however, you're setting the displayed value of the field editor directly, as this version of the patch is doing, there is no need to call FieldEditor.load() (and in fact FieldEditor.load() will just overwrite the value you just set with the old value still stored in the IPreferenceStore). <|endcomment|>  public void propertyChange(PropertyChangeEvent event) { <|startfocus|> if(event.getProperty() == serverChoice.VALUE && event.getSource() == serverChoice) { serverPath.setStringValue(CPPStreamConnectionProvider.getDefaultLSLocation((String) event.getNewValue()).getAbsolutePath()); serverPath.load(); <|endfocus|> }
<|startcomment|> Please change the contributor tag to Thomas Singer (instead of Red Hat). <|endcomment|> ***************************************************************************** * Copyright (c) 2018 Red Hat and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: <|startfocus|> * Red Hat - initial API and implementation <|endfocus|> *******************************************************************************/ package org.eclipse.swt.tests.gtk.snippets; import org.eclipse.swt.SWT; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Table; import org.eclipse.swt.widgets.TableColumn; import org.eclipse.swt.widgets.TableItem; /** * @author Thomas Singer */ public class Bug127132_VirtualTablePackNPE { // Constants ============================================================== static final int COUNT1 = 1000;
<|startcomment|> white space after if <|endcomment|>  nodes.add(new TmfTreeDataModel(fTraceId, -1, String.valueOf(getTrace().getName()))); Map<IGroupingSegmentAspect, Map<String, Long>> names = new HashMap<>(); for (Entry<String, INamedSegment> series : segmentTypes.entrySet()) { long parentId = fTraceId; for (IGroupingSegmentAspect aspect : fGroupingAspects) { names.putIfAbsent(aspect, new HashMap<>()); Map<String, Long> map = names.get(aspect); <|startfocus|> if(map == null) { <|endfocus|> break; } String name = String.valueOf(aspect.resolve(series.getValue())); Long uniqueId = map.get(name); if (uniqueId == null) { uniqueId = getUniqueId(name); map.put(name, uniqueId); nodes.add(new TmfTreeDataModel(uniqueId, parentId, name)); } parentId = uniqueId; } long seriesId = getUniqueId(series.getKey()); nodes.add(new TmfTreeDataModel(seriesId, parentId, series.getKey())); } 
<|startcomment|> Broken header. <|endcomment|> ***************************************************************************** * Copyright (c) 2013 IBM Corporation and others. All rights reserved. * This program and the accompanying materials are made available under the * terms of the Eclipse Public License 2.0 which accompanies this distribution, <|startfocus|> t https://www.eclipse.org/legal/epl-2.0/ t t SPDX-License-Identifier: EPL-2.0 <|endfocus|> * * Contributors: IBM - Initial API and implementation ******************************************************************************/ package org.eclipse.osgi.compatibility.state; import org.osgi.framework.BundleActivator; import org.osgi.framework.BundleContext; public class Activator implements BundleActivator { private final PlatformAdminImpl platformAdmin = new PlatformAdminImpl(); @Override public void start(BundleContext context) throws Exception { platformAdmin.start(context); } @Override public void stop(BundleContext context) throws Exception { platformAdmin.stop(context); } } 
<|startcomment|> is this an expected case? If not an error log message should be added <|endcomment|>  if(0 == modelConnection.getDx2()) { //we have three segment connection check that we are not beyond the input newDx1 = Math.min(newDx1, destP.x - sourceP.x - MoveableRouter.MIN_CONNECTION_FB_DISTANCE); } modelConnection.setDx1(newDx1); break; case 2: modelConnection.setDy(point.y - sourceP.y); break; case 3: modelConnection.setDx2(Math.max(destP.x - point.x, MoveableRouter.MIN_CONNECTION_FB_DISTANCE)); break; <|startfocus|> default: <|endfocus|> break; } connection.revalidate();
<|startcomment|> Either fill in or remove empty javadoc <|endcomment|>  results.getAddedPatterns(uri).forEach( pattern -> { builder.addAddedSpecification(uri, getOrCreateQuerySpecification(pattern, results)); updateImpactCache(pattern); }); results.getUpdatedPatterns(uri).forEach( pattern -> { builder.addUpdatedSpecification(uri, getOrCreateQuerySpecification(pattern, results)); updateImpactCache(pattern); }); results.getImpactedPatterns(uri).forEach( pattern -> { builder.addImpactedSpecification(uri, getOrCreateQuerySpecification(pattern, results)); updateImpactCache(pattern); }); }); } <|startfocus|> /** * @param pattern */ <|endfocus|> private void removeFromImpactCache(Pattern pattern) { Set<URI> referredUris = PatternLanguageHelper.getReferencedPatternsTransitive(pattern).stream().map(p -> p.eResource().getURI()).collect(Collectors.toSet()); referredUris.forEach(u -> impactCache.remove(u, pattern)); } private void updateImpactCache(Pattern pattern) { impactCache.keySet().forEach(uri -> impactCache.remove(uri, pattern));
<|startcomment|> Document the time unit and allowed range. Seconds? Milliseconds? What if < 0? What if == 0? <|endcomment|> import org.eclipse.egit.gitflow.Activator; import org.eclipse.egit.gitflow.GitFlowConfig; import org.eclipse.egit.gitflow.GitFlowRepository; import org.eclipse.egit.gitflow.internal.CoreText; import org.eclipse.jgit.lib.BranchTrackingStatus; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.osgi.util.NLS; /** * git flow feature start */ public final class FeatureStartOperation extends AbstractFeatureOperation { private int timeout; /** * @param repository * @param featureName <|startfocus|> * @param timeout <|endfocus|> * @since 5.2 */ public FeatureStartOperation(GitFlowRepository repository, String featureName, int timeout) { super(repository, featureName); this.timeout = timeout; } /** * @param repository * @param featureName */ public FeatureStartOperation(GitFlowRepository repository, String featureName) { this(repository, featureName, -1); } @Override public void execute(IProgressMonitor monitor) throws CoreException { SubMonitor progress = SubMonitor.convert(monitor, 2); GitFlowConfig config = repository.getConfig();
<|startcomment|> More importantly, this is thread-safe. :) <|endcomment|>  u.add(new ByteArrayInputStream(new byte[] { 4, 5 })); assertEquals(0, u.skip(0)); assertEquals(3, u.skip(3)); assertEquals(3, u.read()); assertEquals(2, u.skip(5)); assertEquals(0, u.skip(5)); assertEquals(-1, u.read()); u.add(new ByteArrayInputStream(new byte[] { 20, 30 }) { @Override <|startfocus|> @SuppressWarnings("UnsynchronizedOverridesSynchronized") // Only used in tests <|endfocus|> public long skip(long n) { return 0; } }); assertEquals(2, u.skip(8)); assertEquals(-1, u.read()); } @Test public void testAutoCloseDuringRead() throws IOException { @SuppressWarnings("resource" /* java 7 */) final UnionInputStream u = new UnionInputStream(); final boolean closed[] = new boolean[2]; u.add(new ByteArrayInputStream(new byte[] { 1 }) { @Override public void close() { closed[0] = true; } });
<|startcomment|> overridden <|endcomment|>  * out, otherwise throw * {@link org.eclipse.jgit.errors.CheckoutConflictException}. If * <code>false</code>, it will silently deal with the problem. * * @param failOnConflict * a boolean. */ public void setFailOnConflict(boolean failOnConflict) { this.failOnConflict = failOnConflict; } /** <|startfocus|> * If <code>true</code>, dirty worktree files may be ovverriden. If * <code>false</code> dirty worktree files will not be overriden in order <|endfocus|> * not to delete unsaved content. This corresponds to native git's 'git * checkout -f' option. By default this option is set to false. * * @param force * a boolean. * @since 5.0 */ public void setForce(boolean force) { this.force = force; } /** * This method implements how to handle conflicts when * {@link #failOnConflict} is false * * @throws CheckoutConflictException */
<|startcomment|> Sorry, I'm gonna stop reviewing here, please indent everything and then we can re-do this. <|endcomment|>  public Activator() { <|startfocus|> // Do nothing <|endfocus|>
<|startcomment|> this is more trace level log entry <|endcomment|>  public Object getIdentifier() { <|startfocus|> LOG.debug("ReadOnlyTransaction.getIdentifier()"); <|endfocus|> return this;
<|startcomment|> D <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package io.fd.honeycomb.v3po.impl.trans; import com.google.common.annotations.Beta; import java.util.List; import javax.annotation.Nonnull; import org.opendaylight.yangtools.yang.binding.DataObject; import org.opendaylight.yangtools.yang.binding.InstanceIdentifier; /** * Base VPP reader, responsible for translation between DataObjects and VPP APIs * <|startfocus|> * @param <C> Specific DataObject derived type, that is handled by this reader <|endfocus|> */ @Beta public interface VppReader<D extends DataObject> extends SubtreeManager<D> { // TODO add vpp read context that will be shared by all readers during a single read to keep useful information // preventing possible duplicate reads from VPP // TODO make async /** * Reads from VPP data identified by id * * @param id unique identifier of subtree to be read. The subtree must contain managed data object type. For * identifiers pointing below node managed by this reader, it's reader's responsibility to filter out the
<|startcomment|> missing javadoc, 'final' in abstract method declaration leads to warnings (in sonar) <|endcomment|>  * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.openvpp.jvpp.dto; /** * Base interface for all request DTOs */ public interface JVppRequest { <|startfocus|> int send(final org.openvpp.jvpp.JVpp jvpp); <|endfocus|> } 
<|startcomment|> not important here and an implementation detail that might change, please remove <|endcomment|>  this.clientName = Objects.requireNonNull(clientName,"Null clientName"); } /** * Guarded by VppJNIConnection.class */ private static final Map<String, VppJNIConnection> connections = new HashMap<>(); /** * Create a new Vpp connection identified by clientName parameter. * * Multiple instances are allowed since this class is not a singleton * (VPP allows multiple management connections). * * However only a single connection per clientName is allowed. * <|startfocus|> * @param clientName identifier of vpp connection <|endfocus|> * @param callback global callback to receive response calls from vpp * * @return new Vpp connection * @throws IOException in case the connection could not be established, or there already is a connection with the same name */ public static VppJNIConnection create(final String clientName, final JVppCallback callback) throws IOException { synchronized (VppJNIConnection.class) { if(connections.containsKey(clientName)) { throw new IOException("Client " + clientName + " already connected"); } 
<|startcomment|> whitespaces <|endcomment|>  private static VxlanGpeAddDelTunnel getVxlanGpeTunnelRequest(final byte isAdd, final byte[] local, final byte[] remote, final int vni, final byte protocol, final int encapVrfId, final int decapVrfId, final byte isIpv6) { final VxlanGpeAddDelTunnel VxlanGpeAddDelTunnel = new VxlanGpeAddDelTunnel(); VxlanGpeAddDelTunnel.isAdd = isAdd; VxlanGpeAddDelTunnel.local = local; <|startfocus|> VxlanGpeAddDelTunnel.remote = remote; <|endfocus|> VxlanGpeAddDelTunnel.vni = vni; VxlanGpeAddDelTunnel.protocol = protocol; VxlanGpeAddDelTunnel.encapVrfId = encapVrfId; VxlanGpeAddDelTunnel.decapVrfId = decapVrfId; VxlanGpeAddDelTunnel.isIpv6 = isIpv6; return VxlanGpeAddDelTunnel;
<|startcomment|> FQN? <|endcomment|>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.openvpp.jvpp.callback; /** * Base JVppCallback interface */ public interface JVppCallback { /** * onError callback handler used to report failing operation * @param ex org.openvpp.jvpp.VppCallbackException object containing details about failing operation */ <|startfocus|> void onError(org.openvpp.jvpp.VppCallbackException ex); <|endfocus|> } 
<|startcomment|> I think this could be removed now and pass -1 explicitly <|endcomment|>  final L2InterfaceVlanTagRewriteReply reply = new L2InterfaceVlanTagRewriteReply(); replyFuture.complete(reply); doReturn(replyFuture).when(api).l2InterfaceVlanTagRewrite(any(L2InterfaceVlanTagRewrite.class)); } /** * Failure response send */ <|startfocus|> private void whenL2InterfaceVlanTagRewriteThenFailure(final int retval) throws ExecutionException, InterruptedException, VppInvocationException { doReturn(TestHelperUtils.<L2InterfaceVlanTagRewriteReply>createFutureException(retval)).when(api).l2InterfaceVlanTagRewrite(any(L2InterfaceVlanTagRewrite.class)); <|endfocus|> } private void whenL2InterfaceVlanTagRewriteThenFailure() throws ExecutionException, InterruptedException, VppInvocationException { whenL2InterfaceVlanTagRewriteThenFailure(-1); } private void verifyL2InterfaceVlanTagRewriteWasInvoked(final L2InterfaceVlanTagRewrite expected) throws VppInvocationException { ArgumentCaptor<L2InterfaceVlanTagRewrite> argumentCaptor = ArgumentCaptor.forClass(L2InterfaceVlanTagRewrite.class); verify(api).l2InterfaceVlanTagRewrite(argumentCaptor.capture()); final L2InterfaceVlanTagRewrite actual = argumentCaptor.getValue(); assertEquals(expected.swIfIndex, actual.swIfIndex); assertEquals(expected.vtrOp, actual.vtrOp);
<|startcomment|> Please remove. We rely on git metadata in HC. Such javadoc is hard to maintain. <|endcomment|> import org.opendaylight.yangtools.concepts.Builder; import org.opendaylight.yangtools.yang.binding.DataObject; import org.opendaylight.yangtools.yang.binding.InstanceIdentifier; import org.openvpp.jvpp.VppBaseCallException; import org.openvpp.jvpp.dto.IpAddressDetails; import org.openvpp.jvpp.dto.IpAddressDetailsReplyDump; import org.openvpp.jvpp.dto.IpAddressDump; import org.openvpp.jvpp.future.FutureJVpp; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * Customizer for read operations for {@link Address} of {@link Ipv4} <|startfocus|> * * @author jsrnicek <|endfocus|> */ public class Ipv4AddressCustomizer extends FutureJVppCustomizer implements ListReaderCustomizer<Address, AddressKey, AddressBuilder> { private static final Logger LOG = LoggerFactory.getLogger(Ipv4AddressCustomizer.class); private static final String CACHE_KEY = Ipv4AddressCustomizer.class.getName(); public Ipv4AddressCustomizer(FutureJVpp futureJvpp) { super(futureJvpp); } @Override public AddressBuilder getBuilder(InstanceIdentifier<Address> id) { return new AddressBuilder(); } @Override public void readCurrentAttributes(InstanceIdentifier<Address> id, AddressBuilder builder, ReadContext ctx) throws ReadFailedException {
<|startcomment|> order - checkstyle complains <|endcomment|> <|startfocus|> private static Boolean isModification(final @Nonnull DataTreeCandidateNode currentCandidate) { <|endfocus|> // Mixin nodes are not considered modifications if (isMixin(currentCandidate) && !isAugment(currentCandidate)) { return false; } else { return isCurrentModified(currentCandidate); }
<|startcomment|> remove <|endcomment|>  * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package io.fd.honeycomb.v3po.translate.util; import org.opendaylight.yangtools.yang.binding.ChildOf; import org.opendaylight.yangtools.yang.binding.DataObject; import org.opendaylight.yangtools.yang.binding.InstanceIdentifier; /** * Created by mmarsale on 7/13/16. */ public class DataObjects { <|startfocus|> public abstract static class DataObject1 implements DataObject { public static InstanceIdentifier<DataObject1> IID = InstanceIdentifier.create(DataObject1.class); <|endfocus|> } public abstract static class DataObject2 implements DataObject { public static InstanceIdentifier<DataObject2> IID = InstanceIdentifier.create(DataObject2.class); } public abstract static class DataObject3 implements DataObject { public static InstanceIdentifier<DataObject3> IID = InstanceIdentifier.create(DataObject3.class); public abstract static class DataObject31 implements DataObject, ChildOf<DataObject3> {
<|startcomment|> shouldn't ordinary equals work? Btw, you use equals in containsId methods (not used but still..) <|endcomment|>  @Nonnull final MappingContext mappingContext) { final Optional<Mappings> read = mappingContext.read(namingContextIid.child(Mappings.class)); final Eid coppiedEid = copyEid(eid); checkState(read.isPresent(), "Mapping for eid: %s is not present. But should be", eid); return read.get().getMapping().stream() <|startfocus|> .filter(mapping -> EidConverter.compareEids(mapping.getEid(), coppiedEid)) <|endfocus|> .collect(SINGLE_ITEM_COLLECTOR).getId(); } /** * Check whether mapping is present for index. * * @param eid eid of a mapped item * @param mappingContext mapping context providing context data for current transaction * @return true if present, false otherwise */ public synchronized boolean containsId( @Nonnull final org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.lisp.rev160520.eid.table.grouping.eid.table.vni.table.local.mappings.local.mapping.Eid eid, @Nonnull final MappingContext mappingContext) { final Optional<Mappings> read = mappingContext.read(namingContextIid.child(Mappings.class)); final Eid coppiedEid = copyEid(eid); 
<|startcomment|> reliance on default encoding (behavior could vary between platforms) <|endcomment|>  throw new WriteFailedException.DeleteFailedException(id, e); } } private void addDelInterfaceAndReply(boolean add, Interface data, int interfaceIndex, String locatorSetName) throws VppBaseCallException, TimeoutException { LispAddDelLocator request = new LispAddDelLocator(); request.isAdd = TranslateUtils.booleanToByte(add); request.priority = data.getPriority().byteValue(); request.weight = data.getWeight().byteValue(); request.swIfIndex = interfaceIndex; <|startfocus|> request.locatorSetName = locatorSetName.getBytes(); <|endfocus|> TranslateUtils.getReply(getFutureJVpp().lispAddDelLocator(request).toCompletableFuture()); } } 
<|startcomment|> could be removed, it is test utility class, and it is not wrapped here <|endcomment|>  static ReaderRegistry getVppStateReader(@Nonnull final FutureJVppCore jVpp, @Nonnull final NamingContext bdContext) { final CompositeReaderRegistryBuilder registry = new CompositeReaderRegistryBuilder(); // VppState(Structural) final InstanceIdentifier<VppState> vppStateId = InstanceIdentifier.create(VppState.class); registry.addStructuralReader(vppStateId, VppStateBuilder.class); // Version <|startfocus|> // Wrap with keepalive reader to detect connection issues <|endfocus|> registry.add(new GenericReader<>(vppStateId.child(Version.class), new VersionCustomizer(jVpp))); // BridgeDomains(Structural) bridgeDomainsId = vppStateId.child(BridgeDomains.class); registry.addStructuralReader(bridgeDomainsId, BridgeDomainsBuilder.class); // BridgeDomain registry.add(getBridgeDomainReader(jVpp, bdContext)); return registry.build();
<|startcomment|> compare suggests Comparator interface, which is bigger, maybe a name containing "equals" would be more suitable <|endcomment|> <|startfocus|> private boolean compareAddresses(final IpAddress left, final IpAddress right) { <|endfocus|> return Arrays.equals(left.getValue(), right.getValue());
<|startcomment|> the comments should be consistent, there are 2 styles over here: //comment // Comment I like the second one <|endcomment|>  this.serializer = checkNotNull(serializer, "Serializer cannot be null"); this.iidParser = checkNotNull(iidParser, "Instance identifier parser cannot be null"); } DataObject getDataForNode(final YangInstanceIdentifier nodeYangIdentifier, final String resourcePath, final DataNodeContainer parentSchema) throws DeserializationException, IOException { <|startfocus|> //reads resources from provided resource path <|endfocus|> final ContainerNode rootData = getCheckedRootData(resourcePath, parentSchema); // Now transform the single child from JSON into BA format final DataContainerChild<? extends YangInstanceIdentifier.PathArgument, ?> actualData = extractCheckedSingleChild(rootData); return getCheckedBinding(nodeYangIdentifier, actualData).getValue(); } private ContainerNode getCheckedRootData(final String resourcePath, final DataNodeContainer parentSchema) throws IOException { // TODO the cast to SchemaNode is dangerous and would not work for Augments, Choices and some other nodes maybe. At least check // TODO not sure if this is true, while testing this code was working fine event while processing choices/cases,
<|startcomment|> not used <|endcomment|>  private String dotlessAddress(@Nonnull final Ipv4Address address) { <|startfocus|> final String addressValue = address.getValue(); <|endfocus|> return dotless(address.getValue());
<|startcomment|> Why not RFC4180? It is proven to work with jenkins plot plugin. <|endcomment|>  import org.apache.commons.csv.CSVFormat; import org.apache.commons.csv.CSVPrinter; import org.slf4j.Logger; import javax.annotation.Nonnull; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Arrays; import java.util.Collections; import java.util.function.Supplier; public interface BenchmarkFilesProvider { <|startfocus|> // creates header : commited,init,max,used CSVFormat CSV_FORMAT = CSVFormat.EXCEL.withHeader(MemoryInfo.COMMITTED, MemoryInfo.INIT, MemoryInfo.MAX, MemoryInfo.USED); <|endfocus|> default void outputBenchmarkResult(@Nonnull final MemoryInfo benchmarkResult, @Nonnull final String outputPath, @Nonnull final Supplier<Logger> loggerSupplier) { // specifies output file in form specified_name-memory_info_type.csv final Path outPath = Paths.get(outputPath + "-" + benchmarkResult.getMemoryInfoTypeName() + ".csv"); try (final CSVPrinter csvPrinter = new CSVPrinter(new StringBuilder(), CSV_FORMAT)) { // prints values in same order that header is
<|startcomment|> precondition check won't do any harm ... <|endcomment|>  checkArgument(!Identifiable.class.isAssignableFrom(id.getTargetType()), "Structural readers cannot be used for keyed nodes[node type %s], use addStructuralListReader()", id.getTargetType()); add(GenericReader.createReflexive(id, builderType)); } @Override public <D extends DataObject & Identifiable<K>, K extends Identifier<D>> void addStructuralListReader(@Nonnull InstanceIdentifier<D> id, @Nonnull Class<? extends Builder<D>> builderType, @Nonnull List<K> staticKeys) { <|startfocus|> GenericListReader.createReflexive(id, builderType, staticKeys); <|endfocus|> } /** * Create {@link CompositeReaderRegistry} with Readers ordered according to submitted relationships. * <p/> * Note: The ordering only applies between nodes on the same level, inter-level and inter-subtree relationships are * ignored. */ @Override public ReaderRegistry build() { ImmutableMap<InstanceIdentifier<?>, Reader<? extends DataObject, ? extends Builder<?>>> mappedReaders = getMappedHandlers(); LOG.debug("Building Reader registry with Readers: {}", mappedReaders.keySet().stream() .map(InstanceIdentifier::getTargetType)
<|startcomment|> never() <|endcomment|>  when(writeContext.readAfter(InstanceIdentifier.create(Interfaces.class))).thenReturn( Optional.of(new InterfacesBuilder().setInterface(references.getInterface()).build())); final int aclIndex = 4; when(standardAclContext.getAclIndex("standard-acl", mappingContext)).thenReturn(aclIndex); try { aclCustomizer.deleteCurrentAttributes(validId, standardAcls.getAcl().get(0), writeContext); } catch (IllegalStateException e) { <|startfocus|> verify(aclApi, times(0)).aclDel(aclDelRequestCaptor.capture()); <|endfocus|> return; } fail("IllegalStateException should have been thrown"); } private void verifyUdpRequest(final int aclIndex) { final AclAddReplace request = aclAddReplaceRequestCaptor.getValue(); assertEquals(aclIndex, request.aclIndex); assertEquals(1, request.count); assertEquals("udp-tag-value", new String(request.tag, StandardCharsets.US_ASCII)); final AclRule udpRule = request.r[0]; assertEquals(0, udpRule.isIpv6); assertEquals(1, udpRule.isPermit); assertTrue(Arrays.equals(new byte[]{-64, -88, 2, 2}, udpRule.srcIpAddr));
<|startcomment|> true <|endcomment|>  : ctx.readAfter(RWUtils.cutId(id, Interface.class)); if (interfaceData.isPresent()) { final java.util.Optional<Interface1> augData = java.util.Optional.of(interfaceData.get()) .map(iface -> iface.getAugmentation(Interface1.class)); final boolean v4NotPresent = augData.map(Interface1::getIpv4).map(Ipv4::getAddress).map(List::isEmpty).orElse(false); final boolean v6NotPresent = <|startfocus|> augData.map(Interface1::getIpv6).map(Ipv6::getAddress).map(List::isEmpty).orElse(false); <|endfocus|> return v4NotPresent && v6NotPresent; } return true;
<|startcomment|> final <|endcomment|> import java.util.jar.JarFile; import java.util.stream.Collectors; import org.apache.commons.io.IOUtils; interface ResourceLoader { default Set<String> loadResourceContentsOnPath(final String path) { final URL folderUrl = getClass().getClassLoader().getResource(path); checkNotNull(folderUrl, "Resources %s not found", path); if (urlToUri(folderUrl).getScheme().equals("jar")) { return readFromJar(path, folderUrl); } else { return readFromFolder(folderUrl); } } class ResourceLoaderIml { <|startfocus|> static Set<String> readFromFolder(final URL folderUrl) { <|endfocus|> final File folder = new File(folderUrl.getPath()); final File[] files = checkNotNull(folder.listFiles(), "No files present on path %s", folderUrl); return Arrays.stream(files) .map(ResourceLoaderIml::fileToUrl) .map(ResourceLoaderIml::urlToContentString) .flatMap(content -> Arrays.stream(content.split(System.lineSeparator()))) .filter(ResourceLoaderIml::filterNonEmpty) .collect(Collectors.toSet()); } 
<|startcomment|> debug <|endcomment|>  protected NetconfTcpServer create() { if (!cfgAttributes.isNetconfTcpEnabled()) { <|startfocus|> LOG.info("NETCONF TCP disabled, skipping initalization"); <|endfocus|> return null; } LOG.info("Starting NETCONF TCP"); InetAddress name = null; try { name = InetAddress.getByName(cfgAttributes.netconfTcpBindingAddress.get()); } catch (UnknownHostException e) { throw new IllegalArgumentException("Illegal binding address", e); } final InetSocketAddress unresolved = new InetSocketAddress(name, cfgAttributes.netconfTcpBindingPort.get()); ChannelFuture tcpServer = dispatcher.createServer(unresolved); tcpServer.addListener(new TcpLoggingListener(unresolved)); return new NetconfTcpServer(tcpServer);
<|startcomment|> YangType ? <|endcomment|>  * limitations under the License. */ package io.fd.hc2vpp.docs.api; import java.util.List; /** * Represents coverage data for one api */ public class CoverageUnit { /** * VPP binary api reference */ private final VppApiReference vppApi; /** * Java equivalent of VPP binary api */ private final JavaApiReference javaApi; /** * Yang types used to bind this request */ <|startfocus|> private final List<YangTypeReference> yangTypes; <|endfocus|> /** * Operations supported for this api */ private final List<OperationReference> supportedOperations; private CoverageUnit(final VppApiReference vppApi, final JavaApiReference javaApi, final List<YangTypeReference> yangTypes, final List<OperationReference> supportedOperations) { this.vppApi = vppApi; this.javaApi = javaApi; this.yangTypes = yangTypes; this.supportedOperations = supportedOperations; } public VppApiReference getVppApi() { return vppApi; } public JavaApiReference getJavaApi() { return javaApi; } 
<|startcomment|> private (we have public builder method) <|endcomment|> <|startfocus|> public DataObjectUpdate(@Nonnull final InstanceIdentifier<?> id, <|endfocus|> @Nullable final DataObject dataBefore, @Nullable final DataObject dataAfter) { this.id = checkNotNull(id); this.dataAfter = dataAfter; this.dataBefore = dataBefore;
<|startcomment|> please remove <|endcomment|> <|startfocus|> private InterfaceNameOrIndex getIfcName(final SwInterfaceEventNotification swInterfaceEventNotification) { <|endfocus|> final Optional<String> optionalName = interfaceContext.getNameIfPresent(swInterfaceEventNotification.swIfIndex, mappingContext); return optionalName.isPresent() ? new InterfaceNameOrIndex(optionalName.get()) : new InterfaceNameOrIndex((long) swInterfaceEventNotification.swIfIndex);
<|startcomment|> testCommitFailedNoRevert <|endcomment|>  try { // Run the test final DataModification dataModification = configDataTree.newModification(); dataModification.write(ModificationDiffTest.NESTED_LIST_ID, nestedList); dataModification.validate(); dataModification.commit(); fail("WriterRegistry.BulkUpdatePostRevertException was expected"); } catch (WriterRegistry.BulkUpdatePostRevertException e) { verify(writer).update(any(WriterRegistry.DataObjectUpdates.class), any(WriteContext.class)); assertThat(e.getFailedIds(), hasItem(DEFAULT_ID)); verify(reverter).revert(); <|startfocus|> return; <|endfocus|> } fail("Test should have thrown WriterRegistry.BulkUpdatePostRevertException"); } @Test public void testCommitUndoFailed() throws Exception { final MapNode nestedList = ModificationDiffTest.getNestedList("listEntry", "listValue"); // Fail on update: final WriterRegistry.Reverter reverter = mock(WriterRegistry.Reverter.class); final TranslationException failedOnUpdateException = new TranslationException("update failed"); doThrow(new WriterRegistry.BulkUpdateException(Collections.singleton(DEFAULT_ID), reverter, failedOnUpdateException)) .when(writer).update(any(WriterRegistry.DataObjectUpdates.class), any(WriteContext.class)); // Fail on revert:
<|startcomment|> I believe we should match against getManagedDataObjectType here as well <|endcomment|>  public NoopWriter(final InstanceIdentifier<T> id) { this.id = id; } @Override public void processModification(@Nonnull final InstanceIdentifier<? extends DataObject> id, @Nullable final DataObject dataBefore, @Nullable final DataObject dataAfter, @Nonnull final WriteContext ctx) throws WriteFailedException { // NOOP } @Override public boolean supportsDirectUpdate() { return true; } <|startfocus|> @Override public boolean canProcess(@Nonnull final InstanceIdentifier<?> instanceIdentifier) { return true; } <|endfocus|> @Nonnull @Override public InstanceIdentifier<T> getManagedDataObjectType() { return id; } @Override public String toString() { return "NoopWriter{" + id.getTargetType().getSimpleName() + '}'; } } 
<|startcomment|> How is that functionality related to the model bump? It this functionality is related to some bug, then should be separate patch. If we need FibTable management, then we either need to map it to ietf-routing model or provide custom model. V3po model might needs update as well. <|endcomment|> import org.slf4j.Logger; import org.slf4j.LoggerFactory; import io.fd.hc2vpp.common.translate.util.AddressTranslator; import io.fd.hc2vpp.routing.services.FibService; import io.fd.hc2vpp.routing.write.factory.base.JVppRequest; import io.fd.honeycomb.translate.ModificationCache; import io.fd.honeycomb.translate.read.ReadFailedException; import io.fd.honeycomb.translate.write.WriteFailedException; import io.fd.vpp.jvpp.core.dto.IpTableAddDel; import io.fd.vpp.jvpp.core.future.FutureJVppCore; <|startfocus|> public class FibTableRequest extends JVppRequest implements AddressTranslator { <|endfocus|> private final FibService fibService; private final ModificationCache modificationCache; private static final Logger LOG = LoggerFactory.getLogger(FibTableRequest.class); /** * FIB table Name */ private String fibName; /** * FIB table id to be installed */ private int fibTable; /** * Whether to write IPv6 fib table or IPv4 */ private boolean isIpv6; public FibTableRequest(FutureJVppCore api, FibService fibService, ModificationCache modificationCache) { super(api); this.fibService = fibService;
<|startcomment|> Would it be possible to move locatorCtx to read part? It is not really needed unless we want to read. This patch could be then rebased on master... <|endcomment|>  "Address in prefix should not be empty for locator: {}", locator); Short locLength = Preconditions.checkNotNull(locator.getPrefix().getLength().getValue(), "Length in prefix should not be empty for locator: {}", locator); locatorCtx.addChild(locator.getName(), locLength.toString(), LOCATOR_LENGTH, writeContext.getMappingContext()); locatorCtx.addChild(locator.getName(), locAddress, LOCATOR_IPV6_ADDRESS, writeContext.getMappingContext()); } @Override public void deleteCurrentAttributes(@Nonnull final InstanceIdentifier<Locator> instanceIdentifier, @Nonnull final Locator locator, @Nonnull final WriteContext writeContext) { <|startfocus|> locatorCtx.removeChild(locator.getName(), LOCATOR_LENGTH, writeContext.getMappingContext()); locatorCtx.removeChild(locator.getName(), LOCATOR_IPV6_ADDRESS, writeContext.getMappingContext()); <|endfocus|> } } 
<|startcomment|> again... running NOOP function <|endcomment|>  .srSteeringPolDetails.stream() .filter(srSteeringPolDetails -> ((int) srSteeringPolDetails.trafficType) == L2_TRAFFIC_TYPE) .map(srSteeringPolDetails -> srSteeringPolDetails.swIfIndex) .map(ifIndex -> new InterfaceKey(ifcNamingContext.getName(ifIndex, ctx.getMappingContext()))) .collect(Collectors.toList()); } @Override public void readSpecific(@Nonnull InstanceIdentifier<Interface> identifier, @Nonnull ReadContext ctx, @Nonnull InterfaceBuilder builder) throws ReadFailedException { <|startfocus|> checkValid(); <|endfocus|> int index = ifcNamingContext.getIndex(identifier.firstKeyOf(Interface.class).getInputInterface(), ctx.getMappingContext()); dumpManager.getDump(identifier, ctx.getModificationCache()).or(STATIC_EMPTY_REPLY) .srSteeringPolDetails.stream() .filter(srSteeringPolDetails -> ((int) srSteeringPolDetails.trafficType) == L2_TRAFFIC_TYPE) .filter(srSteeringPolDetails -> srSteeringPolDetails.swIfIndex == index) .findFirst() .ifPresent(srSteeringPolDetails -> parseL2Steering(srSteeringPolDetails, builder, ctx)); } private void parseL2Steering(SrSteeringPolDetails srSteeringPolDetails, final InterfaceBuilder builder,
<|startcomment|> tap name is not device name. Device name is the real interface name for a tap v2 port we create in VPP (e.g. tap0) <|endcomment|>  final Optional<SwInterfaceTapV2Details> detail = reply.swInterfaceTapV2Details.stream() .filter(d -> d.swIfIndex == index) .findAny(); checkState(detail.isPresent(), "TapV2 interface for index %s not found", index); final SwInterfaceTapV2Details swInterfaceTapV2Details = detail.get(); LOG.trace("TapV2 interface: {} attributes returned from VPP: {}", key.getName(), swInterfaceTapV2Details); <|startfocus|> builder.setTapName(toString(swInterfaceTapV2Details.devName)); <|endfocus|> final SwInterfaceDetails ifcDetails = dumpManager.getInterfaceDetail(id, ctx, key.getName()); if (ifcDetails.tag[0] != 0) { // tag supplied builder.setTag(toString(ifcDetails.tag)); } LOG.debug("TapV2 interface: {}, id: {} attributes read as: {}", key.getName(), index, builder); } @Override public Initialized<org.opendaylight.yang.gen.v1.urn.opendaylight.params.xml.ns.yang.v3po.rev181005.interfaces._interface.TapV2> init(
<|startcomment|> unnecessary extra line <|endcomment|>  // Writers final Multibinder<WriterFactory> writerFactoryBinder = Multibinder.newSetBinder(binder(), WriterFactory.class); writerFactoryBinder.addBinding().to(InterfacesWriterFactory.class); writerFactoryBinder.addBinding().to(SubinterfaceAugmentationWriterFactory.class); writerFactoryBinder.addBinding().to(L2HoneycombWriterFactory.class); // Notifications final Multibinder<ManagedNotificationProducer> notifiersBinder = Multibinder.newSetBinder(binder(), ManagedNotificationProducer.class); notifiersBinder.addBinding().toProvider(InterfaceChangeNotificationProducerProvider.class); notifiersBinder.addBinding().toProvider(StatisticsChangeNotificationProducerProvider.class); <|startfocus|> <|endfocus|> LOG.info("Module V3PO successfully configured");
<|startcomment|> remove empty line <|endcomment|>  Assert.assertEquals(0, argument.getValue().enableDisable); } @Test public void testDeleteStatisticsCollection() throws Exception { StatisticsCollectionBuilder statCollectionBuilder = new StatisticsCollectionBuilder(); statCollectionBuilder.setStatisticsEnabled(true); statCustomizer.deleteCurrentAttributes(getTapId("tap"), statCollectionBuilder.build(), writeContext); verify(statManager).disableInterface(anyInt()); ArgumentCaptor<WantPerInterfaceCombinedStats> argument = ArgumentCaptor.forClass(WantPerInterfaceCombinedStats.class); verify(api).wantPerInterfaceCombinedStats(argument.capture()); Assert.assertEquals(0, argument.getValue().enableDisable); <|startfocus|> <|endfocus|> } private InstanceIdentifier<StatisticsCollection> getTapId(final String tap) { return InstanceIdentifier.create(Interfaces.class).child(Interface.class, new InterfaceKey(tap)).augmentation( VppInterfaceStatsCollectionAugmentation.class).child(StatisticsCollection.class); } } 
<|startcomment|> Brace on the previous line please. <|endcomment|>  dataSource.setDatabaseName(data.get(2)); dataSource.setUser(data.get(3)); dataSource.setPassword(data.get(4)); conn = dataSource.getConnection(); stat = conn.createStatement(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } return conn; } private void closeConnection() { try { stat.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } <|startfocus|> <|endfocus|> } public ResultSet executeCommand(String command) { openConnection(); ResultSet rs = null; try { rs = stat.executeQuery(command); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } closeConnection(); return rs; } } 
<|startcomment|> HashCode for confirmed generated by Eclipse IDE: result = prime * result + (confirmed ? 1231 : 1237); please add it <|endcomment|>  result = prime * result + ((joinedOn == null) ? 0 : joinedOn.hashCode()); result = prime * result + ((mail == null) ? 0 : mail.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((picture == null) ? 0 : picture.hashCode()); result = prime * result + postCount; <|startfocus|> // There isn't a hasCode for boolean confirmed <|endfocus|> return result;
<|startcomment|> already set in xml <|endcomment|>  public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); mContext = getActivity().getApplicationContext(); mDataBaseAdapter = new DataBaseAdapter(getActivity()); mDataBaseAdapter.createDatabase(); mDataBaseAdapter.open(); mItemAdapter = new ATMItemListAdapter(mContext, ((MainActivity) getActivity()).getLocationTracker()); setListAdapter(mItemAdapter); getLoaderManager().initLoader(0, null, this); <|startfocus|> getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE); <|endfocus|>
<|startcomment|> Could add tests checking numbers and ips as valid or not. <|endcomment|>  public void failCase3() { VerifierResult result = hostNameVerifier.verify("**"); Assert.assertFalse(result.passed()); <|startfocus|> <|endfocus|>
<|startcomment|> get rid <|endcomment|>  public void validateButtons(ViewMode viewMode){ if (viewMode == ViewMode.CREATING) { okString = "Create"; clearString = "Clear"; //this.remove(deleteButton); } else if (viewMode == ViewMode.EDITING){ okString = "Update"; clearString = "Undo Changes"; deleteString = "Archive"; <|startfocus|> //this.add(deleteButton); <|endfocus|> } else if (viewMode == ViewMode.ARCHIVING){ okString = "Restore"; deleteString = "Delete"; } this.okButton.setText(okString); this.clearButton.setText(clearString); this.deleteButton.setText(deleteString);
<|startcomment|> The documentation in Storage says NotFoundException. I'd prefer if we could keep that, since it's a more informative exception type. <|endcomment|>  sub.await(1, TimeUnit.SECONDS); sub.reset(1); zom.delete(PojoChain.class, chain.id); sub.await(1, TimeUnit.SECONDS); assertTrue(sub.event().isEmpty()); } @Test public void testSubscribeToNonexistentObject() throws Throwable { UUID id = UUID.randomUUID(); ObjectSubscription<PojoChain> sub = subscribe(PojoChain.class, id, 1); sub.await(1, TimeUnit.SECONDS); assertNotNull(sub.ex()); <|startfocus|> assertEquals(sub.ex().getClass(), IllegalStateException.class); <|endfocus|> assertEquals(sub.event(), Option.empty()); assertEquals(0, sub.updates()); } @Test public void testSecondSubscriberGetsLatestVersion() throws Exception { PojoChain chain = new PojoChain("chain"); zom.create(chain); ObjectSubscription<PojoChain> sub1 = subscribe(PojoChain.class, chain.id, 1); sub1.await(1, TimeUnit.SECONDS); sub1.reset(1); chain.name = "renamedChain"; zom.update(chain); sub1.await(1, TimeUnit.SECONDS); ObjectSubscription<PojoChain> sub2 = subscribe(PojoChain.class,
<|startcomment|> Either remove comment or update it to reflect the change. <|endcomment|>  JobState state = createJob(JobName.MAPREDUCE, schedulerConfigs.getInputString()); List<DeleteDirectoryResponse> deletedDirs; int hadoopErrorCode = -1; String excMsg; //tool.setupHadoopRun(schedulerConfigs); try { // Delete LZOs over 90 days old deletedDirs = hdfsUtils.rmLZOsOlderThan(HadoopLogsConfigs.getDaysOfLZOsToKeep()); logDeleteResults(deletedDirs, "deleted %s", "Error in attempt to delete HDFS old LZO %s: %s\n"); <|startfocus|> // Delete zips over 7 days old <|endfocus|> deletedDirs = hdfsUtils.rmZipsOlderThan(HadoopLogsConfigs.getDaysOfZipsToKeep()); logDeleteResults(deletedDirs, "deleted %s", "Error in attempt to delete HDFS old ZIPs %s: %s\n"); } catch (Exception ex) { excMsg = Debug.getEST(ex); LOG.error(String.format("Error trying to delete old HDFS files:%s\n", excMsg), ex); } try { String dstJarPath = HadoopLogsConfigs.getHdfsJobsJarPath(); // fileHour=2013021517 String fileHour = schedulerConfigs.getInputString(); 
<|startcomment|> Capitolization could be used here but its no ta big deal <|endcomment|>  * @param index * the index of the list */ public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) { b = true; setText(evaluateColor(((Color) value).toString())); setBackground((Color) value); b = false; return this; } /** <|startfocus|> * convert the string extracted from JComboBox to a string to be printed * out. static because will be used in compareTo(beforeTask, afterTask) in <|endfocus|> * TaskPresenter.java * * @param string * representation of the color object. */ public static String evaluateColor(String c) { switch (c) { case "java.awt.Color[r=128,g=128,b=128]": return "gray"; case "java.awt.Color[r=255,g=0,b=0]": return "red"; case "java.awt.Color[r=0,g=0,b=255]": return "blue"; case "java.awt.Color[r=0,g=255,b=255]":
<|startcomment|> This should have actual documentation. What does "filterColor" mean? <|endcomment|>  * * @param showArchived * indicates if archived tasks are shown */ public void setShowArchived(boolean showArchived) { this.showArchived = showArchived; } /** * resets and reloads all buckets */ public void resetAllBuckets() { for (Map.Entry<Integer, BucketPresenter> bucketEntry : getWorkflowPresenter() .getBucketPresenters().entrySet()) { BucketPresenter bucket = bucketEntry.getValue(); bucket.addMiniTaskstoView(); } } <|startfocus|> /** <|endfocus|> * @return current filterColor */ public Color getFilterColor(){ return filterColor; } /** *@param filterColor to change to */ public void setFilterColor(Color filterColor) { this.filterColor = filterColor; } public Color getNoFilterColor(){ return noFilterColor; } } 
<|startcomment|> This assertion is always true. The only way this test can fail is if an exception is thrown, so you can just remove this line. <|endcomment|> kage edu.wpi.cs.wpisuitetng.modules.taskmanager.model; import static org.junit.Assert.*; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import org.junit.Test; import edu.wpi.cs.wpisuitetng.modules.requirementmanager.view.requirements.ViewMode; import edu.wpi.cs.wpisuitetng.modules.taskmanager.presenter.TaskPresenter; public class TestTaskPresenter { @Test <|startfocus|> public final void testTaskPresenterTaskModel() { TaskPresenter test = new TaskPresenter(new TaskModel()); assertTrue(test!=null); } @Test <|endfocus|> public final void testTaskPresenterIntBucketPresenterViewMode() { fail("Not yet implemented"); // TODO } @Test public final void testCompareTasks() { TaskPresenter test = new TaskPresenter(new TaskModel()); DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy"); TaskModel before = new TaskModel (1, "before", "bDes", 0 , new Date(2014,03,20), 1); TaskModel after = new TaskModel (1, "after", "aDes", 2 , new Date(2014,03,22), 2);
<|startcomment|> Why a multi for a single op? <|endcomment|>  Collection<UUID> mappingIds = getUuidList(mappingsPaths, watcher); for (UUID mappingId : mappingIds) { portMappings.add(getVirtualPortMapping(hostId, mappingId)); } } return portMappings; } @VisibleForTesting public void ensureHostPathExists(UUID hostIdentifier) throws StateAccessException { if (!zk.exists(paths.getHostPath(hostIdentifier))) { <|startfocus|> List<Op> operations = new ArrayList<>(); operations.add(zk.getPersistentCreateOp(paths.getHostPath(hostIdentifier), null)); zk.multi(operations); <|endfocus|> } } public void addVirtualDatapathMapping(UUID hostIdentifier, String datapathMapping) throws StateAccessException, SerializationException { List<Op> operations = new ArrayList<>(); if (!zk.exists(paths.getHostPath(hostIdentifier))) operations.add( zk.getPersistentCreateOp(paths.getHostPath(hostIdentifier), null)); String virtualMappingPath = paths.getHostVrnMappingsPath(hostIdentifier); if (!zk.exists(virtualMappingPath)) { operations.add(zk.getPersistentCreateOp(virtualMappingPath, null)); } String hostVrnDatapathMappingPath =
<|startcomment|> Is this needed? <|endcomment|>  @Override public void call(Bridge bridge) { onBridgeCreatedOrUpdated(bridge, bridge.getId()); } })); // Notify the entities initial state: first VTEPs and then bridges. vtepMonitor.notifyState(); bridgeMonitor.notifyState(); log.info("Service started"); notifyStarted(); this.awaitRunning(); } @Override protected void doStop() { log.info("Service stopped"); shutdown(); notifyStopped(); } <|startfocus|> public ClusterNode.Context nodeContext() { return this.nodeCtx; } <|endfocus|> /* Cleanup service state */ private synchronized void shutdown() { // Dispose the monitor: must call before un-subscribing in order to // receive notifications for any clean-up. hostMonitor.dispose(); tunnelZoneMonitor.dispose(); vtepMonitor.dispose(); // Un-subscribe. for (Subscription subscription : subscriptions) { if (!subscription.isUnsubscribed()) { subscription.unsubscribe(); } } subscriptions.clear(); hostMonitor = null; tunnelZoneMonitor = null; vtepMonitor = null; bridgeMonitor = null; 
<|startcomment|> here we'll want to throw only if we are not already tracing this packet. <|endcomment|>  if (depth > 10) { throw new IllegalStateException("Deep recursion when processing " + "chain " + traversedChains.get(0)); } context.addFlowTag(flowInvTag); traversedChains.add(id); Iterator<Rule> iter = rules.iterator(); res.action = Action.CONTINUE; while (iter.hasNext() && res.action == Action.CONTINUE) { Rule r = iter.next(); r.process(context, res, ownerId, isPortFilter); <|startfocus|> if (res.action == Action.TRACE) { throw TraceRequiredException.instance(); } <|endfocus|> if (res.action == Action.JUMP) { Chain jumpChain = getJumpTarget(res.jumpToChain); if (null == jumpChain) { context.jlog().error("ignoring jump to chain {} : not found.", res.jumpToChain, context); res.action = Action.CONTINUE; } else if (traversedChains.contains(jumpChain.id)) { context.jlog().warn( "cannot jump from chain {} to chain {} -- already visited", this, jumpChain, context); res.action = Action.CONTINUE;
<|startcomment|> s/an/a/ <|endcomment|>  public void testNestedBuilderOnChangeEventPropagationReflection() { FieldDescriptor intMapField = f("int32_to_int32_field"); // Create a outer message builder with nested builder. TestOnChangeEventPropagation.Builder parentBuilder = TestOnChangeEventPropagation.newBuilder(); TestMap.Builder testMapBuilder = parentBuilder.getOptionalMessageBuilder(); <|startfocus|> // Create an map entry message. <|endfocus|> TestMap.Builder entryBuilder = TestMap.newBuilder(); entryBuilder.getMutableInt32ToInt32Field().put(1, 1); // Put the entry into the nested builder. testMapBuilder.addRepeatedField( intMapField, entryBuilder.getRepeatedField(intMapField, 0)); // Should be able to observe the change. TestOnChangeEventPropagation message = parentBuilder.build(); assertEquals(1, message.getOptionalMessage().getInt32ToInt32Field().size()); // Change the entry value. entryBuilder.getMutableInt32ToInt32Field().put(1, 4); testMapBuilder = parentBuilder.getOptionalMessageBuilder(); testMapBuilder.setRepeatedField( intMapField, 0, entryBuilder.getRepeatedField(intMapField, 0)); // Should be able to observe the change.
<|startcomment|> Why not using VtepRetrievalException, adding a constructor with the id? That'd save a LOT of lines in this class. <|endcomment|>  throws Exception { Insert<GenericTableSchema> op = lsTable.insert(ls); try { UUID newId = modify(client, lsTable, op).result(Duration.Inf()); if (newId == null) throw new VtepException(endPoint, "cannot create logical switch: " + ls); Set<LogicalSwitch> lSwitch = retrieveLogicalSwitch( lsTable.getUuidMatcher(newId)); if (lSwitch.isEmpty()) <|startfocus|> throw new VtepException( endPoint, "cannot retrieve logical switch for id: " + newId); <|endfocus|> return lSwitch.iterator().next(); } catch (TimeoutException tOut) { throw new VtepException(endPoint, tOut); } } /** * Retrieve the physical locator information directly from the VTEP. * The returned set may be empty. */ public Set<PhysicalLocator> retrievePhysicalLocator(Condition cond) throws Exception { try { Collection<Row<GenericTableSchema>> rows = query(client, plTable, cond) .result(Duration.Inf()); Set<PhysicalLocator> locators = new HashSet<>(); for (Row<GenericTableSchema> r : rows) {
<|startcomment|> nit: registered in NSDB? Thinking on how it sounds for the operator <|endcomment|>  super(zk, paths, serializer); this.portZkManager = new PortZkManager(zk, paths, serializer); } @Override protected String getConfigPath(UUID id) { return paths.getHostPath(id); } @Override protected Class<HostDirectory.Metadata> getConfigClass() { return HostDirectory.Metadata.class; } public void createHost(UUID hostId, HostDirectory.Metadata metadata) throws StateAccessException, SerializationException { zk.multi(prepareCreate(hostId, metadata)); <|startfocus|> log.debug("Host {} was created successfully", hostId); <|endfocus|> } public List<Op> prepareCreate(UUID hostId, HostDirectory.Metadata metadata) throws StateAccessException, SerializationException { log.debug("Creating host folders for hostId {}", hostId); List<Op> ops = new ArrayList<>(metadata.getTunnelZones().size() + 7); try { ops.add(simpleCreateOp(hostId, metadata)); } catch (SerializationException e) { throw new SerializationException( "Could not serialize host metadata for id: " + hostId, e, HostDirectory.Metadata.class); } ops.addAll(zk.getPersistentCreateOps(
<|startcomment|> Czy je?li kto? wyznaczy 2 r?ne trasy na tym samym obiekcie to b?dzie to dzia?a? poprawnie? Nie widz? usuwania elementw z arrayList przed wyznaczeniem trasy. Testowa?a? to? <|endcomment|> kage pl.wroc.pwr.indoorlocalizationtieto.routing; <|startfocus|> import android.util.Log; <|endfocus|> import java.util.ArrayList; public class Dijkstry { private ArrayList<Integer> pending; private ArrayList<Integer> considered; private ArrayList<Integer> precursor; private ArrayList<Integer> path; private ArrayList<Integer> result; private Graph graph; private int justAdded, goal; public Dijkstry(Graph g){ setGraph(g); precursor = new ArrayList<>(); considered = new ArrayList<>(); path = new ArrayList<>(); pending = new ArrayList<>(); result = new ArrayList<>(); for(int i=0 ; i < graph.getNumberOfVertexes() ; i++){ precursor.add(-1); pending.add(i); path.add(Integer.MAX_VALUE); } } public ArrayList<Integer> findShortestPath(int start, int end){ setTarget(start, end); while(!pending.isEmpty()){ for(int neighbour: graph.getVertexes().get(justAdded).getNeighbours()){ if(pending.contains(neighbour)) {
<|startcomment|> dziwna nazwa, niespojna z konwencja <|endcomment|> <|startfocus|> private void showFiltrCategoriesDialog() { FragmentTransaction t = getFragmentManager().beginTransaction(); DialogFragment d = (DialogFragment)getFragmentManager().findFragmentByTag("dialog"); if(d != null) { t.remove(d); <|endfocus|> } t.addToBackStack(null); CategoriesChoiceDialogFragment f = CategoriesChoiceDialogFragment.newInstance(); t.add(f, "dialog"); t.commit();
<|startcomment|> nicht aussagekrftig.. <|endcomment|>  public static void main(String[] args) { <|startfocus|> System.out.println("hi"); <|endfocus|>
<|startcomment|> If we need to do a null check here, don't we need to do the same in other places? <|endcomment|> <|startfocus|> public Integer parseTunnelKey(Row<GenericTableSchema> row) { <|endfocus|> Set tunnelKey = (row == null)? null: row.getColumn(getTunnelKeySchema()).getData(); return (tunnelKey == null || tunnelKey.isEmpty())? null: ((Long)tunnelKey.iterator().next()).intValue();
<|startcomment|> Czy tu potrzeba a? 5 tabw? <|endcomment|>  }; URLConnection connection = url[i].openConnection(); connection.setDoOutput(true); connection.setRequestProperty("Content-Type", "application/json"); connection.setConnectTimeout(5000); connection.setReadTimeout(5000); OutputStreamWriter out = new OutputStreamWriter(connection.getOutputStream()); out.write(jsonObject.toString()); out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); while ((input = in.readLine()) != null) { <|startfocus|> System.out.println(input); <|endfocus|> } System.out.println("\nSukces"); in.close(); } catch (Exception e) { System.out.println("\nNie przeszlo"); System.out.println(e); } } catch (Exception e) { e.printStackTrace(System.out); }
<|startcomment|> Should remove this as well <|endcomment|>  // exception is thrown if ((price*volume) > this.cashInHand) { throw new StockMarketExpection("Cannot place order for stock: " + symbol + " since there is not enough money." + " Trader: " + this.name); } this.position.add(new BuyOrder(symbol, volume, price, this)); // Adjust cash possessed since the trader spent money to purchase a // stock. this.cashInHand -= (price*volume); } <|startfocus|> //TODO rearrange <|endfocus|> public void placeNewOrder(Market m, String symbol, int volume, double price, OrderType orderType) throws StockMarketExpection { if (orderType == OrderType.BUY) { // If the stock's price is larger than the cash possessed, then an // exception is thrown if ((price*volume) > this.cashInHand) { throw new StockMarketExpection("Cannot place order for stock: " + symbol + " since there is not enough money." + " Trader: " + this.name); } // A trader cannot place two orders for the same stock, throw an
<|startcomment|> This comment should be removed. The variable itself is called name and therefore suggests it is the trader's name. <|endcomment|> kage pkg.trader; import java.util.ArrayList; import pkg.exception.StockMarketExpection; import pkg.market.Market; import pkg.order.BuyOrder; import pkg.order.Order; import pkg.order.OrderType; import pkg.order.SellOrder; public class Trader { <|startfocus|> // Name of the trader <|endfocus|> String name; // Cash left in the trader's hand double cashInHand; // Stocks owned by the trader ArrayList<Order> position; // Orders placed by the trader ArrayList<Order> ordersPlaced; public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); } //TODO rearrange public void buyFromBank(Market m, String symbol, int volume) throws StockMarketExpection { // Buy stock straight from the bank // Need not place the stock in the order list double price = m.getStockForSymbol(symbol).getPrice(); // If the stock's price is larger than the cash possessed, then an
<|startcomment|> This comment block should be removed as well. <|endcomment|>  this.ordersPlaced.add(order); m.addOrder(order); } } public void placeNewMarketOrder(Market m, String symbol, int volume, double price, OrderType orderType) throws StockMarketExpection { for(Order o : ordersPlaced){ if(o.getStockSymbol().equals(symbol)){ throw new StockMarketExpection(symbol + " is already placed."); } } Order order; if(orderType == OrderType.BUY){ order = new BuyOrder(symbol, volume, true, this); this.ordersPlaced.add(order); m.addOrder(order); <|startfocus|> } <|endfocus|> else{ int bit = 0; for(Order o: position){ if(o.getStockSymbol().equals(symbol)&&o.getSize()>=volume){ bit = 1; } } if(bit == 0){ throw new StockMarketExpection("You don't have the stock or enough stocks to sell. Trader: " + this.name); } order = new SellOrder(symbol, volume, true, this); this.ordersPlaced.add(order); m.addOrder(order); } } 
<|startcomment|> Verb should be first normally. <|endcomment|> <|startfocus|> private ArrayList<Order> buyOrderSort(ArrayList<Order> buyOrders){ <|endfocus|> ArrayList<Order> sorted = new ArrayList<Order>(); ArrayList<Order> unsorted = (ArrayList<Order>) buyOrders.clone(); for (int i = 0; i < buyOrders.size(); i++){ if(buyOrders.get(i).getPrice() == 0){ sorted.add(buyOrders.get(i)); unsorted.remove(i); } } Collections.sort(unsorted, new Comparator<Order>() { @Override public int compare(Order o1, Order o2){ return Double.compare(o2.getPrice(), o1.getPrice()); } }); sorted.addAll(unsorted); return sorted;
<|startcomment|> could this be extracted out into its own method? <|endcomment|>  } } value = marketSellOrder; for ( int x = 0 ; x <= j-1 ; x++){ flag = 0; for(Order o: allSellOrders){ if (o.getPrice() == price[x]){ value = value +o.getSize(); sOrder.put(price[x], value); flag = 1; } } if(flag == 0){ sOrder.put(price[x], 0); <|startfocus|> } <|endfocus|> } double matchingPrice = 0; int minVol = 0; int maxVol = 0; int bVol =0 ; int sVol = 0; for (int x= 0; x<= j-1; x++){ bVol = bOrder.get(price[x]); sVol = sOrder.get(price[x]); minVol = Math.min(bVol, sVol); if(maxVol <= minVol && minVol != 0){ maxVol = minVol;
<|startcomment|> variable might be confused with the other variable above, might want to change it <|endcomment|>  public static boolean isAlreadyPresent(ArrayList<Order> ordersPlaced, Order newOrder) { <|startfocus|> for (Order orderPlaced : ordersPlaced) { if (((orderPlaced instanceof BuyOrder) && (newOrder instanceof BuyOrder)) || ((orderPlaced instanceof SellOrder) && (newOrder instanceof SellOrder))) { if (orderPlaced.getStockSymbol().equals( <|endfocus|> newOrder.getStockSymbol())) { return true; } } } return false;
<|startcomment|> Needs to be changes to 14, since there are 14 traders <|endcomment|>  IPO.enterNewStock(m, "TWTR", "Twitter Inc.", 47.88); IPO.enterNewStock(m, "VSLR", "Vivint Solar", 16.44); IPO.enterNewStock(m, "GILD", "Gilead Sciences", 93.33); m.printStocks(); Market m1 = new Market("Nikkei"); IPO.enterNewStock(m1, "BABA", "Alibaba", 84.88); IPO.enterNewStock(m1, "BDU", "Baidu", 253.66); m1.printStocks(); <|startfocus|> // Create 10 traders <|endfocus|> Trader trader1 = new Trader("Neda", 200000.00); Trader trader2 = new Trader("Scott", 100000.00); Trader trader3 = new Trader("Luke", 100000.00); Trader trader4 = new Trader("Thomas", 100000.00); Trader trader5 = new Trader("Sritika", 100000.00); Trader trader6 = new Trader("Meg", 100000.00); Trader trader7 = new Trader("Jen", 100000.00); Trader trader8 = new Trader("Emory", 100000.00); Trader trader9 = new Trader("Justin", 100000.00);
<|startcomment|> these comments are unnecessary because the variable names speak for themselves <|endcomment|> kage pkg.trader; import java.util.ArrayList; import pkg.exception.StockMarketExpection; import pkg.market.Market; import pkg.order.BuyOrder; import pkg.order.Order; import pkg.order.OrderType; import pkg.order.SellOrder; <|startfocus|> public class Trader { <|endfocus|> String name; double cashInHand; ArrayList<Order> position; ArrayList<Order> ordersPlaced; public Trader(String name, double cashInHand) { super(); this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); } public void buyFromBank(Market m, String symbol, int volume) throws StockMarketExpection { double price = m.getStockForSymbol(symbol).getPrice(); if(price * volume > this.cashInHand){ throw new StockMarketExpection("Cannot place order for stock: " + symbol + " since there is not enough money. Trader: " + this.name); } Order order = new BuyOrder(symbol, volume, price, this); this.position.add(order);
<|startcomment|> It is clear enough. No need of comments. <|endcomment|>  + " since no stock is currently owned. Trader: " + this.name); } // Check if trader owns enough of the stock if selling if (orderType == OrderType.SELL && volume > OrderUtility.ownedQuantity(position, symbol)) { throw new StockMarketExpection("Cannot place sell order for stock: " + symbol + " since not enough stock is currently owned. Trader: " + this.name); } <|startfocus|> // Enter the order into the orderbook of the market m.addOrder(theOrder); // Add the order to the orders placed <|endfocus|> this.ordersPlaced.add(theOrder); } public void tradePerformed(Order o, double matchPrice) throws StockMarketExpection { // Notification received that a trade has been made, the parameters are // the order corresponding to the trade, and the match price calculated // in the order book. Note than an order can sell some of the stocks he // bought, etc. Or add more stocks of a kind to his position. Handle // these situations. 
<|startcomment|> Remove automatically-generated comment. <|endcomment|>  trader12.placeNewOrder(market, "SBUX", 900, 99.0, OrderType.BUY); trader13.placeNewOrder(market, "SBUX", 1000, 98.5, OrderType.BUY); trader14.placeNewOrder(market, "SBUX", 900, 98.0, OrderType.BUY); trader16.placeNewMarketOrder(market, "SBUX", 700, 0, OrderType.BUY); } catch (StockMarketExpection e) { <|startfocus|> e.printStackTrace(); <|endfocus|> } System.out.println("Printing after the buy orders are placed"); System.out.println("&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^"); trader8.printTrader(); trader9.printTrader(); trader10.printTrader(); trader11.printTrader(); trader12.printTrader(); trader13.printTrader(); trader14.printTrader(); trader16.printTrader(); market.triggerTrade(); System.out.println("Printing after the tradings are done"); System.out.println("&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^&^"); trader1.printTrader(); trader2.printTrader();
<|startcomment|> Change to market for better readability <|endcomment|> import pkg.order.OrderType; import pkg.trader.Trader; public class Client { public static void main(String[] args) throws StockMarketExpection { Market m = new Market("NASDAQ"); IPO.enterNewStock(m, "SBUX", "Starbucks Corp.", 92.86); IPO.enterNewStock(m, "TWTR", "Twitter Inc.", 47.88); IPO.enterNewStock(m, "VSLR", "Vivint Solar", 16.44); IPO.enterNewStock(m, "GILD", "Gilead Sciences", 93.33); <|startfocus|> m.printStocks(); <|endfocus|> Market m1 = new Market("Nikkei"); IPO.enterNewStock(m1, "BABA", "Alibaba", 84.88); IPO.enterNewStock(m1, "BDU", "Baidu", 253.66); m1.printStocks(); // Create 10 traders Trader trader1 = new Trader("Neda", 200000.00); Trader trader2 = new Trader("Scott", 100000.00); Trader trader3 = new Trader("Luke", 100000.00); Trader trader4 = new Trader("Thomas", 100000.00); Trader trader5 = new Trader("Sritika", 100000.00);
<|startcomment|> variable name is not that meaningful <|endcomment|>  int size = buyOrdersList.size(); i++; try { while (i < size) { buyOrdersList.remove(i); sellOrdersList.remove(i); } } catch (Exception e) { } break; } } buyOrdersList.add(marketBuyOrder); sellOrdersList.add(marketSellOrder); Collections.sort(buyOrdersList, new OrderPrices()); Collections.reverse(buyOrdersList); Collections.sort(sellOrdersList, new OrderPrices()); <|startfocus|> for (Order o : buyOrdersList) { <|endfocus|> try { o.getTrader().getPosition().add(m.getStockForSymbol(sellOrdersList.get(i).getStockSymbol())); o.getTrader().tradePerformed(o, matchedPrice); } catch (StockMarketExpection e) { // TODO Auto-generated catch block e.printStackTrace(); } } Stock stockSymbolToRemove = m.getStockForSymbol(sellOrdersList.get(i).getStockSymbol()); for (Order o : sellOrdersList) { try { o.getTrader().getPosition().remove(stockSymbolToRemove); o.getTrader().tradePerformed(o, matchedPrice);
<|startcomment|> Incorrect number in comment. 14 Traders are created. Revise or remove comment. <|endcomment|>  IPO.enterNewStock(m, "TWTR", "Twitter Inc.", 47.88); IPO.enterNewStock(m, "VSLR", "Vivint Solar", 16.44); IPO.enterNewStock(m, "GILD", "Gilead Sciences", 93.33); //PRINTS THE STOCKS m.printStocks(); Market m1 = new Market("Nikkei"); IPO.enterNewStock(m1, "BABA", "Alibaba", 84.88); IPO.enterNewStock(m1, "BDU", "Baidu", 253.66); m1.printStocks(); <|startfocus|> // Create 10 traders <|endfocus|> Trader trader1 = new Trader("Neda", 200000.00); Trader trader2 = new Trader("Scott", 100000.00); Trader trader3 = new Trader("Luke", 100000.00); Trader trader4 = new Trader("Thomas", 100000.00); Trader trader5 = new Trader("Sritika", 100000.00); Trader trader6 = new Trader("Meg", 100000.00); Trader trader7 = new Trader("Jen", 100000.00); Trader trader8 = new Trader("Emory", 100000.00); Trader trader9 = new Trader("Justin", 100000.00);
<|startcomment|> change variable to something more descriptive like traderStocks <|endcomment|> kage pkg.trader; import java.util.ArrayList; import pkg.exception.StockMarketExpection; import pkg.market.Market; import pkg.order.BuyOrder; import pkg.order.Order; import pkg.order.OrderType; import pkg.order.SellOrder; public class Trader { String name; double cashInHand; // Stocks owned by the trader ArrayList<Order> position; ArrayList<Order> ordersPlaced; public Trader(String name, double cashInHand) { <|startfocus|> super(); <|endfocus|> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); } public void buyFromBank(Market m, String symbol, int volume) throws StockMarketExpection { // Buy stock straight from the bank // Need not place the stock in the order list double price = m.getStockForSymbol(symbol).getPrice(); // If the stock's price is larger than the cash possessed, then an // exception is thrown if ((price*volume) > this.cashInHand) {
<|startcomment|> Bad comment! Remove it. <|endcomment|>  Trader trader16 = new Trader("T2", 300000.00); try { trader1.buyFromBank(market, "SBUX", 1600); trader2.buyFromBank(market, "SBUX", 300); trader3.buyFromBank(market, "SBUX", 300); trader4.buyFromBank(market, "SBUX", 300); trader5.buyFromBank(market, "SBUX", 600); trader6.buyFromBank(market, "SBUX", 700); trader7.buyFromBank(market, "SBUX", 500); trader15.buyFromBank(market, "SBUX", 1500); <|startfocus|> // Exception <|endfocus|> trader8.buyFromBank(market, "SBUX", 5000); } catch (StockMarketExpection e) { // TODO Auto-generated catch block e.printStackTrace(); } trader1.printTrader(); trader2.printTrader(); trader3.printTrader(); trader4.printTrader(); trader5.printTrader(); trader6.printTrader(); trader7.printTrader(); trader8.printTrader(); trader15.printTrader(); // Place sell orders try { trader1.placeNewOrder(market, "SBUX", 100, 97.0, OrderType.SELL);
<|startcomment|> Wouldn't getCurrentMarket() be a better name? <|endcomment|> <|startfocus|> public Market getM() { <|endfocus|> return currentMarket;
<|startcomment|> Remove commented-out code. <|endcomment|> kage pkg.trader; import java.util.ArrayList; import pkg.exception.StockMarketExpection; import pkg.market.Market; import pkg.order.BuyOrder; import pkg.order.Order; import pkg.order.OrderType; import pkg.order.SellOrder; public class Trader { String name; double cashInHand; // Stocks owned by the trader ArrayList<Order> position; ArrayList<Order> ordersPlaced; public Trader(String name, double cashInHand) { <|startfocus|> //super(); <|endfocus|> this.name = name; this.cashInHand = cashInHand; this.position = new ArrayList<Order>(); this.ordersPlaced = new ArrayList<Order>(); } public void buyFromBank(Market m, String symbol, int volume) throws StockMarketExpection { // Buy stock straight from the bank // Need not place the stock in the order list double price = m.getStockForSymbol(symbol).getPrice(); if ((price*volume) > this.cashInHand) { throw new StockMarketExpection("Cannot place order for stock: " + symbol + " since there is not enough money."
<|startcomment|> ditto <|endcomment|> <|startfocus|> public void update(UUID id, Bridge from) { this.id = id; <|endfocus|> portIds = from.portIds; vxLanPortIds = from.vxLanPortIds; dhcpIds = from.dhcpIds;
<|startcomment|> nie bede sie tego czepial, skasuje sie kiedys :D <|endcomment|>  paint.setColor(style.getBackgroundColor()); canvas.drawPoint((float) point.getX(), (float) point.getY(), paint); } private void drawLine(Canvas canvas, Point startingPoint, Point endingPoint, MapObjectStyle style) { Paint paint = new Paint(); paint.setColor(style.getBackgroundColor()); paint.setStrokeWidth(style.getLineWidth()); canvas.drawLine((float) startingPoint.getX(), (float) startingPoint.getY(), (float) endingPoint.getX(), (float) endingPoint.getY(), paint); } <|startfocus|> private void drawLine(Canvas canvas, Line line, MapObjectStyle style) { <|endfocus|> Point startingPoint = line.getP1(); Point endingPoint = line.getP2(); drawLine(canvas, startingPoint, endingPoint, style); } private void drawLineString(Canvas canvas, LineString lineString, MapObjectStyle paint) { List<Point> points = lineString.getLineString(); Point point; Point next; for (int i = 0; i < points.size() - 1; i++) { point = points.get(i);
<|startcomment|> 2015 <|endcomment|> <|startfocus|> * Copyright 2014 Midokura SARL <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.midonet.api.neutron; import java.util.List; import java.util.UUID; import javax.annotation.security.RolesAllowed; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.core.Response; import javax.ws.rs.core.SecurityContext;
<|startcomment|> You removed UserPages from the adapter method. Should we also remove it elsewhere? <|endcomment|>  configuredHost.setRestEndpointActive(Boolean.FALSE); hostService.update(configuredHost); } LOG.warn(String.format("SOAP endpoint %s on host[%d] throw an RollBackException but not marking as bad as it was not a network connection error: Exception was %s", configuredHost.getEndpoint(), configuredHost.getId(), Debug.getExtendedStackTrace(af))); } @Override <|startfocus|> public void updateSslTermination(LoadBalancer loadBalancer, ZeusSslTermination sslTermination, UserPages up) throws MalformedURLException, EntityNotFoundException, DecryptException, InsufficientRequestException, RollBackException { <|endfocus|> LoadBalancerEndpointConfiguration config = getConfigbyLoadBalancerId(loadBalancer.getId()); try { reverseProxyLoadBalancerStmAdapter.updateSslTermination(config, loadBalancer, sslTermination); } catch (RollBackException af) { checkAndSetIfRestEndPointBad(config, af); throw af; } } @Override public void removeSslTermination(LoadBalancer lb) throws RemoteException, MalformedURLException, EntityNotFoundException, DecryptException, InsufficientRequestException, RollBackException { LoadBalancerEndpointConfiguration config = getConfigbyLoadBalancerId(lb.getId()); try { reverseProxyLoadBalancerStmAdapter.removeSslTermination(config, lb);
<|startcomment|> nit: doesn't it fit in 1 line? (can be fixed later) <|endcomment|>  StateKey key = await(stateStore.getKey(Topology.Host.class, hostId, MidonetBackend.AliveKey())); return !key.isEmpty(); } private State.HostState getHostState(UUID hostId) throws Exception { StateKey key = await(stateStore.getKey(Topology.Host.class, hostId, MidonetBackend.HostKey())); if (key.isEmpty()) return null; String value = ((SingleValueKey)key).value().get(); <|startfocus|> State.HostState.Builder builder = State.HostState.newBuilder(); <|endfocus|> TextFormat.merge(value, builder); return builder.build(); } private void eventuallyAssertHostState() throws Exception { for (byte attempt = 0; attempt < MAX_ATTEMPTS; attempt++) { try { assertHostState(); return; } catch (Throwable e) { Thread.sleep(WAIT_MILLIS); } } throw new Exception("Eventually host did not exist"); } private void eventuallyAssertShutdown(TestableHostService hostService) throws Exception { for (byte attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
<|startcomment|> Ditto. <|endcomment|>  */ @DELETE @RolesAllowed({AuthRole.ADMIN, AuthRole.TENANT_ADMIN}) @Path("/{prefix}") public void delete(@PathParam("prefix") IPv6Subnet prefix) throws StateAccessException, SerializationException { authoriser.tryAuthoriseBridge( bridgeId, "delete dhcpv6 configuration of this bridge."); dataClient.dhcpSubnet6Delete(bridgeId, prefix); } /** * Handler to list DHCPV6 subnet configurations. * * @throws StateAccessException Data access error. <|startfocus|> * @return A list of DHCPSubnet6 objects. <|endfocus|> */ @GET @PermitAll @Produces({ VendorMediaType.APPLICATION_DHCPV6_SUBNET_COLLECTION_JSON }) public List<DhcpSubnet6> list() throws StateAccessException, SerializationException { authoriser.tryAuthoriseBridge( bridgeId, "view DHCPV6 config of this bridge."); List<Subnet6> subnetConfigs = dataClient.dhcpSubnet6sGetByBridge(bridgeId); List<DhcpSubnet6> subnets = new ArrayList<>(); for (Subnet6 subnetConfig : subnetConfigs) { subnets.add(fromDataV6(subnetConfig, bridgeId, getBaseUri())); } return subnets; } 
<|startcomment|> Nit: this could be: absoluteUri(DHCPV6_HOSTS, clientId) <|endcomment|>  public URI getUri() { <|startfocus|> return UriBuilder.fromUri(getBaseUri()) .path(ResourceUris.DHCPV6_HOSTS) .path(clientIdToUri(clientId)) .build(); <|endfocus|>
<|startcomment|> white space <|endcomment|> import org.midonet.cluster.models.Topology; import org.midonet.cluster.rest_api.ResourceUris; import org.midonet.cluster.util.UUIDUtil; import org.midonet.midolman.state.l4lb.LBStatus; import org.midonet.midolman.state.l4lb.PoolLBMethod; import org.midonet.midolman.state.l4lb.PoolProtocol; @ZoomClass(clazz = Topology.Pool.class) public class Pool extends UriResource { @ZoomField(name = "id", converter = UUIDUtil.Converter.class) public UUID id; @ZoomField(name = "admin_state_up") public boolean adminStateUp = true; <|startfocus|> <|endfocus|> @ZoomField(name = "health_monitor_id", converter = UUIDUtil.Converter.class) public UUID healthMonitorId; @NotNull @ZoomField(name = "load_balancer_id", converter = UUIDUtil.Converter.class) public UUID loadBalancerId; @ZoomField(name = "protocol") public PoolProtocol protocol; @NotNull @ZoomField(name = "lb_method") public PoolLBMethod lbMethod; @ZoomField(name = "status") public LBStatus status; @JsonIgnore @ZoomField(name = "pool_member_ids", converter = UUIDUtil.Converter.class)
<|startcomment|> s/2014/2015/ <|endcomment|> <|startfocus|> * Copyright 2014 Midokura SARL <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.midonet.migrator.converters; import org.midonet.cluster.rest_api.models.Pool; public class PoolDataConverter { public static Pool fromData(org.midonet.cluster.data.l4lb.Pool data) { Pool pool = new Pool(); pool.loadBalancerId = data.getLoadBalancerId(); pool.healthMonitorId = data.getHealthMonitorId(); pool.protocol = data.getProtocol(); pool.lbMethod = data.getLbMethod();
<|startcomment|> This should be enum. <|endcomment|>  public Integer mtu; @ZoomField(name = "initiator") public Initiator initiator; @ZoomField(name = "auth_mode") public AuthMode authMode; @ZoomField(name = "psk") public String psk; @ZoomField(name = "actions") public List<String> actions; @ZoomField(name = "admin_state_up") public Boolean admin_state_up; @ZoomField(name = "status") public Status status; @ZoomField(name = "dpd_action") <|startfocus|> public String dpdAction; <|endfocus|> @ZoomField(name = "dpd_interval") public Integer dpdInterval; @ZoomField(name = "dpd_timeout") public Integer dpdTimeout; @ZoomField(name = "vpn_service_id", converter = UUIDUtil.Converter.class) public UUID vpnServiceId; @ZoomField(name = "ike_policy_id", converter = UUIDUtil.Converter.class) public UUID ikePolicyId; @ZoomField(name = "ipsec_policy_id", converter = UUIDUtil.Converter.class) public UUID ipsecPolicyId; @ZoomEnum(clazz = Neutron.IPSecSiteConnection.Status.class) public enum Status {
<|startcomment|> Values should be 30 and 40 <|endcomment|>  public static void main(String[] args) { <|startfocus|> int a = 30, b = 30; <|endfocus|> System.out.println("sum of a and b is" + add(a, b));
<|startcomment|> ? <|endcomment|> kage com.tatiana.game; import javafx.geometry.Pos; import javafx.scene.effect.DropShadow; import javafx.scene.effect.GaussianBlur; import javafx.scene.effect.Glow; import javafx.scene.layout.StackPane; import javafx.scene.paint.Color; import javafx.scene.shape.Rectangle; import javafx.scene.text.Font; import javafx.scene.text.Text; /** * This class describes buttons that used in menu. * */ public class MenuButton extends StackPane { private Text text; <|startfocus|> MenuButton(String name) { text = new Text(name); <|endfocus|> text.setTranslateX(2); this.text.getFont(); text.setFont(Font.font(22)); text.setFill(Color.WHITE); Rectangle bg = new Rectangle(300, 50); bg.setOpacity(0.7); bg.setFill(Color.GRAY); bg.setEffect(new GaussianBlur(3.5)); setAlignment(Pos.CENTER_LEFT); getChildren().addAll(bg, text); this.setOnMouseEntered(event -> { bg.setTranslateX(20); text.setTranslateX(20); bg.setFill(Color.WHITE); text.setFill(Color.GRAY); }); this.setOnMouseExited(event -> {
<|startcomment|> delete red area <|endcomment|>  i--; j++; countToReverse++; } if (field[i][j] == whichPlayerSets) { i = xPos - 1; j = yPos + 1; while (countToReverse != 0) { field[i][j] = whichPlayerSets; countToReverse--; i--; j++; } } } } /** * This method is called whenever bot should make a move <|startfocus|> * <|endfocus|> * @return true if bot made a move successfully, false if not */ public boolean runBot() { canPlayerSets = false; // while bot is running, user cannot set if (this.isPossibleToSet()) { switch (this.gameDifficulty) { case EASY: runEasyBot(); break; case HARD: runHardBot(); break; } canPlayerSets = true;// bot is done, so allow user to set return true;// bot wade a turn sucsessfully } canPlayerSets = true;// bot is done, so allow user to set
<|startcomment|> bad name of method https://google.github.io/styleguide/javaguide.html#s4-formatting <|endcomment|>  private short Y(short y) { <|startfocus|> if (y == -1) <|endfocus|> return (short) (height - 1); if (y == height) return (short) 0; return y;
<|startcomment|> what if file not found? add try catch ( print error message to console and terminate program) <|endcomment|>  public TextItem(String name) { // making a text Item to make notices Rectangle rectButton = new Rectangle(200, 20, Color.AZURE); rectButton.setOpacity(0.8); Text text = new Text(name); text.setFill(Color.DARKSLATEGRAY); <|startfocus|> text.setFont(Font.loadFont("file:resourses/fonts/20th_century_font.ttf", 20)); <|endfocus|> getChildren().addAll(rectButton, text);
<|startcomment|> xPos, yPos <|endcomment|>  private void initializeGameGrid() { // Clear the lists, add all locations, and call it before startGame gameGrid.clear(); locations.clear(); <|startfocus|> GridOperator.traverseGrid((i, j) -> { Location location = new Location(i, j); <|endfocus|> locations.add(location); gameGrid.put(location, null); return 0; });
<|startcomment|> add more logical spaces here <|endcomment|>  && ball.getPositionY() < bricks[i][j].getBottomBoundary() && ball.getLeftBoundary() <= bricks[i][j].getRightBoundary() && ball.getRightBoundary() > bricks[i][j].getRightBoundary()) { this.actionOnBrickHit(bricks[i][j], ball, <|startfocus|> bricks[i][j].getRightBoundary() + ball.getRadius(), ball. getPositionY(), -ball.getDx(), ball.getDy()); <|endfocus|> } } } } 
<|startcomment|> name <|endcomment|> kage application; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.Reader; import java.util.Map; import java.util.Properties; import java.util.logging.Level; import java.util.logging.Logger; import javafx.beans.property.StringProperty; public class SessionManager { public String SESSION_PROPERTIES_FILENAME; public String SESSION_PROPERTIES_FILENAME_Replay; <|startfocus|> private final Properties PROPS = new Properties(); <|endfocus|> private final GridOperator gridOperator; public static int numberSave = 0; public static int numberRead = 1; public static boolean endFile = false; public SessionManager(GridOperator gridOperator) { this.gridOperator = gridOperator; } public void saveSession(Map<Location, Tile> gameGrid, Integer score, Long time) { this.SESSION_PROPERTIES_FILENAME = "Step#" + numberSave + ".txt"; try { gridOperator.traverseGrid((x, y) -> { Tile t = gameGrid.get(new Location(x, y));
<|startcomment|> Looking through the patch, there is no need to change UNFILLED_FILED to public. Revert it back to private. If you need it in the future, change it in appropriate commit. <|endcomment|> kage bayesnet_pszt; import java.util.Vector; public class BayesNode { /** Our probabilities to recalculate for each node */ public Vector<BayesAttributePair<Float>> mAttrs = null; /** Probability matrix, used for calculations */ public Vector<Float> mProbMatrix = new Vector<Float>(); private int mAttributeCount = 0; private int mCombinationCount = 0; <|startfocus|> public final float UNFILLED_FIELD = -1.0f; <|endfocus|> public int getCombinationCount() { return mCombinationCount; } /** Name of the node, for clarity sake */ public String mName; /** True if we are an evidence node, false if we are not. */ private boolean mIsEvidence = false; /** Parents of given node, to preserve tree structure */ Vector<BayesNode> mParents = new Vector<BayesNode>(); /** Children of given node, for tree structure */ Vector<BayesNode> mChildren = new Vector<BayesNode>(); public BayesNode(String name) { mName = name; } public void SetAttrs(Vector<BayesAttributePair<Float>> attrs)
<|startcomment|> It should not be here. Comment it. <|endcomment|>  public double getValueFor(double x) { <|startfocus|> // TODO Auto-generated method stub System.out.println(this.x.getValueFor(x)-this.y.getValueFor(x)); <|endfocus|> return (this.x.getValueFor(x)-this.y.getValueFor(x));
<|startcomment|> nit 2016 <|endcomment|> <|startfocus|> * Copyright 2015 Midokura SARL <|endfocus|> * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.midonet.cluster.rest_api.models; import com.fasterxml.jackson.annotation.JsonIgnore; import com.google.common.base.MoreObjects; import org.midonet.cluster.data.ZoomClass; import org.midonet.cluster.data.ZoomField; import org.midonet.cluster.models.Topology; import org.midonet.cluster.rest_api.ResourceUris; import java.net.URI; import java.util.List; import java.util.UUID; @ZoomClass(clazz = Topology.QOSPolicy.class) public class QOSPolicy extends UriResource { 
<|startcomment|> ditto <|endcomment|>  * See the License for the specific language governing permissions and * limitations under the License. */ package org.midonet.cluster.rest_api.neutron.models; import com.fasterxml.jackson.annotation.JsonProperty; import com.google.common.base.MoreObjects; import com.google.common.base.Objects; import org.midonet.cluster.data.ZoomClass; import org.midonet.cluster.data.ZoomField; import org.midonet.cluster.data.ZoomObject; import org.midonet.cluster.models.Commons; import org.midonet.cluster.models.Neutron; import org.midonet.cluster.util.IPAddressUtil; <|startfocus|> import java.util.UUID; <|endfocus|> @ZoomClass(clazz = Neutron.NeutronLoadBalancerPoolMember.class) public class PoolMemberV2 extends ZoomObject { @ZoomField(name = "id") public UUID id; @JsonProperty("tenant_id") @ZoomField(name = "tenant_id") public String tenantId; @JsonProperty("project_id") @ZoomField(name = "project_id") public String projectId; @JsonProperty("pool_id") @ZoomField(name = "pool_id") public UUID poolId; @ZoomField(name = "address", converter = IPAddressUtil.Converter.class)
<|startcomment|> subnetIds <|endcomment|>  public String toString() { return MoreObjects.toStringHelper(this) .add("id", id) .add("portId", portId) .add("subnetId", subnetId) <|startfocus|> .add("subnetIds", subnetId) <|endfocus|> .add("tenantId", tenantId).toString();
<|startcomment|> shouldn't this fill the rest of array with 0 like strncpy? <|endcomment|>  public void setName(String name) { setType(IFRN_NAME); for (int i = 0; i < name.length() && i < ifrnName.length; i++) { ifrnName[i] = (byte) name.charAt(i); <|startfocus|> } <|endfocus|>
<|startcomment|> tu mozna normalnie napisac update zamiast pobierac a potem zapisywac <|endcomment|>  public void addMoneyToCourse(Long idCourse, Double money) { // TODO walidacja id kursu, money nie moze byc < = 0 // wplacana kwota nie moze byc wieksza niz cena kursu QAttendingCourseModel attendingCourseModel = QAttendingCourseModel.attendingCourseModel; AttendingCourseModel acm = new JPAQuery<AttendingCourseModel>(entityManager) .from(attendingCourseModel) .where(attendingCourseModel.id.eq(idCourse)) .fetchFirst(); <|startfocus|> acm.setAmountOfPaid(acm.getAmountOfPaid() + money); this.update(acm);//TODO: NPE? <|endfocus|>
<|startcomment|> Remove this debugging statement. <|endcomment|>  public Version(String version) { String[] parts = version.split("[.]"); <|startfocus|> System.out.println(parts[0]); this.major = Integer.valueOf(parts[0]); <|endfocus|> if (parts[1] != null) { this.minor = Integer.valueOf(parts[1]); } if (parts[2] != null) { this.micro = Integer.valueOf(parts[2]); }
<|startcomment|> Should be KRAInfoResouce. <|endcomment|> //--- END COPYRIGHT BLOCK --- package org.dogtagpki.common; import java.net.URISyntaxException; import javax.ws.rs.core.Response; import com.netscape.certsrv.client.Client; import com.netscape.certsrv.client.PKIClient; /** * @author Ade Lee */ public class KRAInfoClient extends Client { public InfoResource resource; public KRAInfoClient(PKIClient client, String subsystem) throws URISyntaxException { super(client, subsystem, "info"); init(); } public void init() throws URISyntaxException { <|startfocus|> resource = createProxy(InfoResource.class); <|endfocus|> } public KRAInfo getInfo() throws Exception { Response response = resource.getInfo(); return client.getEntity(response, KRAInfo.class); } } 
<|startcomment|> RequestId? <|endcomment|>  public SecurityDataRecoveryEvent( String subjectID, String outcome, <|startfocus|> String recoveryID, String dataID, <|endfocus|> String pubkey) { super(LOGGING_PROPERTY); setParameters(new Object[] { subjectID, outcome, recoveryID, dataID, pubkey });
<|startcomment|> remove this comment, it does not give me any good info. <|endcomment|> <|startfocus|> / import java.io.*; // Java i/o library import java.util.Scanner; <|endfocus|> public class Timus1000 { public int sum(int first, int second) { return first+second; } public static void main(String[] arg){ Timus1000 math = new Timus1000(); Scanner input = new Scanner(System.in); int first = input.nextInt(); int second = input.nextInt(); System.out.println(math.sum(first,second)); } } 
<|startcomment|> You can simplify this whole problem by assigning some variables: boolean aInRange = a >= 10 && a <= 20; boolean bInRange = b >= 10 && b <= 20; if (aInRange && bInRange) { } else if (aInRange) { } else if (bInRange) { } else { } <|endcomment|>  public int max1020(int a , int b) { <|startfocus|> if ((a >= 10 && a <= 20) && (b >= 10 && b <= 20) && (a > b)) { return a; } <|endfocus|> if ((a >= 10 && a <= 20) && (b >= 10 && b <= 20) && (b > a)) { return b; } if (!(a >= 10 && a <= 20) && !(b >= 10 && b <= 20)) { return 0; } if((a >= 10 && a <= 20) && !(b >= 10 && b <= 20)) { return a; } else { return b; }
<|startcomment|> You must check the values == null first: if (values == null || values.length == 0) { ... Remember, if values == null, your values.length == 0 check will crash before it has the chance for this check values == null. <|endcomment|>  public static double avgArray(double[] values){ double average = 0; <|startfocus|> if ((values.length == 0) || (values == null)) { <|endfocus|> throw new IllegalArgumentException("Invalid input"); } else { for (double value : values) { average += value; } return average / values.length; }
<|startcomment|> it manages the <|endcomment|>  // when we are done. final Async async = context.async(); // We create a HTTP client and query our application. When we get the response we check it contains // the 'Welcome' message. Then, we call the `complete` method on the async handler to declare // this async (and here the test) done. Notice that the assertions are made on the 'context' <|startfocus|> // object and are not Junit assert. This ways it manage the async aspect of the test the right way. <|endfocus|> vertx.createHttpClient().getNow(port, "localhost", "/", response -> { response.exceptionHandler(context.exceptionHandler()); response.bodyHandler(body -> { assertThat(response.statusCode()).isEqualTo(200); assertThat(response.getHeader(HttpHeaders.CONTENT_TYPE).equals(HttpHeaders.TEXT_HTML)); assertThat(body.toString()).contains("Welcome"); async.complete(); }); });
<|startcomment|> We probably can do this instead: try { r = CryptoUtil.getRandomNumberGenerator(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } <|endcomment|>  public static String[] randomize(String [] t) { String[] s = new String[t.length]; System.arraycopy(t,0,s,0,t.length); String[] result = new String[s.length]; int j=0; SecureRandom r = null; try { r = SecureRandom.getInstance("pkcs11prng","Mozilla-JSS"); <|startfocus|> } catch (NoSuchAlgorithmException | NoSuchProviderException e) { <|endfocus|> } for (int i=0; i<s.length; i++) { int x = r.nextInt(); if (x <0) x = -x; int n = x % (s.length-i); result[j] = s[n]; s[n] = s[s.length-i-1]; j++; } return result;
<|startcomment|> should this be changed to match the e above? it shouldn't just assume it's CMS_KRA_INVALID_PRIVATE_KEY. <|endcomment|>  PKIArchiveOptionsContainer aOpts[] = null; String profileId = request.getExtDataInString(IRequest.PROFILE_ID); if (profileId == null || profileId.equals("")) { try { aOpts = CRMFParser.getPKIArchiveOptions( request.getExtDataInString(IRequest.HTTP_PARAMS, CRMF_REQUEST)); } catch (IOException e) { audit(SecurityDataArchivalRequestEvent.createFailureEvent( auditSubjectID, auditRequesterID, requestId, null, e)); throw new EKRAException( <|startfocus|> CMS.getUserMessage("CMS_KRA_INVALID_PRIVATE_KEY")); <|endfocus|> } } else { // profile-based request PKIArchiveOptions options = toPKIArchiveOptions( request.getExtDataInByteArray(IEnrollProfile.REQUEST_ARCHIVE_OPTIONS)); aOpts = new PKIArchiveOptionsContainer[1]; aOpts[0] = new PKIArchiveOptionsContainer(options, 0/* not matter */); request.setExtData("dbStatus", "NOT_UPDATED"); } for (int i = 0; i < aOpts.length; i++) { ArchiveOptions opts = new ArchiveOptions(aOpts[i].mAO); if (allowEncDecrypt_archival == true) {
<|startcomment|> Just wondering, are there plans to offer specialised implementation here? The current one is equivalent to not declaring the method. (TizenPathDialog doesn't have this.) <|endcomment|> <|startfocus|> protected void okPressed() { super.okPressed(); <|endfocus|>
<|startcomment|> Ok, now you are really digging yourself into a hole. In my humble opinion, making this widget and its callers support multiple addresses in a single input box is *unrelated* to the functionality of adding an additional reviewer to a change. By combining all of this into a single change you have made it very difficult for me to comment on the parts that need work. You also are slowing down acceptance of what was already pretty close to being good as-is, which is the new reviewer feature. Please, lets do this "multiple people in one input box" work in a different change, after we get the basic add one reviewer working. Go back to patch set 2. Fix the couple of items there, including deleting split call that I was objecting to being in that patch. Lets merge that, then do this work as a follow-on improvement. <|endcomment|> <|startfocus|> public List<String> getNamesOrEmails() { <|endfocus|> String s = nameTxtBox.getText(); if (s == null || s.equals(Util.C.defaultAccountName())) { s = ""; } return Arrays.asList(s.split(";"));
<|startcomment|> Its 2009. <|endcomment|> <|startfocus|> Copyright (C) 2008 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server; import com.google.gerrit.client.reviewdb.Project; import com.google.gerrit.client.reviewdb.Change; import com.google.gerrit.git.WorkQueue; import com.google.gwtjsonrpc.server.XsrfException; import com.google.gwtorm.client.OrmException; import org.spearce.jgit.lib.Repository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; import java.io.InputStream; import java.util.concurrent.TimeUnit; import java.util.ArrayList;
<|startcomment|> Please add "final". <|endcomment|>  public Boolean fromResult(JavaScriptObject responseObject) { return booleanResult(responseObject); } }; public static ResultDeserializer<Byte> BYTE_INSTANCE = new ResultDeserializer<Byte>() { @Override public Byte fromResult(JavaScriptObject responseObject) { return byteResult(responseObject); } }; public static ResultDeserializer<Character> CHARACTER_INSTANCE = new ResultDeserializer<Character>() { @Override public Character fromResult(JavaScriptObject responseObject) { return charResult(responseObject); } }; <|startfocus|> public static ResultDeserializer<Double> DOUBLE_INSTANCE = <|endfocus|> new ResultDeserializer<Double>() { @Override public Double fromResult(JavaScriptObject responseObject) { return doubleResult(responseObject); } }; public static ResultDeserializer<Float> FLOAT_INSTANCE = new ResultDeserializer<Float>() { @Override public Float fromResult(JavaScriptObject responseObject) { return floatResult(responseObject); } }; public static ResultDeserializer<Integer> INTEGER_INSTANCE = new ResultDeserializer<Integer>() { @Override public Integer fromResult(JavaScriptObject responseObject) { return intResult(responseObject); } };
<|startcomment|> I try to defer UI construction later, as Screen objects can be created pretty early. I would move these into the hunk below, even if that means holding onto the PatchSetKeys in an instance member. <|endcomment|>  protected PatchScreen(final Patch.Key id, final PatchSetKeys patch, final PatchTable files) { patchKey = id; fileList = files; idSideA = null; idSideB = id.getParentKey(); <|startfocus|> this.previousPatchLink = patch.getPreviousPatchLink(getPatchType()); this.nextPatchLink = patch.getNextPatchLink(getPatchType()); <|endfocus|> if (Gerrit.isSignedIn()) { final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences(); contextLines = p.getDefaultContext(); } else { contextLines = AccountGeneralPreferences.DEFAULT_CONTEXT; }
<|startcomment|> I hate this style of programming. A null assignment here potentially allows the variable to not be overwritten later. Usually its better to leave it unassigned and let the compiler error out if we forget to assign it to a more meaningful value later, during the decision tree. But, actually, in this context, since its also the return value, it might just be cleaner to remove the variable and have each decision point return the link object. <|endcomment|>  private PatchLink createLink(int index, PatchScreen.Type patchType, String before, String after) { Patch patch = patchList.get(index); String fileName = patch.getFileName(); int s = fileName.indexOf(File.pathSeparator); if (s >= 0) { fileName = fileName.substring(s + 1); } Key thisKey = patch.getKey(); <|startfocus|> PatchLink result = null; <|endfocus|> String linkText = before + " " + fileName + " " + after; if (patchType == PatchScreen.Type.SIDE_BY_SIDE && patch.getPatchType() == Patch.PatchType.UNIFIED) { result = new PatchLink.SideBySide(linkText, thisKey, index, this); } else { result = new PatchLink.Unified(linkText, thisKey, index, this); } return result;
<|startcomment|> Duplicate with line above it. Really though, I think you want to use db.accountExternalIds().suggestByEmailAddress(String,String,int) as that includes secondary email addresses, permitting searching for "owner:spearce" and finding me, even though my preferred email address is "sop@google.com". <|endcomment|>  */ private static ResultSet<Account>[] getAccountSources(final String userName, AccountAccess dbAccounts) throws OrmException { ResultSet<Account> emails = dbAccounts.suggestByPreferredEmail(userName, userName, 3); ResultSet<Account>[] result = new ResultSet[] { dbAccounts.suggestBySshUserName(userName, userName + "\u9fa5", 10), <|startfocus|> dbAccounts.suggestByPreferredEmail(userName, userName + "\u9fa5", 10), dbAccounts.suggestByPreferredEmail(userName, userName + "\u9fa5", 10) <|endfocus|> }; return result; } /** * This method factors out the enumeration of accounts coming from several sources * (ssh, email address, full name). */ @Override public void run() { final Map<Change.Id, Change> resultChanges = new HashMap<Change.Id, Change>(); AccountAccess dbAccounts = db.accounts(); try { ResultSet<Account>[] accountSources = getAccountSources(userName, db.accounts()); for (ResultSet<Account> accounts : accountSources) {
<|startcomment|> This comment doesn't make any sense; change can be null if the change has been deleted from the database but the approval was orphaned. Otherwise, it shouldn't be null. <|endcomment|>  @Override void process(ReviewDb db, Account.Id account, Map<Id, Change> outResultChanges) throws OrmException { ChangeApprovalAccess changes = db.changeApprovals(); ChangeAccess changeAccess = db.changes(); Iterator<ChangeApproval> changeIterator = changes.reviewedByUser(account).iterator(); while (changeIterator.hasNext()) { ChangeApproval approval = changeIterator.next(); Change change = changeAccess.get(approval.getChangeId()); <|startfocus|> // This might return null if the change does't have any reviewer <|endfocus|> if (change != null) { outResultChanges.put(change.getId(), change); } } } }; return new ArrayList<Change.Id>(processor.call()); } private abstract class QueryNext implements Action<SingleListChangeInfo> { protected final String pos; protected final int limit; protected final int slim; QueryNext(final int pageSize, final String pos) { this.pos = pos; this.limit = safePageSize(pageSize); this.slim = limit + 1; } 
<|startcomment|> Trailing whitespace. <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.client.reviewdb; import com.google.gwtorm.client.Column; import com.google.gwtorm.client.CompoundKey; /** * An entity that keeps track of what user reviewed what patches. */ public final class AccountPatchReview { <|startfocus|> <|endfocus|> public static class Key extends CompoundKey<Account.Id> { private static final long serialVersionUID = 1L; @Column protected Account.Id accountId; @Column(name = Column.NONE) protected Patch.Key patchId; protected Key() { accountId = new Account.Id(); patchId = new Patch.Key(); } public Key(final Patch.Key p, final Account.Id a) { patchId = p; accountId = a; } @Override public com.google.gwtorm.client.Key<?>[] members() {
<|startcomment|> Unnecessary whitespace. <|endcomment|>  throw new PatchSetInfoNotAvailableException(e); } finally { db.close(); } } public static PatchSetInfo patchSetInfoForPatchSetId(PatchSet.Id id) throws PatchSetInfoNotAvailableException { ReviewDb db; try { db = Common.getSchemaFactory().open(); return patchSetInfoForPatchSet(db.patchSets().get(id)); } catch (OrmException e) { throw new PatchSetInfoNotAvailableException(e); } } private static UserIdentity toUserIdentity(final PersonIdent who) throws OrmException { <|startfocus|> <|endfocus|> final UserIdentity u = new UserIdentity(); u.setName(who.getName()); u.setEmail(who.getEmailAddress()); u.setDate(new Timestamp(who.getWhen().getTime())); u.setTimeZone(who.getTimeZoneOffset()); if (u.getEmail() != null) { // If only one account has access to this email address, select it // as the identity of the user. // final Set<Account.Id> a = new HashSet<Account.Id>();
<|startcomment|> Isn't this unnecessary? If you made the addOption method public in the upstream parser, we don't need to override the class here. <|endcomment|>  import org.kohsuke.args4j.Argument; import org.kohsuke.args4j.FieldSetter; import org.kohsuke.args4j.Option; import org.kohsuke.args4j.spi.OptionHandler; import java.io.IOException; import java.io.PrintWriter; import java.lang.annotation.Annotation; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.Collections; import java.util.Iterator; import java.util.List; import java.util.SortedMap; import java.util.TreeMap; public class ApproveCommand extends BaseCommand { <|startfocus|> public class ApproveCmdLineParser extends CmdLineParser { public ApproveCmdLineParser(final Object bean) { super(bean); } <|endfocus|> } protected final CmdLineParser newCmdLineParserInstance(final Object bean) { Field f = null; ApproveCmdLineParser parser = new ApproveCmdLineParser(bean); try { f = CmdOption.class.getField("value"); for (CmdOption c : optionList) { parser.addOption(new FieldSetter(c, f), c); } } catch (Exception e) { e.printStackTrace(); } return parser; } public class CmdOption implements Option {
<|startcomment|> Yea, usually I try to return only one AccountInfoCache per RPC. Its not uncommon for the same name/email to appear multiple times in a dashboard (for example) so using one cache allows all occurrences to share the same strings, and makes it easier on the outgoing zip to deflate the response as small as possible. Also, I'm a lazy bastard. Building one AIC is usually easier than building one per row.. just declare an AccountInfoCacheFactory in scope, call want(id) for each account we need, and just before the RPC ends, ask that factory to convert to an AIC instance. <|endcomment|> // limitations under the License. package com.google.gerrit.client.data; import com.google.gerrit.client.reviewdb.ApprovalCategory; import com.google.gerrit.client.reviewdb.PatchSetApproval; import java.util.Collections; import java.util.HashMap; import java.util.Map; /** Summarizes the approvals (or negative approvals) for a patch set. * This will typically contain zero or one approvals for each * category, with all of the approvals coming from a single patch set. */ public class ApprovalSummary { <|startfocus|> protected AccountInfoCache accounts; <|endfocus|> protected Map<ApprovalCategory.Id, PatchSetApproval> approvals; protected ApprovalSummary() { } public ApprovalSummary(final Iterable<AccountInfo> accts, final Iterable<PatchSetApproval> list) { accounts = new AccountInfoCache(accts); approvals = new HashMap<ApprovalCategory.Id, PatchSetApproval>(); for (final PatchSetApproval a : list) { approvals.put(a.getCategoryId(), a); } } public Map<ApprovalCategory.Id, PatchSetApproval> getApprovalMap() { return Collections.unmodifiableMap(approvals); } } 
<|startcomment|> Also needs name = "account_id" in the annotation. <|endcomment|>  // they can't be the most recent. // continue; } if (e.isScheme(SCHEME_MAILTO)) { // Don't ever consider an email address as a "recent login" // continue; } if (mostRecent == null || lastUsed.getTime() > mostRecent.getLastUsedOn().getTime()) { mostRecent = e; } } return mostRecent; } @Column(name = Column.NONE) Key key; @Column <|startfocus|> Account.Id accountId; <|endfocus|> @Column(notNull = false) String emailAddress; @Column(notNull = false) Timestamp lastUsedOn; /** <i>computed value</i> is this identity trusted by the site administrator? */ protected boolean trusted; String sha1Id; protected AccountExternalId() { } /** * Create a new binding to an external identity. * * @param who the account this binds to. * @param k the binding key. */
<|startcomment|> I think you can just do @see http:// and skip the anchor tag. <|endcomment|>  /** * Specify the json rpc protocol version and transport mechanism to be used for * a service. * <p> * Default is version 1.1 over HTTP POST. * <p> * <b>Note: if you use the generated (servlet), only version 1.1 over HTTP POST * is supported</b>. */ @Target(ElementType.TYPE) public @interface RpcImpl { /** * JSON-RPC protocol versions. */ public enum Version { /** * Version 1.1. <|startfocus|> * <|endfocus|> * @see <a * href="http://groups.google.com/group/json-rpc/web/json-rpc-1-1-wd">Spec</a> */ V1_1, /** * Version 2.0. * * @see <a * href="http://groups.google.com/group/json-rpc/web/json-rpc-1-2-proposal">Spec</a> */ V2_0 } /** * Supported transport mechanisms. */ public enum Transport { HTTP_POST, HTTP_GET } /**
<|startcomment|> This is why Guice is so cool. Just declare in your constructor the parameters you need. They will be automatically provided to you when someone else has declared they need you. Done. :-) <|endcomment|>  public void start() { RepositoryCacheConfig repoCacheCfg = new RepositoryCacheConfig(); repoCacheCfg.fromConfig(serverConfig); repoCacheCfg.install(); WindowCacheConfig cfg = new WindowCacheConfig(); cfg.fromConfig(serverConfig); if (serverConfig.getString("core", null, "streamFileThreshold") == null) { long mx = Runtime.getRuntime().maxMemory(); <|startfocus|> int limit = (int) Math.min( mx / 4, // don't use more than 1/4 of the heap. 2047 << 20); // cannot exceed array length <|endfocus|> if ((5 << 20) < limit && limit % (1 << 20) != 0) { // If the limit is at least 5 MiB but is not a whole multiple // of MiB round up to the next one full megabyte. This is a very // tiny memory increase in exchange for nice round units. limit = ((limit / (1 << 20)) + 1) << 20; } String desc; if (limit % (1 << 20) == 0) {
<|startcomment|> Why are we testing both? Wouldn't we want to use the RefRight only if they are more specific? (See my remarks in FunctionState.) <|endcomment|>  public boolean isValid(final CurrentUser user, final ApprovalType at, final FunctionState state) { <|startfocus|> return isProjectStateValid(user, at, state) && isRefStateValid(user, at, state); <|endfocus|>
<|startcomment|> You can't make this mutable. The LdapRealm object is a singleton in the virtual machine, with concurrent authentication attempts all using the same object. Updating the fields from within the authenticate() method as you are doing below might allow "bob" to login as "alice" if they both logged in at exactly the same time. <|endcomment|> import javax.naming.NamingEnumeration; import javax.naming.NamingException; import javax.naming.directory.Attribute; import javax.naming.directory.DirContext; import javax.naming.directory.InitialDirContext; import javax.net.ssl.SSLSocketFactory; @Singleton class LdapRealm implements Realm { private static final Logger log = LoggerFactory.getLogger(LdapRealm.class); private static final String LDAP = "com.sun.jndi.ldap.LdapCtxFactory"; private static final String USERNAME = "username"; private static final String GROUPNAME = "groupname"; <|startfocus|> private final String server; private String username; private String password; private final LdapType type; private final boolean sslVerify; <|endfocus|> private final AuthConfig authConfig; private final SchemaFactory<ReviewDb> schema; private final EmailExpander emailExpander; private final ParamertizedString accountFullName; private final ParamertizedString accountEmailAddress; private final ParamertizedString accountSshUserName; private final String accountMemberField; private final List<LdapQuery> accountQueryList; private final SelfPopulatingCache<String, Account.Id> usernameCache; private final GroupCache groupCache; private boolean groupNeedsAccount; private final List<String> groupBases;
<|startcomment|> Nak. I think that within a double quoted string we should behave like Bourne shell does and actually consume \" as ", or \\ as \. <|endcomment|>  case ' ': if (inquote || indblquote) r.append(b); else if (r.length() > 0) { list.add(r.toString()); r = new StringBuilder(); } continue; case '\"': if (inquote) r.append(b); indblquote = !indblquote; continue; case '\'': if (indblquote) r.append(b); inquote = !inquote; continue; case '\\': <|startfocus|> if (inquote || indblquote || ip == commandLine.length()) <|endfocus|> r.append(b); // literal within a quote else r.append(commandLine.charAt(ip++)); continue; default: r.append(b); continue; } } if (r.length() > 0) { list.add(r.toString()); } return list.toArray(new String[list.size()]);
<|startcomment|> Just mark both of these final, it shouldn't be able to change, right? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.common.data; import com.google.gerrit.reviewdb.RefRight; /** * Additional data about a {@link RefRight} not normally loaded: defines if a right is * inherited from a parent structure (e.g. a parent project). */ <|startfocus|> public class InheritedRefRight { <|endfocus|> private RefRight right; private boolean inherited; /** * Creates a instance of a {@link RefRight} with data about inheritance */ public InheritedRefRight(){ } /** * Creates a instance of a {@link RefRight} with data about inheritance * @param right the right * @param inherited true if the right is inherited, false otherwise */ public InheritedRefRight(RefRight right, boolean inherited){ this.right = right; this.inherited = inherited; } 
<|startcomment|> Style-nit: Space before { <|endcomment|>  static final Logger log = LoggerFactory.getLogger(ProjectCreatorGroupsProvider.class); private final Set<AccountGroup.Id> groupIds; @Inject ProjectCreatorGroupsProvider(@GerritServerConfig final Config config, SchemaFactory<ReviewDb> db, final SystemConfig systemConfig) { String[] createGroupNames = config.getStringList("repository", "*", "createGroup"); Set<AccountGroup.Id> createGroups = ConfigUtil.groupsFor(db, createGroupNames, log); if (createGroups.isEmpty()){ groupIds = Collections.singleton(systemConfig.adminGroupId); <|startfocus|> }else{ <|endfocus|> groupIds = createGroups; } } public Set<AccountGroup.Id> get() { return groupIds; } } 
<|startcomment|> Style-nit: We typically put static fields above all instance members, so this should be before line 35. We also offset them by one blank line from the instance members, so insert a new blank line below the constant. <|endcomment|> import com.google.gwtorm.server.Access; import com.google.gwtorm.server.ListResultSet; import com.google.gwtorm.server.OrmConcurrencyException; import com.google.gwtorm.server.OrmException; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; /** Internal base class for implementations of {@link Access}. */ public abstract class JdbcAccess<T, K extends Key<?>> extends <|startfocus|> AbstractAccess<T, K> { <|endfocus|> private final JdbcSchema schema; protected JdbcAccess(final JdbcSchema s) { schema = s; } @Override public void beginTransaction(K key) throws OrmException { try { schema.getConnection().setAutoCommit(false); } catch (SQLException e) { throw convertError("beginTransaction", e); } } @Override public final com.google.gwtorm.server.ResultSet<T> get(final Iterable<K> keys) throws OrmException { final Collection<K> keySet; if (keys instanceof Collection) { keySet = (Collection<K>) keys;
<|startcomment|> Style-nit: Please don't insert unnecessary blank lines. <|endcomment|>  list.remove(limit); } return atEnd; } abstract ResultSet<Change> query(final ReviewDb db, final int slim, String sortKey) throws OrmException; } private abstract class QueryPrev extends QueryNext { QueryPrev(int pageSize, String pos) { super(pageSize, ChangeUtil.invertSortKey(pos)); } @Override boolean finish(final ArrayList<ChangeInfo> list) { final boolean atEnd = super.finish(list); Collections.reverse(list); return atEnd; } } <|startfocus|> <|endfocus|> } 
<|startcomment|> You also need to declare a protected no-arg constructor so that gwtorm can create an instance of this type when it reads from the database. <|endcomment|>  return token; } @Override protected void set(String newValue) { token = newValue; } } @Column(id = 1, name = Column.NONE) protected ActiveSession.Key key; @Column(id = 2) protected Account.Id accountId; @Column(id = 3) protected long refreshCookieAt; @Column(id = 4) protected boolean persistentCookie; @Column(id = 5) protected AccountExternalId.Key externalId; @Column(id = 6) protected String xsrfToken; <|startfocus|> <|endfocus|> public ActiveSession(final ActiveSession.Key k, final Account.Id accountId, final long refreshCookieAt, final boolean persistentCookie, final AccountExternalId.Key externalId, final String xsrfToken) { this.key = k; this.accountId = accountId; this.refreshCookieAt = refreshCookieAt; this.persistentCookie = persistentCookie; this.externalId = externalId; this.xsrfToken = xsrfToken; } public Account.Id getAccountId() { return accountId; } public void setAccountId(Account.Id accountId) { this.accountId = accountId; }
<|startcomment|> Instead of deleting everything up front, load what exists in the database already, and do a set-difference in memory, so that you only have to update the rows that were changed. For most merge operations in the manifest repository there will be no difference, so not churning the SQL server's transaction log would be appreciated by the SQL server's administrators. <|endcomment|>  } } catch (Exception e) { log.error("Cannot send email for submitted patch set " + c.getId(), e); return; } try { final MergedSender cm = mergedSenderFactory.create(c); if (from != null) { cm.setFrom(from.getAccountId()); } cm.setPatchSet(patchSet); cm.send(); } catch (Exception e) { log.error("Cannot send email for submitted patch set " + c.getId(), e); } <|startfocus|> } <|endfocus|> @Override public String toString() { return "send-email merged"; } })); if (submitter != null) { try { hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db); } catch (OrmException ex) { log.error("Cannot run hook for submitted patch set " + c.getId(), ex); } }
<|startcomment|> Please use Set<Project.NameKey>. <|endcomment|>  Realm realm, String anonymousCowardName, Provider<String> canonicalUrl, AccountCache accountCache, GroupBackend groupBackend, Boolean disableReverseDnsLookup, @Nullable Provider<SocketAddress> remotePeerProvider, Account.Id id, @Nullable CurrentUser realUser) { super(capabilityControlFactory); this.canonicalUrl = canonicalUrl; this.accountCache = accountCache; this.groupBackend = groupBackend; this.authConfig = authConfig; this.realm = realm; this.anonymousCowardName = anonymousCowardName; this.disableReverseDnsLookup = disableReverseDnsLookup; <|startfocus|> this.remotePeerProvider = remotePeerProvider; <|endfocus|> this.accountId = id; this.realUser = realUser != null ? realUser : this;
<|startcomment|> Nak. These two fields *MUST* use different objects. That's why none() created a new empty array. <|endcomment|> import com.google.gwtorm.server.OrmException; import com.google.gwtorm.server.SchemaFactory; import com.google.inject.Inject; import com.google.inject.Module; import com.google.inject.Provider; import com.google.inject.Singleton; import com.google.inject.TypeLiteral; import com.google.inject.name.Named; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.Repository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; <|startfocus|> import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; <|endfocus|> import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.concurrent.ExecutionException; /** Provides the {@link SshKeyCacheEntry}. */ @Singleton public class SshKeyCacheImpl implements SshKeyCache { private static final Logger log = LoggerFactory.getLogger(SshKeyCacheImpl.class); private static final String CACHE_NAME = "sshkeys"; static final Iterable<SshKeyCacheEntry> NO_SUCH_USER = none();
<|startcomment|> We don't edit the copyright date. <|endcomment|> <|startfocus|> Copyright (C) 2009-2010 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.mail; import com.google.gerrit.reviewdb.Account; import com.google.gerrit.reviewdb.Change; import com.google.gerrit.server.ssh.SshInfo; import com.jcraft.jsch.HostKey; import java.util.Collection; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set; /** Sends an email alerting a user to a new change for them to review. */
<|startcomment|> Should be e.getEdits() != null <|endcomment|>  if (header[e - 1] == '\n') { e--; } headerLines.add(RawParseUtils.decode(Constants.CHARSET, header, b, e)); } return headerLines; } Patch toPatch(final PatchSet.Id setId) { final Patch p = new Patch(new Patch.Key(setId, getNewName())); p.setChangeType(getChangeType()); p.setPatchType(getPatchType()); p.setSourceFileName(getOldName()); p.setInsertions(insertions); p.setDeletions(deletions); return p; } void writeTo(final OutputStream out) throws IOException { <|startfocus|> writeEnum(out, changeType); writeEnum(out, patchType); <|endfocus|> writeString(out, oldName); writeString(out, newName); writeBytes(out, header); writeVarInt32(out, insertions); writeVarInt32(out, deletions); writeVarInt32(out, edits.size()); for (final Edit e : edits) { writeVarInt32(out, e.getBeginA()); writeVarInt32(out, e.getEndA()); writeVarInt32(out, e.getBeginB());
<|startcomment|> I would prefer shorter cache names: starred_user starred_change <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server; import com.google.common.cache.CacheLoader; import com.google.common.cache.LoadingCache; <|startfocus|> import com.google.common.collect.HashBasedTable; <|endfocus|> import com.google.gerrit.extensions.registration.DynamicItem; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.RefNames; import com.google.gerrit.reviewdb.client.StarredChange; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.cache.CacheModule; import com.google.gerrit.server.config.AllUsersName; import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.notedb.NotesMigration; import com.google.inject.Inject; import com.google.inject.Module; import com.google.inject.Provider; import com.google.inject.Singleton; import com.google.inject.TypeLiteral; import com.google.inject.name.Named; import org.eclipse.jgit.lib.Repository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.Serializable;
<|startcomment|> Style-nit: Unnecessary blank lines. <|endcomment|>  cd.setProjectState(projectMap.get(cd.getChange().getProject())); } } db.close(); return data; } @Override public int getCardinality() { if (cardinality < 0) { cardinality = Integer.MAX_VALUE; for (Predicate<ChangeData> p : getChildren()) { if (p instanceof ChangeDataSource) { int c = ((ChangeDataSource) p).getCardinality(); cardinality = Math.min(cardinality, c); } } } return cardinality; } <|startfocus|> <|endfocus|> } 
<|startcomment|> The groups should be inside ProjectControl. <|endcomment|> import org.eclipse.jgit.transport.PreUploadHookChain; import org.eclipse.jgit.transport.UploadPack; /** Publishes Git repositories over SSH using the Git upload-pack protocol. */ final class Upload extends AbstractGitCommand { @Inject private TransferConfig config; @Inject private VisibleRefFilter.Factory refFilterFactory; @Inject private DynamicSet<PreUploadHook> preUploadHooks; @Inject private DynamicSet<PostUploadHook> postUploadHooks; @Inject private DynamicSet<UploadPackInitializer> uploadPackInitializers; @Inject private UploadValidators.Factory uploadValidatorsFactory; @Inject private SshSession session; @Inject private PermissionBackend permissionBackend; <|startfocus|> <|endfocus|> @Override protected void runImpl() throws IOException, Failure { try { permissionBackend .user(user) .project(projectState.getNameKey()) .check(ProjectPermission.RUN_UPLOAD_PACK); } catch (AuthException e) { throw new Failure(1, "fatal: upload-pack not permitted on this server"); } catch (PermissionBackendException e) { throw new Failure(1, "fatal: unable to check permissions " + e); } final UploadPack up = new UploadPack(repo);
<|startcomment|> Why not compare Project.Ids? <|endcomment|>  public void run() { try { final ReviewDb db = schema.open(); try { for (final Project project : db.projects().all()) { <|startfocus|> if (!project.getNameKey().equals(wildProject.getNameKey())) { <|endfocus|> replication.scheduleFullSync(project.getNameKey(), urlMatch); } } } finally { db.close(); } } catch (OrmException e) { log.error("Cannot enumerate known projects", e); }
<|startcomment|> ClickEvent and ClickHandler are not used -> imports can be removed <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.client.account; import com.google.gerrit.client.Gerrit; import com.google.gerrit.client.ui.NavigationTable; import com.google.gerrit.common.PageLinks; import com.google.gerrit.reviewdb.Project; <|startfocus|> import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.event.dom.client.ClickHandler; <|endfocus|> import com.google.gwt.event.dom.client.KeyCodes; import com.google.gwt.user.client.DOM; import com.google.gwt.user.client.Element; import com.google.gwt.user.client.Event; import com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter; import java.util.List; public class ProjectsTable extends NavigationTable<Project> { public ProjectsTable() { setSavePointerId(PageLinks.SETTINGS_PROJECTS); keysNavigation.add(new PrevKeyCommand(0, 'k', Util.C.projectListPrev())); keysNavigation.add(new NextKeyCommand(0, 'j', Util.C.projectListNext()));
<|startcomment|> abandonChange and submitChange should be mutually exclusive. Its nonsensical to call `gerrit review --submit --abandon`. We should check for this after parseCommandLine() before we continue further. <|endcomment|>  @Option(name = "--submit", aliases = "-s", usage = "submit the specified patch set(s)") private boolean submitChange; @Option(name = "--publish", usage = "publish the specified draft patch set(s)") private boolean publishPatchSet; @Option(name = "--delete", usage = "delete the specified draft patch set(s)") private boolean deleteDraftPatchSet; <|startfocus|> @Option(name = "--json", aliases = "-j", usage = "use json as argument") <|endfocus|> private boolean json; @Option(name = "--label", aliases = "-l", usage = "custom label(s) to assign", metaVar = "LABEL=VALUE") void addLabel(final String token) { LabelVote v = LabelVote.parseWithEquals(token); LabelType.checkName(v.getLabel()); // Disallow SUBM. customLabels.put(v.getLabel(), v.getValue()); } @Inject private ReviewDb db; @Inject private ProjectControl.Factory projectControlFactory; @Inject private AllProjectsName allProjects; @Inject
<|startcomment|> Style-nit: It might not be worth the temporary variable here. The line would be shorter if you just did: result.add(new ProjectData(....)); <|endcomment|>  final List<Change> changes = db.changes().byProjectHaschange(p.getNameKey()).toList(); try { final ProjectControl c = projectControlFactory.controlFor(p.getNameKey()); //Administrators users are also considered in method "isOwner". if (c.isVisible() || c.isOwner()) { if (c.isOwner() && changes.size() == 0) { canBeDeleted = true; } <|startfocus|> final ProjectData projectData = new ProjectData(p.getNameKey(), p.getDescription(), canBeDeleted); result.add(projectData); <|endfocus|> } } catch (NoSuchProjectException e) { continue; } } Collections.sort(result, new Comparator<ProjectData>() { public int compare(final ProjectData a, final ProjectData b) { return a.getName().compareTo(b.getName()); } }); return result; } } 
<|startcomment|> I think the alias should be '-S' (only one '-'), shouldn't it? <|endcomment|> import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.ReplicationQueue; import com.google.gerrit.sshd.BaseCommand; import com.google.gwtorm.client.OrmException; import com.google.inject.Inject; import org.apache.sshd.server.Environment; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.lib.RefUpdate; import org.eclipse.jgit.lib.Repository; import org.kohsuke.args4j.Option; import java.io.PrintWriter; import java.util.ArrayList; <|startfocus|> import java.util.Collection; import java.util.Collections; <|endfocus|> import java.util.HashSet; import java.util.List; import java.util.Set; /** Create a new project. **/ final class CreateProject extends BaseCommand { @Option(name = "--name", required = true, aliases = {"-n"}, metaVar = "NAME", usage = "name of project to be created") private String projectName; @Option(name = "--owner", aliases = {"-o"}, usage = "owner(s) of project") private List<AccountGroup.Id> ownerIds; 
<|startcomment|> Drop this constructor and always use the one that supplies the author time zone. <|endcomment|>  import com.google.gerrit.reviewdb.Account; import com.google.gerrit.reviewdb.ApprovalCategory; import com.google.gerrit.reviewdb.Branch; import com.google.gerrit.reviewdb.Change; import com.google.gerrit.reviewdb.Project; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.util.TimeZone; class ReviewNoteHeaderFormatter { private final DateFormat rfc2822DateFormatter; private final StringBuilder sb = new StringBuilder(); <|startfocus|> ReviewNoteHeaderFormatter() { this(TimeZone.getTimeZone("GMT")); } <|endfocus|> ReviewNoteHeaderFormatter(TimeZone tz) { rfc2822DateFormatter = new SimpleDateFormat("dd MMM yyyy HH:mm:ss Z", Locale.US); rfc2822DateFormatter.setCalendar(Calendar.getInstance(tz, Locale.US)); } void appendChangeId(Change.Id changeId) { sb.append("Change-Id: ").append(changeId).append("\n"); } void appendApproval(ApprovalCategory category, short value, Account user) { sb.append(category.getName());
<|startcomment|> Wrong date. <|endcomment|> <|startfocus|> Copyright (C) 2008 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.client.ui; import com.google.gerrit.client.Gerrit; import com.google.gerrit.client.admin.Util; import com.google.gerrit.client.ui.HintTextBox; import com.google.gerrit.client.ui.RPCSuggestOracle; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.event.dom.client.ClickHandler; import com.google.gwt.event.dom.client.KeyCodes; import com.google.gwt.event.dom.client.KeyPressEvent; import com.google.gwt.event.dom.client.KeyPressHandler;
<|startcomment|> I wonder if --group / -g isn't a better name for this option. <|endcomment|>  @Option(name = "--member", aliases = {"-m"}, metaVar = "USERNAME", usage = "initial set of users to become members of the group") void addMember(final Account.Id id) { initialMembers.add(id); } private final Set<AccountGroup.Id> initialIncludedGroups = new HashSet<AccountGroup.Id>(); <|startfocus|> @Option(name = "--included-groups", aliases = "-i", metaVar = "INCLUDEDGROUPS", usage = "initial set of groups to be included in the group") <|endfocus|> void addIncludedGroup(final AccountGroup.Id id) { initialIncludedGroups.add(id); } @Inject private PerformCreateGroup.Factory performCreateGroupFactory; @Override public void start(Environment env) throws IOException { startThread(new CommandRunnable() { @Override public void run() throws Exception { parseCommandLine(); createGroup(); } }); } private void createGroup() throws OrmException, UnloggedFailure { final PerformCreateGroup performCreateGroup = performCreateGroupFactory.create(); try { performCreateGroup.createGroup(groupName, groupDescription, ownerGroupId,
<|startcomment|> Please extract to the ChangeConstants.java interface and ChangeConstants.properties file. <|endcomment|>  patchesList = new ListBox(); patchesList.addChangeHandler(new ChangeHandler() { @Override public void onChange(ChangeEvent event) { final int index = patchesList.getSelectedIndex(); final String selectedPatchSet = patchesList.getValue(index); if (index == 0) { diffBaseId = null; } else { diffBaseId = PatchSet.Id.parse(selectedPatchSet); } if (patchSetsBlock != null) { patchSetsBlock.refresh(diffBaseId); } } }); <|startfocus|> patchesList.addItem("Base"); <|endfocus|> patchesGrid = new Grid(1, 2); patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion()); patchesGrid.setText(0, 0, Util.C.oldVersionHistory()); patchesGrid.setWidget(0, 1, patchesList); add(patchesGrid); includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn()); includedInTable = new IncludedInTable(changeId); includedInPanel.setContent(includedInTable); add(includedInPanel); dependencies = new ChangeTable() { { table.setWidth("auto"); } };
<|startcomment|> Add consult_stream/1. <|endcomment|>  startThread(new CommandRunnable() { @Override public void run() throws Failure { parseCommandLine(); boolean ok = true; for (final Change.Id changeId : changeIds) { try { ok = ok && modifyOne(changeId); } catch (Exception e) { ok = false; <|startfocus|> writeError("fatal: internal server error while modifying reviewers in " + changeId + "\n"); log.error("internal error while modifying reviewers in " + changeId, e); <|endfocus|> } } if (!ok) { throw new UnloggedFailure(1, "one or more modifications of reviewers failed; review output above"); } } }); } private boolean modifyOne(final Change.Id changeId) throws NoSuchChangeException, UnloggedFailure, OrmException, EmailException, Exception { final ChangeControl changeControl = changeControlFactory.validateFor(changeId); boolean ok = true; for (final Account.Id accountId: reviewersToRemove) { final ReviewerResult result = removeReviewerFactory.create(changeId, accountId).call();
<|startcomment|> Unused import. <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.common.auth.userpass; import com.google.gerrit.reviewdb.AuthType; public class LoginResult { public boolean success; public boolean isNew; <|startfocus|> public AuthType authType; <|endfocus|> private Error error = null; public void setError(final Error error) { this.error = error; success = error == null; } public Error getError() { return error; } public static enum Error { /** Username or password are invalid */ INVALID_LOGIN, /** The authentication server is unavailable or the query to it timed out */ AUTHENTICATION_UNAVAILABLE } } 
<|startcomment|> Are two different values really necessary here? gitweb should be OK with "/" instead of %2F in the project name even in the non-path link format. Which means you don't need this extra variable and we can just always replace %2F with / when setting up the "project" and "branch" values. <|endcomment|>  public String toRevision(final Project.NameKey project, final PatchSet ps) { ParamertizedString pattern = new ParamertizedString(type.getRevision()); final Map<String, String> p = new HashMap<String, String>(); <|startfocus|> String proj_qs = URL.encodeQueryString(project.get()); p.put("project", proj_qs); p.put("project_path", proj_qs.replace("%2F", "/")); <|endfocus|> p.put("commit", URL.encodeQueryString(ps.getRevision().get())); return baseUrl + pattern.replace(p);
<|startcomment|> s/MULTI_USER/SINGLE_USER/ <|endcomment|>  */ public class Rulec extends SiteProgram { @Option(name = "--name", required = true, metaVar = "PROJECT", usage = "project to compile rules for") private String projectName; private Injector dbInjector; private final LifecycleManager manager = new LifecycleManager(); @Inject private GitRepositoryManager gitManager; @Inject @GerritServerConfig private Config config; @Inject private SitePaths site; @Override public int run() throws Exception { <|startfocus|> dbInjector = createDbInjector(MULTI_USER); <|endfocus|> manager.add(dbInjector); manager.start(); dbInjector.injectMembers(this); Project.NameKey project = new Project.NameKey(projectName); Repository git = gitManager.openRepository(project); try { PrologJar jarMaker = new PrologJar(config, site, git); return jarMaker.run() ? 0 : 1; } finally { git.close(); } } } 
<|startcomment|> Should be public. <|endcomment|> // limitations under the License. package gerrit; import com.google.gerrit.reviewdb.Branch; import com.google.gerrit.reviewdb.Change; import com.google.gerrit.rules.PrologEnvironment; import com.google.gerrit.rules.StoredValues; import com.googlecode.prolog_cafe.lang.Operation; import com.googlecode.prolog_cafe.lang.Predicate; import com.googlecode.prolog_cafe.lang.Prolog; import com.googlecode.prolog_cafe.lang.PrologException; import com.googlecode.prolog_cafe.lang.SymbolTerm; import com.googlecode.prolog_cafe.lang.Term; <|startfocus|> class PRED_change_branch_1 extends Predicate.P1 { <|endfocus|> private static final long serialVersionUID = 1L; PRED_change_branch_1(Term a1, Operation n) { arg1 = a1; cont = n; } @Override public Operation exec(Prolog engine) throws PrologException { engine.setB0(); Term a1 = arg1.dereference(); PrologEnvironment env = (PrologEnvironment) engine.control; Change change = StoredValues.CHANGE.get(engine); Branch.NameKey name = change.getDest(); if (!a1.unify(SymbolTerm.create(name.get()), engine.trail)) { return engine.fail(); }
<|startcomment|> See note about Type being the 2nd arg rather than 3rd. <|endcomment|>  import java.util.ArrayList; import java.util.List; /** * Given a regular expression, checks it against the file list in the most * recent patchset of a change. For all files that match the regex, returns the * (new) path of the file, the change type, and the old path of the file if * applicable (if the file was copied or renamed). * * <pre> <|startfocus|> * 'commit_delta'(+Regex, -NewPath, -ChangeType, -OldPath) <|endfocus|> * </pre> */ class PRED_commit_delta_4 extends Predicate.P4 { private static final long serialVersionUID = 1L; static final Operation commit_delta_4_top = new PRED_commit_delta_4_top(); static final Operation commit_delta_check = new PRED_commit_delta_check(); static final Operation commit_delta_next = new PRED_commit_delta_next(); static final Operation commit_delta_modify = new PRED_commit_delta_modify(); PRED_commit_delta_4(Term a1, Term a2, Term a3, Term a4, Operation n) {
<|startcomment|> Nit: not sure if you still like this one or just overlooked it? I would use reviewer here also, but I could see why you might not want to. <|endcomment|>  addReviewerCategoryId = allTypes.get(allTypes.size() - 1).getCategory().getId(); this.changeId = changeId; this.reviewers = userNameOrEmailOrGroupNames; this.confirmed = confirmed; } @Override public ReviewerResult call() throws Exception { final Set<Account.Id> reviewerIds = new HashSet<Account.Id>(); final ChangeControl control = changeControlFactory.validateFor(changeId); final ReviewerResult result = new ReviewerResult(); <|startfocus|> for (final String userNameOrEmailOrGroupName : reviewers) { final Account account = accountResolver.find(userNameOrEmailOrGroupName); <|endfocus|> if (account == null) { AccountGroup group = groupCache .get(new AccountGroup.NameKey(userNameOrEmailOrGroupName)); if (group == null) { result.addError(new ReviewerResult.Error( ReviewerResult.Error.Type.REVIEWER_NOT_FOUND, userNameOrEmailOrGroupName)); continue; } if (!isLegalReviewerGroup(group.getGroupUUID())) { result.addError(new ReviewerResult.Error( ReviewerResult.Error.Type.GROUP_NOT_ALLOWED, userNameOrEmailOrGroupName)); continue;
<|startcomment|> I think the better thing is to have createValue() return null by default, and have this code check createValue()'s result and throw if null was returned. That way implementors cannot return null and be surprised. <|endcomment|>  public T get(Prolog engine) { <|startfocus|> T obj = getOrNull(engine); if (obj == null) { //unless createValue() is overridden, will throw an exception obj = createValue(engine); set(engine, obj); <|endfocus|> } return obj;
<|startcomment|> Nit: seems like this should go above NEW? <|endcomment|>  public static String toLongString(final Change.Status status) { if (status == null) { return ""; } switch (status) { case NEW: return C.statusLongNew(); case SUBMITTED: return C.statusLongSubmitted(); case MERGED: return C.statusLongMerged(); case ABANDONED: return C.statusLongAbandoned(); <|startfocus|> case DRAFT: return C.statusLongDraft(); <|endfocus|> default: return status.name(); }
<|startcomment|> ? <|endcomment|>  // No need to continue. return; } List<String> lastCreateChangeErrors = Lists.newArrayList(); for (CreateRequest create : newChanges) { if (create.cmd.getResult() == OK) { okToInsert++; } else { String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim(); lastCreateChangeErrors.add(createChangeResult); <|startfocus|> log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult)); <|endfocus|> } } if (okToInsert != replaceCount + newChanges.size()) { // One or more new references failed to create. Assume the // system isn't working correctly anymore and abort. reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors)); log.error(String.format(
<|startcomment|> Nit: can you make this looks more like the stuff above? I didn't even know that you could make an interface method abstract, seems kinda redundant. <|endcomment|> import com.google.gwtjsonrpc.client.RpcImpl; import com.google.gwtjsonrpc.client.VoidResult; import com.google.gwtjsonrpc.client.RpcImpl.Version; import java.util.List; @RpcImpl(version = Version.V2_0) public interface SystemInfoService extends RemoteJsonService { @AllowCrossSiteRequest void daemonHostKeys(AsyncCallback<List<SshHostKey>> callback); @SignInRequired void contributorAgreements(AsyncCallback<List<ContributorAgreement>> callback); void clientError(String message, AsyncCallback<VoidResult> callback); <|startfocus|> public abstract void gerritConfig(final AsyncCallback<GerritConfig> callback); <|endfocus|> } 
<|startcomment|> This parameter is not used in this method <|endcomment|>  * @param column name of the column to drop. * @throws OrmException the column could not be added. */ public void dropColumn(StatementExecutor e, String tableName, String column) throws OrmException { final StringBuilder r = new StringBuilder(); r.append("ALTER TABLE "); r.append(tableName); r.append(" DROP COLUMN "); r.append(column); e.execute(r.toString()); } /** * Rename an existing column in a table. * * @param e statement to use to execute the SQL command(s). <|startfocus|> * @param tableName table to add the column onto. <|endfocus|> * @param fromColumn source column name * @param col destination column definition * @throws OrmException the column could not be renamed. */ public abstract void renameColumn(StatementExecutor e, String tableName, String fromColumn, ColumnModel col) throws OrmException; protected abstract String getNextSequenceValueSql(String seqname); /** * Does the array returned by the PreparedStatement.executeBatch method return
<|startcomment|> I think you really mean hasOnlyValidCharacters? <|endcomment|> <|startfocus|> public static boolean hasValidCharacters(String value) { <|endfocus|> return value.matches("[a-z,A-Z,0-9,\\-]*");
<|startcomment|> Hmm, that is confusing. What do you think about getting an "--All Projects" projectState and querying it for canCreateChildProject() instead? <|endcomment|>  public void start(final Environment env) { startThread(new CommandRunnable() { @Override public void run() throws Exception { parseCommandLine(); if ((newParent != null && !newParent.canCreateChildProject()) <|startfocus|> || (newParent == null && !currentUser.getCapabilityByProject(null) <|endfocus|> .canCreateProject())) { String msg = String.format( "fatal: %s does not have \"Create Project\" capability.", currentUser.getUserName()); throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg); } validateParameters(); try { nameKey = new Project.NameKey(projectName); String head = permissionsOnly ? GitRepositoryManager.REF_CONFIG : branch; final Repository repo = repoManager.createRepository(nameKey); try { rq.replicateNewProject(nameKey, head); RefUpdate u = repo.updateRef(Constants.HEAD); u.disableRefLog(); u.link(head); createProjectConfig(); if (!permissionsOnly && createEmptyCommit) { createEmptyCommit(repo, nameKey, branch); } } finally { repo.close(); }
<|startcomment|> Could you add a comment with a sample input and output string for this method? Something as simple as "git://server.a.b/foo/bar" -> "server" if that is what it does. I might also suggest trying to use regexps instead, they are usually easier to read. Lastly, I suspect there are some standard java utilities to get a parse a Url. This could probably be static. <|endcomment|> <|startfocus|> public UrlModule(AuthConfig authConfig) { this.authConfig=authConfig; <|endfocus|>
<|startcomment|> With a simple add/remove flag to this function, these 2 functions could be combined into one function with a larger switch statement. Ignore if you think that would be ugly. <|endcomment|> <|startfocus|> private boolean processResultOfRemoval(final AccountGroup.Id groupId, final GroupMemberResult result) { <|endfocus|> final boolean ok = result.getErrors().isEmpty(); for (final GroupMemberResult.Error resultError : result.getErrors()) { String message; switch (resultError.getType()) { case REMOVE_NOT_PERMITTED: message = "not permitted to remove {0} from {1}"; break; default: message = "could not remove {0} from {1}: {2}"; } writeError("error", MessageFormat.format(message, resultError.getName(), groupId, resultError.getType())); } return ok;
<|startcomment|> better have ": " after MESSAGE <|endcomment|> <|startfocus|> public InvalidNameException(String message) { super(MESSAGE + " " + message); <|endfocus|>
<|startcomment|> I think the merge strategies table should only be visible if there are merge strategies to display. Have a look at the ProjectAccessScreen, there the table with the access rights is also only displayed if there are access rights defined on the project, but otherwise it's hidden. I think it should be the same with the merge strategies table. <|endcomment|>  void display(final ProjectMergeStrategies result) { final Project.NameKey wildKey = Gerrit.getConfig().getWildProject(); Project.NameKey parent = result.getInheritsFrom(); final boolean isWild = parent == null; if (parent == null) { parent = wildKey; } parentPanel.setVisible(!isWild); parentName.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.MERGE_STRATEGY)); parentName.setText(parent.get()); <|startfocus|> mergeStrategies.display(result.getLocal()); <|endfocus|> mergeStrategies.setRevision(result.getRevision());
<|startcomment|> Nothing from this method throws SQLException, could be removed from the throws list. <|endcomment|>  stub(ps.executeUpdate()).toThrow( new AssertionError("unexpected method call")); return ps; } private PreparedStatement setupPreparedStatementException(SQLException e) throws SQLException { PreparedStatement ps = mock(PreparedStatement.class); doNothing().when(ps).addBatch(); stub(ps.executeBatch()).toThrow(e); stub(ps.executeUpdate()).toThrow(e); return ps; } @Before public void setup() { conn = mock(Connection.class); } @Test <|startfocus|> public void testInsertNothing() throws OrmException, SQLException { setup(); <|endfocus|> createClassUnderTest().insert(NO_DATA); } @Test public void testInsertOne() throws OrmException, SQLException { stubExecuteBatchOK(INSERT, 1); createClassUnderTest().insert(ONE_ROW); } @Test public void testInsertOneException() throws OrmException, SQLException { stubExecuteBatchException(INSERT, new BatchUpdateException()); try { createClassUnderTest().insert(ONE_ROW); fail("missingException"); } catch (OrmException e) { // expected } } @Test
<|startcomment|> Do we really need to keep these here for backwards compatibility (i haven't checked)? It seems like even if we support the old mode of having this set on the entire project that this would be represented by a 'refs/*' entry instead? Perhaps this is just needed until the new UI is merged? <|endcomment|>  public Project(Project.NameKey nameKey) { name = nameKey; <|startfocus|> submitType = defaultSubmitType; <|endfocus|>
<|startcomment|> [optional] maybe to call the method just 'get', the class name is already saying what you will get <|endcomment|> import com.google.gwtorm.client.OrmException; import com.google.inject.Inject; import java.util.ArrayList; import java.util.List; public class RetrieveParentCandidates { public interface Factory { RetrieveParentCandidates create(); } private final ProjectControl.Factory projectControlFactory; private final ProjectCache projectCache; @Inject RetrieveParentCandidates(final ProjectControl.Factory projectControlFactory, final ProjectCache projectCache) { this.projectControlFactory = projectControlFactory; this.projectCache = projectCache; } <|startfocus|> public List<Project> getParentCandidates() throws OrmException { final List<Project> r = new ArrayList<Project>(); <|endfocus|> for (Project.NameKey p : projectCache.all()) { try { final ProjectControl project = projectControlFactory.controlFor(p); final Project.NameKey parent = project.getProject().getParent(); if (parent != null) { ProjectControl c = projectControlFactory.controlFor(parent); if (c.isVisible() || c.isOwner()) { if (!r.contains(c.getProject()) && !parent.equals(AllProjectsNameProvider.DEFAULT)) { r.add(c.getProject());
<|startcomment|> Before this change, there was a distinction in com.google.gerrit.sshd.commands.CreateProject between real errors that should be logged (something unexpected happened) and non critical errors (user gave incorrect input and then it failed as expected). For real errors a Failure was thrown and for non critical errors a UnloggedFailure was thrown. The intention was to only log the real errors. If I look at the CreateProjectCommand now, a ProjectCreationFailedException is now always converted into an UnloggedFailure, which means that no error is logged. I think this is fine, if we ensure in this class to log all real errors. I think if we come into this catch block, there was such a real error and we should log it. This is why I would propose to change the above line to: final String msg = "Cannot create " + createProjectArgs.getProject(); log.error(msg, e); throw new ProjectCreationFailedException(msg, e); <|endcomment|>  @Inject CreateProject( Provider<ProjectsCollection> projectsCollection, Provider<GroupsCollection> groupsCollection, ProjectJson json, DynamicSet<ProjectCreationValidationListener> projectCreationValidationListeners, ProjectControl.GenericFactory projectControlFactory, GitRepositoryManager repoManager, DynamicSet<NewProjectCreatedListener> createdListeners, ProjectCache projectCache, GroupBackend groupBackend, ProjectOwnerGroupsProvider.Factory projectOwnerGroups, MetaDataUpdate.User metaDataUpdateFactory, GitReferenceUpdated referenceUpdated, RepositoryConfig repositoryCfg, @GerritPersonIdent PersonIdent serverIdent, Provider<IdentifiedUser> identifiedUser, Provider<PutConfig> putConfig, AllProjectsName allProjects, <|startfocus|> @Assisted String name) { <|endfocus|> this.projectsCollection = projectsCollection; this.groupsCollection = groupsCollection; this.projectCreationValidationListeners = projectCreationValidationListeners; this.json = json; this.projectControlFactory = projectControlFactory; this.repoManager = repoManager; this.createdListeners = createdListeners; this.projectCache = projectCache; this.groupBackend = groupBackend; this.projectOwnerGroups = projectOwnerGroups; this.metaDataUpdateFactory = metaDataUpdateFactory; this.referenceUpdated = referenceUpdated; this.repositoryCfg = repositoryCfg;
<|startcomment|> maybe 'lbl.status' should be included into the exception text, so that it's possible to find out what was the unsupported status <|endcomment|>  break; case NEED: if (errMsg.length() > 0) errMsg.append("; "); errMsg.append("change " + changeId + ": needs " + lbl.label); break; case IMPOSSIBLE: if (errMsg.length() > 0) errMsg.append("; "); errMsg.append("change " + changeId + ": needs " + lbl.label + " (check project access)"); break; default: throw new InvalidChangeOperationException( <|startfocus|> "Unsupported SubmitRecord.Label.status"); <|endfocus|> } } result.addError(new ReviewResult.Error( ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString())); break; case CLOSED: result.addError(new ReviewResult.Error( ReviewResult.Error.Type.CHANGE_IS_CLOSED)); break; case RULE_ERROR: result.addError(new ReviewResult.Error( ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage)); default: throw new InvalidChangeOperationException( "Unsupported SubmitRecord.status"); } } // Submit the change if we can
<|startcomment|> [optional] same question as above when comparing this code to as it was in SubmitAction, why was the IllegalStateException changed to InvalidChangeOperationException? <|endcomment|>  "Unsupported SubmitRecord.Label.status (" + lbl.status + ")"); } } result.addError(new ReviewResult.Error( ReviewResult.Error.Type.SUBMIT_NOT_READY, errMsg.toString())); break; case CLOSED: result.addError(new ReviewResult.Error( ReviewResult.Error.Type.CHANGE_IS_CLOSED)); break; case RULE_ERROR: result.addError(new ReviewResult.Error( ReviewResult.Error.Type.RULE_ERROR, submitResult.get(0).errorMessage)); break; default: <|startfocus|> throw new InvalidChangeOperationException( <|endfocus|> "Unsupported SubmitRecord.status + (" + submitRecord.status + ")"); } } // Submit the change if we can if (result.getErrors().isEmpty()) { final List<PatchSetApproval> allApprovals = new ArrayList<PatchSetApproval>(db.patchSetApprovals().byPatchSet( patchSetId).toList()); final PatchSetApproval.Key akey = new PatchSetApproval.Key(patchSetId, currentUser.getAccountId(), SUBMIT); 
<|startcomment|> Does this edit belong in the previous change? <|endcomment|>  if (c.getResult() == OK) { String refName = c.getRefName(); if (c.getType() == ReceiveCommand.Type.UPDATE) { // aka fast-forward logDebug("Updating tag cache on fast-forward of {}", c.getRefName()); tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId()); } <|startfocus|> if (isHead(c) || isConfig(c)) { switch (c.getType()) { case CREATE: case UPDATE: case UPDATE_NONFASTFORWARD: autoCloseChanges(c); branches.add(new Branch.NameKey(project.getNameKey(), refName)); break; <|endfocus|> case DELETE: break; } } if (isConfig(c)) { logDebug("Reloading project in cache"); projectCache.evict(project); ProjectState ps = projectCache.get(project.getNameKey()); try { repo.setGitwebDescription(ps.getProject().getDescription()); } catch (IOException e) { log.warn("cannot update description of " + project.getName(), e); }
<|startcomment|> nit: s/result/fileList/ <|endcomment|>  log.error("Patch set " + psId + " has invalid revision"); throw new NoSuchEntityException(); } } private PatchListKey keyFor(final Whitespace whitespace) { return new PatchListKey(projectKey, oldId, newId, whitespace); } private PatchList listFor(final PatchListKey key) { return patchListCache.get(key); } private Set<String> getCurrentFileList() throws NoSuchChangeException, OrmException, NoSuchEntityException { <|startfocus|> Set<String> result = new HashSet<String>(); <|endfocus|> // Get the modified file set by comparing active patch to 'Base' getFileListBy(psIdNew, result); // Get the modified file set by comparing the old patch to 'Base' getFileListBy(psIdBase, result); return result; } private void getFileListBy(final PatchSet.Id id, final Set<String> fileList) throws NoSuchChangeException, NoSuchEntityException, OrmException { ChangeControl control = changeControlFactory.validateFor(id.getParentKey()); PatchList patchListComparedToBase =
<|startcomment|> Should we also allow to move a change to a new branch if it is in state 'Submitted, Merge Pending'? If not, then this should probably fail with a proper error message. At the moment the error says "Change is closed or patchset is not latest", which is not true in this since the change is still open when it is in 'Submitted, Merge Pending' state. Also if not, the UI change [1] should then take care to not offer the 'move change' action on changes that are in state 'Submitted, Merge Pending'. [1] https://gerrit-review.googlesource.com/32800 <|endcomment|>  public Change update(Change change) { <|startfocus|> if (change.getStatus() == Change.Status.NEW <|endfocus|> && change.currentPatchSetId().equals(patchSetId)) { change.setDest(new Branch.NameKey(change.getProject(), ref)); ChangeUtil.updated(change); return change; } else { return null; }
<|startcomment|> The revertChange method is, unnecessarily, moved down below the restoreChange. This only makes code review harder. <|endcomment|> import com.google.gwtjsonrpc.common.RpcImpl.Version; @RpcImpl(version = Version.V2_0) public interface ChangeManageService extends RemoteJsonService { @Audit @SignInRequired void submit(PatchSet.Id patchSetId, AsyncCallback<ChangeDetail> callback); @Audit @SignInRequired void cherryPickChange(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final AsyncCallback<ChangeDetail> callback); @Audit @SignInRequired <|startfocus|> void revertChange(PatchSet.Id patchSetId, String message, AsyncCallback<ChangeDetail> callback); @Audit @SignInRequired <|endfocus|> void restoreChange(PatchSet.Id patchSetId, String message, AsyncCallback<ChangeDetail> callback); @Audit @SignInRequired void publish(PatchSet.Id patchSetId, AsyncCallback<ChangeDetail> callback); @Audit @SignInRequired void deleteDraftChange(PatchSet.Id patchSetId, AsyncCallback<VoidResult> callback); @Audit @SignInRequired void rebaseChange(PatchSet.Id patchSetId, AsyncCallback<ChangeDetail> callback); } 
<|startcomment|> Due to the popularity of the trivial rebase detection hook which reapplies approvals, I cannot help but wonder if we shouldn't just copy everything on a rebase instead? But, if this feels like the wrong policy for some, maybe it should be configurable (in a future change) instead? Should we consider making approval behavior for various actions more configurable in the future, or is this just asking for too much complexity and would we better off trying to just get things "right"? One thing for sure is, while it may be good to keep only the vetos, it is not the "right" solution since the popularity of our script implies that many people don't like that policy already. <|endcomment|>  import java.util.Collections; import java.util.List; public class ApprovalsUtil { /* Resync the changeOpen status which is cached in the approvals table for performance reasons*/ public static void syncChangeStatus(final ReviewDb db, final Change change) throws OrmException { final List<PatchSetApproval> approvals = db.patchSetApprovals().byChange(change.getId()).toList(); for (PatchSetApproval a : approvals) { a.cache(change); } db.patchSetApprovals().update(approvals); } /** <|startfocus|> * Moves the PatchSetApprovals to the last PatchSet on the change. <|endfocus|> * * @param db The review database * @param change Change to update * @param source Original PatchSet to move votes from * @param approvalTypes The approval types * @throws OrmException */ public static void copyVetoApprovalsToLatestPatchSet(final ReviewDb db, Change change, PatchSet.Id source, ApprovalTypes approvalTypes) throws OrmException { PatchSet.Id dest = change.currPatchSetId();
<|startcomment|> You can't new this into existence. It has to be taken by Guice injection because its derived from data read from the database. <|endcomment|>  import com.google.gerrit.common.data.ApprovalTypes; import com.google.gerrit.reviewdb.ApprovalCategory; import com.google.gerrit.reviewdb.ApprovalCategoryValue; import com.google.gson.JsonArray; import com.google.gson.JsonElement; import com.google.gson.JsonObject; import com.google.gson.JsonPrimitive; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; /** Parameter class for all review related handlers */ public class ReviewParams extends RequestParams { <|startfocus|> private static final ApprovalTypes approvalTypes = new ApprovalTypes(); <|endfocus|> private List<Review> reviews = new ArrayList<Review>(); public static class Review { private final Set<ApprovalCategoryValue.Id> labels; private String query; private String message; private ClosedActionType closedAction; private ActionType action; public Review() { labels = new HashSet<ApprovalCategoryValue.Id>(); query = null; message = null; closedAction = ClosedActionType.SKIP; action = ActionType.COMMENT; } public static enum ClosedActionType { /** Not a type. */
<|startcomment|> nit: no spaces after ( and before ), e.g.: for (String key : injectedVariables) <|endcomment|>  public void run() { <|startfocus|> for ( String key : injectedVariables ) { <|endfocus|> printInjectedVariable(key); } reload(); runInterpreter("interact", new Class[] { String.class, pyObject }, new Object[] { getDefaultBanner() + " running for Gerrit " + com.google.gerrit.common.Version.getVersion(), null });
<|startcomment|> reformatting not related to the change <|endcomment|>  } if (!c.isLatest()) { s += " [OUTDATED]"; table.getRowFormatter() .addStyleName(row, Gerrit.RESOURCES.css().outdated()); } else { table.getRowFormatter() .removeStyleName(row, Gerrit.RESOURCES.css().outdated()); } table.setWidget(row, C_SUBJECT, new TableChangeLink(s, c)); table.setWidget(row, C_OWNER, link(c.getOwner())); <|startfocus|> table.setWidget(row, C_PROJECT, new ProjectLink(c.getProject().getKey(), c.getStatus())); <|endfocus|> table.setWidget(row, C_BRANCH, new BranchLink(c.getProject().getKey(), c .getStatus(), c.getBranch(), c.getTopic())); table.setText(row, C_LAST_UPDATE, shortFormat(c.getLastUpdatedOn())); setRowItem(row, c);
<|startcomment|> Perhaps much of the duplicated code could be eliminated in this change if this class were changed to no longer inherit from ChangeEvent? <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.events; import com.google.gerrit.reviewdb.client.Change; <|startfocus|> import com.google.gerrit.reviewdb.client.Project; <|endfocus|> public class RefUpdatedEvent extends ChangeEvent { public final String type = "ref-updated"; public AccountAttribute submitter; public RefUpdateAttribute refUpdate; @Override public String getType() { return type; } @Override public Project.NameKey getProjectNameKey() { return new Project.NameKey(refUpdate.project); } @Override public Change.Key getChangeKey() { return null; } @Override public String getRefName() { return refUpdate.refName; } } 
<|startcomment|> This can't be transient, its part of the hashcode and equals methods. boolean not Boolean <|endcomment|> <|startfocus|> private transient Boolean isRebaseTransparent; <|endfocus|> transient Project.NameKey projectKey; // not required to form the key public PatchListKey(final Project.NameKey pk, final AnyObjectId a, final AnyObjectId b, final Whitespace ws) { init(pk, a, b, ws, false);
<|startcomment|> I still don't like the idea of depending on commons-io for this trivial of a function, but I guess I am losing that argument. :-) <|endcomment|>  Class<?> moduleClass = Class.forName(moduleName, false, jarClassLoader); return new Plugin(pluginName, moduleClass); } private URL[] getPluginURLs(File jarFile) throws MalformedURLException { return new URL[] {jarFile.toURI().toURL()}; } @SuppressWarnings("unchecked") private Collection<File> getPluginFiles() throws IOException { if (pluginsDir == null || !pluginsDir.exists()) { return Collections.emptyList(); } <|startfocus|> return FileUtils.listFiles(pluginsDir, new String[] {"jar"}, false); <|endfocus|> } } 
<|startcomment|> s/B/b/ <|endcomment|>  throws IOException, ServletException { List<String> parts = Lists.newArrayList( Splitter.on('/').limit(3).omitEmptyStrings() .split(Strings.nullToEmpty(req.getPathInfo()))); if (isApiCall(req, parts)) { managerApi.service(req, res); return; } String name = parts.get(0); final PluginHolder holder = plugins.get(name); if (holder == null) { <|startfocus|> CacheHeaders.setNotCacheable(res); <|endfocus|> res.sendError(HttpServletResponse.SC_NOT_FOUND); return; } HttpServletRequest wr = wrapper.create(req, name); FilterChain chain = new FilterChain() { @Override public void doFilter(ServletRequest req, ServletResponse res) throws IOException { onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res); } }; if (holder.filter != null) { holder.filter.doFilter(wr, res, chain); } else { chain.doFilter(wr, res); } } private static boolean isApiCall(HttpServletRequest req, List<String> parts) {
<|startcomment|> TODONE this? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.documentation; import static org.pegdown.Extensions.ALL; import org.pegdown.PegDownProcessor; public class MarkdownFormatter { public String getHtmlFromMarkdown(String markdownSource) { return new PegDownProcessor(ALL).markdownToHtml(markdownSource); } <|startfocus|> <|endfocus|> // TODO: Add a cache } 
<|startcomment|> What is a SID? SESSION_ID? <|endcomment|> import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.google.gson.InstanceCreator; import com.google.gwtjsonrpc.server.MapDeserializer; import com.google.gwtjsonrpc.server.SqlDateDeserializer; import com.google.gwtjsonrpc.server.SqlTimestampDeserializer; import java.lang.reflect.Type; import java.text.DateFormat; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set; public class AuditEvent { <|startfocus|> public static final String UNKNOWN_USR = "N/A"; public static final String UNKNOWN_SID = "000000000000000000000000000"; <|endfocus|> private String sid; private String who; private long when; private String what; private List<?> params; private Object result; private long timeAtStart; private long elapsed; public AuditEvent(String sessionid, String who, String what, List<?> params) { if (what == null) throw new IllegalArgumentException("what is a mandatory param!"); this.sid = parseNull(sessionid, UNKNOWN_SID); this.who = parseNull(who, UNKNOWN_USR); this.what = what; this.when = System.currentTimeMillis();
<|startcomment|> sort plugins before projects. <|endcomment|> <|startfocus|> return key(new HttpServlet() { private static final long serialVersionUID = 1L; <|endfocus|> @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException { toGerrit(target, req, rsp); }
<|startcomment|> Calling close isn't actually necessary. <|endcomment|>  if (ref != null) { // Update the owner group UUID to the new ldap UUID scheme. g.setOwnerGroupUUID(ref.getUUID()); toUpdate.add(g); } else if (toResolve.contains(g.getOwnerGroupUUID())) { // The unresolved group is used as an owner. // Add to the list of LDAP groups to be made INTERNAL. resolveToUpdate.add(g.getOwnerGroupUUID()); } } <|startfocus|> } finally { rs.close(); <|endfocus|> } toResolve.removeAll(resolveToUpdate); // Update project.config group references to use the new LDAP GroupReference for (Project.NameKey name : mgr.list()) { Repository git; try { git = mgr.openRepository(name); } catch (RepositoryNotFoundException e) { throw new OrmException(e); } catch (IOException e) { throw new OrmException(e); } try { MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, name, git); md.getCommitBuilder().setAuthor(serverUser);
<|startcomment|> nit: I'd probably include the arrow icon, as seen at the end of the next file name link to catch the eye better, but this makes sense to me too. <|endcomment|>  protected PatchScreen(final Patch.Key id, final int patchIndex, final PatchTable patchTable) { <|startfocus|> patchKey = id; <|endfocus|> fileList = patchTable; // If we have any diff side stored, make sure they are applicable to the // current change, discard them otherwise. // Change.Id thisChangeId = id.getParentKey().getParentKey(); if (currentChangeId != null && !currentChangeId.equals(thisChangeId)) { diffSideA = null; diffSideB = null; historyOpen = null; } currentChangeId = thisChangeId; idSideA = diffSideA; // null here means we're diff'ing from the Base idSideB = diffSideB != null ? diffSideB : id.getParentKey(); this.patchIndex = patchIndex; settingsPanel = new PatchScriptSettingsPanel(); settingsPanel .addValueChangeHandler(new ValueChangeHandler<PatchScriptSettings>() { @Override public void onValueChange(ValueChangeEvent<PatchScriptSettings> event) { update(event.getValue()); } }); settingsPanel.getReviewedCheckBox().addValueChangeHandler(
<|startcomment|> username may be blank, perhaps use some form of getEmailName()? <|endcomment|> import java.util.Map; import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern; /** Receives change upload over SSH using the Git receive-pack protocol. */ final class Receive extends AbstractGitCommand { private static final Logger log = LoggerFactory.getLogger(Receive.class); private static final String NEW_CHANGE = "refs/for/"; private static final Pattern NEW_PATCHSET = Pattern.compile("^refs/changes/(?:[0-9][0-9]/)?([1-9][0-9]*)(?:/new)?$"); <|startfocus|> private static final FooterKey REVIEWED_BY = new FooterKey("Reviewed-by"); private static final FooterKey TESTED_BY = new FooterKey("Tested-by"); private static final FooterKey CHANGE_ID = new FooterKey("Change-Id"); <|endfocus|> private final Set<Account.Id> reviewerId = new HashSet<Account.Id>(); private final Set<Account.Id> ccId = new HashSet<Account.Id>(); 
<|startcomment|> whitespace errors in file <|endcomment|>  throws XmlRpcException { String commitMsg = commit.getFullMessage(); Matcher matcher = commentPattern.matcher(commitMsg); while (matcher.find()) { String matched = matcher.group(); try { addComment(jira, matched, refName, commit); } catch (XmlRpcException e) { log.warn("Jira issue " + matched + " was not found: comment not added"); } } } <|startfocus|> private void addComment(JiraClientSession jira, String commentMatch, String refName, RevCommit commit) throws XmlRpcException { <|endfocus|> Matcher matcher = issuePattern.matcher(commentMatch); if (!matcher.find()) return; jira.addComment(matcher.group(), getComment(refName, commit)); } private String getComment(String refName, RevCommit commit) { String commitId = commit.getName(); String comment = String.format( "Git commit: %s\n" + "Branch: %s\n" + "Author: %s\n" + "Committer: %s\n" + "%s", commitId, refName, getIdentity(commit.getAuthorIdent()),
<|startcomment|> nit: this is import is not used and should be removed <|endcomment|> import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gwt.core.client.GWT; import com.google.gwt.dom.client.SpanElement; import com.google.gwt.dom.client.Style; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.event.dom.client.ClickHandler; import com.google.gwt.resources.client.CssResource; import com.google.gwt.uibinder.client.UiBinder; import com.google.gwt.uibinder.client.UiField; import com.google.gwt.user.client.ui.Anchor; import com.google.gwt.user.client.ui.Composite; <|startfocus|> import com.google.gwt.user.client.ui.FlowPanel; <|endfocus|> import com.google.gwt.user.client.ui.HTMLPanel; import com.google.gwt.user.client.ui.Label; import com.google.gwt.user.client.ui.SimplePanel; import com.google.gwtorm.client.KeyUtil; import java.util.LinkedList; import java.util.List; public class PatchSetSelectBox extends Composite { interface Binder extends UiBinder<HTMLPanel, PatchSetSelectBox> { } private static Binder uiBinder = GWT.create(Binder.class); interface BoxStyle extends CssResource { String selected(); String deselected(); String hidden(); } PatchScript script;
<|startcomment|> precedence of -> precedence over <|endcomment|>  public SshdListenAddressProvider(@GerritServerConfig final Config config) { String sshdListenAddress = config.getString("sshd", null, "listenAddress"); String sshdAdvertisedAddress = config.getString("sshd", null, "advertisedAddress"); /* <|startfocus|> * If advertised address is specified it should take precedence of the <|endfocus|> * "normal" listening address. */ if (sshdAdvertisedAddress != null && sshdAdvertisedAddress != "") { sshAddress = sshdAdvertisedAddress; } else { sshAddress = sshdListenAddress; } 
<|startcomment|> nit: unused import <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License.package com.google.gerrit.server.git; package com.google.gerrit.server.git; import com.google.common.cache.CacheLoader; import com.google.common.cache.LoadingCache; import com.google.gerrit.extensions.events.GitReferenceUpdatedListener; import com.google.gerrit.reviewdb.client.Change; <|startfocus|> import com.google.gerrit.reviewdb.client.PatchSet; <|endfocus|> import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.reviewdb.client.Project.NameKey; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.cache.CacheModule; import com.google.gerrit.server.extensions.events.GitReferenceUpdated; import com.google.gwtorm.server.SchemaFactory; import com.google.inject.Inject; import com.google.inject.Module; import com.google.inject.Singleton; import com.google.inject.TypeLiteral; import com.google.inject.name.Named; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.Collections; import java.util.List;
<|startcomment|> nit: missing curly braces around one-line blocks <|endcomment|>  public MethodHandle getMethod() { if (currentMethod.get() == null) return super.getMethod(); else <|startfocus|> return currentMethod.get(); <|endfocus|>
<|startcomment|> Why is this style not already set in the createDownloadLink() method? <|endcomment|>  public void onClick(ClickEvent event) { if (side == Side.A) { idSideA = id; } else { idSideB = id; } <|startfocus|> Patch.Key k = new Patch.Key(idSideB, patchKey.get()); <|endfocus|> switch (screenType) { case SIDE_BY_SIDE: Gerrit.display(Dispatcher.toPatchSideBySide(idSideA, k)); break; case UNIFIED: Gerrit.display(Dispatcher.toPatchUnified(idSideA, k)); break; }
<|startcomment|> The only usages of the PatchScreen are: 1. get the patch screen type 2. get the patch set detail I think it would be cleaner to just pass these two information into this class rather than the whole PatchScreen. <|endcomment|> <|startfocus|> protected AbstractPatchContentTable(final PatchScreen parent) { <|endfocus|> keysNavigation.add(new PrevKeyCommand(0, 'k', PatchUtil.C.linePrev())); keysNavigation.add(new NextKeyCommand(0, 'j', PatchUtil.C.lineNext())); keysNavigation.add(new PrevChunkKeyCmd(0, 'p', PatchUtil.C.chunkPrev())); keysNavigation.add(new NextChunkKeyCmd(0, 'n', PatchUtil.C.chunkNext())); keysNavigation.add(new PrevCommentCmd(0, 'P', PatchUtil.C.commentPrev())); keysNavigation.add(new NextCommentCmd(0, 'N', PatchUtil.C.commentNext())); keysAction.add(new OpenKeyCommand(0, 'o', PatchUtil.C.expandComment())); keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation()); keysOpenByEnter.add(new OpenKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment())); if (Gerrit.isSignedIn()) { keysAction.add(new InsertCommentCommand(0, 'c', PatchUtil.C .commentInsert())); keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C .keyPublishComments())); 
<|startcomment|> one empty line is enough <|endcomment|>  SymbolTerm.intern("stdin"), new JavaObjectTerm(inReader)); } List<Term> results = new ArrayList<Term>(); Term submitRule = pcl.once("gerrit", "locate_submit_rule", new VariableTerm()); for (Term[] template : pcl.all("gerrit", "can_submit", submitRule, new VariableTerm())) { results.add(template[1]); } if (useSubmitFilters) { runSubmitFilters(projectState, results, pcl); } <|startfocus|> <|endfocus|> List<SubmitRecord> res = cc.resultsToSubmitRecord(submitRule, results); for (SubmitRecord r : res) { outWriter.println("Result: " + r); } } catch (Exception e) { throw new UnloggedFailure("Processing of prolog script failed: " + e); } try { outWriter.flush(); outWriter.close(); inReader.close(); } catch (IOException e) { e.printStackTrace(); } } public void runSubmitFilters(ProjectState projectState, List<Term> results, PrologEnvironment pcl) throws UnloggedFailure {
<|startcomment|> remove the throws IllegalStateException once the changes suggested below are applied <|endcomment|>  break; case RULE_ERROR: sa.status = "RULE_ERROR"; break; default: throw new IllegalStateException( "Unsupported SubmitRecord.status + (" + submitRecord.status + ")"); } ca.submitRecords.add(sa); } // Remove empty lists so a confusing label won't be displayed in the output. if (ca.submitRecords.isEmpty()) { ca.submitRecords = null; } } private void addSubmitRecordLabels(SubmitRecord submitRecord, <|startfocus|> SubmitRecordAttribute sa) throws IllegalStateException { <|endfocus|> if (submitRecord.labels != null && !submitRecord.labels.isEmpty()) { sa.labels = new ArrayList<SubmitLabelAttribute>(); for (SubmitRecord.Label lbl : submitRecord.labels) { SubmitLabelAttribute la = new SubmitLabelAttribute(); la.label = lbl.label; switch (lbl.status) { case OK: la.status = "OK"; break; case REJECT: la.status = "REJECT"; break; case NEED: la.status = "NEED"; break; case MAY:
<|startcomment|> I don't think this will be useful for anything. Probably, you should either log this exception or just write a comment and ignore it. <|endcomment|>  outWriter.print(" by " + a.getNameEmail(anonymousCowardName)); } outWriter.print('\n'); } outWriter.println("\n" + r.status); } } } catch (Exception e) { throw new UnloggedFailure("Processing of prolog script failed: " + e); } <|startfocus|> try { outWriter.flush(); outWriter.close(); inReader.close(); } catch (IOException e) { e.printStackTrace(); } <|endfocus|> } private void runSubmitFilters(ProjectState projectState, List<Term> results, PrologEnvironment pcl) throws UnloggedFailure { ProjectState parentState = projectState.getParentState(); PrologEnvironment childEnv = pcl; Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>(); projectsSeen.add(projectState.getProject().getNameKey()); while (parentState != null) { if (!projectsSeen.add(parentState.getProject().getNameKey())) { // parent has been seen before, stop walk up inheritance tree break; } PrologEnvironment parentEnv; try {
<|startcomment|> Don't do this. Instead let the plugin register its instance(s) with the DynamicSet. <|endcomment|> <|startfocus|> public void add(LifecycleListener listener) { manager.add(listener); <|endfocus|>
<|startcomment|> We shouldn't be processing disabled plugins during init. <|endcomment|>  public boolean accept(File pathname) { String n = pathname.getName(); <|startfocus|> return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile(); <|endfocus|>
<|startcomment|> I don't see why this method call is needed here. <|endcomment|>  public void onNewProjectCreated( com.google.gerrit.extensions.events.NewProjectCreatedListener.Event event) { networkGraphDataCache.refresh(event.getProjectName()); <|startfocus|> repoManager.list(); <|endfocus|> 
<|startcomment|> I don't think I can safely modify the primary key in my database like this. I had expected we do this by making a new table that uses Id (group) and UUID (member) and modified the lookup logic to query both and union them together. <|endcomment|>  import com.google.gwtorm.client.Column; import com.google.gwtorm.client.CompoundKey; /** Membership of an {@link AccountGroup} in an {@link AccountGroup}. */ public final class AccountGroupInclude { public static class Key extends CompoundKey<AccountGroup.Id> { private static final long serialVersionUID = 1L; @Column(id = 1) protected AccountGroup.Id groupId; @Column(id = 2) protected AccountGroup.Id includeId; <|startfocus|> @Column(id = 3) protected AccountGroup.UUID includeUUID; <|endfocus|> protected Key() { groupId = new AccountGroup.Id(); includeId = new AccountGroup.Id(); includeUUID = new AccountGroup.UUID(); } public Key(final AccountGroup.Id g, final AccountGroup.UUID uuid) { groupId = g; includeUUID = uuid; } @Override public AccountGroup.Id getParentKey() { return groupId; } public AccountGroup.Id getGroupId() { return groupId; } public AccountGroup.Id getIncludeId() { return includeId; } 
<|startcomment|> Same as above. <|endcomment|>  throws OrmException { if (!migration.readChanges()) { return ReviewerSet.fromApprovals( db.patchSetApprovals().byChange(notes.getChangeId())); } return notes.load().getReviewers(); } /** * Get all reviewers and CCed accounts for a change. * * @param allApprovals all approvals to consider; must all belong to the same * change. * @return reviewers for the change. * @throws OrmException if reviewers for the change could not be read. */ <|startfocus|> public ReviewerSet getReviewers(ChangeNotes notes, Iterable<PatchSetApproval> allApprovals) <|endfocus|> throws OrmException { if (!migration.readChanges()) { return ReviewerSet.fromApprovals(allApprovals); } return notes.load().getReviewers(); } /** * Get updates to reviewer set. * Always returns empty list for ReviewDb. * * @param notes change notes. * @return reviewer updates for the change. * @throws OrmException if reviewer updates for the change could not be read. */
<|startcomment|> Me hates "output". :( <|endcomment|>  break; default: throw new IllegalStateException("unsupported dashboard level: " + level); } } else { output = Maps.newTreeMap(); } format.newGson().toJson(output, new TypeToken<Map<String, DashboardInfo>>() {}.getType(), stdout); stdout.print('\n'); } finally { stdout.flush(); } } private Map<String, DashboardInfo> projectDashboards(final Project.NameKey projectName) { <|startfocus|> final Map<String, DashboardInfo> output = Maps.newTreeMap(); <|endfocus|> final ProjectState projectState = projectCache.get(projectName); final ProjectControl projectControl = projectState.controlFor(currentUser); if (projectState == null || !projectControl.isVisible()) { return output; } Repository repo = null; RevWalk revWalk = null; try { repo = repoManager.openRepository(projectName); final Map<String, Ref> refs = repo.getRefDatabase().getRefs(REFS_DASHBOARDS); for (final Ref ref : refs.values()) { if (projectControl.controlForRef(ref.getName()).canRead()) {
<|startcomment|> Why not to use projectState.getProject().getParent(allProjectsName) here? Then you don't need the special handling for the All-Projects project below. <|endcomment|>  private DashboardInfo findProjectDefaultDashboard(ProjectState projectState) { final Project.NameKey projectName = projectState.getProject().getNameKey(); Project.NameKey parent; DashboardInfo info; Set<Project.NameKey> seen = new HashSet<Project.NameKey>(); seen.add(projectName); boolean considerLocal = true; do { info = loadProjectDefaultDashboard(projectState, considerLocal); if (info != null) { return info; } <|startfocus|> parent = projectState.getProject().getParent(); if (parent == null || !seen.add(parent)) { break; } projectState = projectCache.get(parent); <|endfocus|> considerLocal = false; } while (projectState != null); projectState = projectCache.getAllProjects(); parent = projectState.getProject().getNameKey(); if (seen.add(parent)) { info = loadProjectDefaultDashboard(projectState, considerLocal); } return info;
<|startcomment|> unrelated change <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.httpd; import static com.google.gerrit.extensions.registration.PrivateInternals_DynamicTypes.registerInParentInjectors; <|startfocus|> import static com.google.inject.Scopes.SINGLETON; <|endfocus|> import com.google.gerrit.common.data.GerritConfig; import com.google.gerrit.extensions.registration.DynamicSet; import com.google.gerrit.extensions.webui.WebUiPlugin; import com.google.gerrit.httpd.auth.become.BecomeAnyAccountLoginServlet; import com.google.gerrit.httpd.auth.container.HttpAuthModule; import com.google.gerrit.httpd.auth.container.HttpsClientSslCertModule; import com.google.gerrit.httpd.auth.ldap.LdapAuthModule; import com.google.gerrit.httpd.gitweb.GitWebModule; import com.google.gerrit.httpd.rpc.UiRpcModule; import com.google.gerrit.lifecycle.LifecycleModule; import com.google.gerrit.server.CmdLineParserModule; import com.google.gerrit.server.RemotePeer;
<|startcomment|> I couldn't find any other place in our code with formatting like this :-) <|endcomment|> import com.google.gerrit.reviewdb.client.LabelId; import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gerrit.reviewdb.client.PatchSetApproval; import com.google.gerrit.reviewdb.client.PatchSetInfo; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.notedb.ChangeNotes; import com.google.gerrit.server.notedb.ChangeUpdate; import com.google.gerrit.server.notedb.NotesMigration; import com.google.gerrit.server.notedb.ReviewerState; <|startfocus|> import com.google.gerrit.server.project.ChangeControl; <|endfocus|> import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Singleton; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; /** * Utility functions to manipulate patchset approvals. * <p> * Approvals are overloaded, they represent both approvals and reviewers * which should be CCed on a change. To ensure that reviewers are not lost * there must always be an approval on each patchset for each reviewer,
<|startcomment|> s/autenticate/authenticate <|endcomment|>  } return new AuthUser(new AuthUser.UUID(username), username); } finally { try { ctx.close(); } catch (NamingException e) { log.warn("Cannot close LDAP query handle", e); } } } catch (AccountException e) { log.error("Cannot query LDAP to autenticate user", e); throw new InvalidCredentialsException("Cannot query LDAP for account", e); } catch (NamingException e) { <|startfocus|> log.error("Cannot query LDAP to autenticate user", e); <|endfocus|> throw new AuthException("Cannot query LDAP for account", e); } catch (LoginException e) { log.error("Cannot authenticate server via JAAS", e); throw new AuthException("Cannot query LDAP for account", e); } } } 
<|startcomment|> I think that this class (ReceiveCommits) must know which exactly commit validators it needs. It feels strange to delegate that knowledge to the CommitValidators class. The CommitValidators class should only provide reusable validators and leave it to the callers to combine the validators as they need. <|endcomment|>  final ObjectId newCommitId; final ReceiveCommand inputCommand; final boolean checkMergedInto; ChangeNotes notes; ChangeControl changeCtl; BiMap<RevCommit, PatchSet.Id> revisions; PatchSet.Id psId; ReceiveCommand prev; ReceiveCommand cmd; PatchSetInfo info; boolean skip; private PatchSet.Id priorPatchSet; List<String> groups = ImmutableList.of(); private ReplaceOp replaceOp; ReplaceRequest(Change.Id toChange, RevCommit newCommit, ReceiveCommand cmd, boolean checkMergedInto) { this.ontoChange = toChange; <|startfocus|> this.newCommitId = newCommit.copy(); <|endfocus|> this.inputCommand = cmd; this.checkMergedInto = checkMergedInto; revisions = HashBiMap.create(); for (Ref ref : refs(toChange)) { try { revisions.forcePut( rp.getRevWalk().parseCommit(ref.getObjectId()), PatchSet.Id.fromRef(ref.getName())); } catch (IOException err) { log.warn(String.format( "Project %s contains invalid change ref %s", project.getName(), ref.getName()), err); }
<|startcomment|> s/its/it's <|endcomment|>  for (ChangeNotes notes : allNotes) { replaceByChange.get(notes.getChangeId()).notes = notes; } } private class ReplaceRequest { final Change.Id ontoChange; final ObjectId newCommitId; final ReceiveCommand inputCommand; final boolean checkMergedInto; ChangeNotes notes; ChangeControl changeCtl; BiMap<RevCommit, PatchSet.Id> revisions; PatchSet.Id psId; ReceiveCommand prev; ReceiveCommand cmd; PatchSetInfo info; boolean skip; private PatchSet.Id priorPatchSet; List<String> groups = ImmutableList.of(); <|startfocus|> private ReplaceOp replaceOp; <|endfocus|> ReplaceRequest( Change.Id toChange, RevCommit newCommit, ReceiveCommand cmd, boolean checkMergedInto) { this.ontoChange = toChange; this.newCommitId = newCommit.copy(); this.inputCommand = cmd; this.checkMergedInto = checkMergedInto; revisions = HashBiMap.create(); for (Ref ref : refs(toChange)) { try { revisions.forcePut( rp.getRevWalk().parseCommit(ref.getObjectId()), PatchSet.Id.fromRef(ref.getName()));
<|startcomment|> Tab <|endcomment|>  } @Override protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException { GitilesAccess access = getAccess(req); RepositoryDescription desc = access.getRepositoryDescription(); renderJson(req, res, desc, desc.getClass()); } @VisibleForTesting Map<String, ?> buildData(HttpServletRequest req) throws IOException { GitilesView view = ViewFilter.getView(req); Repository repo = ServletUtils.getRepository(req); GitilesAccess access = getAccess(req); <|startfocus|> RepositoryDescription desc = access.getRepositoryDescription(); <|endfocus|> RevWalk walk = new RevWalk(repo); List<Map<String, Object>> tags; Map<String, Object> data; try { tags = RefServlet.getTagsSoyData(req, timeCache, walk, REF_LIMIT); ObjectId headId = repo.resolve(Constants.HEAD); if (headId != null) { RevObject head = walk.parseAny(headId); if (head.getType() == Constants.OBJ_COMMIT) { walk.reset(); walk.markStart((RevCommit) head); DateFormatter df = new DateFormatter(access, Format.DEFAULT);
<|startcomment|> s/watches/watchers <|endcomment|>  import java.util.HashSet; import java.util.List; import java.util.Set; public class ProjectWatch { private static final Logger log = LoggerFactory.getLogger(ProjectWatch.class); protected final EmailArguments args; protected final ProjectState projectState; protected final Project.NameKey project; protected final ChangeData changeData; public ProjectWatch(EmailArguments args, Project.NameKey project, ProjectState projectState, ChangeData changeData) { this.args = args; this.project = project; this.projectState = projectState; this.changeData = changeData; } /** Returns all watchers that are relevant */ public final Watchers getWatchers(NotifyType type) throws OrmException { Watchers matching = new Watchers(); <|startfocus|> Set<Account.Id> projectWatchers = new HashSet<>(); <|endfocus|> for (AccountProjectWatch w : args.db.get().accountProjectWatches() .byProject(project)) { if (add(matching, w, type)) { // We only want to prevent matching All-Projects if this filter hits projectWatchers.add(w.getAccountId()); } } 
<|startcomment|> Lists.newArrayList(). There isn't a good reason to use a LinkedList here. In general ArrayList performs better and uses less memory than LinkedList *unless* you are doing insertion or removal of elements in the middle fo the list. <|endcomment|>  @Option(name = "--recursive", usage = "to resolve included groups recursively") private boolean recursive; @Inject ListMembers(final GroupCache groupCache, final GroupDetailFactory.Factory groupDetailFactory, final AccountCache accountCache) { this.groupCache = groupCache; this.groupDetailFactory = groupDetailFactory; this.accountCache = accountCache; } @Override public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception { <|startfocus|> return Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new HashSet<AccountGroup.UUID>()).values()); <|endfocus|> } private Map<Account.Id, MemberInfo> getMembers( final AccountGroup.UUID groupUUID, final boolean recursive, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException { seenGroups.add(groupUUID); final Map<Account.Id, MemberInfo> members = Maps.newHashMap(); final AccountGroup group = groupCache.get(groupUUID); final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call(); if (groupDetail.members != null) {
<|startcomment|> Each of the parent names should be a link to that parent project. Here they all link to the 0th parent. :-( You need to modify the widgets here so inheritsFrom is a panel and each parent is a link added to the panel. <|endcomment|>  List<Project.NameKey> parents = value.getInheritsFrom(); if (parents != null && parents.size() > 0) { inheritsFrom.getStyle().setDisplay(Display.BLOCK); String text = new String(parents.get(0).get()); for (int i = 1; i < parents.size(); i++) { text += ", " + parents.get(i).get(); } <|startfocus|> parentProject.setText(text); parentProject.setTargetHistoryToken( // Dispatcher.toProjectAdmin(parents.get(0), ProjectScreen.ACCESS)); <|endfocus|> } else { inheritsFrom.getStyle().setDisplay(Display.NONE); } final GitwebLink c = Gerrit.getGitwebLink(); if (value.isConfigVisible() && c != null) { history.getStyle().setDisplay(Display.BLOCK); gitweb.setText(c.getLinkName()); gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config")); } else { history.getStyle().setDisplay(Display.NONE); } 
<|startcomment|> _oneGroup? <|endcomment|> import com.google.gerrit.server.BadRequestHandler; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.IdentifiedUser; import com.google.gerrit.server.account.GroupControl; import com.google.gerrit.server.account.GroupIncludeCache; import com.google.gerrit.server.group.AddIncludedGroups.Input; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import java.util.List; import java.util.Map; public class AddIncludedGroups implements RestModifyView<GroupResource, Input> { static class Input { @DefaultInput <|startfocus|> String _oneIncludedGroup; <|endfocus|> List<String> includedGroups; static Input init(Input in) { if (in == null) { in = new Input(); } if (in.includedGroups == null) { in.includedGroups = Lists.newArrayListWithCapacity(1); } if (!Strings.isNullOrEmpty(in._oneIncludedGroup)) { in.includedGroups.add(in._oneIncludedGroup); } return in; } } private final GroupControl.Factory groupControlFactory; private final Provider<GroupsCollection> groupsCollection; private final GroupIncludeCache groupIncludeCache;
<|startcomment|> get() <|endcomment|>  public static void removeIncludedGroups(AccountGroup.UUID group, Set<AccountGroupIncludeByUuid.Key> ids, final AsyncCallback<VoidResult> cb) { if (ids.size() == 1) { AccountGroupIncludeByUuid.Key g = ids.iterator().next(); groups(group).id(g.getIncludeUUID().toString()).delete(cb); } else { IncludedGroupInput in = IncludedGroupInput.create(); <|startfocus|> for (AccountGroupIncludeByUuid.Key g : ids) { in.add_group(g.getIncludeUUID().toString()); <|endfocus|> } group(group).view("groups.delete").post(in, cb); }
<|startcomment|> don't you need missing.get(account.getId()) here? <|endcomment|>  for (AccountInfo info : Iterables.concat(created.values(), provided)) { AccountState state = accountCache.getIfPresent(info._id); if (state != null) { fill(info, state.getAccount()); } else { missing.put(info._id, info); } } if (!missing.isEmpty()) { for (Account account : db.get().accounts().get(missing.keySet())) { <|startfocus|> for (AccountInfo info : missing.values()) { <|endfocus|> fill(info, account); } } }
<|startcomment|> s/moved/renamed <|endcomment|> import com.google.gerrit.common.errors.ProjectRenamingFailedException; import com.google.gerrit.extensions.annotations.RequiresCapability; import com.google.gerrit.server.project.RenameProject; import com.google.gerrit.sshd.SshCommand; import com.google.inject.Inject; import org.kohsuke.args4j.Argument; /** Create a new project. **/ @RequiresCapability(GlobalCapability.RENAME_PROJECT) final class RenameProjectCommand extends SshCommand { @Argument(index = 0, required = true, metaVar = "PROJECT", <|startfocus|> usage = "name of the project to be moved") <|endfocus|> private String sourceName; @Argument(index = 1, required = true, metaVar = "NEWNAME", usage = "new name for the project") private String destinationName; @Inject private RenameProject.Factory renameProjectFactory; @Override protected void run() throws Failure { try { final RenameProject renameProject = renameProjectFactory.create( sourceName, destinationName); renameProject.renameProject(); } catch (ProjectRenamingFailedException e) { throw die(e); } } } 
<|startcomment|> s/2009/2013 <|endcomment|> <|startfocus|> Copyright (C) 2009 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.sshd; import com.google.inject.Provider; import org.apache.sshd.server.Command; /*package*/final class CommandProvider { private final Provider<Command> provider; private final String description; /*package*/ CommandProvider(final Provider<Command> p, final String d) { this.provider = p; this.description = d; } public Provider<Command> getProvider() { return provider; } public String getDescription() {
<|startcomment|> s/exist/exists <|endcomment|>  ProjectControl ctl; try { ctl = controlFactory.controlFor(new Project.NameKey(input.parent), user.get()); args.newParent = ctl; } catch (NoSuchProjectException e) { throw new BadRequestException("Parent project \"" + input.parent + "\" does not exist."); } if (!ctl.isVisible() && !ctl.isOwner()) { throw new BadRequestException("Parent project \"" + input.parent <|startfocus|> + "\" exist, but out of control."); <|endfocus|> } } try { controlFactory.controlFor(new Project.NameKey(input.projectName), user.get()); throw new NameAlreadyUsedException(input.projectName); } catch (NoSuchProjectException e) { } args.setProjectName(input.projectName); args.createEmptyCommit = input.createEmptyCommit; args.permissionsOnly = input.permissionsOnly; args.projectDescription = ""; args.submitType = SubmitType.MERGE_IF_NECESSARY; args.branch = Collections.emptyList(); final PerformCreateProject createProject = createProjectFactory.create(args); createProject.createProject(); 
<|startcomment|> s/2012/2013 ? <|endcomment|> <|startfocus|> Copyright (C) 2012 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.change; import com.google.common.base.Charsets; import com.google.common.base.Function; import com.google.common.base.Joiner; import com.google.common.base.Objects; import com.google.common.base.Throwables; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.gerrit.common.data.SubmitRecord; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.BadRequestException;
<|startcomment|> Why isn't one from an ApprovalCategory overrideable? <|endcomment|>  List<ApprovalCategoryValue> acvs) { List<LabelValue> values = new ArrayList<LabelValue>(acvs.size()); for (ApprovalCategoryValue acv : acvs) { values.add( new LabelValue(acv.getValue(), acv.getName())); } LabelType lt = new LabelType(ac.getId().get(), ac.getLabelName(), values); lt.setAbbreviatedName(ac.getAbbreviatedName()); lt.setFunctionName(ac.getFunctionName()); lt.setCopyMinScore(ac.isCopyMinScore()); <|startfocus|> lt.setCanOverride(false); <|endfocus|> return lt;
<|startcomment|> Use ref here in the error message in case we mangled their input in some strange way, at least the user can now see what the server really balked on. <|endcomment|>  } if (input == null || Strings.isNullOrEmpty(input.ref)) { throw new BadRequestException("ref required"); } String ref = input.ref; if (!ref.startsWith(Constants.R_REFS)) { ref = Constants.R_HEADS + ref; } Repository repo = null; try { repo = repoManager.openRepository(rsrc.getNameKey()); if (repo.getRef(ref) == null) { throw new UnprocessableEntityException(String.format( <|startfocus|> "Ref Not Found: %s", input.ref)); <|endfocus|> } if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) { final RefUpdate u = repo.updateRef(Constants.HEAD, true); u.disableRefLog(); RefUpdate.Result res = u.link(ref); switch(res) { case NO_CHANGE: case RENAMED: case FORCED: break; default: throw new IOException("Setting HEAD failed with " + res); } } return ref; } catch (RepositoryNotFoundException e) { throw new ResourceNotFoundException(rsrc.getName());
<|startcomment|> nitpick: "To signal, that" -> "To signal that" <|endcomment|> // strictly necessary, it helps when doing cherry-picking between branches // for different api versions. public interface DatabaseDeleteHandler { /** * Asserts that the project can be deleted from the database. * <p> * This method performs all required precursory checks whether or not the * project can by deleted from the database. * <p> * This method must not yet remove any data. * <p> <|startfocus|> * To signal, that deletion of the project is not okay, throw an exception. <|endfocus|> * * @param project The project for which should be checked whether or not it * can be deleted. * @throws Exception If there is on obstacle to the deletion. The exception's * message should describe the problem. */ public void assertCanDelete(Project project) throws Exception; /** * Gets warnings to show to user before allowing to delete project. * <p> * This method expects that the caller called {@code assertCanDelete()} in
<|startcomment|> Uhm, this shouldn't be clipping the DNS host name. Just use the host name. <|endcomment|>  DynamicSet.bind(binder(), BranchWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), FileHistoryWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), FileWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), ParentWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), ProjectWebLink.class).to(GitilesWeblinks.class); DynamicSet.bind(binder(), TagWebLink.class).to(GitilesWeblinks.class); } bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class); bind(new TypeLiteral<RepositoryResolver<HttpServletRequest>>() {}).to(Resolver.class); <|startfocus|> listener().to(Lifecycle.class); <|endfocus|>
<|startcomment|> Like with push to refs/for/refs/heads/master we should be testing on the full name not the short name. <|endcomment|>  "Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err); reject(cmd, "invalid object"); return; } logDebug("Creating {}", cmd); if (isHead(cmd) && !isCommit(cmd)) { return; } RefControl ctl = projectControl.controlForRef(cmd.getRefName()); <|startfocus|> if (ctl.canCreate(db, rp.getRepository(), obj)) { if (!validRefOperation(cmd)) { return; } <|endfocus|> validateNewCommits(ctl, cmd); batch.addCommand(cmd); } else { reject(cmd, "prohibited by Gerrit: create access denied for " + cmd.getRefName()); }
<|startcomment|> 2013? <|endcomment|> <|startfocus|> Copyright (C) 2009 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.pgm.util; import com.google.gerrit.server.config.GerritServerConfig; import com.google.gerrit.server.config.SitePaths; import com.google.gerrit.server.schema.DataSourceProvider; import com.google.gerrit.server.schema.DataSourceType; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.lib.Config; import java.io.File; import java.io.FileFilter; import java.util.Arrays; import java.util.Comparator; import javax.sql.DataSource; 
<|startcomment|> This shouldn't matter for a valid base but we will decode the parameter twice. Maybe add a method fromDecodedString to IdString to call Url.encode() first to work around double decoding. <|endcomment|>  return new FileResource(rev, id.get()); } private final class List implements RestReadView<RevisionResource> { @Option(name = "--base", metaVar = "revision-id") String base; @Override public Object apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception { PatchSet basePatchSet = null; if (base != null) { <|startfocus|> RevisionResource baseResource = revisions.get().parse( resource.getChangeResource(), IdString.fromUrl(base)); <|endfocus|> basePatchSet = baseResource.getPatchSet(); } return fileInfoJson.toFileInfoMap( resource.getChange(), resource.getPatchSet(), basePatchSet); } } } 
<|startcomment|> Rebase onto current master and use UiCommands. <|endcomment|>  private PatchListKey keyFor(final Whitespace whitespace) { <|startfocus|> return new PatchListKey(projectKey, oldId, newId, whitespace, true); <|endfocus|>
<|startcomment|> s/all/All <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.webui; import com.google.gerrit.extensions.restapi.RestResource; import com.google.gerrit.extensions.restapi.RestView; import java.util.Set; public interface UiCommand<R extends RestResource> extends RestView<R> { public static enum Place { <|startfocus|> /* all patch sets */ <|endfocus|> PATCHSET_ACTION_PANEL, /* current patch set only */ CURRENT_PATCHSET_ACTION_PANEL, }; Set<Place> getPlaces(); String getLabel(R resource); String getTitle(R resource); boolean isVisible(R resource); boolean isEnabled(R resource); } 
<|startcomment|> unnecessary blank line <|endcomment|>  public final native Configuration set(String name, String val) /*-{ this[name] = val; return this; }-*/; public final native Configuration set(String name, int val) /*-{ this[name] = val; return this; }-*/; public final native Configuration set(String name, boolean val) /*-{ this[name] = val; return this; }-*/; public final native Configuration setInfinity(String name) /*-{ this[name] = Infinity; return this; }-*/; protected Configuration() { } <|startfocus|> <|endfocus|> } 
<|startcomment|> I am inclined to feel like this validator is standalone enough to merrit its one file? That would prevent this class from growing wildly. <|endcomment|>  } public void validatePreMergeCommit(final CodeReviewCommit commit, ProjectState destProject, final Branch.NameKey destBranch) throws MergeValidationException { List<MergeValidationListener> validators = new LinkedList<MergeValidationListener>(); validators.add(new PluginCommitValidationListener(commitValidationListeners)); validators.add(new ProjectConfigValidator(repo, allProjectsName, db, ps, projectCache, identifiedUserFactory)); for (MergeValidationListener validator : validators) { validator.onPreMergeCommit(commit, destProject, destBranch); } } <|startfocus|> public static class ProjectConfigValidator implements <|endfocus|> MergeValidationListener { private final Repository repo; private final AllProjectsName allProjectsName; private final ReviewDb db; private final PatchSet ps; private final ProjectCache projectCache; private final IdentifiedUser.GenericFactory identifiedUserFactory; public ProjectConfigValidator(final Repository repo, final AllProjectsName allProjectsName, final ReviewDb db, final PatchSet ps, final ProjectCache projectCache, final IdentifiedUser.GenericFactory iuf) { this.repo = repo; this.allProjectsName = allProjectsName; this.db = db; this.ps = ps;
<|startcomment|> Please use Eclipse's Organize Imports feature on this file to correct the ordering of import statements. <|endcomment|>  import static com.google.common.base.Objects.firstNonNull; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.ResourceConflictException; import com.google.gerrit.extensions.restapi.RestReadView; import com.google.gerrit.reviewdb.client.PatchLineComment; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.account.AccountInfo; <|startfocus|> import com.google.gerrit.server.change.CommentInfo; import com.google.gerrit.common.changes.Side; <|endfocus|> import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import java.util.Collections; import java.util.Comparator; import java.util.List; import java.util.Map; class ListDrafts implements RestReadView<RevisionResource> { protected final Provider<ReviewDb> db; private final AccountInfo.Loader.Factory accountLoaderFactory; @Inject ListDrafts(Provider<ReviewDb> db, AccountInfo.Loader.Factory alf) { this.db = db; this.accountLoaderFactory = alf; } protected Iterable<PatchLineComment> listComments(RevisionResource rsrc)
<|startcomment|> nit: we usually write id.equals("server") <|endcomment|> RestCollection<TopLevelResource, ConfigResource> { private final DynamicMap<RestView<ConfigResource>> views; @Inject ConfigCollection( DynamicMap<RestView<ConfigResource>> views) { this.views = views; } @Override public RestView<TopLevelResource> list() { return null; } @Override public DynamicMap<RestView<ConfigResource>> views() { return views; } @Override public ConfigResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException { <|startfocus|> if (!"server".equals(id.get())) { throw new ResourceNotFoundException(id); <|endfocus|> } return new ConfigResource(); } } 
<|startcomment|> pull this up above the loop and reuse <|endcomment|>  CommentInfo info = comments.get(i); Side mySide = info.side(); CodeMirror cm = mySide == Side.PARENT ? cmA : cmB; CodeMirror other = cm.equals(cmA) ? cmB : cmA; final CommentBox box = new CommentBox(info.author(), info.updated(), info.message(), isDraft); int line = info.line() - 1; // CommentInfo is 1-based, but CM is 0-based <|startfocus|> Configuration config = Configuration.create().set("coverGutter", true); <|endfocus|> diffTable.add(box); cm.addLineWidget(line, box.getElement(), config); int lineToPad = gapProcessor.lineOnOther(mySide, line); // Estimated height at 21px, fixed by deferring after display final Element paddingOtherside = addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX); Runnable callback = new Runnable() { @Override public void run() { paddingOtherside.getStyle().setHeight( box.getOffsetHeight(), Unit.PX); } };
<|startcomment|> See comment for line 93. <|endcomment|>  deleteEvent(); pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status, refUpdateStatus); RefReplicationStatus completedRefStatus = null; boolean allPushTaksCompleted = false; countingLock.lock(); try { RefReplicationStatus refStatus = getRefStatus(project, ref); refStatus.replicatedNodesCount++; finishedPushTasksCount++; if (allScheduled) { if (refStatus.allDone()) { completedRefStatus = statusByProjectRef.remove(project, ref); } allPushTaksCompleted = finishedPushTasksCount == totalPushTasksCount; <|startfocus|> } <|endfocus|> } finally { countingLock.unlock(); } if (completedRefStatus != null) { doRefPushTasksCompleted(completedRefStatus); } if (allPushTaksCompleted) { doAllPushTasksCompleted(); }
<|startcomment|> createArray().cast() <|endcomment|> import com.google.gwt.user.client.DOM; import com.google.gwt.user.client.Window; import net.codemirror.lib.CodeMirror; import net.codemirror.lib.CodeMirror.LineClassWhere; import net.codemirror.lib.Configuration; import net.codemirror.lib.LineCharacter; import net.codemirror.lib.ModeInjector; import java.util.ArrayList; import java.util.List; public class CodeMirrorDemo extends Screen { private static final int HEADER_FOOTER = 60 + 15 * 2 + 38; private static final JsArrayString EMPTY = <|startfocus|> (JsArrayString) JavaScriptObject.createArray(); <|endfocus|> private final PatchSet.Id base; private final PatchSet.Id revision; private final String path; private DiffTable diffTable; private CodeMirror cmA; private CodeMirror cmB; private HandlerRegistration resizeHandler; private JsArray<CommentInfo> published; private JsArray<CommentInfo> drafts; private List<Runnable> resizeCallbacks; private LineMapper mapper; public CodeMirrorDemo( PatchSet.Id base, PatchSet.Id revision, String path) { this.base = base; this.revision = revision; this.path = path; } @Override
<|startcomment|> Log this so the admin knows the message for this change is not indexed. <|endcomment|>  public String get(ChangeData input, FillArgs args) throws OrmException { return input.change().getProject().get(); } }; /** Reference (aka branch) the change will submit onto. */ public static final FieldDef<ChangeData, String> REF = new FieldDef.Single<ChangeData, String>( ChangeQueryBuilder.FIELD_REF, FieldType.EXACT, false) { @Override public String get(ChangeData input, FillArgs args) throws OrmException { return input.change().getDest().get(); } }; <|startfocus|> @Deprecated <|endfocus|> /** Topic, a short annotation on the branch. */ public static final FieldDef<ChangeData, String> LEGACY_TOPIC = new FieldDef.Single<ChangeData, String>( ChangeQueryBuilder.FIELD_TOPIC, FieldType.EXACT, false) { @Override public String get(ChangeData input, FillArgs args) throws OrmException { return input.change().getTopic(); } }; /** Topic, a short annotation on the branch. */ public static final FieldDef<ChangeData, String> TOPIC =
<|startcomment|> This is a wrong import and causes the Buck build to fail. Should be: import com.google.common.collect.Lists; <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.query.change; import com.google.common.collect.Lists; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.IdentifiedUser; <|startfocus|> import com.google.gerrit.server.index.Schema; import com.google.gerrit.server.query.OrPredicate; import com.google.gerrit.server.query.Predicate; import com.google.gerrit.server.query.QueryParseException; import com.google.gerrit.server.query.change.ChangeQueryBuilder.Arguments; <|endfocus|> import com.google.gwtorm.server.OrmException; import com.google.gwtorm.server.ResultSet; import java.util.List; import java.util.Set; class IsStarredByPredicate extends OrPredicate<ChangeData> implements ChangeDataSource { private static String describe(CurrentUser user) { if (user.isIdentifiedUser()) { return ((IdentifiedUser) user).getAccountId().toString(); } return user.toString(); } 
<|startcomment|> Do you actually need db and repoManager? Can both parameters be removed? <|endcomment|> import com.google.gerrit.server.index.ChangeIndex; import com.google.gerrit.server.index.IndexPredicate; import com.google.gerrit.server.query.Predicate; import com.google.gerrit.server.query.QueryParseException; import com.google.gwtorm.server.OrmException; /** * Predicate to match changes that contains specified text in commit messages * body. */ class MessagePredicate extends IndexPredicate<ChangeData> { private final ChangeIndex index; MessagePredicate(ChangeIndex index, String value) { super(ChangeField.COMMIT_MESSAGE, value); this.index = index; } <|startfocus|> <|endfocus|> @Override public boolean match(ChangeData object) throws OrmException { try { for (ChangeData cData : index.getSource( Predicate.and(new LegacyChangeIdPredicate( index.getSchema(), object.getId()), this), 0, 1).read()) { if (cData.getId().equals(object.getId())) { return true; } } } catch (QueryParseException e) { throw new OrmException(e); } return false; } @Override public int getCost() { return 1; } } 
<|startcomment|> This seems backwards. Invert the logic and return true when the arrows need to update and false when they are unnecessary? <|endcomment|>  void setMarker(TextMarker marker, int length) { this.marker = marker; numSkipLines = length; skipNum.setText(Integer.toString(length)); <|startfocus|> if (!checkAndUpdateArrows()) { <|endfocus|> upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND)); downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND)); }
<|startcomment|> Still need to solve the IdentifiedUser issue mentioned in the previous patch set. <|endcomment|> import org.eclipse.jgit.lib.ObjectInserter; import org.eclipse.jgit.lib.PersonIdent; import org.eclipse.jgit.lib.Ref; import org.eclipse.jgit.lib.RefUpdate; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.merge.ThreeWayMerger; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevWalk; import java.io.IOException; import java.sql.Timestamp; import java.util.Collections; import java.util.List; import java.util.Set; public class RebaseChange { <|startfocus|> public interface Factory { RebaseChange create(); } private final ChangeControl.Factory changeControlFactory; private final PatchSetInfoFactory patchSetInfoFactory; private final ReviewDb db; <|endfocus|> private final GitRepositoryManager gitManager; private final PersonIdent myIdent; private final GitReferenceUpdated replication; private final RebasedPatchSetSender.Factory rebasedPatchSetSenderFactory; private final ChangeHookRunner hooks; private final ApprovalsUtil approvalsUtil; private final Config cfg; @Inject RebaseChange(final ChangeControl.Factory changeControlFactory, final PatchSetInfoFactory patchSetInfoFactory, final ReviewDb db, @GerritPersonIdent final PersonIdent myIdent, final GitRepositoryManager gitManager,
<|startcomment|> s/return/returns s/execuded/excluded <|endcomment|>  */ public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException; /** * By default Gerrit will not validate commits pushed by user that have forge * author, committer and server identity and push merge permissions and * project doesn't require 'Signed-Off-By' flag in commit message. This is a * intended 'fast path' for improving performance of initial repository push. * <|startfocus|> * If this method return {@code true} then this validator will be execuded for <|endfocus|> * all incoming commits. Otherwise default Gerrit behavior will be preserved. * * @return {@code false} when this listener can be skip during initial push, * {@code true} otherwise */ public boolean shouldValidateAllCommits(); } 
<|startcomment|> can't this be determined from the getCommentInfo()? <|endcomment|>  /** An HtmlPanel for displaying a comment */ abstract class CommentBox extends Composite { static { Resources.I.style().ensureInjected(); } private PaddingManager widgetManager; private PaddingWidgetWrapper selfWidgetWrapper; private final DiffScreen parent; private final CodeMirror cm; private final DisplaySide side; private DiffChunkInfo diffChunkInfo; private GutterWrapper gutterWrapper; private FromTo fromTo; private TextMarker rangeMarker; private TextMarker rangeHighlightMarker; <|startfocus|> CommentBox(DiffScreen parent, CodeMirror cm, CommentInfo info, DisplaySide side) { this.parent = parent; this.cm = cm; this.side = side; CommentRange range = info.range(); <|endfocus|> if (range != null) { fromTo = FromTo.create(range); rangeMarker = cm.markText( fromTo.getFrom(), fromTo.getTo(), Configuration.create() .set("className", Resources.I.diffTableStyle().range())); } addDomHandler(new MouseOverHandler() { @Override public void onMouseOver(MouseOverEvent event) { setRangeHighlight(true); }
<|startcomment|> ... so that you can get it straight as: downloadSchemes = Arrays.asList(config.getStringList("download", null, "scheme"); <|endcomment|>  public GitBlitUrlsConfig(Config config) { canonicalWebUrlString = config.getString("gerrit", null, "canonicalWebUrl"); sshdListenAddressString = config.getString("sshd", null, "listenAddress"); httpdListenUrlString = config.getString("httpd", null, "listenUrl"); <|startfocus|> downloadSchemes = config.getStringList("download", null, "scheme"); <|endfocus|>
<|startcomment|> No leading / here in the URL. <|endcomment|>  private void setupNav(Nav nav, FileInfo info) { final String url = url(info); if (info != null) { String fileName = getFileNameOnly(info.path()); <|startfocus|> if (nav == Nav.PREV) { prevLink.setHref("/#" + url); prevLink.setHTML(SafeHtml.asis(Util.C.prevPatchLinkIcon() + fileName)); <|endfocus|> } else { nextLink.setHref("/#" + url); nextLink.setHTML(SafeHtml.asis(fileName + Util.C.nextPatchLinkIcon())); } } if (keys != null) { if (url != null) { cmds[nav.cmd] = new KeyCommand(0, nav.key, nav.help) { @Override public void onKeyPress(KeyPressEvent event) { Gerrit.display(url); } }; } else { cmds[nav.cmd] = new UpToChangeCommand2(patchSetId, 0, nav.key); } keys.add(cmds[nav.cmd]); }
<|startcomment|> We prefer nested try/finally blocks: InputStream in = openRobotsTxt(); try { OutputStream out = rsp.getOutputStream(); try { ByteStreams.copy(in, out); } finally { out.close(); } } finally { in.close(); } <|endcomment|>  if (path != null) { file = new File(path); if (!file.exists() || !file.canRead()) { log.warn("The robots file " + path + " doesn't exist or can't be read, will use the default"); file = null; } } } @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException { rsp.setContentType("text/plain"); <|startfocus|> InputStream in = null; OutputStream out = null; <|endfocus|> try { if (file == null) { in = getServletContext().getResourceAsStream("/robots.txt"); } else { in = new FileInputStream(file); } out = rsp.getOutputStream(); byte[] buffer = new byte[1024]; int count = 0; while ((count = in.read(buffer)) != -1) { out.write(buffer, 0, count); } } finally { if (in != null) { in.close(); }
<|startcomment|> Declare this version before the other constructor you have. <|endcomment|> <|startfocus|> protected CommentRange() { <|endfocus|>
<|startcomment|> Consider line breaking right after ( instead of inside the middle of the ?: operator. <|endcomment|>  msg.append("\n"); msg.append("Gerrit Code Review is not shipped with %s\n"); if (required) { msg.append("** This library is required for your configuration. **\n"); } else { msg.append(" If available, Gerrit can take advantage of features\n"); msg.append(" in the library, but will also function without it.\n"); } <|startfocus|> msg.append(String.format("%s and install it now", download ? "Download" : "Copy")); <|endfocus|> return ui.yesno(true, msg.toString(), name); }
<|startcomment|> While you're here it might be worth removing the trailing // <|endcomment|>  private void listTables() { final DatabaseMetaData meta; try { meta = connection.getMetaData(); } catch (SQLException e) { error(e); return; } try { final String[] types = {"TABLE", "VIEW"}; ResultSet rs = meta.getTables(null, null, null, types); try { if (outputFormat == OutputFormat.PRETTY) { println(" List of relations"); } <|startfocus|> showResultSet(rs, false, 0, // Identity.create(rs, "TABLE_SCHEM"), // Identity.create(rs, "TABLE_NAME"), // <|endfocus|> Identity.create(rs, "TABLE_TYPE")); } finally { rs.close(); } } catch (SQLException e) { error(e); } println("");
<|startcomment|> nit: blank line after block <|endcomment|>  void onEdit() { if (popup != null) { popup.hide(); return; <|startfocus|> } <|endfocus|> if (editBox == null) { editBox = new EditMessageBox( changeId, revision, originalMessage); } final PluginSafePopupPanel p = new PluginSafePopupPanel(true); p.setStyleName(style.replyBox()); p.addAutoHidePartner(editMessageButton.getElement()); p.addCloseHandler(new CloseHandler<PopupPanel>() { @Override public void onClose(CloseEvent<PopupPanel> event) { if (popup == p) { popup = null; } } }); p.add(editBox); p.showRelativeTo(replyButton); GlobalKey.dialog(p); popup = p;
<|startcomment|> Use Gerrit.RESOURCES instead. <|endcomment|>  package com.google.gerrit.client.change; import com.google.gerrit.client.changes.ChangeInfo; import com.google.gerrit.reviewdb.client.Change; import com.google.gwt.core.client.GWT; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.event.dom.client.ClickHandler; import com.google.gwt.user.client.Window; import com.google.gwt.user.client.ui.Image; class DownloadPatch extends Image implements ClickHandler { private Change.Id changeId; private String revision; DownloadPatch() { <|startfocus|> setResource(Resources.I.download_icon()); <|endfocus|> addClickHandler(this); } void set(ChangeInfo info, String revision) { this.changeId = info.legacy_id(); this.revision = revision; } @Override public void onClick(ClickEvent e) { StringBuilder url = new StringBuilder(GWT.getHostPageBaseURL()) .append("changes/") .append(changeId.toString()) .append("/revisions/") .append(revision) .append("/download_patch"); Window.open(url.toString(), "_blank", ""); } } 
<|startcomment|> This check is not necessary with @RequiresCapability. <|endcomment|>  import java.util.concurrent.ExecutionException; public class Index implements RestModifyView<ChangeResource, Input> { public static class Input { } private final ChangeIndexer indexer; @Inject Index(ChangeIndexer indexer) { this.indexer = indexer; } @Override public Object apply(ChangeResource rsrc, Input input) throws AuthException, InterruptedException, ExecutionException { <|startfocus|> CurrentUser caller = rsrc.getControl().getCurrentUser(); if (!caller.getCapabilities().canAdministrateServer()) { throw new AuthException("index not permitted"); } <|endfocus|> indexer.index(rsrc.getChange()).get(); return Response.none(); } } 
<|startcomment|> [optional] At this place I slightly liked more the old code which directly throws the UnloggedFailure. Using the die(...) method means that the message is prefixed with 'fatal: ', but in this case it is not really a fatal error, but a normal message. <|endcomment|>  msgBuilder.append(":\n"); for (String warning : warnings) { msgBuilder.append(" * "); msgBuilder.append(warning); msgBuilder.append("\n"); } msgBuilder.append("To really delete "); msgBuilder.append(rsrc.getName()); msgBuilder.append(", re-run with the --force flag."); throw new UnloggedFailure(msgBuilder.toString()); } } deleteProject.doDelete(rsrc, input); <|startfocus|> } catch (AuthException | ResourceNotFoundException | ResourceConflictException <|endfocus|> | OrmException | IOException e) { die(e); } } } 
<|startcomment|> Move this into the new else if block? } else if (refs.size() == 1 && refs.get(0).equals("sameAsAccess")) { r.addAll(getRefControl().getLabelTypes().getLabelTypes()); continue; } Then the else block can stay unchanged and is easier to read. <|endcomment|>  public boolean isOwner() { if (getCurrentUser().isIdentifiedUser()) { final IdentifiedUser i = (IdentifiedUser) getCurrentUser(); <|startfocus|> return i.getAccountId().equals(getChange().getOwner()); <|endfocus|> } return false;
<|startcomment|> name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "". <|endcomment|>  && account.isActive() // Can the suggestion see the change? && visibilityControl.isVisibleTo(account) // Can the account see the current user? && accountControlFactory.get().canSee(account)) { map.put(account.getId(), info); } } private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException { if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) { return false; } try { <|startfocus|> Set<Account> members = groupMembersFactory <|endfocus|> .create(currentUser.get()) .listAccounts(group.getUUID(), project.getNameKey()); if (members.isEmpty()) { return false; } if (maxAllowed > 0 && members.size() > maxAllowed) { return false; } // require that at least one member in the group can see the change for (Account account : members) { if (visibilityControl.isVisibleTo(account)) { return true; } } } catch (NoSuchGroupException e) {
<|startcomment|> This line wrapping is sort of hideous. In situations like this I prefer to pull a complex argument into a new local variable, e.g.: Project project = rsrc.getControl().getProject(); before the loop, e.g. at line 145 in this revision. This should allow you to fit the entire (now simpler) condition on a single line. <|endcomment|>  List<AccountInfo> suggestedAccounts = suggestAccount(visibilityControl); accountLoaderFactory.create(true).fill(suggestedAccounts); final List<SuggestReviewerInfo> reviewer = new ArrayList<SuggestReviewerInfo>(suggestedAccounts.size()); for (final AccountInfo a : suggestedAccounts) { reviewer.add(new SuggestReviewerInfo(a)); } <|startfocus|> final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(rsrc.getControl().getProjectControl()); for (final GroupReference g : suggestedAccountGroups) { if (suggestGroupAsReviewer(rsrc.getControl().getProject(), g, visibilityControl)) { <|endfocus|> GroupBaseInfo info = new GroupBaseInfo(); info.id = Url.encode(g.getUUID().get()); info.name = g.getName(); reviewer.add(new SuggestReviewerInfo(info)); } } Collections.sort(reviewer); if (reviewer.size() <= limit) { return reviewer; } else { return reviewer.subList(0, limit); } } private VisibilityControl getVisibility(final ChangeResource rsrc) { VisibilityControl visibilityControl; if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
<|startcomment|> final is unnecessary <|endcomment|> <|startfocus|> static void publish(final Change.Id id, String revision) { <|endfocus|> ChangeApi.publish(id.get(), revision, cs(id));
<|startcomment|> This might be better as a method on key, key.getRevWalk(reader), to avoid this ternary everywhere it's used. Not a big deal now because this is exactly once. <|endcomment|>  } finally { repo.close(); } } private static RawTextComparator comparatorFor(Whitespace ws) { switch (ws) { case IGNORE_ALL_SPACE: return RawTextComparator.WS_IGNORE_ALL; case IGNORE_SPACE_AT_EOL: return RawTextComparator.WS_IGNORE_TRAILING; case IGNORE_SPACE_CHANGE: return RawTextComparator.WS_IGNORE_CHANGE; case IGNORE_NONE: default: return RawTextComparator.DEFAULT; } } <|startfocus|> private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException { <|endfocus|> final RawTextComparator cmp = comparatorFor(key.getWhitespace()); final ObjectReader reader = repo.newObjectReader(); try { final RevWalk rw = new RevWalk(reader); final RevCommit b = rw.parseCommit(key.getNewId()); final RevObject a = aFor(key, repo, rw, b); if (a == null) { // TODO(sop) Remove this case. // This is a merge commit, compared to its ancestor. // final PatchListEntry[] entries = new PatchListEntry[1];
<|startcomment|> entries <|endcomment|> import com.google.gerrit.extensions.restapi.RestReadView; import com.google.gerrit.extensions.webui.TopMenu; import com.google.inject.Inject; import java.util.List; public class ListTopMenus implements RestReadView<ConfigResource> { private DynamicSet<TopMenu> extensions; @Inject ListTopMenus(DynamicSet<TopMenu> extensions) { this.extensions = extensions; } @Override public Object apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException { <|startfocus|> List<TopMenu.MenuEntry> enties = Lists.newArrayList(); <|endfocus|> for (TopMenu extension : extensions) { enties.addAll(extension.getEntries()); } return enties; } } 
<|startcomment|> Please cluster with STATUS_DRAFT so it appears before MAX_OPEN. <|endcomment|>  static int nextNonDigit(String s, int i) { while (i < s.length() && s.charAt(i) >= '0' && s.charAt(i) <= '9') { i++; } return i; <|startfocus|> <|endfocus|>
<|startcomment|> Callables.returning(null); <|endcomment|>  * compute some of the fields and/or update the index. */ public abstract class ChangeIndexer { public interface Factory { ChangeIndexer create(ChangeIndex index); ChangeIndexer create(IndexCollection indexes); } /** Instance indicating secondary index is disabled. */ public static final ChangeIndexer DISABLED = new ChangeIndexer(null) { @Override public CheckedFuture<?, IOException> indexAsync(ChangeData cd) { return Futures.immediateCheckedFuture(null); } @Override protected Callable<?> indexTask(ChangeData cd) { <|startfocus|> return new Callable<Void>() { @Override public Void call() { return null; } }; <|endfocus|> } @Override protected Callable<?> deleteTask(ChangeData cd) { return new Callable<Void>() { @Override public Void call() { return null; } }; } }; private static final Function<Exception, IOException> MAPPER = new Function<Exception, IOException>() { @Override public IOException apply(Exception in) { if (in instanceof IOException) { return (IOException) in; } else if (in instanceof ExecutionException
<|startcomment|> [optionally] Can't we be smarter here and only request all revisions, if the revision to request is not the current one? I.e. if a change has 7 ps and current ps is 7, then in this specific case would be enouph to only request the ListChangesOption.CURRENT_REVISION. If however it needs the commands for the revision 3 then currently we need all revisions. Additional bonus points would be to introduce new request option: ListChangesOption.SPECIFIC_REVISION and pass the requested revision number as a parameter, to position in the middle of the change's pacth set list and still to include only one revision in the response. For our projects it is not unusual to have 20-40 patch sets per change. <|endcomment|>  protected void onLoad() { if (fetch == null) { <|startfocus|> RestApi call = ChangeApi.detail(changeId.get()); ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, <|endfocus|> ListChangesOption.DOWNLOAD_COMMANDS)); call.get(new AsyncCallback<ChangeInfo>() { @Override public void onSuccess(ChangeInfo result) { fetch = result.revision(revision).fetch(); renderScheme(); } @Override public void onFailure(Throwable caught) { } }); }
<|startcomment|> Hrrmph. We name things. You could use a DynamicMap instead of DynamicSet and then the name is implied by Guice binding used by the developer. <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.config; import com.google.gerrit.extensions.annotations.ExtensionPoint; @ExtensionPoint public abstract class DownloadCommand { <|startfocus|> /** @return name of the download command */ public abstract String getName(); <|endfocus|> /** * Returns the download command for the given download scheme, project and * ref. * * @param scheme the download scheme for which the command should be returned * @param project the name of the project for which the download command * should be returned * @param ref the change ref * @return the download command */ public abstract String getCommand(DownloadScheme scheme, String project, String ref); } 
<|startcomment|> Bind this in GerritGlobalModule. If you don't do that it will be an implicit binding possibly registered twice, once in the HTTP stack and again in the SSH stack. Yes I know its horribly confusing. Our code is not very clear or easy to work. <|endcomment|> import org.apache.lucene.search.IndexSearcher; import org.apache.lucene.search.Query; import org.apache.lucene.search.ScoreDoc; import org.apache.lucene.search.TopDocs; import org.apache.lucene.store.Directory; import org.apache.lucene.store.IndexOutput; import org.apache.lucene.store.RAMDirectory; import org.apache.lucene.util.Version; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.io.InputStream; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipInputStream; <|startfocus|> @Singleton <|endfocus|> public class QueryDocumentationExecutor { private static final Logger log = LoggerFactory.getLogger(QueryDocumentationExecutor.class); private static final String INDEX_PATH = "index.zip"; private static final Version LUCENE_VERSION = Version.LUCENE_44; private IndexSearcher searcher; private QueryParser parser; public static class DocResult { public String title; public String url; public String content; } @Inject public QueryDocumentationExecutor() { try { Directory dir = readIndexDirectory(); if (dir == null) { searcher = null; parser = null;
<|startcomment|> I believe emptyToNull() is unnecessary - an enum.toString() shouldn't return empty. <|endcomment|>  } else { info.parent = hiddenNames.get(parent.getProject().getName()); if (info.parent == null) { info.parent = "?-" + (hiddenNames.size() + 1); hiddenNames.put(parent.getProject().getName(), info.parent); } } } } if (showDescription) { info.description = Strings.emptyToNull(e.getProject().getDescription()); } <|startfocus|> info.state = Strings.emptyToNull(e.getProject().getState().toString()); <|endfocus|> try { if (!showBranch.isEmpty()) { Repository git = repoManager.openRepository(projectName); try { if (!type.matches(git)) { continue; } List<Ref> refs = getBranchRefs(projectName, pctl); if (!hasValidRef(refs)) { continue; } for (int i = 0; i < showBranch.size(); i++) { Ref ref = refs.get(i); if (ref != null && ref.getObjectId() != null) { if (info.branches == null) {
<|startcomment|> Static method should be accessed in static way: DocList.query(loadCallback(), query); <|endcomment|>  protected void onLoad() { super.onLoad(); <|startfocus|> docs.query(loadCallback(), query); <|endfocus|>
<|startcomment|> wrong indentation <|endcomment|>  continue; } RefControl.validateRefPattern(name); replace(config, toDelete, section); } } for (String name : toDelete) { if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) { if (!checkIfOwner || projectControl.isOwner()) { config.remove(config.getAccessSection(name)); } } else if (!checkIfOwner || projectControl.controlForRef(name).isOwner()) { config.remove(config.getAccessSection(name)); } } <|startfocus|> <|endfocus|> try { setParent.get().validateParentUpdate(projectControl, parentProjectName.get()); } catch (AuthException e) { throw new UpdateParentFailedException(e.getMessage(), e); } catch (ResourceConflictException e) { throw new UpdateParentFailedException(e.getMessage(), e); } catch (UnprocessableEntityException e) { throw new UpdateParentFailedException(e.getMessage(), e); } config.getProject().setParentName(parentProjectName); if (message != null && !message.isEmpty()) { if (!message.endsWith("\n")) {
<|startcomment|> optional: allPushTasksCompleted = finishedPushTasksCount == totalPushTasksCount; <|endcomment|>  RefReplicationInfo completedRefRepInfo = null; boolean allPushTaksCompleted = false; countingLock.lock(); try { RefReplicationInfo refRepInfo = getRefReplicationInfo(project, ref); refRepInfo.replicatedNodesCount++; finishedPushTasksCount++; if (allScheduled) { if (refRepInfo.nodesToReplicateCount == refRepInfo.replicatedNodesCount) { completedRefRepInfo = replicationInfoPerProjectRef.remove(project, ref); } <|startfocus|> if (finishedPushTasksCount == totalPushTasksCount) { allPushTaksCompleted = true; } <|endfocus|> } } finally { countingLock.unlock(); } if (completedRefRepInfo!=null) { doRefPushTasksCompleted(completedRefRepInfo); } if (allPushTaksCompleted) { doAllPushTasksCompleted(); }
<|startcomment|> This should be a widget itself that is added to the parent's widget graph. Don't pass in a container widget. I think you can use a FlowPanel here for this widget type, and simplify the DOM graph away from the ugly table used by VerticalPanel. <|endcomment|>  return o + '(event,this)'; }-*/; private static boolean onOpen(NativeEvent evt, Element e) { if (LINK.handleAsClick(evt.<Event>cast())) { Gerrit.display(e.getAttribute("href").substring(1)); evt.preventDefault(); return false; } return true; } private final SimplePanel panel; private boolean showBranches; <|startfocus|> private boolean showIndirectAncestors; <|endfocus|> private boolean registerKeys; private int maxHeight; private String project; private NavigationList view; RelatedChangesTab() { panel = new SimplePanel(); } @Override public Widget asWidget() { return panel; } void setShowBranches(boolean showBranches) { this.showBranches = showBranches; } void setShowIndirectAncestors(boolean showIndirectAncestors) { this.showIndirectAncestors = showIndirectAncestors; } void setMaxHeight(int height) { maxHeight = height; if (view != null) { view.setHeight(height + "px"); view.ensureRowMeasurements(); view.movePointerTo(view.selectedRow, true); } } 
<|startcomment|> @Nullable <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.query.change; public interface ConflictsCache { public void put(ConflictKey key, Boolean value); <|startfocus|> public Boolean get(ConflictKey key); <|endfocus|> } 
<|startcomment|> final? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.replication; import com.google.gerrit.server.events.ChangeEvent; import com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult; public class RefReplicatedEvent extends ChangeEvent { public final String type = "ref-replicated"; <|startfocus|> public String project; public String ref; public String targetNode; public String status; <|endfocus|> public RefReplicatedEvent(String project, String ref, String targetNode, RefPushResult status) { this.project = project; this.ref = ref; this.targetNode = targetNode; this.status = toStatusString(status); } private String toStatusString(RefPushResult status) { return status.name().toLowerCase().replace("_", "-"); } } 
<|startcomment|> Widen to Collection<Ref>? <|endcomment|>  Set<Ref> allRefs) { List<String> refNames = new ArrayList<String>(); for (Ref matchingRef : matchingRefs) { if (allRefs.contains(matchingRef)) { refNames.add(Repository.shortenRefName(matchingRef.getName())); } } return refNames; } /** * Parse commit of ref and store the relation between ref and commit. */ <|startfocus|> private static Map<RevCommit, Set<Ref>> parseCommits(final Repository repo, final RevWalk rw, final Set<Ref> refs) throws IOException { Map<RevCommit, Set<Ref>> result = new HashMap<RevCommit, Set<Ref>>(); <|endfocus|> for (Ref ref : refs) { final RevCommit commit; try { commit = rw.parseCommit(ref.getObjectId()); } catch (IncorrectObjectTypeException notCommit) { // Its OK for a tag reference to point to a blob or a tree, this // is common in the Linux kernel or git.git repository. // continue; } catch (MissingObjectException notHere) {
<|startcomment|> This statement becomes: --active; start(); <|endcomment|>  public void onSuccess(NativeMap<JsArray<CommentInfo>> result) { addComments(revisionNumber, result); update(revisionNumber); <|startfocus|> if (--active < 2 && !toLoad.isEmpty() && isAttached()) { start(); } <|endfocus|>
<|startcomment|> @param <T> http://stackoverflow.com/questions/2015972/is-there-a-javadoc-tag-for-documentating-generic-type-parameters <|endcomment|>  * given the same inputs if they are {@link #equals(Object)}. * <p> * Predicates should support deep inspection whenever possible, so that generic * algorithms can be written to operate against them. Predicates which contain * other predicates should override {@link #getChildren()} to return the list of * children nested within the predicate. * <|startfocus|> * {@literal @type} <T> type of object the predicate can evaluate in memory. <|endfocus|> */ public abstract class Predicate<T> { /** A predicate that matches any input, always, with no cost. */ @SuppressWarnings("unchecked") public static <T> Predicate<T> any() { return (Predicate<T>) Any.INSTANCE; } /** Combine the passed predicates into a single AND node. */ public static <T> Predicate<T> and(final Predicate<T>... that) { if (that.length == 1) { return that[0]; } return new AndPredicate<T>(that); } /** Combine the passed predicates into a single AND node. */
<|startcomment|> This does not seem to be related to the warnings described in the commit message. <|endcomment|>  package com.google.gerrit.server.index; import static com.google.common.base.Preconditions.checkArgument; import com.google.common.collect.ImmutableMap; import com.google.common.collect.Iterables; import com.google.common.collect.Maps; import com.google.gerrit.server.query.change.ChangeData; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.lang.reflect.ParameterizedType; import java.util.Arrays; import java.util.Collection; import java.util.Map; /** Secondary index schemas for changes. */ public class ChangeSchemas { <|startfocus|> @SuppressWarnings({"deprecation"}) <|endfocus|> static final Schema<ChangeData> V1 = release( ChangeField.LEGACY_ID, ChangeField.ID, ChangeField.STATUS, ChangeField.PROJECT, ChangeField.REF, ChangeField.TOPIC, ChangeField.UPDATED, ChangeField.LEGACY_SORTKEY, ChangeField.FILE, ChangeField.OWNER, ChangeField.REVIEWER, ChangeField.COMMIT, ChangeField.TR, ChangeField.LABEL, ChangeField.REVIEWED, ChangeField.COMMIT_MESSAGE, ChangeField.COMMENT); @SuppressWarnings({"deprecation"}) static final Schema<ChangeData> V2 = release( ChangeField.LEGACY_ID, ChangeField.ID, ChangeField.STATUS,
<|startcomment|> There shouldn't be a global cpability for creating branches. Whether branch creation is allowed is controlled on project level by the 'Create Reference' access right. <|endcomment|>  */ public static final String ADMINISTRATE_SERVER = "administrateServer"; /** Can create any account on the server. */ public static final String CREATE_ACCOUNT = "createAccount"; /** Can create any group on the server. */ public static final String CREATE_GROUP = "createGroup"; /** Can create any project on the server. */ public static final String CREATE_PROJECT = "createProject"; <|startfocus|> /** Can create any branch on the server. */ public static final String CREATE_BRANCH = "createBranch"; <|endfocus|> /** * Denotes who may email change reviewers and watchers. * <p> * This can be used to deny build bots from emailing reviewers and people who * watch the change. Instead, only the authors of the change and those who * starred it will be emailed. The allow rules are evaluated before deny * rules, however the default is to allow emailing, if no explicit rule is * matched. */ public static final String EMAIL_REVIEWERS = "emailReviewers"; 
<|startcomment|> s/update/updateAsync <|endcomment|>  throws Exception { if (!indexUpdated) { return (ListenableFuture<Object>) indexer.indexAsync(change); } return Futures.immediateFuture(null); } }), MAPPER); } public boolean update(Change change) throws IOException { try { return new ChangeUpdateTask(schemaFactory, change).call(); } catch (RuntimeException e) { throw e; <|startfocus|> } catch (Exception e) { <|endfocus|> throw MAPPER.apply(e); } } private class ChangeUpdateTask implements Callable<Boolean> { private final SchemaFactory<ReviewDb> schemaFactory; private final Change change; private ReviewDb reviewDb; ChangeUpdateTask(SchemaFactory<ReviewDb> schemaFactory, Change change) { this.schemaFactory = schemaFactory; this.change = change; } @Override public Boolean call() throws Exception { RequestContext context = new RequestContext() { @Override public CurrentUser getCurrentUser() { return identifiedUserFactory.create(change.getOwner()); } @Override public Provider<ReviewDb> getReviewDbProvider() { return new Provider<ReviewDb>() { @Override
<|startcomment|> We don't use assert much. Where we do, we omit parens: assert psId.isEdit; In places where we want the code to fail if its being called wrong we overwhelmingly prefer actual exceptions over asserts. The rationale is, if its worth checking an argument or state to detect a logic bug, we should always be doing that, not just when the jvm was run with -ea. <|endcomment|>  public RevisionEdit(IdentifiedUser user, PatchSet.Id psid) { <|startfocus|> assert(psid.isEdit()); <|endfocus|> this.user = user; this.psid = psid;
<|startcomment|> com.google.gerrit.server.auth.ldap.Helper also reads ldap.password from secure.config. You should patch that in this change. AuthConfig reads auth.restTokenPrivateKey and auth.registerEmailPrivateKey from secure.config. These should also be using secure store. <|endcomment|>  String driver = dbs.optional("driver"); if (Strings.isNullOrEmpty(driver)) { driver = dst.getDriver(); } String url = dbs.optional("url"); if (Strings.isNullOrEmpty(url)) { url = dst.getUrl(); } String username = dbs.optional("username"); <|startfocus|> String password = dbs.optional("password"); <|endfocus|> String interceptor = dbs.optional("dataSourceInterceptorClass"); boolean usePool; if (context == Context.SINGLE_USER) { usePool = false; } else { usePool = cfg.getBoolean("database", "connectionpool", dst.usePool()); } if (usePool) { final BasicDataSource ds = new BasicDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); if (username != null && !username.isEmpty()) { ds.setUsername(username); } if (password != null && !password.isEmpty()) { ds.setPassword(password); } ds.setMaxActive(cfg.getInt("database", "poollimit", DEFAULT_POOL_LIMIT));
<|startcomment|> checkNotNull(stream); <|endcomment|>  HttpPut put = new HttpPut(url + "/a" + endPoint); if (content != null) { put.addHeader(new BasicHeader("Content-Type", "application/json")); put.setEntity(new StringEntity( new Gson().toJson(content), Charsets.UTF_8.name())); } return new RestResponse(getClient().execute(put)); } public RestResponse putRaw(String endPoint, RawInput stream) throws IOException { <|startfocus|> Preconditions.checkArgument(stream != null); <|endfocus|> HttpPut put = new HttpPut(url + "/a" + endPoint); put.addHeader(new BasicHeader("Content-Type", "application/octet-stream")); put.setEntity(new BufferedHttpEntity( new InputStreamEntity( stream.getInputStream(), stream.getContentLength()))); return new RestResponse(getClient().execute(put)); } public RestResponse post(String endPoint) throws IOException { return post(endPoint, null); } public RestResponse post(String endPoint, Object content) throws IOException { HttpPost post = new HttpPost(url + "/a" + endPoint);
<|startcomment|> Index will build with stale data. <|endcomment|>  throws OrmException, IOException { ReviewDb db = dbProvider.get(); ChangeUpdate update = updateFactory.create(rsrc.getControl()); List<PatchSetApproval> added; db.changes().beginTransaction(rsrc.getChange().getId()); try { ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db); added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet()); db.commit(); } finally { db.rollback(); <|startfocus|> } <|endfocus|> update.commit(); CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(rsrc.getChange().getId()); result.reviewers = Lists.newArrayListWithCapacity(added.size()); for (PatchSetApproval psa : added) { // New reviewers have value 0, don't bother normalizing. result.reviewers.add(json.format( new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa))); } accountLoaderFactory.create(true).fill(result.reviewers); indexFuture.checkedGet();
<|startcomment|> Why is this needed? <|endcomment|>  log.warn(String.format( "Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.name)); continue; } if (v.value == null) { cfg.unset(v.name); } else { cfg.setString(v.name, v.value); } } else { throw new BadRequestException(String.format( <|startfocus|> "The config paramter '%s' of plugin '%s' does not exist.", v.name, pluginName)); <|endfocus|> } } } } private static boolean isValidParameterName(String name) { return CharMatcher.JAVA_LETTER_OR_DIGIT .or(CharMatcher.is('-')) .matchesAllOf(name) && !name.startsWith("-"); } } 
<|startcomment|> Nit: in other files this is named `log` in lower case. <|endcomment|> import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.WorkQueue; import com.google.gwtorm.server.SchemaFactory; import com.google.inject.Inject; import com.google.inject.Injector; import com.google.inject.Singleton; import com.googlesource.gerrit.plugins.replication.RemoteSiteUser; import org.eclipse.jgit.errors.ConfigInvalidException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.util.List; @Singleton public class AutoReloadConfigDecorator implements ReplicationConfig { <|startfocus|> private static final Logger LOG = LoggerFactory <|endfocus|> .getLogger(AutoReloadConfigDecorator.class); private ReplicationFileBasedConfig currentConfig; private long currentConfigTs; private final Injector injector; private final SitePaths site; private final RemoteSiteUser.Factory remoteSiteUserFactory; private final PluginUser pluginUser; private final SchemaFactory<ReviewDb> db; private final GitRepositoryManager gitRepositoryManager; private final GroupBackend groupBackend; private final WorkQueue workQueue; @Inject public AutoReloadConfigDecorator(Injector injector, SitePaths site, RemoteSiteUser.Factory ruf, PluginUser pu, SchemaFactory<ReviewDb> db,
<|startcomment|> String url = selfRedirect(item.getUrl()); <|endcomment|>  public void onScreenLoad(ScreenLoadEvent event) { Screen screen = event.getScreen(); Project.NameKey projectKey; if (screen instanceof ProjectScreen) { projectKey = ((ProjectScreen)screen).getProjectKey(); } else { projectKey = ProjectScreen.getSavedKey(); } <|startfocus|> if (projectKey != null) { setVisible(true); setTargetHistoryToken(Dispatcher.toProjectAdmin(projectKey, panel)); } else { setVisible(false); } super.onScreenLoad(event); <|endfocus|>
<|startcomment|> static <|endcomment|>  String host = sshInfo.getHostKeys().get(0).getHost(); int c = host.lastIndexOf(':'); if (0 <= c) { sshHost = host.substring(0, c); sshPort = Integer.parseInt(host.substring(c+1)); } else { sshHost = host; sshPort = SshAddressesModule.IANA_SSH_PORT; } } this.sshHost = sshHost; this.sshPort = sshPort; } <|startfocus|> private Policy loadPolicy(SitePaths sitePaths, Config cfg) <|endfocus|> throws PolicyException { AntiSamyPolicy policy = cfg.getEnum("site", null, "antiSamyPolicy", AntiSamyPolicy.MODEST); return AntiSamyPolicy.CUSTOM.equals(policy) ? Policy.getInstance(new File(sitePaths.etc_dir, "antisamy.xml")) : Policy.getInstance(getClass().getResourceAsStream( "antisamy-" + policy.name().toLowerCase() + ".xml")); } @Override public Resource load(ProjectDocResourceKey key) throws Exception { Repository repo = repoManager.openRepository(key.getProject()); try { RevWalk rw = new RevWalk(repo);
<|startcomment|> nit: space before { <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gitiles; import org.eclipse.jgit.lib.Config; /** Serves an HTML page with blame data for a commit. */ <|startfocus|> public class BlameServlet extends BaseServlet{ <|endfocus|> private static final long serialVersionUID = 1L; public BlameServlet(Config cfg, Renderer renderer) { super(cfg, renderer); } } 
<|startcomment|> Do we need this prefix? <|endcomment|>  this.gitManager = gitManager; this.myIdent = myIdent; this.userProvider = userProvider; this.commitValidatorsFactory = commitValidatorsFactory; this.changeInserterFactory = changeInserterFactory; } @Override public Response<String> apply(ProjectResource rsrc, Input input) throws AuthException, OrmException, InvalidChangeOperationException, IOException { String ref = input.ref; String msg = input.msg; if (Strings.isNullOrEmpty(ref)) { throw new InvalidChangeOperationException( <|startfocus|> "Change baker: Destination branch cannot be null or empty"); <|endfocus|> } if (Strings.isNullOrEmpty(msg)) { throw new InvalidChangeOperationException( "Change baker: Commit message cannot be null or empty"); } if (!userProvider.get().isIdentifiedUser()) { throw new AuthException("User must be authenticated to create a change"); } RefControl refControl = rsrc.getControl().controlForRef(ref); if (!refControl.canUpload()) { throw new AuthException(String.format( "Not allowed to create a change to %s", ref)); } 
<|startcomment|> You see, that what I meant in comment in JettyServer.java in previous ps. In one place you added final, in another you have not, even though final presents on Config config here. Suggestion: be consistent and don't add new finals that not needed in all places. <|endcomment|>  private final Cache<String, ImmutableSet<String>> groupsByInclude; private final Config config; private final String server; private final String username; private final String password; private final String referral; private final boolean sslVerify; private final String authentication; private volatile LdapSchema ldapSchema; private final String readTimeOutMillis; @Inject Helper(@GerritServerConfig final Config config, @Named(LdapModule.GROUPS_BYINCLUDE_CACHE) Cache<String, ImmutableSet<String>> groupsByInclude, <|startfocus|> Provider<SecureStore> secureStoreProvider) { <|endfocus|> this.config = config; this.server = LdapRealm.optional(config, "server"); this.username = LdapRealm.optional(config, "username"); this.password = secureStoreProvider.get().get("ldap", null, "password"); this.referral = LdapRealm.optional(config, "referral"); this.sslVerify = config.getBoolean("ldap", "sslverify", true); this.authentication = LdapRealm.optional(config, "authentication"); String timeout = LdapRealm.optional(config, "readTimeout"); if (timeout != null) { readTimeOutMillis = Long.toString(ConfigUtil.getTimeUnit(timeout, 0,
<|startcomment|> Maybe changes.length()? Although that should exactly equal pageSize and if it doesn't _more_changes really better be false. <|endcomment|>  protected void display(ChangeList result) { changes = result; if (changes.length() != 0) { if (start > 0) { int p = Math.max(start - pageSize, 0); prev.setTargetHistoryToken(anchorPrefix + (p > 0 ? "," + p : "")); prev.setVisible(true); } else { prev.setVisible(false); } <|startfocus|> next.setTargetHistoryToken(anchorPrefix + "," + (start + pageSize)); <|endfocus|> next.setVisible(changes.get(changes.length() - 1)._more_changes()); } table.updateColumnsForLabels(result); section.display(result); table.finishDisplay();
<|startcomment|> diffChange <|endcomment|>  return (ChangeScreen2) l; } } return null; } private final Change.Id changeId; private String base; private String base1; private String revision; private ChangeInfo changeInfo; private CommentLinkProcessor commentLinkProcessor; private KeyCommandSet keysNavigation; private KeyCommandSet keysAction; private List<HandlerRegistration> handlers = new ArrayList<>(4); private UpdateCheckTimer updateCheck; private Timestamp lastDisplayedUpdate; private UpdateAvailableBar updateAvailable; private boolean openReplyBox; private boolean loaded; <|startfocus|> private boolean diffchange; <|endfocus|> private String panel; @UiField HTMLPanel headerLine; @UiField Style style; @UiField ToggleButton star; @UiField Anchor permalink; @UiField Element ccText; @UiField Reviewers reviewers; @UiField Element ownerText; @UiField Element statusText; @UiField Image projectQuery; @UiField InlineHyperlink projectLink; @UiField InlineHyperlink branchLink; @UiField Element strategy; @UiField Element submitActionText; @UiField Element notMergeable; @UiField Topic topic; @UiField Element actionText; @UiField Element actionDate; 
<|startcomment|> display <|endcomment|>  List<Plugin> plugins = Lists.newArrayList(pluginLoader.getPlugins(all)); Collections.sort(plugins, new Comparator<Plugin>() { @Override public int compare(Plugin a, Plugin b) { return a.getName().compareTo(b.getName()); } }); if (!format.isJson()) { stdout.format("%-30s %-10s %-8s %s\n", "Name", "Version", "Status", "File"); stdout.print("-------------------------------------------------------------------------------\n"); } for (Plugin p : plugins) { <|startfocus|> PluginInfo info = new PluginInfo(p); <|endfocus|> if (format.isJson()) { output.put(p.getName(), info); } else { stdout.format("%-30s %-10s %-8s %s\n", p.getName(), Strings.nullToEmpty(info.version), p.isDisabled() ? "DISABLED" : "ENABLED", p.getSrcFile().getName()); } } if (stdout == null) { return OutputFormat.JSON.newGson().toJsonTree( output,
<|startcomment|> It should be simpler to just write the edges in the other direction into the DAG. Create the edge from the parent to the child. Then the standard topological sorting will produce the parent first, which is the startup ordering. <|endcomment|>  private DependencyResolver() {} // Topological ordering of a directed graph is a linear ordering // of its vertices such that for every directed edge uv from vertex // u to vertex v, u comes before v in the ordering. // In plugin domain however, plugin src depends on plugin dest // means that plugin dest must be loaded before plugin src. // We preserve the edge direction during the DAG construction // and reverse the resulting ordering to get the right sorting. <|startfocus|> static List<Dependency> sort(Map<String, File> activePlugins) { <|endfocus|> return reverseTopologicalSort(Lists.newArrayList(Iterables.transform( activePlugins.values(), new Function<File, Dependency>() { @Override public Dependency apply(File f) { String n; String deps; try { n = Objects.firstNonNull(PluginLoader.getGerritPluginName(f), PluginLoader.nameOf(f)); deps = Strings.nullToEmpty(getDependencies(f)); } catch (IOException e) { log.error(String.format("Cannot read manifest for plugin: %s", f));
<|startcomment|> We should null out the other injectors too, even if the class does not currently create them. You have setter methods that subclasses can use to set the fields. During stop we null out the httpInjector, so lets null the others. <|endcomment|>  protected void stop(PluginGuiceEnvironment env) { if (manager != null) { manager.stop(); <|startfocus|> httpInjector = null; <|endfocus|> }
<|startcomment|> remote plugin administration <|endcomment|>  import java.util.List; @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) @CommandMetaData(name = "reload", description = "Reload/Restart plugins", runsAt = MASTER_OR_SLAVE) final class PluginReloadCommand extends SshCommand { @Argument(index = 0, metaVar = "NAME", usage = "plugins to reload/restart") private List<String> names; @Inject private PluginLoader loader; @Override protected void run() throws UnloggedFailure { if (!loader.isRemoteAdminEnabled()) { <|startfocus|> throw die("remote installation is disabled"); <|endfocus|> } if (names == null || names.isEmpty()) { loader.rescan(); } else { try { loader.reload(names); } catch (InvalidPluginException e) { throw die(e.getMessage()); } catch (PluginInstallException e) { throw die(e.getMessage()); } } } } 
<|startcomment|> same here: @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER, scope = CapabilityScope.CORE) <|endcomment|> // WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE // OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN // IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. package com.googlesource.gerrit.plugins.multimaster.commands; import com.google.gerrit.common.data.GlobalCapability; import com.google.gerrit.extensions.annotations.RequiresCapability; import com.google.gerrit.sshd.CommandMetaData; import com.google.gerrit.sshd.SshCommand; import com.google.inject.Inject; import com.googlesource.gerrit.plugins.multimaster.StateManager; <|startfocus|> @RequiresCapability(GlobalCapability.ADMINISTRATE_SERVER) @CommandMetaData(name = "degrade", descr = "Enable DEGRADED mode") <|endfocus|> public class EnableDegradedMode extends SshCommand { @Inject StateManager stateManager; @Override protected void run() { stateManager.disableAutoMode(); } } 
<|startcomment|> Non-refactoring change <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.acceptance.api.project; import com.google.gerrit.acceptance.AbstractDaemonTest; import com.google.gerrit.acceptance.NoHttpd; import com.google.gerrit.extensions.api.projects.BranchInput; import com.google.gerrit.extensions.restapi.RestApiException; import org.junit.Test; @NoHttpd public class ProjectIT extends AbstractDaemonTest { @Test <|startfocus|> public void createBranch() throws RestApiException { <|endfocus|> gApi.projects() .name(project.get()) .branch("foo") .create(new BranchInput()); } } 
<|startcomment|> nit: unnecessary blank line <|endcomment|>  @Override public String get(String section, String subsection, String name) { String value = impl.get(section, subsection, name); // ensure that property is always encrypted impl.set(section, subsection, name, value); return value; } @Override public void set(String section, String subsection, String name, String value) { impl.set(section, subsection, name, value); } @Override public void unset(String section, String subsection, String name) { impl.unset(section, subsection, name); } <|startfocus|> <|endfocus|> } } 
<|startcomment|> SendEmailsExecutor <|endcomment|>  List<PatchLineComment> comments); } private final Executor sendEmailsExecutor; private final PatchSetInfoFactory patchSetInfoFactory; private final CommentSender.Factory commentSenderFactory; private final SchemaFactory<ReviewDb> schemaFactory; private final ThreadLocalRequestContext requestContext; private final PostReview.NotifyHandling notify; private final Change change; private final PatchSet patchSet; private final Account.Id authorId; private final ChangeMessage message; private List<PatchLineComment> comments; private ReviewDb db; @Inject EmailReviewComments ( <|startfocus|> @ReceiveCommitsExecutor final Executor executor, <|endfocus|> PatchSetInfoFactory patchSetInfoFactory, CommentSender.Factory commentSenderFactory, SchemaFactory<ReviewDb> schemaFactory, ThreadLocalRequestContext requestContext, @Assisted NotifyHandling notify, @Assisted Change change, @Assisted PatchSet patchSet, @Assisted Account.Id authorId, @Assisted ChangeMessage message, @Assisted List<PatchLineComment> comments) { this.sendEmailsExecutor = executor; this.patchSetInfoFactory = patchSetInfoFactory; this.commentSenderFactory = commentSenderFactory; this.schemaFactory = schemaFactory; this.requestContext = requestContext; this.notify = notify;
<|startcomment|> You need to add a default field LabelInfo in both: gerrit-server/src/main/jcg/gerrit/server/change/ChangeJson.java gerrit-gwtui/src/main/jcg/gerrit/client/changes/ChangeInfo.java (and also the relevant REST API docs). Modify ChangeJson to populate the value, then you will have it here as lv.info.default. <|endcomment|>  ? lv.info.for_user(Gerrit.getUserAccount().getId().get()) : null; final LabelRadioGroup group = new LabelRadioGroup(row, id, lv.permitted.size()); for (int i = 0; i < columns.size(); i++) { Short v = columns.get(i); if (lv.permitted.contains(v)) { String text = lv.info.value_text(LabelValue.formatValue(v)); LabelRadioButton b = new LabelRadioButton(group, text, v); <|startfocus|> // set default label value if ((self != null && v == self.value()) || (self == null && v == 0)) { <|endfocus|> b.setValue(true); group.select(b); labelsTable.setText(row, labelHelpColumn, b.text); } group.buttons.add(b); labelsTable.setWidget(row, 1 + i, b); } } if (CODE_REVIEW.equalsIgnoreCase(id) && !group.buttons.isEmpty()) { lgtm = new Runnable() { @Override public void run() { group.selectMax(); } }; }
<|startcomment|> Unnecessary blank line <|endcomment|>  select(); } void select() { group.select(this); in.label(group.label, value); } @Override public void onMouseOver(MouseOverEvent event) { labelsTable.setText(group.row, labelHelpColumn, text); } @Override public void onMouseOut(MouseOutEvent event) { LabelRadioButton b = group.selected; String s = b != null && b.value != 0 ? b.text : ""; labelsTable.setText(group.row, labelHelpColumn, s); } } <|startfocus|> <|endfocus|> } 
<|startcomment|> why public? most of injectable constructor o in gerrit are package protected <|endcomment|> <|startfocus|> public UniversalServerPluginProvider(DynamicSet<ServerPluginProvider> sf) { <|endfocus|> this.serverPluginProviders = sf;
<|startcomment|> unused import <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.project; import com.google.common.base.Preconditions; import com.google.common.base.Strings; import com.google.gerrit.extensions.api.projects.CreateChangeInput; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.Response; import com.google.gerrit.extensions.restapi.RestModifyView; <|startfocus|> import com.google.gerrit.extensions.webui.UiAction; <|endfocus|> import com.google.gerrit.reviewdb.client.Branch; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.Change.Id; import com.google.gerrit.reviewdb.client.PatchSet; import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.GerritPersonIdent; import com.google.gerrit.server.IdentifiedUser; import com.google.gerrit.server.change.ChangeInserter; import com.google.gerrit.server.change.ChangeJson; import com.google.gerrit.server.events.CommitReceivedEvent; import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.MergeUtil;
<|startcomment|> I think we should put a Logger in this class and report in this method (with debug or info level) which secure store implementation was picked up. <|endcomment|> <|startfocus|> public DynamicItem<SecureStore> get() { <|endfocus|> String secureStore = getCurrentSecureStoreName(); if (DefaultSecureStore.NAME.equals(secureStore)) { return DynamicItem.<SecureStore> of(defaultSecureStore); } int separatorPosition = secureStore.lastIndexOf("/"); if (separatorPosition < 0) { throw new SecureStoreException(String.format( "Unsupported secure store format %s." + "Proper format is: $plugin_name/$secure_store_name", secureStore)); } String storeName = secureStore.substring(separatorPosition + 1); String pluginName = secureStore.substring(0, separatorPosition); Set<SecureStoreData> stores = getSecureStores(pluginName); for (SecureStoreData store : stores) { if (store.getStoreName().equals(secureStore)) { Class<? extends SecureStore> secureStoreImpl = store.load(); return DynamicItem.<SecureStore> of(new SecureStoreWrapper(injector .getInstance(secureStoreImpl))); } } throw new SecureStoreException(String.format( "Cannot find secure store with name %s in plugin %s", storeName, pluginName));
<|startcomment|> This is going to be null. I think we may still have some older messages with no PatchSet.Id stored, etc. Lets not fail hard and instead just auto-include them. if (ps == null || ctl.isPatchVisible(ps, db.get()) <|endcomment|>  // label. value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null; } tag = psa.getTag(); date = psa.getGranted(); } else { // Either the user cannot vote on this label, or they were added as a // reviewer but have not responded yet. Explicitly check whether the // user can vote on this label. <|startfocus|> value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null; <|endfocus|> } addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date)); } } } private Timestamp getSubmittedOn(ChangeData cd) throws OrmException { Optional<PatchSetApproval> s = cd.getSubmitApproval(); return s.isPresent() ? s.get().getGranted() : null; } private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException { Set<Account.Id> allUsers = new HashSet<>(); if (detailed) {
<|startcomment|> I would rather not use /new here, I would prefer to PUT to /changes/. Unfortunately I think that means we have to make some changes to RestApiServlet ~ line 215 to permit AcceptsCreate when path is empty and method is PUT. This is like the AcceptsPost on line 211. Of course this is exactly what the AcceptsPost interface was created to handle. POST /changes/ to make a change not PUT /changes/{id} I hate that we keep kicking this simple change around, but its part of our public API and will become hard to change once its in. So I am really trying to "get it right" when the feature lands. <|endcomment|>  } } // Try change triplet ChangeTriplet triplet; try { triplet = new ChangeTriplet(id); } catch (ChangeTriplet.ParseException e) { throw new ResourceNotFoundException(id); } return db.get().changes().byBranchKey( triplet.getBranchNameKey(), triplet.getChangeKey()).toList(); } @SuppressWarnings("unchecked") @Override <|startfocus|> public CreateChange create( TopLevelResource parent, IdString id) throws RestApiException { if (!id.equals("new")) { throw new ResourceNotFoundException(id); } <|endfocus|> return createChangeFactory.create(); } } 
<|startcomment|> replace with: return true; This line could also be moved up, between the lines 187-188 <|endcomment|>  for (Ref branch : branches) { if (branch.getObjectId() != targetRef.getObjectId()) { rw.markUninteresting(rw.parseCommit(branch.getObjectId())); } } for (RevCommit n; (n = rw.next()) != null;) { if (n.equals(mergeBase)) { // targetRef reached commitBranchFlag = false; break; } } } finally { rw.release(); } } finally { git.close(); } <|startfocus|> return commitBranchFlag; <|endfocus|> } } 
<|startcomment|> why static? <|endcomment|> import org.eclipse.jgit.revwalk.RevWalk; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; public class GetRelated implements RestReadView<RevisionResource> { private static final Logger log = LoggerFactory.getLogger(GetRelated.class); private static GitRepositoryManager gitMgr; private final Provider<ReviewDb> dbProvider; <|startfocus|> private static Change change; <|endfocus|> @Inject GetRelated(GitRepositoryManager gitMgr, Provider<ReviewDb> db) { GetRelated.gitMgr = gitMgr; this.dbProvider = db; } @Override public RelatedInfo apply(RevisionResource rsrc) throws RepositoryNotFoundException, IOException, OrmException { Repository git = gitMgr.openRepository(rsrc.getChange().getProject()); try { Ref ref = git.getRef(rsrc.getChange().getDest().get()); RevWalk rw = new RevWalk(git); try { RelatedInfo info = new RelatedInfo();
<|startcomment|> Move this around line 104, where it is used? <|endcomment|>  private final Provider<CurrentUser> currentUserProvider; private final Provider<GetPreferences> getPreferences; private final GerritConstantsProperties constProps; @Inject GerritTopMenus(Provider<CurrentUser> cup, Provider<GetPreferences> gp, GerritConstantsProperties gcp) throws IOException { currentUserProvider = cup; constProps = gcp; getPreferences = gp; } Collection<TopMenu.MenuEntry> getTopMenuBar(boolean populateMyMenu, Project.NameKey projectNameKey) { CurrentUser currentUser = currentUserProvider.get(); <|startfocus|> CapabilityControl capabilities = currentUser.getCapabilities(); <|endfocus|> boolean signedIn = currentUser.isIdentifiedUser(); Collection<TopMenu.MenuEntry> topMenu = Lists.newArrayList(); topMenu.add(menu(GerritTopMenu.ALL, subMenu("menuAllOpen", changeQuery("status:open")), subMenu("menuAllMerged", changeQuery("status:merged")), subMenu("menuAllAbandoned", changeQuery("status:abandoned")))); if (signedIn) { topMenu.add(menu(GerritTopMenu.MY, getMySubMenu((IdentifiedUser) currentUser))); } List<MenuItem> projectsMenuItems = Lists.newArrayList();
<|startcomment|> unneeded parentheses? <|endcomment|>  ContextMapper classUnderTest = new ContextMapper(CONTEXT); HttpServletRequest originalRequest = createMockRequest("/plugins/", PLUGIN_NAME + "/" + RESOURCE); HttpServletRequest result = classUnderTest.create(originalRequest, PLUGIN_NAME); assertEquals(CONTEXT + "/plugins/" + PLUGIN_NAME, result.getContextPath()); assertEquals("", result.getServletPath()); assertEquals("/" + RESOURCE, result.getPathInfo()); <|startfocus|> assertEquals(CONTEXT + "/plugins/" + (PLUGIN_NAME + "/" + RESOURCE), <|endfocus|> result.getRequestURI()); } @Test public void testAuthorized() throws Exception { ContextMapper classUnderTest = new ContextMapper(CONTEXT); HttpServletRequest originalRequest = createMockRequest("/a/plugins/", PLUGIN_NAME + "/" + RESOURCE); HttpServletRequest result = classUnderTest.create(originalRequest, PLUGIN_NAME); assertEquals(CONTEXT + "/a/plugins/" + PLUGIN_NAME, result.getContextPath()); assertEquals("", result.getServletPath()); assertEquals("/" + RESOURCE, result.getPathInfo());
<|startcomment|> In second thought this and other tests are not complete and should respect major file change types: public static enum ChangeType implements CodedEnum { /** Path is being created/introduced by this patch. */ ADDED('A'), /** Path already exists, and has updated content. */ MODIFIED('M'), /** Path existed, but is being removed by this patch. */ DELETED('D'), /** Path existed at {@link Patch#getSourceFileName()} but was moved. */ RENAMED('R'), [...] <|endcomment|> import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.lib.StoredConfig; import org.eclipse.jgit.revwalk.RevCommit; import org.junit.Test; @NoHttpd public class PatchListCacheIT extends AbstractDaemonTest { private static String SUBJECT_1 = "subject 1"; private static String SUBJECT_2 = "subject 2"; private static String SUBJECT_3 = "subject 3"; private static String FILE_A = "a.txt"; private static String FILE_B = "b.txt"; private static String FILE_C = "c.txt"; private static String FILE_D = "d.txt"; <|startfocus|> @Inject private PatchListCache patchListCache; @Inject private GitRepositoryManager repositoryManager; <|endfocus|> @Test public void listPatchesAgainstBase() throws Exception { commitBuilder().add(FILE_D, "4").message(SUBJECT_1).create(); pushHead(testRepo, "refs/heads/master", false); // Change 1, 1 (+FILE_A, -FILE_D) RevCommit c = commitBuilder().add(FILE_A, "1").rm(FILE_D).message(SUBJECT_2).insertChangeId().create();
<|startcomment|> Add a javadoc or comment here and below specifying that these endpoints are inclusive. <|endcomment|>  @Override public boolean match(T object) throws OrmException { int valueInt = getValueInt(object); switch (relation) { case LESS_THAN: return queryInt < valueInt; case LESS_THAN_OR_EQUAL: return queryInt <= valueInt; case GREATER_THAN: return queryInt > valueInt; case GREATER_THAN_OR_EQUAL: return queryInt >= valueInt; case EQUAL: return queryInt == valueInt; default: throw new IllegalStateException("Unknown relation " + relation); } } <|startfocus|> <|endfocus|> public int getMinimumValue() { switch (relation) { case LESS_THAN: case LESS_THAN_OR_EQUAL: return Integer.MIN_VALUE; case GREATER_THAN_OR_EQUAL: case EQUAL: return queryInt; case GREATER_THAN: if (queryInt == Integer.MAX_VALUE) { return queryInt; } else { return queryInt + 1; } default: throw new IllegalStateException("Unknown relation " + relation); } } public int getMaximumValue() { switch (relation) { case GREATER_THAN:
<|startcomment|> Consider to make it singleton. <|endcomment|> // limitations under the License. package com.google.gerrit.server.config; import com.google.gerrit.common.data.GlobalCapability; import com.google.gerrit.extensions.annotations.RequiresCapability; import com.google.gerrit.extensions.registration.DynamicMap; import com.google.gerrit.extensions.restapi.ChildCollection; import com.google.gerrit.extensions.restapi.IdString; import com.google.gerrit.extensions.restapi.ResourceNotFoundException; import com.google.gerrit.extensions.restapi.RestView; import com.google.inject.Inject; import com.google.inject.Provider; <|startfocus|> @RequiresCapability(GlobalCapability.VIEW_CACHES) <|endfocus|> public class CachesCollection implements ChildCollection<ConfigResource, CacheResource> { private final DynamicMap<RestView<CacheResource>> views; private final Provider<ListCaches> list; @Inject CachesCollection(DynamicMap<RestView<CacheResource>> views, Provider<ListCaches> list) { this.views = views; this.list = list; } @Override public RestView<ConfigResource> list() { return list.get(); } @Override public CacheResource parse(ConfigResource parent, IdString id) throws ResourceNotFoundException { throw new ResourceNotFoundException(id); } @Override
<|startcomment|> Apache-commons? We are guava funs, not? Joiner.on('\n').join(cacheNames); <|endcomment|>  // plugin caches for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) { if (!"gerrit".equals(e.getPluginName())) { m.put(cacheNameOf(e.getPluginName(), e.getExportName()), e.getProvider().get()); } } return m; } private static String cacheNameOf(String plugin, String name) { if ("gerrit".equals(plugin)) { return name; } else { <|startfocus|> return plugin + "-" + name; <|endfocus|> } } public enum CacheType { MEM, DISK; } public static class CacheInfo { public String name; public CacheType type; public EntriesInfo entries; public String averageGet; public HitRationInfo hitRatio; public CacheInfo(Cache<?,?> cache) { CacheStats stat = cache.stats(); entries = new EntriesInfo(); entries.setMem(cache.size()); averageGet = duration(stat.averageLoadPenalty()); hitRatio = new HitRationInfo(); hitRatio.setMem(stat.hitCount(), stat.requestCount()); 
<|startcomment|> If this is what's used on gerrithub.io, that doesn't look secure: the me() is the same for me between different browsers. You'll want to generate a cryptographically-secure random and store it in a cookie. See http://tools.ietf.org/html/rfc6819#section-3.6 for the related threat. It's not a serious threat in the context of Gerrit I believe (allows an attacker to log you in with his own account; the main risk is when the victim will later enter credit card number or link account to Paypal, etc.), which is why I disclose it here publicly. <|endcomment|>  Provider<HttpClient> httpClientProvider, Gson gson) { this.config = config; this.http = httpClientProvider.get(); this.gson = gson; } public void loginPhase1(HttpServletRequest request, HttpServletResponse response) throws IOException { LOG.debug("Initiating GitHub Login for ClientId=" + config.gitHubClientId); response.sendRedirect(String.format( <|startfocus|> "%s?client_id=%s%s&redirect_uri=%s&state=%s%s", config.gitHubOAuthUrl, config.gitHubClientId, "", getURLEncoded(config.oAuthFinalRedirectUrl), <|endfocus|> me(), getURLEncoded(request.getRequestURI().toString()))); } public static boolean isOAuthFinal(HttpServletRequest request) { return Strings.emptyToNull(request.getParameter("code")) != null; } public String me() { return "" + hashCode() + ME_SEPARATOR; } public static boolean isOAuthLogin(HttpServletRequest request) { return request.getRequestURI().indexOf(GitHubOAuthConfig.OAUTH_LOGIN) >= 0; } public boolean isOAuthRequest(HttpServletRequest httpRequest) { return OAuthProtocol.isOAuthLogin(httpRequest)
<|startcomment|> The appropriate way to do that is per configuration and not per commenting out the code. In very big organization (big open source projects) there are too many administrators, and i afraid, that such organization may also want that feature. And no, to fork Gerrit is not really an option there. That why i would suggest to introduce new configuration option: cache.remoteConfiguration: allow to configure caches remotely. and may be even disable it per default. <|endcomment|>  modules.add(new WorkQueue.Module()); modules.add(new ChangeHookRunner.Module()); modules.add(new ReceiveCommitsExecutorModule()); modules.add(new MergeabilityChecksExecutorModule()); modules.add(new IntraLineWorkerPool.Module()); modules.add(cfgInjector.getInstance(GerritGlobalModule.class)); modules.add(new InternalAccountDirectory.Module()); modules.add(new DefaultCacheFactory.Module()); modules.add(new SmtpEmailSender.Module()); modules.add(new SignedTokenEmailTokenVerifier.Module()); modules.add(new PluginRestApiModule()); <|startfocus|> modules.add(new RemoteCacheAdminModule()); <|endfocus|> AbstractModule changeIndexModule; switch (IndexModule.getIndexType(cfgInjector)) { case LUCENE: changeIndexModule = new LuceneIndexModule(); break; case SOLR: changeIndexModule = new SolrIndexModule(); break; default: throw new IllegalStateException("unsupported index.type"); } modules.add(changeIndexModule); modules.add(new CanonicalWebUrlModule() { @Override protected Class<? extends Provider<String>> provider() { return HttpCanonicalWebUrlProvider.class; } }); modules.add(SshKeyCacheImpl.module());
<|startcomment|> by the convention injected constructors are package protected <|endcomment|> <|startfocus|> public JarPluginProvider(SitePaths sitePaths) { <|endfocus|> tmpDir = sitePaths.tmp_dir;
<|startcomment|> You need to keep the logic to set the author to the submitter on the message if it doesn't already have the author. I would just add update as an arg to addMergedMessage and keep that method. <|endcomment|>  if (log.isWarnEnabled()) { log.warn(submissionId + msg, t); } } private void logWarn(String msg) { if (log.isWarnEnabled()) { log.warn(submissionId + msg); } } private void logError(String msg, Throwable t) { if (log.isErrorEnabled()) { if (t != null) { log.error(submissionId + msg, t); } else { <|startfocus|> log.error(submissionId + msg); <|endfocus|> } } } private void logError(String msg) { logError(msg, null); } } 
<|startcomment|> This is somehow inconsistent with the injection of PostReceiveHooks in class Receive.java. There any plugin can add new PostReceiveHooks to the DynamicSet. I would like it more if you inject here only DynamicSet<PreUploadHook> preUploadHooks and to add the uploadValidatorsFactory to the preUploadHooks somewhere else. I think the interface PreUploadHook is the right abstraction matching the UploadPack. <|endcomment|> import com.google.gerrit.sshd.AbstractGitCommand; import com.google.gerrit.sshd.SshSession; import com.google.inject.Inject; import com.google.inject.Provider; import org.eclipse.jgit.transport.UploadPack; import java.io.IOException; /** Publishes Git repositories over SSH using the Git upload-pack protocol. */ final class Upload extends AbstractGitCommand { @Inject private Provider<ReviewDb> db; @Inject private TransferConfig config; @Inject private TagCache tagCache; @Inject private ChangeCache changeCache; <|startfocus|> @Inject <|endfocus|> private UploadValidators.Factory uploadValidatorsFactory; @Inject private SshSession session; @Override protected void runImpl() throws IOException, Failure { if (!projectControl.canRunUploadPack()) { throw new Failure(1, "fatal: upload-pack not permitted on this server"); } final UploadPack up = new UploadPack(repo); if (!projectControl.allRefsAreVisible()) { up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true)); } up.setPackConfig(config.getPackConfig());
<|startcomment|> private static and goes at the end of the file. <|endcomment|> <|startfocus|> private String dropTrailingSlash(String url) { return (url.endsWith("/") ? url.substring(0, url.length() - 1) : url); <|endfocus|>
<|startcomment|> You don't have to do it in this change, but I would not approve this until there is a real implementation of this API. I consider public methods that in practice do nothing but throw NIE harmful. <|endcomment|>  String content() throws RestApiException; /** * diff against the revision's parent version of the file */ DiffInfo diff() throws RestApiException; /** * @param diffBaseRevisionId revision id of the revision to be used as the * diff base */ DiffInfo diff(String diffBaseRevisionId) throws RestApiException; /** * A default implementation which allows source compatibility * when adding new methods to the interface. **/ public class NotImplemented implements FileApi { <|startfocus|> <|endfocus|> @Override public String content() throws RestApiException { throw new NotImplementedException(); } @Override public DiffInfo diff() throws RestApiException { throw new NotImplementedException(); } @Override public DiffInfo diff(String diffBaseRevisionId) throws RestApiException { throw new NotImplementedException(); } } } 
<|startcomment|> Just: public boolean isShowInfoInReviewCategory() { return getReviewCategoryStrategy() != ReviewCategoryStrategy.NONE; } <|endcomment|>  public boolean isShowInfoInReviewCategory() { <|startfocus|> ReviewCategoryStrategy rcs = getReviewCategoryStrategy(); if (rcs.equals(ReviewCategoryStrategy.NONE)){ return false; } return true; <|endfocus|>
<|startcomment|> Does this need to be a Provider? GetDiff is not explicitly marked @Singleton but it looks like it could be. <|endcomment|> import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.assistedinject.Assisted; import java.io.ByteArrayOutputStream; import java.io.IOException; class FileApiImpl extends FileApi.NotImplemented implements FileApi { interface Factory { FileApiImpl create(FileResource r); } private final GetContent getContent; private final Provider<GetDiff> gtDiff; private final FileResource file; @Inject FileApiImpl(GetContent getContent, <|startfocus|> Provider<GetDiff> gtDiff, <|endfocus|> @Assisted FileResource file) { this.getContent = getContent; this.gtDiff = gtDiff; this.file = file; } @Override public String content() throws RestApiException { try { BinaryResult bin = getContent.apply(file); ByteArrayOutputStream os = new ByteArrayOutputStream(); bin.writeTo(os); return new String(os.toByteArray(), Charsets.UTF_8); } catch (IOException e) { throw new RestApiException("Cannot retrieve file content", e); } } @Override
<|startcomment|> nit: the second } should go into a new line <|endcomment|>  public List<Data> getData() { return data; <|startfocus|> <|endfocus|>
<|startcomment|> Tiny nit: blank line <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and <|startfocus|> // limitations under the License. <|endfocus|> package com.google.gerrit.server.plugins; import com.google.gerrit.extensions.registration.DynamicSet; import com.google.gerrit.server.PluginUser; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.internal.storage.file.FileSnapshot; import java.io.File; @Singleton class UniversalServerPluginProvider implements ServerPluginProvider { private final DynamicSet<ServerPluginProvider> serverPluginProviders; @Inject public UniversalServerPluginProvider(DynamicSet<ServerPluginProvider> sf) { this.serverPluginProviders = sf; } @Override public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
<|startcomment|> optional: UsageDataEvent would be a more precise name for its purpose? <|endcomment|>  return event; } private RepoEvent createEvent(MetaData metaData, Cache<NameKey, AtomicLong> cache) { RepoEvent event = new RepoEvent(metaData); for (Project.NameKey p : projectCache.all()) { AtomicLong count = cache.getIfPresent(p); if (count != null) { long currentCount = count.getAndSet(0); if (currentCount != 0) { event.addData(currentCount, p.get()); } } } return event; } <|startfocus|> private static class RepoEvent implements Event { <|endfocus|> private final Timestamp timestamp; private final MetaData metaData; private final List<Data> data; public RepoEvent(MetaData metaData) { this.metaData = metaData; timestamp = new Timestamp(System.currentTimeMillis()); data = new ArrayList<Data>(); } private void addData(final long value, final String projectName) { Data dataRow = new Data() { @Override public long getValue() { return value; } @Override public String getProjectName() {
<|startcomment|> I can see where this is useful. But it's also telling me that Manifest is the wrong thing to be returning from the PluginContentScanner interface. Add to the list of later cleanups I guess? <|endcomment|>  protected final Set<Class<?>> preloadedClasses; protected final ApiType apiType; protected Class<? extends Module> sshModule; protected Class<? extends Module> httpModule; protected Class<? extends Module> sysModule; public AbstractPreloadedPluginScanner(String pluginName, String pluginVersion, Set<Class<?>> preloadedClasses, Plugin.ApiType apiType) { this.pluginName = pluginName; this.pluginVersion = pluginVersion; this.preloadedClasses = preloadedClasses; this.apiType = apiType; } @Override public Manifest getManifest() throws IOException { scanGuiceModules(preloadedClasses); <|startfocus|> String manifestString = "PluginName: " + pluginName + "\n" <|endfocus|> + "Implementation-Version: " + pluginVersion + "\n" + "Gerrit-ReloadMode: restart\n" + (sysModule == null ? "" : ("Gerrit-Module: " + sysModule.getName() + "\n")) + (httpModule == null ? "" : ("Gerrit-HttpModule: " + httpModule.getName() + " \n"))
<|startcomment|> Can be static. Name "assertCommentEquals" to match other assert methods. You could also just add equals()/hashCode()/toString() methods to PatchLineComment. ("Just" :) <|endcomment|>  RevCommit commit = tr.commit().message("PS1 again").create(); update.setCommit(rw, commit); update.commit(); try { notes = newNotes(c); fail("Expected IOException"); } catch (OrmException e) { assertCause( e, ConfigInvalidException.class, "Multiple revisions parsed for patch set 1:" <|startfocus|> + " RevId{" + commit.name() + "} and " + ps.getRevision().get()); <|endfocus|> } } @Test public void patchSetChangeNotes() throws Exception { Change c = newChange(); // ps1 created by newChange() ChangeNotes notes = newNotes(c); PatchSet ps1 = notes.getCurrentPatchSet(); assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps1.getId()); assertThat(notes.getChange().getSubject()).isEqualTo("Change subject"); assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject"); assertThat(ps1.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
<|startcomment|> This is naive implementation. It assumes that plugin would have only one SshModule, HttpModule, Module class. When in reality there could be multiple of those installed in one 'main' ssh/http/plugin module. Main module should be somehow marked, maybe by annotation or name convention. I'm not sure whether this improvement should be also part of this commit. But IMO current implementation is to simple and naive. Maybe look for @Export annotation on module classes? <|endcomment|>  Class<?> sshModuleBaseClass = Class.forName("com.google.gerrit.sshd.CommandModule"); for (Class<?> scriptClass : scriptClasses) { if (sshModuleBaseClass.isAssignableFrom(scriptClass)) { sshModule = ((Class<? extends Module>) scriptClass); } else if (httpModuleBaseClass.isAssignableFrom(scriptClass)) { httpModule = ((Class<? extends Module>) scriptClass); } else if (sysModuleBaseClass.isAssignableFrom(scriptClass)) { <|startfocus|> sysModule = ((Class<? extends Module>) scriptClass); <|endfocus|> } } } catch (ClassNotFoundException e) { throw new IOException( "Cannot find base Gerrit classes for Guice Plugin Modules", e); } } @Override public Map<Class<? extends Annotation>, Iterable<ExtensionMetaData>> scan( String pluginName, Iterable<Class<? extends Annotation>> annotations) throws InvalidPluginException { ImmutableMap.Builder<Class<? extends Annotation>, Iterable<ExtensionMetaData>> result = ImmutableMap.builder(); for (Class<? extends Annotation> annotation : annotations) {
<|startcomment|> When I said you could reuse this I meant actually reuse the method, not copy/paste. <|endcomment|>  } } private static ConfigInvalidException parseException(Id changeId, String fmt, Object... args) { return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args)); } private PersonIdent newIdent(Account author, Date when) { return new PersonIdent( author.getFullName(), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone()); } <|startfocus|> private static Account.Id parseIdent(PersonIdent ident, Id changeId) <|endfocus|> throws ConfigInvalidException { String email = ident.getEmailAddress(); int at = email.indexOf('@'); if (at >= 0) { String host = email.substring(at + 1, email.length()); Integer id = Ints.tryParse(email.substring(0, at)); if (id != null && host.equals(GERRIT_PLACEHOLDER_HOST)) { return new Account.Id(id); } } throw parseException(changeId, "invalid identity, expected <id>@%s: %s", GERRIT_PLACEHOLDER_HOST, email); } 
<|startcomment|> unused imports <|endcomment|> import com.google.gerrit.client.changes.ChangeInfo; import com.google.gerrit.client.changes.ChangeInfo.CommitInfo; import com.google.gerrit.client.changes.ChangeInfo.GitPerson; import com.google.gerrit.client.changes.ChangeInfo.RevisionInfo; import com.google.gerrit.client.rpc.Natives; import com.google.gerrit.client.ui.CommentLinkProcessor; import com.google.gerrit.client.ui.InlineHyperlink; import com.google.gerrit.common.PageLinks; import com.google.gwt.core.client.GWT; import com.google.gwt.core.client.JsArray; <|startfocus|> import com.google.gwt.dom.client.AnchorElement; import com.google.gwt.dom.client.ImageElement; <|endfocus|> import com.google.gwt.dom.client.Element; import com.google.gwt.dom.client.TableCellElement; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.resources.client.CssResource; import com.google.gwt.uibinder.client.UiBinder; import com.google.gwt.uibinder.client.UiField; import com.google.gwt.uibinder.client.UiHandler; import com.google.gwt.user.client.DOM; import com.google.gwt.user.client.ui.Anchor; import com.google.gwt.user.client.ui.Button; import com.google.gwt.user.client.ui.Composite; import com.google.gwt.user.client.ui.FlowPanel;
<|startcomment|> Javadoc? <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.plugins; import com.google.inject.Binder; <|startfocus|> <|endfocus|> public interface BindCallback { void bind(Binder binder); } 
<|startcomment|> Bikeshed: "peeled" <|endcomment|>  private static class RefJsonData { public RefJsonData(Ref ref) { name = ref.getName(); objectId = ref.getObjectId().getName(); storage = ref.getStorage().toString(); if(ref.getPeeledObjectId() != null) { peeledObjectId = ref.getPeeledObjectId().getName(); } if (ref.isSymbolic()) { target = ref.getTarget().getName(); } } public String name; public String objectId; public String peeledObjectId; public String target; <|startfocus|> public String storage; <|endfocus|> } } 
<|startcomment|> This won't update the entry if value is the same? What if on subsequent patchset the score is the same, but the URL has changed? Shouldn't the URL get updated? Also it doesn't look like these values tie into the Gerrit ACL system at this point. What are your thoughts on that? Right now there's no range checking to make sure votes are reported in the appropriate range. <|endcomment|>  } private boolean updateLabels(RevisionResource rsrc, Map<String, VerificationInfo> jobs) throws OrmException { Preconditions.checkNotNull(jobs); List<PatchSetVerification> ups = Lists.newArrayList(); Map<String, PatchSetVerification> current = scanLabels(rsrc); for (Map.Entry<String, VerificationInfo> ent : jobs.entrySet()) { String name = ent.getKey(); PatchSetVerification c = current.remove(name); if (c != null) { <|startfocus|> if (c.getValue() != ent.getValue().value) { c.setValue(ent.getValue().value); c.setGranted(timestamp); c.setUrl(ent.getValue().url); ups.add(c); } <|endfocus|> } else { c = new PatchSetVerification(new PatchSetVerification.Key( rsrc.getPatchSet().getId(), new LabelId(name)), ent.getValue().value, TimeUtil.nowTs()); c.setGranted(timestamp); c.setUrl(ent.getValue().url); ups.add(c); } } db.get().patchSetVerifications().upsert(ups); return !ups.isEmpty(); } 
<|startcomment|> This is unnecessary. Can just call builder.field directly; ES will determine the type. Also need to figure out how to add arrays. builder.array does not seem to work as expected. <|endcomment|>  } } } else if (type == FieldType.EXACT || type == FieldType.PREFIX || type == FieldType.FULL_TEXT) { for (Object value : values.getValues()) { builder.field(name, (String) value); } } else if (type == FieldType.STORED_ONLY) { for (Object value : values.getValues()) { builder.field(name, (byte[]) value); } } else { throw QueryBuilder.badFieldType(type); <|startfocus|> } <|endfocus|> } private void flush(String type) { try { client.admin().indices() .flush(new FlushRequest(type).force(true)) .actionGet(); } catch (IndexMissingException emi) { // Ignore } } private void insert(String type, ChangeData cd) throws IOException { String id = cd.getId().toString(); IndexRequest indexRequest = new IndexRequest(INDEX_NAME, type, id).source(toDoc(cd)); client.index(indexRequest).actionGet(); flush(type); } private void delete(String type, ChangeData cd) {
<|startcomment|> Maybe just 'emailFieldLabel'? <|endcomment|> // limitations under the License. package com.google.gerrit.client.account; import com.google.gwt.i18n.client.Constants; public interface AccountConstants extends Constants { String settingsHeading(); String changeAvatar(); String fullName(); String preferredEmail(); String registeredOn(); String accountId(); String commentVisibilityLabel(); String changeScreenLabel(); String diffViewLabel(); String maximumPageSizeFieldLabel(); String dateFormatLabel(); String contextWholeFile(); String showSiteHeader(); String useFlashClipboard(); <|startfocus|> String emailingOptionsFieldLabel(); <|endfocus|> String reversePatchSetOrder(); String reviewCategoryLabel(); String messageShowInReviewCategoryNone(); String messageShowInReviewCategoryName(); String messageShowInReviewCategoryEmail(); String messageShowInReviewCategoryUsername(); String messageShowInReviewCategoryAbbrev(); String buttonSaveChanges(); String showRelativeDateInChangeTable(); String showSizeBarInChangeTable(); String showLegacycidInChangeTable(); String myMenu(); String myMenuInfo(); String myMenuName(); String myMenuUrl(); String myMenuReset(); String changeScreenOldUi(); String changeScreenNewUi(); String tabAccountSummary();
<|startcomment|> nit: wrap this line <|endcomment|>  NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Field f = obj.getClass().getDeclaredField(field); f.setAccessible(true); return (T) f.get(obj); } private static InetAddress getLocalHost() throws UnknownHostException { return InetAddress.getLoopbackAddress(); } private Daemon daemon; private ExecutorService daemonService; private Injector testInjector; private String url; private InetSocketAddress sshdAddress; private InetSocketAddress httpAddress; <|startfocus|> private GerritServer(Injector testInjector, Daemon daemon, ExecutorService daemonService) throws IOException, ConfigInvalidException { <|endfocus|> this.testInjector = testInjector; this.daemon = daemon; this.daemonService = daemonService; Config cfg = testInjector.getInstance( Key.get(Config.class, GerritServerConfig.class)); url = cfg.getString("gerrit", null, "canonicalWebUrl"); URI uri = URI.create(url); sshdAddress = SocketUtil.resolve( cfg.getString("sshd", null, "listenAddress"), 0); httpAddress = new InetSocketAddress(uri.getHost(), uri.getPort()); } String getUrl() { return url; } 
<|startcomment|> commit.setMessage(String.format("Comment on patch set %d", psId.get()); <|endcomment|>  return RefNames.refsDraftComments(accountId, getChange().getId()); } @Override protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException { if (isEmpty()) { return false; } commit.setAuthor(newIdent(getUser().getAccount(), when)); commit.setCommitter(new PersonIdent(serverIdent, when)); StringBuilder msg = new StringBuilder(); msg.append("Comment on patch set ").append(psId.get()); commit.setMessage(msg.toString()); return true; } <|startfocus|> private boolean isEmpty() { return deleteComments.isEmpty() && upsertComments.isEmpty(); } <|endfocus|> } 
<|startcomment|> Writing a config file is the same as writing any other file.... so this method name is not really telling the difference. What it does it: - write the file - send an audit event Therefore, it could be named: writeFileAndFireEvent <|endcomment|>  res.setStatus(HttpServletResponse.SC_FORBIDDEN); return; } streamFile(req, res); } @Override public void doPut(HttpServletRequest req, HttpServletResponse res) throws IOException { if (!isValidFile(req)) { res.setStatus(HttpServletResponse.SC_FORBIDDEN); return; } if (isGerritConfig(req)) { writeConfigFile(req, res); } else { writeFile(req, res); } } <|startfocus|> private void writeConfigFile(HttpServletRequest req, HttpServletResponse res) throws IOException { <|endfocus|> File oldFile = configFile(req); File dir = oldFile.getParentFile(); File newFile = File.createTempFile(oldFile.getName(), ".new", dir); streamRequestToFile(req, newFile); String diff = diff(oldFile, newFile); audit("about to change config file", oldFile.getPath(), diff); oldFile.delete(); newFile.renameTo(oldFile); audit("changed config file", oldFile.getPath(), diff); res.setStatus(HttpServletResponse.SC_NO_CONTENT); } 
<|startcomment|> space after comma <|endcomment|>  } } private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException { gApi.get().changes() .id(patchSet.getId().getParentKey().get()) .revision(patchSet.getRevision().get()) .review(review); } private ReviewInput reviewFromJson() throws UnloggedFailure { try (InputStreamReader r = new InputStreamReader(in, StandardCharsets.UTF_8)) { return OutputFormat.JSON.newGson(). <|startfocus|> fromJson(CharStreams.toString(r),ReviewInput.class); <|endfocus|> } catch (IOException | JsonSyntaxException e) { writeError (e.getMessage() + '\n'); throw error("internal error while reading review input"); } } private void reviewPatchSet(final PatchSet patchSet) throws Exception { if (changeComment == null) { changeComment = ""; } ReviewInput review = new ReviewInput(); review.message = Strings.emptyToNull(changeComment); review.notify = notify; review.labels = Maps.newTreeMap(); review.drafts = ReviewInput.DraftHandling.PUBLISH; review.strictLabels = false;
<|startcomment|> Unnecessary, already done in constructor and these attributes are immutable. <|endcomment|>  public String getRefName() { <|startfocus|> Preconditions.checkNotNull(user); Preconditions.checkNotNull(change); <|endfocus|> return String.format("%s/edit-%d", RefNames.refsUsers(user.getAccountId()), change.getId().get());
<|startcomment|> Duplicate if? <|endcomment|>  patchList = patchListCache.get(rsrc.getChange(), rsrc.getPatchSet()); } catch (PatchListNotAvailableException e) { throw new OrmException("could not load PatchList for this patchset", e); } RevId patchSetCommit = new RevId(ObjectId.toString(patchList.getNewId())); RevId baseCommit = new RevId(ObjectId.toString(patchList.getOldId())); PatchLineComment c = rsrc.getComment(); if (c.getRevId() == null) { <|startfocus|> if (c.getRevId() == null) { c.setRevId((c.getSide() == (short) 0) ? baseCommit : patchSetCommit); } <|endfocus|> } plcUtil.deleteComments(db.get(), update, Collections.singleton(c)); update.commit(); return Response.none(); } } 
<|startcomment|> Nit: blank line. <|endcomment|>  try { IdentifiedUser identifiedUser = (IdentifiedUser) user.get(); Ref ref = repo.getRefDatabase().getRef(editRefName( identifiedUser.getAccountId(), change.getId())); if (ref == null) { return Optional.absent(); } return Optional.of(new ChangeEdit(identifiedUser, change, ref)); } finally { repo.close(); } } /** * Returns reference for this change edit with sharded user and change number: <|startfocus|> * refs/users/UU/UUUU/edit-CCCC. <|endfocus|> * @param accountId accout id * @param changeId change number * @return reference for this change edit */ static String editRefName(Account.Id accountId, Change.Id changeId) { return String.format("%s/edit-%d", RefNames.refsUsers(accountId), changeId.get()); } } 
<|startcomment|> That's to verbose and the logic is preaded in three different places. So no return, just one method: putPreferred and do all there: search for preferred mail, change it and return or issue the warning when not found. <|endcomment|>  "exclusive for the same email address."); } } private void setAccount() throws OrmException, IOException, UnloggedFailure { user = genericUserFactory.create(id); rsrc = new AccountResource(user); try { for (String email : addEmails) { addEmail(email); } for (String email : deleteEmails) { deleteEmail(email); } if (preferredEmail != null) { <|startfocus|> if (isRegistered(preferredEmail)) { putPreferred(preferredEmail); } else { System.err.println("WARNING: preferred email not set, " + preferredEmail + " not registered"); } <|endfocus|> } if (fullName != null) { PutName.Input in = new PutName.Input(); in.name = fullName; putName.apply(rsrc, in); } if (httpPassword != null || clearHttpPassword) { PutHttpPassword.Input in = new PutHttpPassword.Input(); in.httpPassword = httpPassword; putHttpPassword.apply(rsrc, in); } if (active) { putActive.apply(rsrc, null);
<|startcomment|> squashedCommit <|endcomment|>  ru.setForceUpdate(true); RefUpdate.Result result = ru.delete(); switch (result) { case FORCED: case NEW: case NO_CHANGE: break; default: throw new IOException(String.format("Failed to delete ref %s: %s", refName, result)); } } private RevCommit writeSquashedCommit(PersonIdent myIdent2, RevWalk rw, ObjectInserter inserter, RevCommit parent, RevCommit edit) <|startfocus|> throws IOException, MissingObjectException, IncorrectObjectTypeException { <|endfocus|> CommitBuilder mergeCommit = new CommitBuilder(); mergeCommit.setParentIds(parent.getParent(0)); mergeCommit.setAuthor(parent.getAuthorIdent()); mergeCommit.setMessage(parent.getFullMessage()); mergeCommit.setCommitter(edit.getCommitterIdent()); mergeCommit.setTreeId(edit.getTree()); return rw.parseCommit(commit(inserter, mergeCommit)); } private ObjectId commit(ObjectInserter inserter, CommitBuilder mergeCommit) throws IOException, UnsupportedEncodingException { ObjectId id = inserter.insert(mergeCommit); inserter.flush(); return id; } } 
<|startcomment|> Wrap this line. <|endcomment|>  private void setLoggingLevel(Level level) { for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements();) { Logger log = logger.nextElement(); <|startfocus|> if (regex == null) { <|endfocus|> log.setLevel(level); } else if (log.getName().matches(regex)) { log.setLevel(level); } }
<|startcomment|> same <|endcomment|> <|startfocus|> private void setLoggingLevel(Level level) { <|endfocus|> for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements();) { Logger log = logger.nextElement(); if (log.getName().matches(regex)) { log.setLevel(level); } }
<|startcomment|> I think if you create a class called Batches this comment can move to the Javadoc, e.g.: static class Batches { /** Batch update for change meta ref in the main repo. */ final BatchMetaDataUpdate change; /** Batch update for draft ref in the All-Users repo. */ final BatchMetaDataUpdate batch; } <|endcomment|>  public void setHashtags(Set<String> hashtags) { this.hashtags = hashtags; } public void setAssignee(Optional<Account.Id> assignee) { this.assignee = assignee; } public Map<Account.Id, ReviewerStateInternal> getReviewers() { return reviewers; } public void putReviewer(Account.Id reviewer, ReviewerStateInternal type) { checkArgument(type != ReviewerStateInternal.REMOVED, "invalid ReviewerType"); reviewers.put(reviewer, type); } public void removeReviewer(Account.Id reviewer) { reviewers.put(reviewer, ReviewerStateInternal.REMOVED); } <|startfocus|> public void setPatchSetState(PatchSetState psState) { this.psState = psState; <|endfocus|> } public void setGroups(List<String> groups) { checkNotNull(groups, "groups may not be null"); this.groups = groups; } /** @return the tree id for the updated tree */ private ObjectId storeRevisionNotes(RevWalk rw, ObjectInserter inserter, ObjectId curr) throws ConfigInvalidException, OrmException, IOException { if (comments.isEmpty() && pushCert == null) { return null; }
<|startcomment|> Add a comment about the race condition: "Even if the latest patch set changed since the user triggered the operation, deleting the whole file is probably still what they intended." <|endcomment|>  ChangeEditModifier editModifier, Provider<ReviewDb> db, @Assisted @Nullable String path) { this.editUtil = editUtil; this.editModifier = editModifier; this.db = db; this.path = path; } @Override public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException { Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange()); if (edit.isPresent() && path == null) { <|startfocus|> // Edit is wipped out <|endfocus|> editUtil.delete(edit.get()); } else if (!edit.isPresent() && path != null) { // Edit is created on top of current patch set by deleting path editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get( rsrc.getChange().currentPatchSetId())); edit = editUtil.byChange(rsrc.getChange()); editModifier.deleteFile(edit.get(), path); } else { // Bad request throw new ResourceConflictException(
<|startcomment|> ws here and below. <|endcomment|>  @Inject @GerritServerConfig private Config gerritConfig; @Inject @PluginName private String pluginName; @Inject private ItsConfig itsConfig; @Inject private IssueExtractor issueExtractor; private List<CommitValidationMessage> validCommit(ReceiveCommand cmd, RevCommit commit) throws CommitValidationException { List<CommitValidationMessage> ret = Lists.newArrayList(); ItsAssociationPolicy associationPolicy = getItsAssociationPolicy(); String commitMessage = commit.getFullMessage(); String[] issueIds = issueExtractor.getIssueIds(commitMessage); String synopsis; String details; <|startfocus|> <|endfocus|> switch (associationPolicy) { case MANDATORY: case SUGGESTED: if (issueIds.length > 0) { List<String> nonExistingIssueIds = Lists.newArrayList(); for (String issueId : issueIds) { boolean exists = false; try { exists = client.exists(issueId); } catch (IOException e) { synopsis = "Failed to check whether or not issue " + issueId + " exists"; log.warn(synopsis, e); details = e.toString(); ret.add(commitValidationFailure(synopsis, details)); }
<|startcomment|> Nit: space after , <|endcomment|>  private static final String PENDING_REVIEWER_FIELD = ChangeField.PENDING_REVIEWER.getName(); private static final String PENDING_REVIEWER_BY_EMAIL_FIELD = ChangeField.PENDING_REVIEWER_BY_EMAIL.getName(); private static final String REF_STATE_FIELD = ChangeField.REF_STATE.getName(); private static final String REF_STATE_PATTERN_FIELD = ChangeField.REF_STATE_PATTERN.getName(); private static final String REVIEWEDBY_FIELD = ChangeField.REVIEWEDBY.getName(); private static final String REVIEWER_FIELD = ChangeField.REVIEWER.getName(); <|startfocus|> private static final String REVIEWER_BY_EMAIL_FIELD = ChangeField.REVIEWER_BY_EMAIL.getName(); private static final String HASHTAG_FIELD = ChangeField.HASHTAG_CASE_AWARE.getName(); <|endfocus|> private static final String STAR_FIELD = ChangeField.STAR.getName(); private static final String SUBMIT_RECORD_LENIENT_FIELD = ChangeField.STORED_SUBMIT_RECORD_LENIENT.getName(); private static final String SUBMIT_RECORD_STRICT_FIELD = ChangeField.STORED_SUBMIT_RECORD_STRICT.getName(); private static final String UNRESOLVED_COMMENT_COUNT_FIELD = ChangeField.UNRESOLVED_COMMENT_COUNT.getName();
<|startcomment|> Nit: unneeded new line. <|endcomment|>  child(PROJECT_KIND, "children").to(ChildProjectsCollection.class); get(CHILD_PROJECT_KIND).to(GetChildProject.class); get(PROJECT_KIND, "HEAD").to(GetHead.class); put(PROJECT_KIND, "HEAD").to(SetHead.class); put(PROJECT_KIND, "ban").to(BanCommit.class); get(PROJECT_KIND, "statistics.git").to(GetStatistics.class); post(PROJECT_KIND, "gc").to(GarbageCollect.class); post(PROJECT_KIND, "create_change").to(ProjectCreateChange.class); <|startfocus|> <|endfocus|> child(PROJECT_KIND, "branches").to(BranchesCollection.class); put(BRANCH_KIND).to(PutBranch.class); get(BRANCH_KIND).to(GetBranch.class); delete(BRANCH_KIND).to(DeleteBranch.class); install(new FactoryModuleBuilder().build(CreateBranch.Factory.class)); get(BRANCH_KIND, "reflog").to(GetReflog.class); child(BRANCH_KIND, "files").to(FilesCollection.class); get(FILE_KIND, "content").to(GetContent.class); child(PROJECT_KIND, "commits").to(CommitsCollection.class); get(COMMIT_KIND).to(GetCommit.class); child(COMMIT_KIND, "files").to(FilesInCommitCollection.class); 
<|startcomment|> Hm, I wonder if this will lead to lurking NPEs? Would it make more sense to throw UnsupportedOperationException? Or is there actually something that calls this method and stores the result? <|endcomment|>  public Schema<ChangeData> getSchema() { <|startfocus|> return null; <|endfocus|>
<|startcomment|> Extract this to a constant? <|endcomment|>  public Hashtags() { hashtagsSuggestOracle = new RestHashtagsSuggestOracle(); nameTxtBox = new HintTextBox(); suggestBox = new SuggestBox(hashtagsSuggestOracle, nameTxtBox); initWidget(uiBinder.createAndBindUi(this)); <|startfocus|> nameTxtBox.setVisibleLength(55); <|endfocus|> nameTxtBox.addKeyDownHandler(new KeyDownHandler() { @Override public void onKeyDown(KeyDownEvent e) { submitOnSelection = false; if (e.getNativeEvent().getKeyCode() == KeyCodes.KEY_ESCAPE) { onCancel(null); } else if (e.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) { if (((DefaultSuggestionDisplay) suggestBox.getSuggestionDisplay()) .isSuggestionListShowing()) { submitOnSelection = true; } else { onAdd(null); } } } }); suggestBox.addSelectionHandler(new SelectionHandler<Suggestion>() { @Override public void onSelection(SelectionEvent<Suggestion> event) { nameTxtBox.setFocus(true); if (submitOnSelection) { onAdd(null); } } });
<|startcomment|> Missing space. <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.config; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.ResourceConflictException; import com.google.gerrit.extensions.restapi.RestReadView; import com.google.inject.Inject; import com.google.inject.Singleton; @Singleton <|startfocus|> public class GetServerConfig implements RestReadView<ConfigResource>{ <|endfocus|> private final AllProjectsName allProjectsName; private final AllUsersName allUsersName; @Inject public GetServerConfig(AllProjectsName allProjectsName, AllUsersName allUsersName) { this.allProjectsName = allProjectsName; this.allUsersName = allUsersName; } @Override public ConfigInfo apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception { ConfigInfo config = new ConfigInfo(); config.allProjectsName = allProjectsName.get(); config.allUsersName = allUsersName.get(); return config; } public static class ConfigInfo {
<|startcomment|> Can be one line. <|endcomment|>  ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false) : new ChangeScreen(id)); } else if ("publish".equals(panel)) { publish(ps); } else { Gerrit.display(token, new NotFoundScreen()); } } } private static PatchSet.Id toPsId(Change.Id id, String psIdStr) { <|startfocus|> return new PatchSet.Id(id, psIdStr.equals("edit") ? 0 : Integer.parseInt(psIdStr)); <|endfocus|> } private static void extension(final String token) { ExtensionScreen view = new ExtensionScreen(skip(token)); if (view.isFound()) { Gerrit.display(token, view); } else { Gerrit.display(token, new NotFoundScreen()); } } public static boolean isChangeScreen2() { if (!Gerrit.getConfig().getNewFeatures()) { return false; } else if (changeScreen2) { return true; } AccountGeneralPreferences.ChangeScreen ui = null;
<|startcomment|> add a call to trim here. Currently if you enter "a,a ,a ,b" you end up with multiple "a" tags. <|endcomment|>  void onAdd(ClickEvent e) { <|startfocus|> String hashtag = suggestBox.getText(); <|endfocus|> if (!hashtag.isEmpty()) { addHashtag(hashtag); }
<|startcomment|> Rather use get() <|endcomment|>  public void onClick(ClickEvent event) { <|startfocus|> CreateChangeAction.call(createChange, getProjectKey().toString()); <|endfocus|>
<|startcomment|> 2014 <|endcomment|> <|startfocus|> Copyright (C) 2012 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.change; import com.google.common.base.Strings; import com.google.gerrit.extensions.restapi.AuthException; import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.DefaultInput; import com.google.gerrit.extensions.restapi.Response; import com.google.gerrit.extensions.restapi.RestModifyView; import com.google.gerrit.server.change.DeleteHashtags.Input; import com.google.gerrit.server.notedb.ChangeNotes; import com.google.gerrit.server.notedb.ChangeUpdate;
<|startcomment|> not needed, in Gerrit we don't explicitly compare booleans to true <|endcomment|>  .iterator().hasNext()) { throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes"); } Repository r = repoManager.openRepository(rsrc.getNameKey()); try { RefUpdate.Result result; RefUpdate u; try { u = r.updateRef(rsrc.getRef()); u.setForceUpdate(true); <|startfocus|> Optional<String> notValid = validateRefDeletion(rsrc, u); if (notValid.isPresent() == true) { throw new ResourceConflictException(notValid.get()); } <|endfocus|> result = u.delete(); } catch (IOException e) { log.error("Cannot delete " + rsrc.getBranchKey(), e); throw e; } switch (result) { case NEW: case NO_CHANGE: case FAST_FORWARD: case FORCED: referenceUpdated.fire(rsrc.getNameKey(), u); hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount()); break; case REJECTED_CURRENT_BRANCH:
<|startcomment|> Unnecessary <|endcomment|> <|startfocus|> public static void getContent(PatchSet.Id id, String filename, AsyncCallback<String> cb) { <|endfocus|> contentEditOrPs(id, filename).get( new CallbackWrapper<NativeString, String>(cb) { @Override public void onSuccess(NativeString b64) { if (b64 != null) { wrapped.onSuccess(b64decode(b64.asString())); } } });
<|startcomment|> This is a little crazy simply because the suggest oracle may be called many times in rapid succession during the course of one operation. It would be easy to have a simple Cache<Boolean, List<Account>> with a short expiration time, say 30s. (The cache will only have a single key, say True, we're just using Cache for the expiration behavior.) (Also totally will not work for googlesource.com but we can wait till there's a proper secondary index for accounts.) <|endcomment|>  addSuggestion(r, p, info, visibilityControl); } } } return Lists.newArrayList(r.values()); } private List<AccountInfo> suggestAccountFullTextSearch( VisibilityControl visibilityControl) throws OrmException { String str = query.toLowerCase(); LinkedHashMap<Account.Id, AccountInfo> accountMap = Maps.newLinkedHashMap(); List<Account> fullNameMatches = Lists.newArrayList(); List<Account> emailMatches = Lists.newArrayList(); <|startfocus|> for (Account a : dbProvider.get().accounts().all()) { <|endfocus|> if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) { emailMatches.add(a); } if (fullNameMatches.size() >= fullTextMaxMatches) { break; } } for (Account a : fullNameMatches) {
<|startcomment|> Unnecessary blank line <|endcomment|>  this.privateByDefault = config.getBoolean("change", "privateByDefault", false); this.submitType = config.getEnum("project", null, "submitType", SubmitType.MERGE_IF_NECESSARY); this.mergeUtilFactory = mergeUtilFactory; this.notifyUtil = notifyUtil; } @Override <|startfocus|> protected Response<ChangeInfo> applyImpl( BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException { <|endfocus|> if (Strings.isNullOrEmpty(input.project)) { throw new BadRequestException("project must be non-empty"); } if (Strings.isNullOrEmpty(input.branch)) { throw new BadRequestException("branch must be non-empty"); } if (Strings.isNullOrEmpty(input.subject)) { throw new BadRequestException("commit message must be non-empty"); } if (input.status != null) { if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) { throw new BadRequestException("unsupported change status"); }
<|startcomment|> We could also use a floating API here like in "Changes". But since there is only one additional parameter (limit), it would probably be an overkill. <|endcomment|>  * * @see Changes#id(int) */ ChangeApi revert(RevertInput in) throws RestApiException; String topic() throws RestApiException; void topic(String topic) throws RestApiException; void addReviewer(AddReviewerInput in) throws RestApiException; void addReviewer(String in) throws RestApiException; void addHashTag(AddHashTagInput in) throws RestApiException; ChangeInfo get(EnumSet<ListChangesOption> options) throws RestApiException; <|startfocus|> <|endfocus|>
<|startcomment|> Would this work: @Option(name = "--hashtag", aliases = {"-#tag"}, ... <|endcomment|>  if (newObject != null) { validateNewCommits(ctl, cmd); if (cmd.getResult() != NOT_ATTEMPTED) { return; } } if (ctl.canForceUpdate()) { batch.setAllowNonFastForwards(true).addCommand(cmd); } else { cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege."); } } <|startfocus|> static class MagicBranchInput { <|endfocus|> private static final Splitter COMMAS = Splitter.on(',').omitEmptyStrings(); final ReceiveCommand cmd; Branch.NameKey dest; RefControl ctl; Set<Account.Id> reviewer = Sets.newLinkedHashSet(); Set<Account.Id> cc = Sets.newLinkedHashSet(); Map<String, Short> labels = new HashMap<>(); String message; List<RevCommit> baseCommit; LabelTypes labelTypes; CmdLineParser clp; Set<String> hashtags = new HashSet<>(); NotesMigration notesMigration; @Option(name = "--base", metaVar = "BASE", usage = "merge base of changes") List<ObjectId> base; 
<|startcomment|> nit: please wrap lines at 80 chars. <|endcomment|> import org.eclipse.jgit.transport.SideBandOutputStream; import org.eclipse.jgit.treewalk.TreeWalk; import org.kohsuke.args4j.Argument; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.kohsuke.args4j.Option; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.io.OutputStream; import java.util.Arrays; import java.util.Collections; import java.util.List; <|startfocus|> /** Allows getting archives for Git repositories over SSH using the Git upload-archive protocol. */ <|endfocus|> public class UploadArchive extends AbstractGitCommand { /** Options for parsing Git commands. * These options are not passed on command line, but received through input stream in Pkt-Line format. */ static class Options { @Option(name = "-f", aliases = {"--format"}, usage = "Format of the resulting archive: tar or zip. If this option is not given, " + "and the output file is specified, the format is inferred from the filename" +
<|startcomment|> This TODO is in the JSON case because we actually have to define a JSON format for other types first. For raw data it should be trivial to copy any type of object, and the suggestions I've given above don't depend on type. <|endcomment|>  Repository repo = ServletUtils.getRepository(req); RevWalk walk = new RevWalk(repo); try { RevObject obj = walk.parseAny(view.getRevision().getId()); switch (obj.getType()) { case OBJ_COMMIT: try (Writer writer = startRenderText(req, res); OutputStream out = BaseEncoding.base64().encodingStream(writer)) { out.write(((RevCommit)obj).getRawBuffer()); } break; default: // TODO(dborowitz): Support showing other types. res.setStatus(SC_NOT_FOUND); break; } <|startfocus|> } finally { walk.release(); <|endfocus|> } } @Override protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException { GitilesView view = ViewFilter.getView(req); Repository repo = ServletUtils.getRepository(req); RevWalk walk = new RevWalk(repo); try { DateFormatter df = new DateFormatter(getAccess(req), Format.DEFAULT); RevObject obj = walk.parseAny(view.getRevision().getId()); switch (obj.getType()) { case OBJ_COMMIT:
<|startcomment|> L <|endcomment|>  @Override public WebLinkInfo getWebLinkInfoFor(RevisionResource resource) { return new WebLinkInfo(getLinkName(), getImageUrl(), getPatchSetUrl(resource.getChange().getProject().get(), resource.getPatchSet().getRevision().get()), getTarget()); } private String getPatchSetUrl(String project, String commit) { return String.format(placeHolderUrlProjectCommit, project, commit); } } <|startfocus|> public static class BranchWeblink implements WebLink<BranchResource> { <|endfocus|> @Override public WebLinkInfo getWebLinkInfoFor(BranchResource resource) { return new WebLinkInfo(getLinkName(), getImageUrl(), getBranchUrl( resource.getName(), resource.getBranchKey().get()), getTarget()); } private String getBranchUrl(String projectName, String branchName) { return String .format(placeHolderUrlProjectBranch, projectName, branchName); } } public static class ProjectWebLink implements WebLink<ProjectResource> { @Override public WebLinkInfo getWebLinkInfoFor(ProjectResource resource) {
<|startcomment|> This should be: changeDataFactory.create(db.get(), rsrc.getControl())); <|endcomment|>  this.rules = rules; } @Override public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException { if (input == null) { input = new Input(); } if (input.rule != null && !rules.isProjectRulesEnabled()) { throw new AuthException("project rules are disabled"); } input.filters = MoreObjects.firstNonNull(input.filters, filters); SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator( <|startfocus|> changeDataFactory.create(db.get(), rsrc.getChange())); <|endfocus|> List<Term> results; try { results = evaluator.setPatchSet(rsrc.getPatchSet()) .setSkipSubmitFilters(input.filters == Filters.SKIP) .setRule(input.rule) .evaluateSubmitType(); } catch (RuleEvalException e) { throw new BadRequestException(String.format( "rule failed with exception: %s", e.getMessage())); } if (results.isEmpty()) { throw new BadRequestException(String.format( "rule %s has no solution", evaluator.getSubmitRule())); }
<|startcomment|> Add another replyError that doesn't have the err parameter, and make it just call the existing replyError with err=null? Then it won't be necessary to change the calls in this file. <|endcomment|>  this.session = session; this.accountResolver = accountResolver; } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; String runas = req.getHeader(RUN_AS); if (runas != null) { if (!enabled) { RestApiServlet.replyError(req, res, SC_FORBIDDEN, <|startfocus|> RUN_AS + " disabled by auth.enableRunAs = false", null); <|endfocus|> return; } CurrentUser self = session.get().getCurrentUser(); if (!self.getCapabilities().canRunAs()) { RestApiServlet.replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null); return; } Account target; try { target = accountResolver.find(runas); } catch (OrmException e) { log.warn("cannot resolve account for " + RUN_AS, e); RestApiServlet.replyError(req, res, SC_INTERNAL_SERVER_ERROR,
<|startcomment|> If it always returns null it should be Callable<Void>, I think. <|endcomment|>  || (oldCfg.getRulesId() == null ? newCfg.getRulesId() != null : !oldCfg.getRulesId().equals(newCfg.getRulesId())); } private ProjectConfig parseConfig(Project.NameKey p, String idStr) throws IOException, ConfigInvalidException, RepositoryNotFoundException { ObjectId id = ObjectId.fromString(idStr); if (ObjectId.zeroId().equals(id)) { return null; } return ProjectConfig.read(metaDataUpdateFactory.create(p), id); } <|startfocus|> private class Task implements Callable<Object> { <|endfocus|> private final Change change; private final boolean force; private final boolean reindex; private ReviewDb reviewDb; Task(Change change, boolean force, boolean reindex) { this.change = change; this.force = force; this.reindex = reindex; } @Override public Object call() throws Exception { mergeabilityCheckQueue.updatingMergeabilityFlag(change, force); RequestContext context = new RequestContext() { @Override public CurrentUser getCurrentUser() { return identifiedUserFactory.create(change.getOwner()); } @Override
<|startcomment|> I guess it's still WIP, because this ps would compile as is? <|endcomment|>  private void fire(final Project.NameKey p) { Event event = new GarbageCollectorListener.Event() { @Override public String getProjectName() { return p.get(); <|startfocus|> } <|endfocus|> }; for (GarbageCollectorListener listener : listeners) { listener.onGarbageCollected(event); }
<|startcomment|> Hm, I could see the argument for PUT here, since it's really just a single value and the request body replaces the value. <|endcomment|>  get(COMMENT_KIND).to(GetComment.class); child(REVISION_KIND, "files").to(Files.class); put(FILE_KIND, "reviewed").to(PutReviewed.class); delete(FILE_KIND, "reviewed").to(DeleteReviewed.class); get(FILE_KIND, "content").to(GetContent.class); get(FILE_KIND, "diff").to(GetDiff.class); <|startfocus|> child(CHANGE_KIND, "edit").to(ChangeEdits.class); <|endfocus|> child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class); child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class); put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class); delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class); get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class); install(new FactoryModule() { @Override protected void configure() { factory(ReviewerResource.Factory.class); factory(AccountInfo.Loader.Factory.class); factory(EmailReviewComments.Factory.class); factory(ChangeInserter.Factory.class); factory(PatchSetInserter.Factory.class); factory(ChangeEdits.Create.Factory.class); factory(ChangeEdits.DeleteEdit.Factory.class); } });
<|startcomment|> Is this annotation still needed if there are no longer any injected parameters? Is the constructor even needed? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.download.command; import com.google.gerrit.extensions.config.DownloadCommand; import com.google.gerrit.extensions.config.DownloadScheme; import com.google.gerrit.reviewdb.client.RefNames; import com.google.inject.Inject; import com.googlesource.gerrit.plugins.download.scheme.RepoScheme; public class RepoCommand extends DownloadCommand { <|startfocus|> @Inject RepoCommand() { } <|endfocus|> @Override public String getCommand(DownloadScheme scheme, String project, String ref) { if (scheme instanceof RepoScheme) { String id = trim(ref); if (id != null) { return "repo download " + scheme.getUrl(project) + " " + id; } } return null; } private static String trim(String ref) { if (ref.startsWith(RefNames.REFS_CHANGES)) { int s1 = ref.lastIndexOf('/'); if (s1 > 0) {
<|startcomment|> I'd drop the "this." to save typing, as it's obvious here it's the same thing. <|endcomment|>  public CommentLinkInfo(String name, String match, String link, String html) { checkArgument(name != null, "invalid commentlink.name"); checkArgument(!Strings.isNullOrEmpty(match), "invalid commentlink.%s.match", name); link = Strings.emptyToNull(link); html = Strings.emptyToNull(html); this.name = name; this.match = match; this.link = link; this.html = html; <|startfocus|> this.pattern = Pattern.compile(this.match); <|endfocus|>
<|startcomment|> Given that you're doing this by calling clp.replace(), I think you don't need to enclose each portion of the giant regex in (). IIRC the purpose of that was so you could check for a non-null group in the matcher. (Which might not actually number nested groups correctly, it's possible Gerrit is broken here too.) <|endcomment|>  for (int index = 0; index < parsed.size(); index++) { Map<String, String> piece = parsed.get(index); if (piece.get("url") == null) { String text = piece.get("text"); Matcher m = allPattern.matcher(text); if (m.find()) { <|startfocus|> // go through the individual regexps now for replacement for (CommentLinkInfo clp : operationalCommentLinks) { List<Map<String, String>> resultingReplacement = clp.replace(piece.get("text")); <|endfocus|> if (resultingReplacement != null) { parsed.remove(index); for (Map<String, String> it : resultingReplacement) { parsed.add(index, it); index++; } } } } } } return parsed; } } 
<|startcomment|> nit: extra blank line <|endcomment|>  try { DatabaseMetaData meta = conn.getMetaData(); JavaSchemaModel jsm = new JavaSchemaModel(ReviewDb.class); for (RelationModel rm : jsm.getRelations()) { String tableName = rm.getRelationName(); List<String> relationPK = relationPK(rm); List<String> tablePK = dbTablePK(meta, tableName); if (!relationPK.equals(tablePK)) { corrections.put(tableName, relationPK); } } return corrections; } finally { db.close(); } } <|startfocus|> <|endfocus|> private List<String> relationPK(RelationModel rm) throws OrmException, SQLException { List<String> pk = new ArrayList<>(); for (ColumnModel cm : rm.getPrimaryKeyColumns()) { pk.add(cm.getColumnName().toUpperCase()); } return pk; } private List<String> dbTablePK(DatabaseMetaData meta, String tableName) throws OrmException, SQLException { ResultSet cols = meta.getPrimaryKeys(null, null, tableName.toUpperCase()); Map<Short, String> seqToName = new HashMap<>();
<|startcomment|> I would prefer to keep that "cannot update gitlinks" text. <|endcomment|>  changeHooks.doRefUpdatedHook(subscriber, rfu, account); // TODO since this is performed "in the background" no mail will be // sent to inform users about the updated branch break; default: throw new IOException(rfu.getResult().name()); } recRw = new RevWalk(pdb); // Recursive call: update subscribers of the subscriber updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString()); } catch (IOException e) { <|startfocus|> throw new SubmoduleException("Unknown IO exception", e); <|endfocus|> } finally { if (recRw != null) { recRw.release(); } if (pdb != null) { pdb.close(); } } } private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException { final RevWalk rw = new RevWalk(pdb); try { final DirCache dc = DirCache.newInCore(); final DirCacheBuilder b = dc.builder(); b.addTree(new byte[0], // no prefix path
<|startcomment|> (optional) It might makes sense to combine these statements. (no strong opinion either way --- just thought I should mention it since I suggested the original code in a comment) <|endcomment|>  this.pattern = compiledMatch; this.link = link; } public List<Map<String, String>> replace(String input) { List<Map<String, String>> parsed = Lists.newArrayList(); Matcher m = pattern.matcher(input); int last = 0; while (m.find()) { addText(parsed, input.substring(last, m.start())); <|startfocus|> if (link != null) { String s = pattern.matcher(m.group(0)).replaceAll(link); addLink(parsed, m.group(0), s); } <|endfocus|> last = m.end(); } addText(parsed, input.substring(last)); return parsed; } private static void addLink(List<Map<String, String>> parts, String text, String url) { parts.add(ImmutableMap.of("text", text, "url", url)); } private static void addText(List<Map<String, String>> parts, String text) { if (text.isEmpty()) { return; } if (parts.isEmpty()) { parts.add(ImmutableMap.of("text", text)); } else {
<|startcomment|> nit: trailing whitespace <|endcomment|>  cs.decode(ByteBuffer.wrap(input)); return true; } catch(CharacterCodingException e){ return false; } } private boolean validateLine(byte[] line, int lineStart, int lineEnd) { for (; lineStart < lineEnd; lineStart++) if ((line[lineStart] & 128) > 0) { int utf8Index = lineStart++; int utf8Bit = 64; /* UTF8 format: <|startfocus|> First byte contains "count" 1 bits and a zero bit - the count is 2-4 and denotes the number of bytes followig that is part of that character. <|endfocus|> Each following byte has "10" as upper bits. Exampls: 11000010 10100010 11100010 10000010 10101100 11110000 10100100 10101101 10100010 */ if ((line[utf8Index] & utf8Bit) == 0) // Is the sevent bit set on the UTF8 start character? return false; for (; (lineStart - utf8Index) < 4 && // Max size of a UTF8 character is 4 bytes
<|startcomment|> nit: unused import <|endcomment|>  import com.google.gerrit.extensions.annotations.PluginName; import com.google.gerrit.server.config.PluginConfig; import com.google.gerrit.server.config.PluginConfigFactory; import com.google.gerrit.server.events.CommitReceivedEvent; import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.validators.CommitValidationException; import com.google.gerrit.server.git.validators.CommitValidationListener; import com.google.gerrit.server.git.validators.CommitValidationMessage; import com.google.gerrit.server.project.NoSuchProjectException; import com.google.inject.Inject; <|startfocus|> import org.eclipse.jgit.api.errors.GitAPIException; <|endfocus|> import org.eclipse.jgit.lib.Repository; import java.io.IOException; import java.util.Collections; import java.util.List; import java.util.regex.*; import java.nio.charset.Charset; import java.nio.ByteBuffer; import java.nio.charset.CharsetDecoder; import java.nio.charset.CharacterCodingException; public class CharSetValidator implements CommitValidationListener { public static String CHARSET_VALIDATOR = "charSetValidator"; private final String pluginName; private final PluginConfigFactory cfgFactory; private final GitRepositoryManager repoManager; private boolean fastUtf8Check; private boolean validateUtf8; private Pattern okCharPattern;
<|startcomment|> remove this <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.git; import static com.google.gerrit.common.data.GlobalCapability.BATCH_CHANGES_LIMIT; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.config.GerritServerConfig; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.lib.Config; @Singleton class ReceiveConfig { final boolean checkMagicRefs; final boolean checkReferencedObjectsAreReachable; final boolean allowDrafts; <|startfocus|> final private int systemMaxBatchChangesOf; <|endfocus|> @Inject ReceiveConfig(@GerritServerConfig Config config) { checkMagicRefs = config.getBoolean( "receive", null, "checkMagicRefs", true); checkReferencedObjectsAreReachable = config.getBoolean( "receive", null, "checkReferencedObjectsAreReachable", true); allowDrafts = config.getBoolean( "change", null, "allowDrafts", true); systemMaxBatchChangesOf = config.getInt("receive", "maxBatchChanges", 0); } public int getEffectiveMaxBatchChangesLimit(CurrentUser user) { if (user.getCapabilities().canPerform(BATCH_CHANGES_LIMIT)) {
<|startcomment|> nit: no spacing here <|endcomment|>  static boolean needsQuotedPrintableWithinPhrase(final int cp) { switch (cp) { case '!': case '*': case '+': case '-': case '/': case '=': case '_': return false; default: <|startfocus|> if ( (cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z') || (cp >= '0' && cp <= '9') ) <|endfocus|> return false; else return true; }
<|startcomment|> I have no idea what this means. What are "merged" and "mergeResult" in this context? They are just strings. Are they SHA-1s or what? What do the keys and values represent? Why use strings for this instead of a richer type, like for example CodeReviewCommit? <|endcomment|>  } } /** * Moves this MergeTip to newTip and appends mergeResult. * @param newTip The new tip * @param mergedFrom The result of the merge of newTip */ public void moveTipTo(CodeReviewCommit newTip, String mergedFrom) { currentTip = newTip; appendMergeResult(newTip, mergedFrom); } /** * The merge results of all the merges of this merge operation. <|startfocus|> * @return The mergeResults of the mergeOperation Map<merged, mergeResult> <|endfocus|> */ public Map<String,String> getMergeResults() { return this.mergeResults; } private void appendMergeResult(CodeReviewCommit commit, String mergedFrom) { mergeResults.put(mergedFrom, commit.getName()); } public CodeReviewCommit getCurrentTip() { return currentTip; } } 
<|startcomment|> This line can be moved outside the if/else. <|endcomment|>  if (branchTip == null) { // The branch is unborn. Take a fast-forward resolution to // create the branch. mergeTip = new MergeTip(toMerge.get(0), toMerge); branchTip = toMerge.remove(0); mergeTip.moveTipTo(branchTip, branchTip.getName()); } else { mergeTip = new MergeTip(branchTip, toMerge); branchTip = args.mergeUtil.getFirstFastForward(branchTip, args.rw, toMerge); <|startfocus|> mergeTip.moveTipTo(branchTip, branchTip.getName()); <|endfocus|> } // For every other commit do a pair-wise merge. while (!toMerge.isEmpty()) { CodeReviewCommit mergedFrom = toMerge.remove(0); branchTip = args.mergeUtil.mergeOneCommit(args.serverIdent.get(), args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, branchTip, mergedFrom); mergeTip.moveTipTo(branchTip, mergedFrom.getName()); } final PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges( args.rw, args.canMergeFlag, branchTip, args.alreadyAccepted);
<|startcomment|> Here you put every param on new line. <|endcomment|>  public GerritWicketFilter( <|startfocus|> final DynamicItem<WebSession> webSession, final GerritAuthFilter gerritAuthFilter, final GerritGitBlitContext gerritGitblitContext, final SitePaths sitePaths, <|endfocus|> IStoredSettings settings, IRuntimeManager runtimeManager, IRepositoryManager repositoryManager, IProjectManager projectManager, GitBlitWebApp webapp) { super(settings, runtimeManager, repositoryManager, projectManager, webapp); this.webSession = webSession; this.gerritAuthFilter = gerritAuthFilter; this.gerritGitblitContext = gerritGitblitContext;
<|startcomment|> Comments should start with a capital letter and end with a period. <|endcomment|>  existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null); } List<ChangeLookup> pending = Lists.newArrayList(); final Set<Change.Key> newChangeIds = new HashSet<>(); final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user); for (;;) { final RevCommit c = rp.getRevWalk().next(); if (c == null) { break; } groupCollector.visit(c); Collection<Ref> existingRefs = existing.get(c); <|startfocus|> if (!existingRefs.isEmpty()) { // Commit is already tracked. <|endfocus|> // Corner cases where an existing commit might need a new group: // A) Existing commit has a null group; wasn't assigned during schema // upgrade, or schema upgrade is performed on a running server. // B) Let A<-B<-C, then: // 1. Push A to refs/heads/master // 2. Push B to refs/for/master // 3. Force push A~ to refs/heads/master
<|startcomment|> Import order <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.git; import static com.google.common.base.Preconditions.checkNotNull; <|startfocus|> import static com.google.common.base.Preconditions.checkState; <|endfocus|> import static com.google.gerrit.common.FooterConstants.CHANGE_ID; import static com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES; import static com.google.gerrit.server.change.HashtagsUtil.cleanupHashtag; import static com.google.gerrit.server.git.MultiProgressMonitor.UNKNOWN; import static com.google.gerrit.server.mail.MailUtil.getRecipientsFromFooters; import static java.util.Comparator.comparingInt; import static java.util.stream.Collectors.joining; import static java.util.stream.Collectors.toList; import static org.eclipse.jgit.lib.Constants.R_HEADS; import static org.eclipse.jgit.lib.RefDatabase.ALL; import static org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED;
<|startcomment|> This wont support alpha numerical unicode characters like #FR GA or #BER. It's really Java's fault for not including good unicode character groups. But since we can add those #Hashtags using the UI/REST, we could perhaps try a different approach, like including everything that is not a "," or \\s or \\". <|endcomment|> import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.Singleton; import java.io.IOException; import java.util.Collections; import java.util.HashSet; import java.util.Set; import java.util.TreeSet; import java.util.regex.Matcher; import java.util.regex.Pattern; @Singleton public class HashtagsUtil { private static final CharMatcher LEADER = WHITESPACE.or(CharMatcher.is('#')); <|startfocus|> private static final String PATTERN = "(?:\\s|\\A)#[A-Za-z0-9-_]+"; <|endfocus|> private final ChangeUpdate.Factory updateFactory; private final Provider<ReviewDb> dbProvider; private final ChangeIndexer indexer; private final ChangeHooks hooks; private final DynamicSet<HashtagValidationListener> hashtagValidationListeners; @Inject HashtagsUtil(ChangeUpdate.Factory updateFactory, Provider<ReviewDb> dbProvider, ChangeIndexer indexer, ChangeHooks hooks, DynamicSet<HashtagValidationListener> hashtagValidationListeners) { this.updateFactory = updateFactory; this.dbProvider = dbProvider; this.indexer = indexer; this.hooks = hooks; this.hashtagValidationListeners = hashtagValidationListeners; } 
<|startcomment|> nit: wrap this long line <|endcomment|>  public void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException { for (ChangeListenerHolder holder : listeners.values()) { <|startfocus|> if (isVisibleTo(change, holder.user, db)) { holder.listener.onEvent(event); } <|endfocus|> } fireEventForUnrestrictedListeners( event );
<|startcomment|> implements Realm is no longer necessary. <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.account; import com.google.common.base.Strings; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.AuthType; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.config.AuthConfig; import com.google.inject.Inject; import com.google.inject.Singleton; import java.util.Set; @Singleton <|startfocus|> public class DefaultRealm extends AbstractRealm implements Realm { <|endfocus|> private final EmailExpander emailExpander; private final AccountByEmailCache byEmail; private final AuthConfig authConfig; @Inject DefaultRealm(final EmailExpander emailExpander, final AccountByEmailCache byEmail, final AuthConfig authConfig) { this.emailExpander = emailExpander; this.byEmail = byEmail; this.authConfig = authConfig; } @Override public boolean allowsEdit(final Account.FieldName field) { if (authConfig.getAuthType() == AuthType.HTTP) { switch (field) { case USER_NAME: return false; case FULL_NAME:
<|startcomment|> statusRaw could return null. Which will fail in valueOf. String s = statusRaw(); return s != null ? Change.Status.valueOf(s) : null; <|endcomment|>  return arr; } } public static class RelatedInfo extends JavaScriptObject { public final native JsArray<ChangeAndCommit> changes() /*-{ return this.changes }-*/; protected RelatedInfo() { } } public static class ChangeAndCommit extends JavaScriptObject { static ChangeAndCommit create() { return (ChangeAndCommit) createObject(); } public final native String id() /*-{ return this.change_id }-*/; public final Change.Status status() { <|startfocus|> return Change.Status.valueOf(statusRaw()); <|endfocus|> } private final native String statusRaw() /*-{ return this.status; }-*/; public final native CommitInfo commit() /*-{ return this.commit }-*/; final native String branch() /*-{ return this.branch }-*/; final native void set_id(String i) /*-{ if(i)this.change_id=i; }-*/; final native void set_commit(CommitInfo c) /*-{ if(c)this.commit=c; }-*/; final native void set_branch(String b)
<|startcomment|> Some comment here about what you're doing and why would be nice. <|endcomment|> <|startfocus|> private static Injector buildInjector(final Injector parent) { <|endfocus|> return Guice.createInjector(Stage.DEVELOPMENT, new AbstractModule() { @Override protected void configure() { bind(SchemaVersion.class).to(SchemaVersion.C); for (Key<?> k : new Key<?>[]{ Key.get(PersonIdent.class, GerritPersonIdent.class), Key.get(String.class, AnonymousCowardName.class), }) { rebind(parent, k); } for (Class<?> c : new Class<?>[] { AllProjectsName.class, AllUsersCreator.class, GitRepositoryManager.class, SitePaths.class, }) { rebind(parent, Key.get(c)); } } private <T> void rebind(Injector parent, Key<T> c) { bind(c).toProvider(parent.getProvider(c)); } });
<|startcomment|> nit: should be before MergeableInfo <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.api.changes; import com.google.gerrit.extensions.common.MergeableInfo; <|startfocus|> import com.google.gerrit.extensions.common.FileInfo; <|endfocus|> import com.google.gerrit.extensions.restapi.NotImplementedException; import com.google.gerrit.extensions.restapi.RestApiException; import java.util.Map; import java.util.Set; public interface RevisionApi { void delete() throws RestApiException; void review(ReviewInput in) throws RestApiException; /** {@code submit} with {@link SubmitInput#waitForMerge} set to true. */ void submit() throws RestApiException; void submit(SubmitInput in) throws RestApiException; void publish() throws RestApiException; ChangeApi cherryPick(CherryPickInput in) throws RestApiException; ChangeApi rebase() throws RestApiException;
<|startcomment|> Unused. Is your Eclipse configuration wrong? Or are you using Emacs? <|endcomment|>  UiAction<RevisionResource> { private static final Logger log = LoggerFactory.getLogger(Submit.class); private static final String DEFAULT_TOOLTIP = "Submit patch set ${patchSet} into ${branch}"; private static final String DEFAULT_TOOLTIP_ANCESTORS = "Submit patch set ${patchSet} and ancestors (${submitSize} changes " + "altogether) into ${branch}"; private static final String DEFAULT_TOPIC_TOOLTIP = "Submit all ${topicSize} changes of the same topic " + <|startfocus|> "(${submitSize} changes including ancestors)"; <|endfocus|> private static final String BLOCKED_SUBMIT_TOOLTIP = "This change depends on other changes which are not ready"; private static final String BLOCKED_HIDDEN_SUBMIT_TOOLTIP = "This change depends on other hidden changes which are not ready"; private static final String CLICK_FAILURE_TOOLTIP = "Clicking the button would fail"; private static final String CLICK_FAILURE_OTHER_TOOLTIP = "Clicking the button would fail for other changes"; public static class Output { transient Change change; private Output(Change c) {
<|startcomment|> Doesn't this change belong in https://gerrit-review.googlesource.com/#/c/63211/1 ? <|endcomment|> import com.google.gerrit.server.git.RebaseSorter; import com.google.gerrit.server.patch.PatchSetInfoFactory; import com.google.gerrit.server.project.InvalidChangeOperationException; import com.google.gerrit.server.project.NoSuchChangeException; import com.google.gwtorm.server.OrmException; import org.eclipse.jgit.lib.ObjectId; import java.io.IOException; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; public class RebaseIfNecessary extends SubmitStrategy { <|startfocus|> private PatchSetInfoFactory patchSetInfoFactory; private RebaseChange rebaseChange; private Map<Change.Id, CodeReviewCommit> newCommits; <|endfocus|> RebaseIfNecessary(SubmitStrategy.Arguments args, PatchSetInfoFactory patchSetInfoFactory, RebaseChange rebaseChange) { super(args); this.patchSetInfoFactory = patchSetInfoFactory; this.rebaseChange = rebaseChange; this.newCommits = new HashMap<>(); } @Override protected CodeReviewCommit _run(CodeReviewCommit mergeTip, Collection<CodeReviewCommit> toMerge) throws MergeException { CodeReviewCommit newMergeTip = mergeTip; List<CodeReviewCommit> sorted = sort(toMerge); 
<|startcomment|> This actually should inherit from a RefEvent now I think. <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.replication; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.server.events.ChangeEvent; import com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult; <|startfocus|> public class RefReplicatedEvent extends ChangeEvent { <|endfocus|> public final String project; public final String ref; public final String targetNode; public final String status; public RefReplicatedEvent(String project, String ref, String targetNode, RefPushResult status) { super("ref-replicated"); this.project = project; this.ref = ref; this.targetNode = targetNode; this.status = toStatusString(status); } private String toStatusString(RefPushResult status) { return status.name().toLowerCase().replace("_", "-"); } @Override public String getType() { return type; } 
<|startcomment|> Issue log entry here? log.warn("Branch: " + branch + " doesn't exist"); <|endcomment|>  this.dbProvider = dbProvider; this.referenceUpdated = referenceUpdated; this.hooks = hooks; } @Override public Response<?> apply(ProjectResource project, Input input) throws OrmException, IOException, ResourceConflictException { input = Input.init(input); Repository r = repoManager.openRepository(project.getNameKey()); try { BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate(); for (String branch : input.branches) { Ref ref = r.getRefDatabase().getRef(branch); <|startfocus|> if (ref == null){ <|endfocus|> continue; } batchUpdate.addCommand(createDeleteCommand(project, ref)); } batchUpdate.execute(new RevWalk(r), NullProgressMonitor.INSTANCE); StringBuilder errorMessages = new StringBuilder(); for (ReceiveCommand command : batchUpdate.getCommands()) { if(command.getResult() == Result.OK){ referenceUpdated.fire(project.getNameKey(), command.getRefName(), command.getOldId(), command.getNewId()); Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), command.getRefName());
<|startcomment|> Nit: blank line goes between logger and other class constants, not before. <|endcomment|>  "(${submitSize} changes including ancestors and other " + "changes related by topic)"; private static final String BLOCKED_SUBMIT_TOOLTIP = "This change depends on other changes which are not ready"; private static final String BLOCKED_HIDDEN_SUBMIT_TOOLTIP = "This change depends on other hidden changes which are not ready"; private static final String CLICK_FAILURE_TOOLTIP = "Clicking the button would fail"; private static final String CLICK_FAILURE_OTHER_TOOLTIP = "Clicking the button would fail for other changes"; <|startfocus|> <|endfocus|> public static class Output { transient Change change; private Output(Change c) { change = c; } } private final Provider<ReviewDb> dbProvider; private final GitRepositoryManager repoManager; private final ChangeData.Factory changeDataFactory; private final ChangeMessagesUtil cmUtil; private final ChangeControl.GenericFactory changeControlFactory; private final Provider<MergeOp> mergeOpProvider; private final MergeSuperSet mergeSuperSet; private final AccountsCollection accounts; private final ChangesCollection changes; private final String label; private final ParameterizedString titlePattern;
<|startcomment|> editFileInfo <|endcomment|>  public EditScreen(Patch.Key patch) { this.revision = patch.getParentKey(); <|startfocus|> this.path = patch.get(); <|endfocus|> prefs = DiffPreferences.create(Gerrit.getAccountDiffPreference()); add(uiBinder.createAndBindUi(this)); addDomHandler(GlobalKey.STOP_PROPAGATION, KeyPressEvent.getType());
<|startcomment|> scheme != null or better, invert the logic so the first test is `scheme == null` <|endcomment|>  public String getSchemeRest() { String scheme = key.getScheme(); <|startfocus|> return null != scheme ? getExternalId().substring(scheme.length() + 1) <|endfocus|> : null;
<|startcomment|> necessary? <|endcomment|>  import com.google.inject.Inject; import com.google.inject.servlet.SessionScoped; import org.apache.http.HttpStatus; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @SessionScoped class GitHubLogin { private static final Logger log = LoggerFactory.getLogger(GitHubLogin.class); private final OAuthProtocol oauth; private String token; private String user; @Inject <|startfocus|> GitHubLogin(final OAuthProtocol oauth) { <|endfocus|> this.oauth = oauth; } boolean isLoggedIn() { return token != null && user != null; } boolean login(HttpServletRequest request, HttpServletResponse response) throws IOException { if (isLoggedIn()) { return true; } log.debug("Login " + this); if (OAuthProtocol.isOAuthFinal(request)) { String redirectUrl = oauth.getTargetUrl(request); if (redirectUrl == null) { response.sendError(HttpServletResponse.SC_NOT_FOUND); return false; } 
<|startcomment|> Is this the right order of arguments? Shouldn't this be switched? <|endcomment|>  areq.setEmailAddress(authFilter.getRemoteEmail(req)); final AuthResult arsp; try { arsp = accountManager.authenticate(areq); } catch (AccountException e) { log.error("Unable to authenticate user \"" + user + "\"", e); rsp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } String remoteExternalId = authFilter.getRemoteExternalIdToken(req); <|startfocus|> log.debug("Associating external identity \"{}\" to user \"{}\"", user, remoteExternalId); <|endfocus|> if (remoteExternalId != null) { try { updateRemoteExternalId(arsp, remoteExternalId); } catch (AccountException | OrmException e) { log.error("Unable to associate external identity \"" + remoteExternalId + "\" to user \"" + user + "\"", e); rsp.sendError(HttpServletResponse.SC_FORBIDDEN); return; } } final StringBuilder rdr = new StringBuilder(); if (arsp.isNew() && authConfig.getRegisterPageUrl() != null) { rdr.append(authConfig.getRegisterPageUrl()); } else {
<|startcomment|> make this a field and just add a builder style method to set it false? <|endcomment|>  checkArgument(old == null || old == op.ctl, "mismatched ChangeControls for change %s", id); changeOps.put(id, op); changeControls.put(id, op.ctl); } // TODO(dborowitz): Support async operations? public void addPostOp(PostOp update) { postOps.add(update); } public void execute() throws UpdateException { execute(true); } <|startfocus|> // TODO(dborowitz): Remove doRefUpdates once callers are fully migrated. public void execute(boolean doRefUpdates) throws UpdateException { <|endfocus|> if (doRefUpdates) { executeRefUpdates(); } executeChangeOps(); reindexChanges(); executePostOps(); } private void executeRefUpdates() throws UpdateException { if (batchRefUpdate.getCommands().isEmpty()) { return; } try { inserter.flush(); batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE); boolean ok = true; for (ReceiveCommand cmd : batchRefUpdate.getCommands()) { if (cmd.getResult() != ReceiveCommand.Result.OK) { ok = false; break; } }
<|startcomment|> Remove this if not needed. <|endcomment|>  if (myself != null) { List<GHEmail> emails = myself.getEmails2(); ReviewDb db = null; try { db = this.schema.open(); AccountAccess accounts = db.accounts(); for (GHEmail email: emails) { List<Account> results = accounts.byPreferredEmail(email.getEmail()).toList(); if (results.size() > 1) { //httpResponse.sendRedirect(String.format("%s?email=%s", PREFERRED_EMAIL_ERROR_PAGE, email.getEmail())); <|startfocus|> log.error(String.format("'%s' is register as preferred email for multiple accounts", email.getEmail())); <|endfocus|> break; } Account.Id accountId =results.get(0).getId(); AccountExternalId.Key gitHubKey = new AccountExternalId.Key(AccountExternalId.SCHEME_GERRIT, myself.getLogin()); // Do we already have the entry if (haveGitHubIdEntry(db, accountId, gitHubKey)) { break; } log.info(String.format("Inserting external id entry for '%s' " +
<|startcomment|> This is now a no-op change, unrelated to this change as a whole. <|endcomment|> <|startfocus|> void loadChangeInfo(boolean f, AsyncCallback<ChangeInfo> cb) { <|endfocus|> RestApi call = ChangeApi.detail(changeId.get()); ChangeList.addOptions(call, EnumSet.of( ListChangesOption.CHANGE_ACTIONS, ListChangesOption.ALL_REVISIONS)); if (!f) { call.background(); } call.get(cb);
<|startcomment|> Constant up by index.md <|endcomment|>  Repository repo = ServletUtils.getRepository(req); RevWalk rw = new RevWalk(repo); try { String path = view.getPathPart(); RevTree root = getRoot(view, rw); if (root == null) { res.setStatus(SC_NOT_FOUND); return; } SourceFile srcmd = findFile(rw, root, path); if (srcmd == null) { res.setStatus(SC_NOT_FOUND); return; } <|startfocus|> SourceFile navmd = findFile(rw, root, "navbar.md"); String etag = req.getHeader(HttpHeaders.IF_NONE_MATCH); if (etag != null && etag.equals(etag(srcmd, navmd))) { <|endfocus|> res.setStatus(SC_NOT_MODIFIED); return; } view = view.toBuilder().setPathPart(srcmd.path).build(); srcmd.read(rw.getObjectReader()); if (navmd != null) { navmd.read(rw.getObjectReader()); } MarkdownHelper fmt = new MarkdownHelper(view); RootNode doc = parseFile(view, fmt, srcmd); if (doc == null) {
<|startcomment|> This also needs to be done conditionally. <|endcomment|>  d = w - i; } if (0 < inserted) { sb.openDiv() .setStyleName(R.css().inserted()) .setAttribute("style", "width:" + i + "px") .closeDiv(); } if (0 < deleted) { sb.openDiv() .setStyleName(R.css().deleted()) .setAttribute("style", "width:" + d + "px") <|startfocus|> .closeDiv(); <|endfocus|> } sb.closeTh(); sb.closeTr();
<|startcomment|> unused import <|endcomment|> import com.google.gerrit.client.rpc.GerritCallback; import com.google.gerrit.client.rpc.Natives; import com.google.gwt.event.dom.client.ClickHandler; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.user.client.ui.Widget; import com.google.gwt.user.client.ui.CheckBox; import com.google.gwt.user.client.ui.FlowPanel; import com.google.gwt.user.client.ui.FocusWidget; import com.google.gwt.user.client.ui.SuggestBox; import com.google.gwt.user.client.ui.SuggestOracle.Suggestion; <|startfocus|> import com.google.gwtexpui.globalkey.client.GlobalKey; <|endfocus|> import com.google.gwtexpui.safehtml.client.HighlightSuggestOracle; import java.util.LinkedList; import java.util.List; public abstract class RebaseDialog extends CommentedActionDialog { private final SuggestBox base; private final CheckBox cb; private List<ChangeInfo> changes; public RebaseDialog(final String project, final String branch) { super(Util.C.rebaseTitle(), null); // create the suggestion box base = new SuggestBox( new HighlightSuggestOracle() { @Override protected void onRequestSuggestions(Request request, Callback done) {
<|startcomment|> Do not import the UUID class, but rather use AccountGroup.UUID. <|endcomment|>  import static com.google.gerrit.server.account.GroupBackends.GROUP_REF_NAME_COMPARATOR; import com.google.common.collect.ArrayListMultimap; import com.google.common.collect.ImmutableMap; import com.google.common.collect.Iterables; import com.google.common.collect.Multimap; import com.google.common.collect.Sets; import com.google.gerrit.common.Nullable; import com.google.gerrit.common.data.GroupDescription; import com.google.gerrit.common.data.GroupReference; import com.google.gerrit.extensions.registration.DynamicSet; import com.google.gerrit.reviewdb.client.AccountGroup; <|startfocus|> import com.google.gerrit.reviewdb.client.AccountGroup.UUID; import com.google.gerrit.server.IdentifiedUser; import com.google.gerrit.server.auth.ldap.LdapGroupBackend; import com.google.gerrit.server.project.ProjectControl; <|endfocus|> import com.google.inject.Inject; import com.google.inject.Singleton; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.Collection; import java.util.Map; import java.util.Set; /** * Universal implementation of the GroupBackend that works with the injected * set of GroupBackends. */ @Singleton public class UniversalGroupBackend implements GroupBackend { private static final Logger log =
<|startcomment|> // after these? Also just startsWith("//")? <|endcomment|>  public static boolean isValidHttpUri(String val) { <|startfocus|> return (val.startsWith("http:") || val.startsWith("https:")) <|endfocus|> && URI.getValueFilter().matcher(val).find();
<|startcomment|> 2015 <|endcomment|> <|startfocus|> Copyright (C) 2009 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.client.ui; import com.google.gerrit.client.Gerrit; import com.google.gwt.event.dom.client.ClickEvent; import com.google.gwt.event.dom.client.ClickHandler; import com.google.gwt.event.logical.shared.CloseEvent; import com.google.gwt.event.logical.shared.CloseHandler; import com.google.gwt.user.client.ui.Button; import com.google.gwt.user.client.ui.FlowPanel; import com.google.gwt.user.client.ui.FocusWidget;
<|startcomment|> do we need this line, when we have @return below? <|endcomment|>  public void addEventListener(EventListener listener, CurrentUser user) { <|startfocus|> listeners.put(listener, new EventListenerHolder(listener, user)); <|endfocus|>
<|startcomment|> What's this needed for? <|endcomment|> import static com.google.gerrit.server.ioutil.BasicSerialization.writeString; import static org.eclipse.jgit.lib.ObjectIdSerialization.readNotNull; import static org.eclipse.jgit.lib.ObjectIdSerialization.writeNotNull; import com.google.common.base.MoreObjects; import com.google.common.cache.Cache; import com.google.common.cache.Weigher; import com.google.common.collect.BiMap; import com.google.common.collect.ImmutableBiMap; import com.google.common.util.concurrent.UncheckedExecutionException; import com.google.gerrit.extensions.client.SubmitType; <|startfocus|> import com.google.gerrit.reviewdb.client.Branch; <|endfocus|> import com.google.gerrit.server.cache.CacheModule; import com.google.gerrit.server.git.CodeReviewCommit; import com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk; import com.google.gerrit.server.git.IntegrationException; import com.google.gerrit.server.git.strategy.SubmitDryRun; import com.google.gerrit.server.project.NoSuchProjectException; import com.google.inject.Inject; import com.google.inject.Module; import com.google.inject.Singleton; import com.google.inject.name.Named; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.Ref; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevCommit;
<|startcomment|> In the unit tests, extends the ScheduledThreadPoolExecutor, override the execute method and move this line in that method. Then setup a mock of the EventQueue that will return this implementation of ScheduledThreadPoolExecutor. This way, the task will be executed in the same thread for the unit tests. <|endcomment|>  public void onEvent(Event event) { <|startfocus|> if (event instanceof ProjectEvent) { if (pool != null) { pool.execute(new StoreEventTask((ProjectEvent) event)); } else { (new StoreEventTask((ProjectEvent) event)).run(); } } <|endfocus|>
<|startcomment|> Oooh. Here be dragons. You can't actually do this. Is this a findbugs thing you are trying to "fix"? hashCode() needs to be stable for an object. But val is mutated to be different things during the execution of a Prolog program. A VariableTerm that was stored in a HashMap as a key needs to have the same hashCode through its life. The default java.lang.Object hashCode() implementation gives a stable hash for the variable. I think that makes more sense then trying to define our own hashCode for the object based on a mutable property. Relying on the object identity hashCode still gets us "some" value of a.hashCode() == b.hashCode() if a.equals(b). <|endcomment|>  public int hashCode() { <|startfocus|> return val.hashCode(); <|endfocus|>
<|startcomment|> Since you're invalidating all existing cache entries, you need to bump the serialVersionID. <|endcomment|>  return new Loader(key, repoManager, project, rw, repoConfig).call(); } catch (IOException e) { log.warn( "Cannot check trivial rebase of new patch set " + next.name() + " in " + project, e); return ChangeKind.REWORK; } } @Override public ChangeKind getChangeKind(ReviewDb db, Change change, PatchSet patch) { return getChangeKindInternal(this, db, change, patch, changeDataFactory, repoManager); } @Override <|startfocus|> public ChangeKind getChangeKind( @Nullable RevWalk rw, @Nullable Config repoConfig, ChangeData cd, PatchSet patch) { return getChangeKindInternal(this, rw, repoConfig, cd, patch); <|endfocus|> } } public static class Key implements Serializable { private static final long serialVersionUID = 1L; private transient ObjectId prior; private transient ObjectId next; private transient String strategyName; private Key(ObjectId prior, ObjectId next, boolean useRecursiveMerge) { checkNotNull(next, "next"); String strategyName = MergeUtil.mergeStrategyName(true, useRecursiveMerge);
<|startcomment|> Is there any reason to not use `checkNotNull`? <|endcomment|>  public TestAccount get(String username) { <|startfocus|> TestAccount account = accounts.get(username); checkArgument(account != null, "No TestAccount created for %s", username); return account; <|endfocus|>
<|startcomment|> Remove <|endcomment|>  * {@link com.google.gerrit.extensions.api.accounts.Accounts#id(String)} * @throws RestApiException */ void deleteMembers(String... members) throws RestApiException; /** * Add groups to be included in this one. * * @param members list of group identifiers, in any format accepted by * {@link Groups#id(String)} * @throws RestApiException */ void addGroups(String... groups) throws RestApiException; /** <|startfocus|> * Delete included groups from this one. <|endfocus|> * * @param members list of group identifiers, in any format accepted by * {@link Groups#id(String)} * @throws RestApiException */ void deleteGroups(String... groups) throws RestApiException; } 
<|startcomment|> No need for an extra lookup here, repo.branch("HEAD")...create() will return an ObjectId. <|endcomment|>  grant(Permission.SUBMIT, project, "refs/for/refs/heads/*"); return cloneProject(project); } private ObjectId pushChangeTo(TestRepository<?> repo, String branch, String message) throws Exception { repo.branch("HEAD").commit().insertChangeId() .message(message) .add("a.txt", "a contents") .create(); repo.git().push().setRemote("origin").setRefSpecs( new RefSpec("HEAD:refs/heads/" + branch)).call(); <|startfocus|> return repo.getRepository().resolve("HEAD"); <|endfocus|> } private ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception { return pushChangeTo(repo, branch, "some change"); } private void createSubscription( TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception { subscribeToRepo = name(subscribeToRepo); // The submodule subscription module checks for gerrit.canonicalWebUrl to // detect if it's configured for automatic updates. It doesn't matter if // it serves from that URL.
<|startcomment|> There is no need to copy the javadoc from the method definition in the (implemented) interface. If anything changes then this javadoc has to be maintained in two places. <|endcomment|>  /** * Fire the Patchset Created Hook. * * @param change The change itself. * @param patchSet The Patchset that was created. * @throws OrmException */ public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException { final PatchSetCreatedEvent event = new PatchSetCreatedEvent(); final AccountState uploader = accountCache.get(patchSet.getUploader()); final AccountState owner = accountCache.get(change.getOwner()); <|startfocus|> boolean isTrivialRebase = false; boolean noCodeChange = false; <|endfocus|> ChangeKind kind = changeKindCache.getChangeKind(db, change, patchSet); switch (kind) { case TRIVIAL_REBASE: isTrivialRebase = true; break; case NO_CODE_CHANGE: noCodeChange = true; break; default: // intentionally left blank } event.change = eventFactory.asChangeAttribute(change); event.patchSet = eventFactory.asPatchSetAttribute(patchSet); event.uploader = eventFactory.asAccountAttribute(uploader.getAccount()); event.kind = kind; fireEvent(change, event, db);
<|startcomment|> `name` can be used here. <|endcomment|>  for (Map.Entry<String, Ref> e : refs.entrySet()) { String name = e.getKey(); if (name.startsWith("imports/")) { continue; } if (name.startsWith("cache-automerge/")) { continue; } if (name.startsWith("changes/")) { continue; } if (name.startsWith("users/") && name.contains("/edit")) { continue; } <|startfocus|> String targetRef = Constants.R_REFS + e.getKey(); <|endfocus|> RefUpdate ru = repo.updateRef(targetRef); ru.setNewObjectId(e.getValue().getObjectId()); RefUpdate.Result result = ru.forceUpdate(); switch (result) { case NEW: case FAST_FORWARD: case FORCED: case NO_CHANGE: break; default: throw new IOException(String.format( "Failed to update %s, RefUpdate.Result = %s", targetRef, result)); } } } } 
<|startcomment|> Shorter: if (n == Account.FieldName.REGISTER_NEW_EMAIL && (emailSender == null || !emailSender.isEnabled())) { continue; } fields.add(n); } <|endcomment|>  config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500)); config.setArchiveFormats(Lists.newArrayList(Iterables.transform( archiveFormats.getAllowed(), new Function<ArchiveFormat, String>() { @Override public String apply(ArchiveFormat in) { return in.getShortName(); } }))); config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true)); <|startfocus|> config.setAvatarSupport(avatarSupport); <|endfocus|> final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl"); config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list"); config.setReportBugText(cfg.getString("gerrit", null, "reportBugText")); final Set<Account.FieldName> fields = new HashSet<>(); for (final Account.FieldName n : Account.FieldName.values()) { if (realm.allowsEdit(n)) { fields.add(n); } } if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
<|startcomment|> Tabs to Spaces :-) <|endcomment|> // limitations under the License. package com.googlesource.gerrit.plugins.gitblit; import org.eclipse.jgit.lib.Config; import com.google.gerrit.extensions.annotations.PluginName; import com.google.gerrit.pgm.init.api.ConsoleUI; import com.google.gerrit.pgm.init.api.InitFlags; import com.google.gerrit.pgm.init.api.InitStep; import com.google.gerrit.pgm.init.api.Section; import com.google.gerrit.pgm.init.api.Section.Factory; import com.google.inject.Inject; public class GitBlitInitStep implements InitStep { <|startfocus|> private final ConsoleUI ui; private final String pluginName; private final Factory sections; private final Config cfg; <|endfocus|> @Inject public GitBlitInitStep(ConsoleUI ui, Section.Factory sections, @PluginName String pluginName, InitFlags flags) { this.ui = ui; this.pluginName = pluginName; this.sections = sections; this.cfg = flags.cfg; } @Override public void run() throws Exception { ui.message("\n"); ui.header("GitBlit Integration"); if(ui.yesno(true, "Do you want to use GitBlit as your GitWeb viewer ?")) {
<|startcomment|> is <|endcomment|> import java.sql.SQLException; import java.util.HashSet; import java.util.Set; /** Internal base class for implementations of {@link Schema}. */ public abstract class JdbcSchema extends AbstractSchema { private final Database<?> dbDef; private Connection conn; private boolean lockedDatabaseAccess; protected JdbcSchema(final Database<?> d) throws OrmException { dbDef = d; conn = dbDef.newConnection(); } public final Connection getConnection() { if (lockedDatabaseAccess) { <|startfocus|> throw new IllegalStateException("Database access was locked"); <|endfocus|> } return conn; } public final SqlDialect getDialect() { return dbDef.getDialect(); } @Override public void commit() throws OrmException { try { if (!conn.getAutoCommit()) { conn.commit(); } } catch (SQLException err) { throw new OrmException("Cannot commit transaction", err); } finally { try { conn.setAutoCommit(true); } catch (SQLException err) { throw new OrmException("Cannot set auto commit mode", err); } } } 
<|startcomment|> Why 's'? <|endcomment|>  public final native void syntaxHighlighting(boolean s) /*-{ this.syntax_highlighting = s }-*/; public final native void hideLineNumbers(boolean s) /*-{ this.hide_line_numbers = s }-*/; public final void showLineNumbers(boolean s) { hideLineNumbers(!s); } <|startfocus|> public final KeyMap keyMap() { String s = keyMapRaw(); return s != null ? KeyMap.valueOf(s) : KeyMap.DEFAULT; } private final native String keyMapRaw() /*-{ return this.key_map }-*/; <|endfocus|> public final Theme theme() { String s = themeRaw(); return s != null ? Theme.valueOf(s) : Theme.DEFAULT; } private final native String themeRaw() /*-{ return this.theme }-*/; public final int tabSize() {return get("tab_size", 8); } public final int lineLength() {return get("line_length", 100); } public final native boolean lineWrapping() /*-{ return this.line_wrapping || false }-*/;
<|startcomment|> May be put a comment here, that this is just a verbose was to say: amqpProperties.setTimestamp(new Date(TimeUtil.nowMs()); <|endcomment|>  break; default: break; } } catch (Exception ex) { LOGGER.info(ex.getMessage()); } } } } Message message = properties.getSection(Message.class); amqpProperties = new AMQP.BasicProperties.Builder() .appId(EVENT_APPID) .contentEncoding(CharEncoding.UTF_8) .contentType(CONTENT_TYPE_JSON) .deliveryMode(message.deliveryMode) .priority(message.priority) .headers(headers) <|startfocus|> .timestamp(new Date()) <|endfocus|> .build(); } return amqpProperties; } } 
<|startcomment|> remove <|endcomment|>  * * @param project the name of the project * @param commit the ID of the commit for which it should be checked if it is * included * @param tags the tags that include the commit * @param branches the branches that include the commit * @return a list of systems that contain the given commit, e.g. names of * servers on which this commit is deployed */ <|startfocus|> public List<String> getIncludedIn(String project, String commit, <|endfocus|> Collection<String> tags, Collection<String> branches); } 
<|startcomment|> Why are we not providing the port anymore? Shouldn't it be new HttpHost(URI.create(url).getHost(), URI.create(url).getPort()) ? <|endcomment|>  public HttpSession(GerritServer server, TestAccount account) { this.url = CharMatcher.is('/').trimTrailingFrom(server.getUrl()); this.executor = Executor .newInstance() <|startfocus|> .auth(new HttpHost(URI.create(url).getHost()), <|endfocus|> account.username, account.httpPassword);
<|startcomment|> And here <|endcomment|>  if (hook != null) { return hook; } final String scproot = "com/google/gerrit/server/tools/root"; final String path = scproot + "/hooks/" + name; URL url = cl().getResource(path); assertThat(url).isNotNull(); String protocol = url.getProtocol(); assertThat(protocol).isAnyOf("file", "jar"); if ("file".equals(protocol)) { hook = new File(url.getPath()); <|startfocus|> assertThat(hook.isFile()).isTrue(); <|endfocus|> long time = hook.lastModified(); hook.setExecutable(true); hook.setLastModified(time); hooks.put(name, hook); } else if ("jar".equals(protocol)) { InputStream in = url.openStream(); try { hook = File.createTempFile("hook_", ".sh"); cleanup.add(hook); FileOutputStream out = new FileOutputStream(hook); try { ByteStreams.copy(in, out); } finally { out.close(); } } finally { in.close(); } hook.setExecutable(true);
<|startcomment|> Bad rebase? <|endcomment|>  result = newGson().fromJson(r.getReader(), new TypeToken<List<TaskInfo>>() {}.getType()); r.consume(); assertThat(result).hasSize(taskCount - 1); } @Test public void killTask_NotFound() throws Exception { RestResponse r = adminSession.get("/config/server/tasks/"); List<TaskInfo> result = newGson().fromJson(r.getReader(), new TypeToken<List<TaskInfo>>() {}.getType()); r.consume(); <|startfocus|> assertThat(result.size()).isEqualTo(0); <|endfocus|> } } 
<|startcomment|> I'm not sure a subsection makes sense here, why not just gitiles.docroot? <|endcomment|>  private Handler appHandler() { DebugRenderer renderer = new DebugRenderer( STATIC_PREFIX, Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), new File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/templates") .getPath(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles")); <|startfocus|> String docRoot = cfg.getString("gitiles", "docroot", "gitdir"); <|endfocus|> Servlet servlet; if (!Strings.isNullOrEmpty(docRoot)) { servlet = createRootedDocServlet(renderer, docRoot); } else { servlet = new GitilesServlet( cfg, renderer, null, null, null, null, null, null, null); } ServletContextHandler handler = new ServletContextHandler(); handler.setContextPath(""); handler.addServlet(new ServletHolder(servlet), "/*"); return handler;
<|startcomment|> Comment why this shortcut is ok. <|endcomment|>  } } catch (ResourceConflictException e) { msgbuf.append(e.getMessage() + "\n"); problemChanges.add(id); } } String reason = msgbuf.toString(); if (!reason.isEmpty()) { throw new ResourceConflictException("The change could not be " + "submitted because it depends on change(s) " + problemChanges.toString() + ", which could not be submitted " + "because:\n" + reason); } } <|startfocus|> public void merge(ReviewDb db, Change change, IdentifiedUser caller, <|endfocus|> boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException { logPrefix = String.format("[%s]: ", String.valueOf(change.hashCode())); this.db = db; logDebug("Beginning integration of {}", change); try { ChangeSet cs = mergeSuperSet.completeChangeSet(db, change); logDebug("Calculated to merge {}", cs); if (checkSubmitRules) { logDebug("Checking submit rules and state"); checkSubmitRulesAndState(cs); } try {
<|startcomment|> Now, that AccountDiffPreference table was migrated to Git backend: [1], what is the plan to migrate AccountSshKey table to Git backend? * [1] https://gerrit-review.googlesource.com/#/c/61604 <|endcomment|>  /** Magic user branch in All-Users {@code refs/users/self} */ public static final String REFS_USERS_SELF = "refs/users/self"; /** Default user preference settings */ public static final String REFS_USERS_DEFAULT = RefNames.REFS_USERS + "default"; /** Configurations of project-specific dashboards (canned search queries). */ public static final String REFS_DASHBOARDS = "refs/meta/dashboards/"; <|startfocus|> /** Draft inline comments of a user on a change */ <|endfocus|> public static final String REFS_DRAFT_COMMENTS = "refs/draft-comments/"; /** A change starred by a user */ public static final String REFS_STARRED_CHANGES = "refs/starred-changes/"; /** Sequence counters in NoteDb. */ public static final String REFS_SEQUENCES = "refs/sequences/"; /** * Prefix applied to merge commit base nodes. * * <p>References in this directory should take the form {@code refs/cache-automerge/xx/yyyy...}
<|startcomment|> If you follow my advice above, withSpread doesn't need to be a field at all, since it's not used outside of the completeChangeSet method. I would go one step further and make changes not a field as well. You'll have to pass it in to a few of your private methods but I don't think that's too onerous. Once you do that this whole class can be a @Singleton. <|endcomment|>  * branch for the merging/rebasing submit strategies. For the cherry-pick * strategy no additional changes are included. */ public class MergeSuperSet { public interface Factory { MergeSuperSet create(ChangeSet changes, boolean withSpread); } private static final Logger log = LoggerFactory.getLogger(MergeOp.class); private final ChangeData.Factory changeDataFactory; private final Provider<InternalChangeQuery> queryProvider; private final GitRepositoryManager repoManager; private final SchemaFactory<ReviewDb> schemaFactory; <|startfocus|> private ChangeSet changes; private boolean withSpread; <|endfocus|> @Inject MergeSuperSet(ChangeData.Factory changeDataFactory, Provider<InternalChangeQuery> queryProvider, GitRepositoryManager repoManager, SchemaFactory<ReviewDb> schemaFactory, @Assisted ChangeSet changes, @Assisted boolean withSpread) { this.changeDataFactory = changeDataFactory; this.queryProvider = queryProvider; this.repoManager = repoManager; this.schemaFactory = schemaFactory; this.changes = changes; this.withSpread = withSpread; } private ChangeSet calculateCompleteChangeSet(ReviewDb db) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException { 
<|startcomment|> This will cause it to stop on the first error. Would it be better to have separate handling of the initial query, and on the abandon? Then if the query fails, abort. But if an abandon fails, log it and continue to the next? <|endcomment|>  try { String query = "status:open age:" + TimeUnit.MILLISECONDS.toMinutes(cfg.getAbandonAfter()) + "m"; List<ChangeData> changesToAbandon = queryProcessor.enforceVisibility(false) .queryChanges(queryBuilder.parse(query)).changes(); for (ChangeData cd : changesToAbandon) { try { abandon.abandon(changeControl(cd), cfg.getAbandonMessage(), null); } catch (ResourceConflictException e) { // Change was already merged or abandoned. } } <|startfocus|> } catch (Throwable e) { <|endfocus|> log.error("Failed to auto-abandon inactive open changes.", e); }
<|startcomment|> Batch by project so you only have to open each repo once. <|endcomment|>  SubmoduleSectionParser.Factory subSecParserFactory) { this.urlProvider = urlProvider; this.schemaFactory = sf; this.myIdent = myIdent; this.repoManager = repoManager; this.gitRefUpdated = gitRefUpdated; this.account = account; this.changeHooks = changeHooks; this.subSecParserFactory = subSecParserFactory; updatedSubscribers = new HashSet<>(); } protected void updateSubmoduleSubscriptions(Set<Branch.NameKey> branches) throws SubmoduleException { for (Branch.NameKey branch : branches) { <|startfocus|> updateSubmoduleSubscriptions(branch); <|endfocus|> } } protected void updateSubmoduleSubscriptions(Branch.NameKey destBranch) throws SubmoduleException { if (urlProvider.get() == null) { logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file."); } try (ReviewDb schema = schemaFactory.open();) { Repository repo = repoManager.openRepository(destBranch.getParentKey()); ObjectId id = repo.resolve(destBranch.get()); RevWalk rw = CodeReviewCommit.newRevWalk(repo);
<|startcomment|> use this instead, it fixes the tests: this.getClass().getResourceAsStream(existingKey); <|endcomment|>  private InputStream loadFile(String file) { <|startfocus|> return ClassLoader.getSystemResourceAsStream(file); <|endfocus|>
<|startcomment|> Hmm, how about adding an early check for the placeholder case instead? Like this after line 88 at the beginning of the method: if (project.startsWith('$') || ref.startsWith('$')) { // No real value but placeholders are being used. return ref; } And in exchange remove this code as well as the one starting at line 104. And I would keep the log.error() from the previous patch set here. <|endcomment|>  Config cfg = repo.getConfig(); if (cfg.getBoolean(UPLOADPACK, KEY_ALLOW_TIP_SHA1_IN_WANT, false) && Arrays.asList(cfg.getStringList(UPLOADPACK, null, KEY_HIDE_REFS)) .contains(RefNames.REFS_CHANGES)) { ObjectId id = repo.resolve(ref); if (id != null) { return id.name(); } else { <|startfocus|> // instead of a real ref a placeholder such as '${ref}' may be given return ref; <|endfocus|> } } else { return ref; } } catch (RepositoryNotFoundException e) { // Ignored: instead of a real project name a placeholder such as // '${project}' may be given return ref; } catch (IOException e) { log.error( String.format("Failed to lookup project %s from cache.", project), e); return null; }
<|startcomment|> db <|endcomment|>  + " config file is invalid.", e); } catch (IOException e) { logAndThrowSubmoduleException( "Problem at update of subscriptions table from " + GIT_MODULES + ".", e); } catch (URISyntaxException e) { logAndThrowSubmoduleException( "Incorrect gerrit canonical web url provided in gerrit.config file.", e); } } <|startfocus|> protected void updateSuperProjects(Set<Branch.NameKey> updatedBranches) throws SubmoduleException { try (ReviewDb schema = schemaFactory.open();) { <|endfocus|> // These (repo/branch) will be updated later with all the given // individual submodule subscriptions Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create(); for (Branch.NameKey updatedBranch : updatedBranches) { for (SubmoduleSubscription sub : schema.submoduleSubscriptions() .bySubmodule(updatedBranch)) { targets.put(sub.getSuperProject(), sub); } } updatedSubscribers.addAll(Sets.newHashSet(updatedBranches)); // update subscribers for (Branch.NameKey dest : targets.keySet()) { try {
<|startcomment|> Use placeHolderUrlProject here? <|endcomment|> <|startfocus|> private String getLinkName() { <|endfocus|> return name ;
<|startcomment|> SideBySide and Unified <|endcomment|> import com.google.gwt.dom.client.Style.Unit; import com.google.gwt.user.client.DOM; import com.google.gwt.user.client.EventListener; import net.codemirror.lib.CodeMirror; import net.codemirror.lib.CodeMirror.LineClassWhere; import net.codemirror.lib.Configuration; import net.codemirror.lib.LineWidget; import net.codemirror.lib.Pos; import net.codemirror.lib.TextMarker; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; <|startfocus|> /** Colors modified regions for {@link SideBySide}. */ <|endfocus|> abstract class ChunkManager { static final native void onClick(Element e, JavaScriptObject f) /*-{ e.onclick = f }-*/; private final Scrollbar scrollbar; private final LineMapper mapper; private List<DiffChunkInfo> chunks; private List<TextMarker> markers; private List<Runnable> undo; ChunkManager(Scrollbar scrollbar) { this.scrollbar = scrollbar; this.mapper = new LineMapper(); } LineMapper getLineMapper() { return mapper; } DiffChunkInfo getFirst() { return !chunks.isEmpty() ? chunks.get(0) : null;
<|startcomment|> wrap this line <|endcomment|>  public void onLoad(Panel panel) { <|startfocus|> AccountInfo accountInfo = panel.getObject(GerritUiExtensionPoint.Key.ACCOUNT_INFO).cast(); <|endfocus|> panel.setWidget(new CookBookProfileExtension(accountInfo));
<|startcomment|> Injecting MetaDataUpdate.User into a singleton may lead to bad commit timestamps, see [1]. [1] https://gerrit-review.googlesource.com/69265 <|endcomment|> import com.google.gerrit.server.config.AllUsersName; import com.google.gerrit.server.git.MetaDataUpdate; import com.google.gerrit.server.git.UserConfigSections; import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.Singleton; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.errors.RepositoryNotFoundException; import java.io.IOException; @Singleton public class SetEditPreferences implements RestModifyView<AccountResource, EditPreferencesInfo> { private final Provider<CurrentUser> self; <|startfocus|> private final MetaDataUpdate.User metaDataUpdateFactory; <|endfocus|> private final AllUsersName allUsersName; @Inject SetEditPreferences(Provider<CurrentUser> self, MetaDataUpdate.User metaDataUpdateFactory, AllUsersName allUsersName) { this.self = self; this.metaDataUpdateFactory = metaDataUpdateFactory; this.allUsersName = allUsersName; } @Override public Response<?> apply(AccountResource rsrc, EditPreferencesInfo in) throws AuthException, BadRequestException, RepositoryNotFoundException, IOException, ConfigInvalidException { if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
<|startcomment|> nit: unrelated code reformatting <|endcomment|>  .annotatedWith(UniqueAnnotations.create()) .to(OnStartStop.class); bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to( ReplicationLogFile.class); bind(CredentialsFactory.class).to( AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON); bind(CapabilityDefinition.class) .annotatedWith(Exports.named(START_REPLICATION)) .to(StartReplicationCapability.class); install(new FactoryModuleBuilder().build(PushAll.Factory.class)); install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class)); bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class); <|startfocus|> bind(ReplicationStateListener.class).to(ReplicationStateLogger.class); <|endfocus|> bind(ReplicationSshSessionFactory.class).to( DefaultReplicationSshSessionFactory.class); EventTypes.registerClass(new RefReplicatedEvent(null, null, null, SUCCEEDED)); EventTypes.registerClass(new RefReplicationDoneEvent(null, null, 0));
<|startcomment|> No assert of some sort? Maybe the code under test is not testable enough then; would revisit it. <|endcomment|>  Files.createFile(dir.resolve(key)); assertThat(flatFileWebSessionCache.asMap()).isEmpty(); loadExistingKeyToCacheDir(); assertThat(flatFileWebSessionCache.asMap()).containsKey(existingKey); } @Test public void constructorCreateDir() throws IOException { Path testDir = Paths.get("tmp"); flatFileWebSessionCache = new FlatFileWebSessionCache(testDir); assertThat(Files.exists(testDir)).isTrue(); Files.deleteIfExists(testDir); } @Test <|startfocus|> public void cleanUpTest() throws Exception { loadExistingKeyToCacheDir(); flatFileWebSessionCache.cleanUp(); assertThat(isDirEmpty(dir)).isTrue(); } @Test <|endfocus|> public void getAllPresentTest() throws Exception { Files.createFile(dir.resolve(key)); loadExistingKeyToCacheDir(); List<String> keys = Arrays.asList(new String[] {key, existingKey}); assertThat(flatFileWebSessionCache.getAllPresent(keys)) .containsKey(existingKey); } @Test public void getIfPresentKeyDoesNotExistTest() throws Exception { assertThat(flatFileWebSessionCache.getIfPresent(key)).isNull(); } @Test
<|startcomment|> How about something more specific and closer to the old thing that got added as a ChangeMessage: "Change X depends on patch set A of change Y, but the latest patch set is B" <|endcomment|>  throws ResourceConflictException, OrmException { StringBuilder msgbuf = new StringBuilder(); List<Change.Id> problemChanges = new ArrayList<>(); for (PatchSet.Id id : cs.patchIds()) { try { ChangeData cd = changeDataFactory.create(db, id.getParentKey()); if (!cd.change().currentPatchSetId().equals(id)) { <|startfocus|> throw new ResourceConflictException("Change " + cd.change().getChangeId() + " was not included with its newest patchset."); <|endfocus|> } if (cd.change().getStatus() != Change.Status.NEW){ throw new ResourceConflictException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus()); } else { records.put(cd.change().getId(), checkSubmitRule(cd)); } } catch (ResourceConflictException e) { msgbuf.append(e.getMessage() + "\n"); problemChanges.add(id.getParentKey()); } } String reason = msgbuf.toString(); if (!reason.isEmpty()) {
<|startcomment|> this .copy() is pointless. parseCommit does not retain the passed in ObjectId in any way. The Ref is very likely giving you an ObjectId anyway, whose copy() is implemented as return this, making this a no-op. <|endcomment|>  Ref ref = repo.getRefDatabase().exactRef(RefNames.REFS_GPG_KEYS); if (ref == null) { return; } try (RevWalk rw = new RevWalk(reader)) { notes = NoteMap.read( rw.getObjectReader(), rw.parseCommit(ref.getObjectId())); } } /** * Read public keys with the given key ID. * <p> <|startfocus|> * Keys should not be trusted unless verified with {@link PublicKeyVerifier}. <|endfocus|> * <p> * Multiple calls to this method use the same state of the key ref; to reread * the ref, call {@link #close()} first. * * @param keyId key ID. * @return any keys found that could be successfully parsed. * @throws PGPException if an error occurred parsing the key data. * @throws IOException if an error occurred reading the repository data. */ public PGPPublicKeyRingCollection get(long keyId) throws PGPException, IOException { if (reader == null) { load(); }
<|startcomment|> Personally, I'd be more defensive here and try to protect the consistency of initializedFilters even if this destroy() call fails. I'd wrap this in a try-catch (RuntimeException) and log the exception. Otherwise, a failing filter will never be removed from initializedFilters. <|endcomment|>  private void cleanUpInitializedFilters() { synchronized (initializedFilters) { DynamicSet<AllRequestFilter> cleaned = new DynamicSet<>(); Iterator<AllRequestFilter> iterator = initializedFilters.iterator(); while (iterator.hasNext()) { AllRequestFilter initializedFilter = iterator.next(); if (filters.contains(initializedFilter)) { cleaned.add(initializedFilter); } else { initializedFilter.destroy(); } } <|startfocus|> initializedFilters = cleaned; <|endfocus|> }
<|startcomment|> Prefix with the class name: return getClass().getSimpleName() + ids(); <|endcomment|>  public String toString() { <|startfocus|> return String.valueOf(ids()); <|endfocus|>
<|startcomment|> nit: wrap this line <|endcomment|>  CheckResult result = checker.check(key); if (!result.isOk()) { throw new BadRequestException(String.format( "Problems with public key %s:\n%s", keyToString(key), Joiner.on('\n').join(result.getProblems()))); } try { addKeyFactory.create(rsrc.getUser(), null, key).send(); } catch (EmailException e) { <|startfocus|> log.error("Cannot send GPG key added message to " + rsrc.getUser().getAccount().getPreferredEmail(), e); <|endfocus|> } store.add(keyRing); } for (Fingerprint fp : toRemove) { store.remove(fp.get()); } CommitBuilder cb = new CommitBuilder(); PersonIdent committer = serverIdent.get(); cb.setAuthor(rsrc.getUser().newCommitterIdent( committer.getWhen(), committer.getTimeZone())); cb.setCommitter(committer); RefUpdate.Result saveResult = store.save(cb); switch (saveResult) { case NEW: case FAST_FORWARD: case FORCED: case NO_CHANGE: break; default:
<|startcomment|> Multimap<String, Branch.NameKey> <|endcomment|> // limitations under the License. package com.google.gerrit.server.git; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.gerrit.reviewdb.client.Branch; import com.google.gerrit.reviewdb.client.Project; import java.io.IOException; import java.util.List; import java.util.Map; import java.util.Set; public class DestinationList extends TabFile { public static final String DIR_NAME = "destinations"; <|startfocus|> private Map<String, Set<Branch.NameKey>> destinations = Maps.newHashMap(); <|endfocus|> public Set<Branch.NameKey> getDestinations(String label) { return destinations.get(label); } public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException { destinations.put(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors))); } public String asText(String label) { Set<Branch.NameKey> dests = destinations.get(label); if (dests == null) { return null; } List<Row> rows = Lists.newArrayListWithCapacity(dests.size());
<|startcomment|> This might be different from the MIME we used to determine if it is safe, do we need to do it as in `resolveContentType` ? <|endcomment|>  } int mode = tw.getFileMode(0).getObjectType(); if (mode != Constants.OBJ_BLOB) { throw new ResourceNotFoundException(); } ObjectId id = tw.getObjectId(0); ObjectLoader obj = repo.open(id, OBJ_BLOB); byte[] raw; try { raw = obj.getCachedBytes(MAX_SIZE); } catch (LargeObjectException e) { raw = null; } MimeType contentType = registry.getMimeType(path, raw); return registry.isSafeInline(contentType) <|startfocus|> ? wrapBlob(project, path, obj, raw, contentType, side) : zipBlob(path, obj, commit, side); <|endfocus|> } } private BinaryResult wrapBlob(ProjectState project, String path, final ObjectLoader obj, byte[] raw, MimeType contentType, @Nullable String side) { BinaryResult result; if (raw != null) { result = BinaryResult.create(raw); } else { result = new BinaryResult() { @Override public void writeTo(OutputStream os) throws IOException { obj.copyTo(os);
<|startcomment|> nit: wrap this line <|endcomment|> <|startfocus|> abstract void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status, RemoteRefUpdate.Status refStatus); <|endfocus|> abstract void onRefReplicatedToAllNodes(String project, String ref, int nodesCount); abstract void onAllRefsReplicatedToAllNodes(int totalPushTasksCount); /** * Write message to standard out. * * @param message message text. */ void writeStdOut(final String message) { // Default doing nothing
<|startcomment|> Not need to be public, protected should be fine. <|endcomment|> <|startfocus|> public PaginatedProjectScreen(Project.NameKey toShow) { <|endfocus|> super(toShow); pageSize = Gerrit.getUserPreferences().changesPerPage();
<|startcomment|> wrap <|endcomment|>  } else if (!tokenType.equals(other.tokenType)) return false; return true; } public boolean isError() { return !Strings.isNullOrEmpty(error); } } @Inject public OAuthProtocol(GitHubOAuthConfig config, GitHubHttpProvider httpClientProvider, /* We need to explicitly tell Guice which Provider<> we need as this class may be instantiated outside the standard Guice Module set-up (e.g. initial Servlet login filter) */ GsonProvider gsonProvider) { this.config = config; <|startfocus|> this.http = httpClientProvider.get(); <|endfocus|> this.gson = gsonProvider.get(); } public void loginPhase1(HttpServletRequest request, HttpServletResponse response, Set<Scope> scopes) throws IOException { String scopesString = getScope(scopes); LOG.debug("Initiating GitHub Login for ClientId=" + config.gitHubClientId + " Scopes=" + scopesString); response.sendRedirect(String.format( "%s?client_id=%s%s&redirect_uri=%s&state=%s%s", config.gitHubOAuthUrl, config.gitHubClientId, scopesString,
<|startcomment|> Nit: Fix/keep the list lexicographically sorted. <|endcomment|> import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.CopyOnWriteArrayList; public abstract class SqlDialect { private static final List<SqlDialect> DIALECTS = new CopyOnWriteArrayList<>(); static { DIALECTS.add(new DialectDB2()); DIALECTS.add(new DialectH2()); DIALECTS.add(new DialectPostgreSQL()); DIALECTS.add(new DialectMySQL()); DIALECTS.add(new DialectOracle()); DIALECTS.add(new DialectMaxDB()); <|startfocus|> DIALECTS.add(new DialectDerby()); <|endfocus|> } public static void register(SqlDialect dialect) { DIALECTS.add(0, dialect); } public static SqlDialect getDialectFor(Connection c) throws SQLException, OrmException { String url = c.getMetaData().getURL(); for (SqlDialect d : DIALECTS) { if (d.handles(url, c)) { return d.refine(c); } } throw new OrmException("No dialect known for " + url); } protected final Map<Class<?>, SqlTypeInfo> types;
<|startcomment|> This import is no longer used. <|endcomment|> // limitations under the License. package com.google.gerrit.server.securestore; import com.google.gerrit.common.FileUtil; import com.google.gerrit.server.config.SitePaths; import com.google.inject.Inject; import com.google.inject.ProvisionException; import com.google.inject.Singleton; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.internal.storage.file.LockFile; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.storage.file.FileBasedConfig; import org.eclipse.jgit.util.FS; <|startfocus|> <|endfocus|> @Singleton public class DefaultSecureStore extends SecureStore { private final FileBasedConfig sec; private final Map<String, FileBasedConfig> pluginSec; private final SitePaths site; @Inject DefaultSecureStore(SitePaths site) { this.site = site; sec = new FileBasedConfig(site.secure_config.toFile(), FS.DETECTED); try { sec.load(); } catch (IOException | ConfigInvalidException e) { throw new RuntimeException("Cannot load secure.config", e);
<|startcomment|> Why? Shouldn't the email be sent only after indexing is done, so that when you click on the link in the email you come to the updated change? <|endcomment|>  db.changes().update(Collections.singleton(c)); ChangeMessage m = newMessage( msgTxt, acc != null ? acc.getId() : null, c); cmUtil.addChangeMessage(db, update, m); change.set(c); message.set(m); patchSet.set(db.patchSets().get(c.currentPatchSetId())); } }); u.addPostOp(new Callable<Void>() { @Override public Void call() throws OrmException { <|startfocus|> // TODO(dborowitz): send email while indexing. <|endfocus|> Change c = change.get(); try { ReplyToChangeSender cm = abandonedSenderFactory.create(id); if (acc != null) { cm.setFrom(acc.getId()); } cm.setChangeMessage(message.get()); cm.send(); } catch (Exception e) { log.error("Cannot email update for change " + id, e); } hooks.doChangeAbandonedHook(c, acc, patchSet.get(), Strings.emptyToNull(msgTxt), dbProvider.get()); return null; } });
<|startcomment|> Why was this changed? Now there is no null check. <|endcomment|>  } } @Override public String toString() { return "send-email newchange"; } }; if (requestScopePropagator != null) { workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender)); } else { sender.run(); } } f.checkedGet(); gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit); if (runHooks) { hooks.doPatchsetCreatedHook(change, patchSet, db); <|startfocus|> if (!hashtags.isEmpty()) { <|endfocus|> hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db); } if (!approvals.isEmpty()) { hooks.doCommentAddedHook(change, ((IdentifiedUser) ctl.getCurrentUser()).getAccount(), patchSet, null, approvals, db); } } return change; } private void commitMessageNotForChange() throws OrmException, IOException { ReviewDb db = dbProvider.get(); if (changeMessage != null) { Change otherChange =
<|startcomment|> Don't use final unless the compiler complains without it. <|endcomment|> import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; @RunWith(ConfigSuite.class) public class IdentifiedUserTest{ @ConfigSuite.Parameter public Config config; @ConfigSuite.Config @GerritServerConfig public static Config noteDbEnabled() { return NotesMigration.allEnabledConfig(); } private IdentifiedUser identifiedUser; @Inject private IdentifiedUser.GenericFactory identifiedUserFactory; @Before public void setUp() throws Exception { final FakeAccountCache accountCache = new FakeAccountCache(); final Realm mockRealm = new FakeRealm() { <|startfocus|> HashSet<String> emails = new HashSet<String>(Arrays.asList( "", "!#$%&'+-/=.?^`{|}~@[IPv6:0123:4567:89AB:CDEF:0123:4567:89AB:CDEF]", "FirstName.LastName@Corporation.com" )); <|endfocus|> @Override public boolean hasEmailAddress(IdentifiedUser who, String email) { return emails.contains(email); } @Override public Set<String> getEmailAddresses(IdentifiedUser who) { return emails; } }; AbstractModule mod = new AbstractModule() {
<|startcomment|> Slightly odd to see a "check" method that returns void rather than an enum or boolean. Is this using BouncyCastle idioms? This appears to be "gatherProblemsWithRevocationKeys". <|endcomment|> <|startfocus|> private void checkRevocation(PGPPublicKey key, List<String> problems) { <|endfocus|> try { List<PGPSignature> revocations = new ArrayList<>(); Map<Long, RevocationKey> revokers = new HashMap<>(); PGPSignature selfRevocation = scanRevocations(key, revocations, revokers); if (selfRevocation != null) { problems.add(reasonToString(getRevocationReason(selfRevocation))); } else { checkRevocations(key, revocations, revokers, problems); } } catch (PGPException | IOException e) { problems.add("Error checking key revocation"); }
<|startcomment|> I know sop@ mentioned that line should be enough to disambiguate, but I think he was thinking of the state of things before range comments were introduced. Could this have a range field, too? (That way, it is possible to produce multiple comments with the same content attached to different parts of the same line.) <|endcomment|>  return create(comment.getKey().getParentKey().getParentKey(), comment.getLine(), Side.fromShort(comment.getSide()), checkNotNull(comment.getMessage())); } public static CommentSetEntry create(CommentInput comment, PatchSet.Id id) { Side side = comment.side == Side.PARENT ? Side.PARENT : Side.REVISION; return create(id, comment.line, side, checkNotNull(comment.message)); } abstract PatchSet.Id id(); @Nullable abstract Integer line(); @Nullable abstract Side side(); <|startfocus|> abstract String message(); <|endfocus|> } private class Op extends BatchUpdate.Op { private final PatchSet.Id psId; private final ReviewInput in; private IdentifiedUser user; private Change change; private PatchSet ps; private ChangeMessage message; private List<PatchLineComment> comments = new ArrayList<>(); private List<String> labelDelta = new ArrayList<>(); private Map<String, Short> categories = new HashMap<>(); private Op(PatchSet.Id psId, ReviewInput in) { this.psId = psId;
<|startcomment|> Don't import Id. We have too many of them. Use Account.Id instead. <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.auth.oauth; <|startfocus|> import static com.google.gerrit.extensions.client.AccountFieldName.USER_NAME; <|endfocus|> import com.google.common.base.Strings; import com.google.gerrit.extensions.auth.oauth.OAuthLoginProvider; import com.google.gerrit.extensions.auth.oauth.OAuthUserInfo; import com.google.gerrit.extensions.registration.DynamicMap; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.Account.FieldName; import com.google.gerrit.server.account.AbstractRealm; import com.google.gerrit.server.account.AccountException; import com.google.gerrit.server.account.AccountManager; import com.google.gerrit.server.account.AuthRequest; import com.google.gerrit.server.config.GerritServerConfig; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.lib.Config; import java.io.IOException; import java.util.HashSet;
<|startcomment|> unused import <|endcomment|> import com.google.gerrit.server.git.GarbageCollection; import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.LocalDiskRepositoryManager; import com.google.gerrit.server.git.WorkQueue; import com.google.gerrit.server.project.GarbageCollect.Input; import com.google.gerrit.server.util.IdGenerator; import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.Singleton; import java.io.IOException; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.util.Collections; <|startfocus|> import java.util.concurrent.TimeUnit; <|endfocus|> @RequiresCapability(GlobalCapability.RUN_GC) @Singleton public class GarbageCollect implements RestModifyView<ProjectResource, Input>, UiAction<ProjectResource> { public static class Input { public boolean showProgress; public boolean aggressive; public boolean async; } private final boolean canGC; private final GarbageCollection.Factory garbageCollectionFactory; private final WorkQueue workQueue; private Provider<String> canonicalUrl; @Inject GarbageCollect(GitRepositoryManager repoManager, GarbageCollection.Factory garbageCollectionFactory, WorkQueue workQueue, @CanonicalWebUrl Provider<String> canonicalUrl) {
<|startcomment|> nit: extra blank line <|endcomment|>  private final byte[] replace; private final ByteArrayOutputStream outBuff; private HttpServletResponse resp; private int outLen; public TokenReplaceOutputStream(HttpServletResponse resp, int contentLength, byte[] token, byte[] replace) { this.resp = resp; this.outLen = contentLength; this.token = token; this.replace = replace; this.outBuff = new ByteArrayOutputStream(contentLength); } @Override public void write(int b) throws IOException { outBuff.write(b); } <|startfocus|> <|endfocus|> @Override public void flush() throws IOException { if (outBuff.size() < outLen) { return; } byte[] outData = outBuff.toByteArray(); byte[] cmp = new byte[token.length]; ByteArrayOutputStream convertedData = new ByteArrayOutputStream(outData.length); for (int i = 0; i < outData.length; i++) { byte b = outData[i]; if (b != token[0] || (outData.length - i) < token.length) { convertedData.write(outData, i, 1);
<|startcomment|> Same comment for above line 14 as in previous file, this time referring to the ClippyResources usage below or so. (You just don't want the comment to be high maintenance versus the below involved code that could change a tad.) <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. <|startfocus|> //The MIT License (MIT) <|endfocus|> // //Copyright (c) 2014 Drifty (http://drifty.com/) // //Permission is hereby granted, free of charge, to any person obtaining a copy //of this software and associated documentation files (the "Software"), to deal //in the Software without restriction, including without limitation the rights //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell //copies of the Software, and to permit persons to whom the Software is //furnished to do so, subject to the following conditions: //
<|startcomment|> Would insert a blank line here as well. <|endcomment|>  revision(r).review(ReviewInput.reject()); } @Test public void failChangedLabelValueOnOldPatchSet() throws Exception { PushOneCommit.Result r = createChange(); revision(r).review(ReviewInput.reject()); assertApproval(r, -2); PatchSet.Id first = r.getPatchSetId(); amendChange(r.getChangeId()); exception.expect(ResourceConflictException.class); exception.expectMessage("review is not for current patch set"); gApi.changes().id(r.getChangeId()).revision(1) <|startfocus|> .review(ReviewInput.approve()); <|endfocus|> ApprovalsUtil approvalsUtil = new ApprovalsUtil(null, null); for (PatchSetApproval approval : approvalsUtil.byPatchSet(db, r.getChange().changeControl(), first)) { assertThat(approval.getLabelId().equals(codeReview)); assertThat(approval.getValue() == -2); } } @Test public void noCopyMinScoreOnRework() throws Exception { codeReview.setCopyMinScore(false); saveLabelConfig(); PushOneCommit.Result r = createChange(); revision(r).review(ReviewInput.reject()); assertApproval(r, -2);
<|startcomment|> Instead of passing the entire env, just pass the MetricRegistry from the env. <|endcomment|>  private Injector newRootInjector(final PluginGuiceEnvironment env) { List<Module> modules = Lists.newArrayListWithCapacity(2); if (getApiType() == ApiType.PLUGIN) { modules.add(env.getSysModule()); } <|startfocus|> modules.add(new ServerPluginInfoModule(this, env)); <|endfocus|> return Guice.createInjector(modules);
<|startcomment|> getMerger? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.events; import com.google.gerrit.extensions.annotations.ExtensionPoint; import com.google.gerrit.extensions.common.AccountInfo; /** Notified whenever a Change is merged. */ @ExtensionPoint public interface ChangeMergedListener { public interface Event extends RevisionEvent { <|startfocus|> public AccountInfo getSubmitter(); public String getNewRevisionId(); <|endfocus|> } void onChangeMerged(Event event); } 
<|startcomment|> of <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.cookbook; import com.google.gerrit.extensions.annotations.Listen; import com.google.gerrit.extensions.events.LifecycleListener; import com.google.inject.Inject; import com.google.inject.Singleton; import com.codahale.metrics.ConsoleReporter; import com.codahale.metrics.MetricRegistry; import java.util.concurrent.TimeUnit; /** <|startfocus|> * Demonstration on how to add a new Dropwizard Metrics Reporter using <|endfocus|> * Gerrit's plug-in API. * * @see <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/#reporting-via-jmx">here</a> * @see <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/#reporting-via-http">here</a> * @see <a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/#other-reporting">here</a> */ @Listen @Singleton public class ConsoleMetricReporter implements LifecycleListener { private ConsoleReporter consoleReporter; @Inject public ConsoleMetricReporter(MetricRegistry registry) {
<|startcomment|> is this the correct import? <|endcomment|> import com.google.gerrit.server.change.Submit; import com.google.gerrit.server.config.AllProjectsName; import com.google.gerrit.server.config.CanonicalWebUrl; import com.google.gerrit.server.config.PluginConfig; import com.google.gerrit.server.config.ProjectConfigEntry; import com.google.gerrit.server.edit.ChangeEdit; import com.google.gerrit.server.edit.ChangeEditUtil; import com.google.gerrit.server.events.CommentAdded; import com.google.gerrit.server.events.CommitReceivedEvent; <|startfocus|> import com.google.gerrit.server.events.RevisionCreated; import com.google.gerrit.server.extensions.events.ChangeMerged; <|endfocus|> import com.google.gerrit.server.extensions.events.GitReferenceUpdated; import com.google.gerrit.server.git.MultiProgressMonitor.Task; import com.google.gerrit.server.git.validators.CommitValidationException; import com.google.gerrit.server.git.validators.CommitValidationMessage; import com.google.gerrit.server.git.validators.CommitValidators; import com.google.gerrit.server.index.ChangeIndexer; import com.google.gerrit.server.mail.MailUtil.MailRecipients; import com.google.gerrit.server.mail.MergedSender; import com.google.gerrit.server.mail.ReplacePatchSetSender; import com.google.gerrit.server.notedb.ChangeNotes; import com.google.gerrit.server.notedb.ChangeUpdate; import com.google.gerrit.server.notedb.NotesMigration;
<|startcomment|> Nit: too long line. <|endcomment|>  public void run() { <|startfocus|> for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) { <|endfocus|> long count = gc.getCollectionCount(); if (count != -1) { gcCount.set(gc.getName(), count); } long time = gc.getCollectionTime(); if (time != -1) { gcTime.set(gc.getName(), time); } }
<|startcomment|> guava Strings: String annotation = Strings.nullToEmpty(reviewer.annotation()); <|endcomment|>  public String getDisplayString() { <|startfocus|> String annotation = reviewer.annotation(); if (annotation == null) { annotation = ""; } <|endfocus|> if (reviewer.account() != null) { return FormatUtil.nameEmail(reviewer.account()) + annotation; } return reviewer.group().name() + " (" + Util.C.suggestedGroupLabel() + ")" + annotation;
<|startcomment|> This is not required, as changesByBranch takes different branches for different projects into account, as (projectA, master) != (projectB, master) <|endcomment|>  resource.getUser()); if (submitProblems != null) { return new UiAction.Description() .setLabel(submitTopicLabel) .setTitle(submitProblems) .setVisible(true) .setEnabled(false); } int topicSize = 0; if (!Strings.isNullOrEmpty(topic)) { topicSize = getChangesByTopic(topic).size(); } if (submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1) { Map<String, String> params = ImmutableMap.of( "topicSize", String.valueOf(topicSize), <|startfocus|> "submitSize", String.valueOf(cs.size())); <|endfocus|> return new UiAction.Description() .setLabel(submitTopicLabel) .setTitle(Strings.emptyToNull( submitTopicTooltip.replace(params))) .setVisible(true) .setEnabled(Boolean.TRUE.equals(enabled)); } else { RevId revId = resource.getPatchSet().getRevision(); Map<String, String> params = ImmutableMap.of( "patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()),
<|startcomment|> These aren't thread safe. A simple boolean is good enough. <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.metrics; import java.util.concurrent.atomic.AtomicBoolean; abstract class TimerContext implements AutoCloseable { private final long startNanos; <|startfocus|> private final AtomicBoolean stopped = new AtomicBoolean(); <|endfocus|> TimerContext() { this.startNanos = System.nanoTime(); } /** * Record the elapsed time to the timer. * * @param elapsed Elapsed time in nanoseconds. * * */ public abstract void record(long elapsed); /** Get the start time in system time nanoseconds. */ public long getStartTime() { return startNanos; } /** * Stop the timer and record the elapsed time. * * @return the elapsed time in nanoseconds.
<|startcomment|> Nit: too long line. <|endcomment|>  return new ListResultSet<>(empty); } } private Set<String> getRefNames(String prefix) throws OrmException { try (Repository repo = repoManager.openMetadataRepository(allUsers)) { RefDatabase refDb = repo.getRefDatabase(); return refDb.getRefs(prefix).keySet(); } catch (IOException e) { throw new OrmException(e); } } private static class ChangeIdResultSet implements ResultSet<Change.Id> { <|startfocus|> private static final Function<StarredChange, Change.Id> STARRED_CHANGE_TO_CHANGE_ID = new Function<StarredChange, Change.Id>() { @Override public Change.Id apply(StarredChange starredChange) { return starredChange.getChangeId(); } }; <|endfocus|> private final ResultSet<StarredChange> starredChangesResultSet; ChangeIdResultSet(ResultSet<StarredChange> starredChangesResultSet) { this.starredChangesResultSet = starredChangesResultSet; } @Override public Iterator<Change.Id> iterator() { return Iterators.transform(starredChangesResultSet.iterator(), STARRED_CHANGE_TO_CHANGE_ID); } @Override public List<Change.Id> toList() {
<|startcomment|> Move this up above l. 66 so there isn't even a dropdown if it would only have one item? <|endcomment|>  if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) { if (!suggestionDisplay.isSuggestionSelected) { doSearch(); } } } }); dropdown = new ListBox(); dropdown.setStyleName("searchDropdown"); dropdown.addItem(Gerrit.C.searchDropdownChanges()); dropdown.addItem(Gerrit.C.searchDropdownDoc()); dropdown.setVisibleItemCount(1); dropdown.setSelectedIndex(0); if (!Gerrit.hasDocSearch()) { // Documentation search NOT available, hide the dropdown. dropdown.setVisible(false); <|startfocus|> dropdown.setSelectedIndex(0); <|endfocus|> } final SuggestBox suggestBox = new SuggestBox(new SearchSuggestOracle(), searchBox, suggestionDisplay); searchBox.setStyleName("searchTextBox"); searchBox.setVisibleLength(70); searchBox.setHintText(Gerrit.C.searchHint()); final Button searchButton = new Button(Gerrit.C.searchButton()); searchButton.setStyleName("searchButton"); searchButton.addClickHandler(new ClickHandler() { @Override public void onClick(ClickEvent event) { doSearch(); } }); body.add(suggestBox);
<|startcomment|> Question: wouldn't this expose LFS without the authentication? I thought the servlet was already bound using the extension point, so this seems redundant... <|endcomment|> <|startfocus|> protected void configureServlets() { <|endfocus|> serve("/*").with(LfsContentServlet.class);
<|startcomment|> This is probably just personal preference, but I would probably prefer using the email (or even just the part up to the @) in the short blame rather than a last name. <|endcomment|>  JsArray<LintLine> annotations = JsArray.createArray().cast(); for (BlameInfo.BlameLine line : Natives.asList(blameInfo.blames())) { for (BlameInfo.BlameLine.FromTo fromTo : Natives.asList(line.fromTo())) { Date commitTime = new Date(line.time() * 1000L); String commitDate = DateTimeFormat.getFormat(DateTimeFormat.PredefinedFormat.DATE_SHORT) .format(commitTime); String[] author = line.author().split(" "); <|startfocus|> String authorLastName = author[author.length - 1]; <|endfocus|> String shortBlame = line.id().substring(0, 8) + " " + commitDate + " " + authorLastName; String detailedBlame = "commit " + line.id() + "\n" + "Author: " + line.author() + "\n" + "Date: " + FormatUtil.mediumFormat(commitTime) + "\n\n" + line.commitMsg(); if (shortBlame.length() > 30) { shortBlame = shortBlame.substring(0, 30) + "..."; }
<|startcomment|> "new" seems wrong. <|endcomment|> <|startfocus|> private String formatLabelValue(short value) { if (value > 0) { return "+" + value; } else { return Short.toString(value); } <|endfocus|>
<|startcomment|> Doesn't it need to be closed? <|endcomment|>  prefs.autoHideDiffTableHeader = toBoolean(rs.getString(21)); imports.put(accountId, prefs); } } if (imports.isEmpty()) { return; } try (Repository git = mgr.openRepository(allUsersName); RevWalk rw = new RevWalk(git)) { BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate(); for (Map.Entry<Account.Id, DiffPreferencesInfo> e : imports.entrySet()) { MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru); <|startfocus|> md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); <|endfocus|> VersionedAccountPreferences p = VersionedAccountPreferences.forUser(e.getKey()); p.load(md); storeSection(p.getConfig(), UserConfigSections.DIFF, null, e.getValue(), DiffPreferencesInfo.defaults()); p.commit(md); } bru.execute(rw, NullProgressMonitor.INSTANCE); } catch (ConfigInvalidException | IOException ex) { throw new OrmException(ex); } } private static Theme toTheme(String v) {
<|startcomment|> Nit: Unneeded new line. <|endcomment|>  // subsequent parameters are widgets to listenTo. public OnEditEnabler(final FocusWidget w, final TextBoxBase tb) { this(w); originalValue = tb.getValue().trim(); listenTo(tb); } public OnEditEnabler(final FocusWidget w, final ListBox lb) { this(w); listenTo(lb); } public OnEditEnabler(final FocusWidget w, final CheckBox cb) { this(w); listenTo(cb); } public OnEditEnabler(final FocusWidget w) { widget = w; } <|startfocus|> <|endfocus|> // Register input widgets to be listened to public void listenTo(final TextBoxBase tb) { strings.put(tb, tb.getText().trim()); tb.addKeyPressHandler(this); // Is there another way to capture middle button X11 pastes in browsers // which do not yet support ONPASTE events (Firefox)? tb.addMouseUpHandler(this); // Resetting the "original text" on focus ensures that we are // up to date with non-user updates of the text (calls to
<|startcomment|> [optional] Put this into RefNames? Not sure if it's worth it, since it's unlikely that this is needed anywhere else. <|endcomment|>  * by a ref in the {@code refs/sequences/*} namespace. Multiple processes can * share the same sequence by incrementing the counter using normal git ref * updates. To amortize the cost of these ref updates, processes can increment * the counter by a larger number and hand out numbers from that range in memory * until they run out. This means concurrent processes will hand out somewhat * non-monotonic numbers. */ public class RepoSequence { <|startfocus|> static final String REFS_SEQUENCES = "refs/sequences/"; <|endfocus|> @VisibleForTesting static RetryerBuilder<RefUpdate.Result> retryerBuilder() { return RetryerBuilder.<RefUpdate.Result> newBuilder() .retryIfResult(Predicates.equalTo(RefUpdate.Result.LOCK_FAILURE)) .withWaitStrategy( WaitStrategies.join( WaitStrategies.exponentialWait(5, TimeUnit.SECONDS), WaitStrategies.randomWait(50, TimeUnit.MILLISECONDS))) .withStopStrategy(StopStrategies.stopAfterDelay(30, TimeUnit.SECONDS)); } private static Retryer<RefUpdate.Result> RETRYER = retryerBuilder().build(); private final GitRepositoryManager repoManager; private final Project.NameKey projectName;
<|startcomment|> optional: these are builder methods and the calls can be chained onto the the same statement at line 109. i.e.: ProcessBuilder sshKeygenRsa = new ProcessBuilder("ssh-keygen", "-q" /* quiet */ ... ...) .redirectError(Redirect.INHERIT) .redirectOutput(Redirect.INHERIT); <|endcomment|>  // final String comment = "gerrit-code-review@" + hostname(); System.err.print(" rsa..."); System.err.flush(); ProcessBuilder sshKeygenRsa = new ProcessBuilder("ssh-keygen", // "-q" /* quiet */, // "-t", "rsa", // "-P", "", // "-C", comment, // "-f", site.ssh_rsa.toAbsolutePath().toString() // <|startfocus|> ); sshKeygenRsa.redirectError(Redirect.INHERIT); sshKeygenRsa.redirectOutput(Redirect.INHERIT); sshKeygenRsa.start().waitFor(); <|endfocus|> System.err.print(" dsa..."); System.err.flush(); ProcessBuilder sshKeygenDsa = new ProcessBuilder("ssh-keygen", // "-q" /* quiet */, // "-t", "dsa", // "-P", "", // "-C", comment, // "-f", site.ssh_dsa.toAbsolutePath().toString() // ); sshKeygenDsa.redirectError(Redirect.INHERIT); sshKeygenDsa.redirectOutput(Redirect.INHERIT); sshKeygenDsa.start().waitFor(); } else {
<|startcomment|> nit: wrap <|endcomment|>  final PatchList list; try { if (psIdBase != null) { oldId = toObjectId(psIdBase); if (edit != null && edit.isPresent()) { newId = edit.get().getEditCommit().toObjectId(); } else { newId = toObjectId(psIdNew); } list = listFor(keyFor(diffPrefs.ignoreWhitespace)); } else { // OK, means use base to compare <|startfocus|> list = patchListCache.get(control.getChange(), patchSet, DiffType.AUTO_MERGE); <|endfocus|> } } catch (PatchListNotAvailableException e) { throw new NoSuchEntityException(); } final List<Patch> patches = list.toPatchList(patchSet.getId()); final Map<Patch.Key, Patch> byKey = new HashMap<>(); for (final Patch p : patches) { byKey.put(p.getKey(), p); } ChangeNotes notes = control.getNotes(); if (edit == null) { for (PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
<|startcomment|> VersionedAccountPreferences versionedPrefs = VersionedAccountPreferences.forUser(id); and then remove line 143 above. <|endcomment|>  storeUrlAliases(prefs, i.urlAliases); prefs.commit(md); cache.evict(id); } } private void writeToDb(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, OrmException, ConfigInvalidException { VersionedAccountPreferences versionedPrefs; MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName); db.get().accounts().beginTransaction(id); try { Account a = db.get().accounts().get(id); <|startfocus|> versionedPrefs = VersionedAccountPreferences.forUser(id); <|endfocus|> versionedPrefs.load(md); AccountGeneralPreferences p = a.getGeneralPreferences(); if (p == null) { p = new AccountGeneralPreferences(); a.setGeneralPreferences(p); } initAccountGeneralPreferences(p, i); db.get().accounts().update(Collections.singleton(a)); db.get().commit(); storeMyMenus(versionedPrefs, i.my); storeUrlAliases(versionedPrefs, i.urlAliases); versionedPrefs.commit(md); cache.evict(id); } finally { db.get().rollback(); } } 
<|startcomment|> Same here. <|endcomment|>  private static void onRemoveReviewer(NativeEvent event) { Integer user = getDataId(event); if (user != null) { final ChangeScreen screen = ChangeScreen.get(event); <|startfocus|> ChangeApi.reviewer(screen.getPatchSetId().getParentKey().get(), user).delete( <|endfocus|> new GerritCallback<JavaScriptObject>() { @Override public void onSuccess(JavaScriptObject result) { if (screen.isCurrentView()) { Gerrit.display( PageLinks.toChange(screen.getPatchSetId().getParentKey())); } } }); }
<|startcomment|> How about extracting condition !sameFirstParents(prior, next) && sameRestOfParents(prior, next) to method: firstParentChanged(prior, next) and calling here like !(firstParentChanged(prior, next)) <|endcomment|>  private final Repository alreadyOpenRepo; private Loader(Key key, GitRepositoryManager repoManager, Project.NameKey projectName, @Nullable Repository alreadyOpenRepo) { this.key = key; this.repoManager = repoManager; this.projectName = projectName; this.alreadyOpenRepo = alreadyOpenRepo; } @Override public ChangeKind call() throws IOException { if (Objects.equals(key.prior, key.next)) { return ChangeKind.NO_CODE_CHANGE; } Repository repo = alreadyOpenRepo; boolean close = false; <|startfocus|> if (repo != null) { <|endfocus|> repo = repoManager.openRepository(projectName); close = true; } try (RevWalk walk = new RevWalk(repo)) { RevCommit prior = walk.parseCommit(key.prior); walk.parseBody(prior); RevCommit next = walk.parseCommit(key.next); walk.parseBody(next); if (!next.getFullMessage().equals(prior.getFullMessage())) { if (isSameDeltaAndTree(prior, next)) { return ChangeKind.NO_CODE_CHANGE; } return ChangeKind.REWORK; } 
<|startcomment|> Maybe better use 'name' here? Otherwise the message can be confusing if the case is different from the actual name of the existing group. <|endcomment|>  } return null; } private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException { // Do not allow creating groups with the same name as system groups List<String> sysGroupNames = SystemGroupBackend.getSystemGroupNames(); for (String name : sysGroupNames) { if (name.toLowerCase(Locale.US).equals( createGroupArgs.getGroupName().toLowerCase(Locale.US))) { <|startfocus|> throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists"); <|endfocus|> } } AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId()); AccountGroup.UUID uuid = GroupUUID.make( createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone())); AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid); group.setVisibleToAll(createGroupArgs.visibleToAll); if (createGroupArgs.ownerGroupId != null) { AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
<|startcomment|> Are we sure we want to just log and do nothing about this failed transition? <|endcomment|>  /** * @return Serverinformation of jira */ public JiraServerInfo sysInfo() throws JiraRestException { return (JiraServerInfo) doGet("/rest/api/2/serverInfo", new TypeToken<JiraServerInfo>(){}.getType()); } /** * @return List of all projects we have access to in jira */ public Iterable<JiraProject> getProjects() throws JiraRestException { return (List<JiraProject>) doGet("/rest/api/2/project", <|startfocus|> new TypeToken<List<JiraProject>>(){}.getType()); <|endfocus|> } private JiraTransition.Item getTransitionByName(Iterable<JiraTransition.Item> transitions, String transition) { JiraTransition.Item ret = null; for (JiraTransition.Item t : transitions) { if (transition.equals(t.getName())) { ret = t; break; } } return ret; } /** * Do a simple GET request. */ private Object doGet(String spec, Type typeOfObject) throws JiraRestException { try { URL url = new URL(baseUrl, spec);
<|startcomment|> Merge l and check that everything is submitted? <|endcomment|>  approve(f.getChangeId()); approve(g.getChangeId()); approve(j.getChangeId()); approve(k.getChangeId()); assertChangeSetMergeable(g.getChange(), false); assertChangeSetMergeable(k.getChange(), false); PushOneCommit.Result l = createChange(project1, "L", "new.txt", "Resolving conflicts again", ImmutableList.of(c.getCommit(), g.getCommit()), "refs/for/master/" + name("topic1")); approve(l.getChangeId()); <|startfocus|> assertChangeSetMergeable(l.getChange(), true); <|endfocus|> } @Test public void resolvingMergeCommitAtEndOfChainAndNotUpToDate() throws Exception { /* A <-- B \ C <- D \ / E B is the target branch, and D should be merged with B, but one of C conflicts with B */ PushOneCommit.Result a = createChange("A"); PushOneCommit.Result b = createChange("B", "new.txt", "No conflict line", ImmutableList.of(a.getCommit())); approve(a.getChangeId());
<|startcomment|> looks like we have two levels of outer-most parenthesis here: if ((...)) { } <|endcomment|>  for (RevCommit p : receiveEvent.commit.getParents()) { tw.addTree(p.getTree()); } while (tw.next()) { boolean diff = true; if (receiveEvent.commit.getParentCount() > 1) { for (int p = 0; p < receiveEvent.commit.getParentCount(); p++) { if (tw.getObjectId(0).equals(tw.getObjectId(p+1))) { diff = false; break; } } } <|startfocus|> if ((diff && (tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)) { <|endfocus|> addValidationMessage(messages, tw); } } } else { while(tw.next()) { if ((tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) { addValidationMessage(messages, tw); } } } if (!messages.isEmpty()) { throw new CommitValidationException( "contains symbolic links", messages); } } } } catch (NoSuchProjectException | IOException e) {
<|startcomment|> Why false here? Why should an automerge not be saved any more? <|endcomment|>  if (key.getOldId() != null) { return rw.parseAny(key.getOldId()); } switch (b.getParentCount()) { case 0: return rw.parseAny(emptyTree(repo)); case 1: { RevCommit r = b.getParent(0); rw.parseBody(r); return r; } case 2: switch (key.getDiffType()){ case FIRST_PARENT: return firstparent(rw, b); case AUTO_MERGE: default: <|startfocus|> return automerge(repo, rw, b, mergeStrategy, false); <|endfocus|> } default: // TODO(sop) handle an octopus merge. return null; } } public static RevTree firstparent(RevWalk rw, RevCommit b) throws IOException { return rw.parseCommit(b.getParent(0)).getTree(); } public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy) throws IOException { return automerge(repo, rw, b, mergeStrategy, true); } public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b,
<|startcomment|> aka change.notes(), I believe. <|endcomment|>  break; } } } return !mergeabilityMap.values().contains(Boolean.FALSE); } private HashMap<Change.Id, RevCommit> findCommits( Collection<ChangeData> changes, Project.NameKey project) throws IOException, OrmException, NoSuchChangeException { HashMap<Change.Id, RevCommit> commits = new HashMap<>(); try (Repository repo = repoManager.openRepository(project); RevWalk walk = new RevWalk(repo)) { for (ChangeData change : changes) { <|startfocus|> ChangeNotes notes = changeNotesFactory.createChecked(change.getId()); <|endfocus|> RevCommit commit = walk.parseCommit(ObjectId.fromString( psUtil.current(dbProvider.get(), notes).getRevision().get())); commits.put(change.getId(), commit); } } return commits; } private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException { ChangeControl caller = rsrc.getControl(); if (!caller.canSubmit()) { throw new AuthException("submit not permitted"); } if (!caller.canSubmitAs()) {
<|startcomment|> nit: package declaration in most of files goes after the license header <|endcomment|> <|startfocus|> kage com.google.gerrit.server.events; //Copyright (C) 2016 The Android Open Source Project <|endfocus|> // //Licensed under the Apache License, Version 2.0 (the "License"); //you may not use this file except in compliance with the License. //You may obtain a copy of the License at // //http://www.apache.org/licenses/LICENSE-2.0 // //Unless required by applicable law or agreed to in writing, software //distributed under the License is distributed on an "AS IS" BASIS, //WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //See the License for the specific language governing permissions and //limitations under the License. import com.google.common.base.Supplier; import com.google.common.base.Suppliers; import com.google.gerrit.server.data.RefUpdateAttribute; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import org.junit.Test; public class EventDeserializerTest { @Test public void test() { RefUpdatedEvent refUpdatedEvent = new RefUpdatedEvent(); final RefUpdateAttribute refUpdatedAttribute = new RefUpdateAttribute(); refUpdatedAttribute.refName = "refs/heads/master";
<|startcomment|> To be consistent with 'value' this should be String. <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.data; public class ApprovalAttribute { public String type; public String description; public String value; <|startfocus|> public Short old; <|endfocus|> public Long grantedOn; public AccountAttribute by; } 
<|startcomment|> This schema migration doesn't modify any types. Was this copy pasted from the push certificate column type migration? :) <|endcomment|>  } @Override protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException { JdbcSchema schema = (JdbcSchema) db; String[] tables = {"patch_set_approvals", "change_messages"}; try (Statement stmt = schema.getConnection().createStatement()) { for (String table : tables) { stmt.execute("ALTER TABLE " + table + " ADD tag VARCHAR(255) NULL"); } <|startfocus|> } catch (SQLException e) { // Ignore. Type may have already been modified manually. <|endfocus|> } } } 
<|startcomment|> Above, for labels that *do not* appear in approvals, the old value is null. Here, for labels that *do* appear in approvals, the old value is 0. Why the discrepancy? <|endcomment|>  Map<String, Short> allApprovals = new HashMap<>(); Map<String, Short> oldApprovals = new HashMap<>(); for (LabelType lt : labels){ allApprovals.put(lt.getName(), (short) 0); oldApprovals.put(lt.getName(), null); } for (Map.Entry<String, Short> entry : approvals.entrySet()) { if (entry.getValue() != 0) { allApprovals.put(entry.getKey(), entry.getValue()); <|startfocus|> oldApprovals.put(entry.getKey(), (short)0); <|endfocus|> } } hooks.doCommentAddedHook(change, ctx.getUser().asIdentifiedUser().getAccount(), patchSet, null, approvals, oldApprovals, db); } } } private void validate(RepoContext ctx) throws IOException, ResourceConflictException { if (validatePolicy == CommitValidators.Policy.NONE) { return; } try { RefControl refControl = projectControlFactory .controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName); CommitValidators cv = commitValidatorsFactory.create(
<|startcomment|> ChangeSubIndex <|endcomment|>  } @Override public ChangeDataSource getSource(Predicate<ChangeData> p, QueryOptions opts) throws QueryParseException { Set<Change.Status> statuses = ChangeIndexRewriter.getPossibleStatus(p); List<ChangeSubIndex> indexes = new ArrayList<>(2); if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) { indexes.add(openIndex); } if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) { indexes.add(closedIndex); } <|startfocus|> return new QuerySource(indexes, p, opts, getSort()); <|endfocus|> } @Override public void markReady(boolean ready) throws IOException { // Arbitrary done on open index, as ready bit is set // per index and not sub index openIndex.markReady(ready); } private Sort getSort() { return new Sort( new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(ID_SORT_FIELD, SortField.Type.LONG, true)); } public ChangeSubIndex getClosedChangesIndex() { return closedIndex; } private class QuerySource implements ChangeDataSource {
<|startcomment|> Do you have to do this dynamically within this method? Can this URL actually change over the lifetime of a server? <|endcomment|>  } RevCommit commit = rw.parseCommit(id); TreeWalk tw = TreeWalk.forPath(repo, GIT_MODULES, commit.getTree()); if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) { BlobBasedConfig bbc = new BlobBasedConfig(null, repo, commit, GIT_MODULES); String thisServer = new URI(urlProvider.get()).getHost(); subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections(); <|startfocus|> } <|endfocus|> } catch (ConfigInvalidException | IOException e) { throw new SubmoduleException( "Could not read .gitmodule file of super project: " + branch.getParentKey(), e); } catch (URISyntaxException e) { throw new SubmoduleException("Incorrect Gerrit canonical web url " + "provided in gerrit.config file.", e); } } public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) { logDebug("Checking for a subscription of " + src);
<|startcomment|> s/toParentNo/toParentNumber ? Ditto in other places. <|endcomment|> <|startfocus|> public static int toParentNo(int revisionNo) { <|endfocus|> if (revisionNo < 0) { return revisionNo * -1 - 1; } return revisionNo;
<|startcomment|> Nit: put comma on the previous line. <|endcomment|> <|startfocus|> public static LintLine create(String shortMsg, String msg, String sev , Pos line) { <|endfocus|> StyleInjector.inject(".CodeMirror-lint-marker-" + sev + " {\n" + " visibility: hidden;\n" + " text-overflow: ellipsis;\n" + " white-space: nowrap;\n" + " overflow: hidden;\n" + " position: relative;\n" + "}\n" + ".CodeMirror-lint-marker-" + sev + ":after {\n" + " content:'"+shortMsg+"';\n" + " visibility: visible;\n" + "}"); return create(msg, sev, line, null);
<|startcomment|> Doesn't seem to be used. <|endcomment|> import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import java.util.Set; import java.util.concurrent.ExecutionException; @Singleton public class LuceneAccountIndex extends AbstractLuceneIndex<Account.Id, AccountState> implements AccountIndex { private static final Logger log = LoggerFactory.getLogger(LuceneAccountIndex.class); private static final String ACCOUNTS = "accounts"; private static final String ID_SORT_FIELD = sortFieldName(ID); <|startfocus|> static interface Factory { LuceneAccountIndex create(Schema<AccountState> schema, @Nullable String base); } <|endfocus|> private static Term idTerm(AccountState as) { return idTerm(as.getAccount().getId()); } private static Term idTerm(Account.Id id) { return QueryBuilder.intTerm(ID.getName(), id.get()); } private final GerritIndexWriterConfig indexWriterConfig; private final QueryBuilder<AccountState> queryBuilder; private final AccountCache accountCache; private static Directory dir(Schema<AccountState> schema, Config cfg, SitePaths sitePaths, String base) throws IOException { if (LuceneIndexModule.isInMemoryTest(cfg)) {
<|startcomment|> Most of the fields in this class are pubilc and non-final. If a field is immutable, I'd prefer it to be final and assign them in the constructor so that later developers can't accidentally assign to them. If a field might be changed later, please make it private and use a pair of getter / setter. <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.common; import java.util.List; public class BlameInfo { public List<Blame> blames; <|startfocus|> public static class Line { public Meta meta; public int from; public int to; } <|endfocus|> public static class Meta { public String author; public String id; public int time; public String commitMsg; public int changeId; public int patchSetId; @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; }
<|startcomment|> removing a reviewer will also remove his comments? <|endcomment|>  private final Account reviewer; Op(Account reviewerAccount) { this.reviewer = reviewerAccount; } @Override public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException { Account.Id reviewerId = reviewer.getId(); PatchSet.Id currPs = ctx.getChange().currentPatchSetId(); <|startfocus|> Map<String, Short> newApprovals = new HashMap<>(); Map<String, Short> oldApprovals = new HashMap<>(); LabelTypes labelTypes = ctx.getControl().getLabelTypes(); <|endfocus|> // removing a reviewer will remove all her votes for (LabelType lt : labelTypes.getLabelTypes()) { newApprovals.put(lt.getName(), (short) 0); } List<PatchSetApproval> del = Lists.newArrayList(); StringBuilder msg = new StringBuilder(); for (PatchSetApproval a : approvals(ctx, reviewerId)) { if (ctx.getControl().canRemoveReviewer(a)) { del.add(a); if (a.getPatchSetId().equals(currPs) && a.getValue() != 0) {
<|startcomment|> what is uvp? <|endcomment|> kage com.googlesource.gerrit.plugins.uploadvalidator; import com.google.common.cache.CacheLoader; import com.google.gerrit.server.cache.CacheModule; import java.util.regex.Pattern; public class PatternCache extends CacheModule { <|startfocus|> public static final String CACHE_NAME = "uvp_PatternCache"; <|endfocus|> @Override protected void configure() { cache(CACHE_NAME, String.class, Pattern.class).loader(Loader.class); } static class Loader extends CacheLoader<String, Pattern> { @Override public Pattern load(String regex) throws Exception { return Pattern.compile(regex); } } } 
<|startcomment|> Schema_120 <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.schema; import com.google.inject.Inject; import com.google.inject.Provider; public class Schema_121 extends SchemaVersion { @Inject <|startfocus|> Schema_121(Provider<Schema_106> prior) { <|endfocus|> super(prior); } } 
<|startcomment|> So isBase = true, when base == null? What does actually "isBase" mean here? <|endcomment|>  private void display(final CommentsCollections comments) { final DiffInfo diff = getDiff(); setThemeStyles(prefs.theme().isDark()); setShowIntraline(prefs.intralineDifference()); if (prefs.showLineNumbers()) { diffTable.addStyleName(Resources.I.diffTableStyle().showLineNumbers()); } cmA = newCm(diff.metaA(), diff.textA(), diffTable.cmA); cmB = newCm(diff.metaB(), diff.textB(), diffTable.cmB); <|startfocus|> boolean isBase = base == null; PatchSet.Id rev = isBase ? revision : base; getDiffTable().setUpBlameIconA(cmA, isBase, rev, path); getDiffTable().setUpBlameIconB(cmB, false, revision, path); <|endfocus|> cmA.extras().side(DisplaySide.A); cmB.extras().side(DisplaySide.B); setShowTabs(prefs.showTabs()); chunkManager = new SideBySideChunkManager(this, cmA, cmB, diffTable.scrollbar); skipManager = new SideBySideSkipManager(this, commentManager); operation(new Runnable() { @Override public void run() {
<|startcomment|> Wrong indentation. <|endcomment|>  .append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()) .append("\n"); } } else { throw new AuthException("delete not permitted"); } } if (del.isEmpty()) { throw new ResourceNotFoundException(); } ctx.getDb().patchSetApprovals().delete(del); ChangeUpdate update = ctx.getUpdate(currPs); update.removeReviewer(reviewerId); <|startfocus|> ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(ctx.getChange().getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), currPs); <|endfocus|> if (msg.length() > 0) { changeMessage.setMessage(msg.toString()); cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage); } emailReviewers(ctx.getProject(), ctx.getChange(), del, changeMessage); PatchSet patchSet = dbProvider.get().patchSets().get( ctx.getChange().currentPatchSetId()); hooks.doReviewerDeletedHook(ctx.getChange(), reviewer,
<|startcomment|> Yes. This is the correct (and obvious) condition. I didn't like that magic to try to encode voting/non voting aspect in vote value by parsing a vote with value +1 as success without voting and +2 as sucess with voting and the opposite for the negative votes, from the previous patch set. <|endcomment|>  short vote = job.getValue().value(); // Mapping for votes and displayed results // -1=Failed, 0=Abstain, +1=Passed if (vote > 0) { p.add(new Image(VerifyStatusPlugin.RESOURCES.greenCheck())); p.add(new InlineHyperlink("Passed", job.getValue().url())); } else if (vote < 0) { p.add(new Image(VerifyStatusPlugin.RESOURCES.redNot())); <|startfocus|> p.add(new InlineHyperlink("Failed", job.getValue().url())); <|endfocus|> } else { p.add(new Image(VerifyStatusPlugin.RESOURCES.info())); p.add(new InlineHyperlink("Abstain", job.getValue().url())); } // TODO: Allow user to define a voting vs non-voting job and display that // in this panel. p.add(new InlineLabel(" ("+job.getValue().duration()+")")); grid.setWidget(row, 3, p); row++; } add(new PopDownButton("Jobs", grid));
<|startcomment|> parentNo <|endcomment|>  String revOrId, String defaultValue) { if (revOrId == null) { revOrId = defaultValue; } else if (isParentCommitRevision(revOrId)) { int number = Integer.parseInt(revOrId); int parentNo = toParentNumber(number); CommitInfo commitInfo = info.revision(revision).commit(); if (commitInfo != null) { JsArray<CommitInfo> parents = commitInfo.parents(); <|startfocus|> if (parents.length() > parentNo) { return RevisionInfo.forParent(number, parents.get(parentNo)); <|endfocus|> } } } else if (!info.revisions().containsKey(revOrId)) { JsArray<RevisionInfo> list = info.revisions().values(); for (int i = 0; i < list.length(); i++) { RevisionInfo r = list.get(i); if (revOrId.equals(String.valueOf(r._number()))) { revOrId = r.name(); break; } } } return revOrId != null ? info.revision(revOrId) : null;
<|startcomment|> Simpler: return db.accounts().get(id) != null; and then we don't need the local account variable. <|endcomment|>  } else { return Collections.emptySet(); } } if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) { AccountState who = byId.getByUsername(nameOrEmail); if (who != null) { return Collections.singleton(who.getAccount().getId()); } } return findAllByNameOrEmail(nameOrEmail); } private boolean exists(Account.Id id) throws OrmException { ReviewDb db = null; db = schema.get(); try { <|startfocus|> Account account = db.accounts().get(id); <|endfocus|> } finally { if ( db != null ) { db.close(); db = null; } } return account != null; } /** * Locate exactly one account matching the name or name/email string. * * @param nameOrEmail a string of the format * "Full Name &lt;email@example&gt;", just the email address * ("email@example"), a full name ("Full Name"). * @return the single account that matches; null if no account matches or
<|startcomment|> Optional: if you make VersionedAuthorizedKeys AutoCloseable you can avoid all these finally blocks. <|endcomment|>  throws IOException, ConfigInvalidException { return read(accountId).getKeys(); } public AccountSshKey getKey(Account.Id accountId, int seq) throws IOException, ConfigInvalidException { return read(accountId).getKey(seq); } public synchronized AccountSshKey addKey(Account.Id accountId, String pub) throws IOException, ConfigInvalidException, InvalidSshKeyException { VersionedAuthorizedKeys authorizedKeys = read(accountId); AccountSshKey key = authorizedKeys.addKey(pub); commit(authorizedKeys); return key; } <|startfocus|> public synchronized void deleteKey(Account.Id accountId, int seq) <|endfocus|> throws IOException, ConfigInvalidException { VersionedAuthorizedKeys authorizedKeys = read(accountId); if (authorizedKeys.deleteKey(seq)) { commit(authorizedKeys); } } public synchronized void markKeyInvalid(Account.Id accountId, int seq) throws IOException, ConfigInvalidException { VersionedAuthorizedKeys authorizedKeys = read(accountId); if (authorizedKeys.markKeyInvalid(seq)) { commit(authorizedKeys); } } private VersionedAuthorizedKeys read(Account.Id accountId) throws IOException, ConfigInvalidException {
<|startcomment|> Unrelated changes. <|endcomment|>  PushOneCommit.SUBJECT + String.format( "\n\nSigned-off-by: %s <%s>", admin.fullName, admin.email), "b.txt", "anotherContent"); r = push.to("refs/for/master"); r.assertOkStatus(); push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent"); r = push.to("refs/for/master"); <|startfocus|> r.assertErrorStatus( "not Signed-off-by author/committer/uploader in commit message footer"); <|endfocus|> } @Test public void testCreateNewChangeForAllNotInTarget() throws Exception { ProjectConfig config = projectCache.checkedGet(project).getConfig(); config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE); saveProjectConfig(project, config); PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content"); PushOneCommit.Result r = push.to("refs/for/master"); r.assertOkStatus(); push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT,
<|startcomment|> nit: this helper method is only used form the isBinary below, move it below the (public) isBinary method <|endcomment|>  + "enter content types to avoid that these checks run on " + "files with one of the entered content types.")); } }; } @VisibleForTesting static String[] getBinaryTypes(PluginConfig cfg) { return cfg.getStringList(KEY_BINARY_TYPES); } private final LoadingCache<String, Pattern> patternCache; private final FileTypeRegistry mimeUtil; @Inject ContentTypeUtil( @Named(CACHE_NAME) LoadingCache<String, Pattern> patternCache, FileTypeRegistry mimeUtil) { this.patternCache = patternCache; <|startfocus|> this.mimeUtil = mimeUtil; <|endfocus|> } public boolean isBinary(ObjectLoader ol, String pathname, PluginConfig cfg) throws IOException, ExecutionException { return matchesAny(getContentType(ol, pathname), getBinaryTypes(cfg)); } public String getContentType(ObjectLoader ol, String pathname) throws IOException { try (InputStream is = ol.openStream()) { return mimeUtil.getMimeType(pathname, is).toString(); } } @VisibleForTesting boolean matchesAny(String s, String[] patterns) throws ExecutionException {
<|startcomment|> nit: trailing whitespace <|endcomment|>  if (openChanges.iterator().hasNext()) { ret.add(project.getName() + " has open changes"); } return ret; } public void delete(Project project) throws OrmException { // TODO(davido): Why not to use 1.7 features? // http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.3.2 Connection conn = ((JdbcSchema) db).getConnection(); try { conn.setAutoCommit(false); try { <|startfocus|> java.sql.ResultSet resultSet = conn.createStatement() .executeQuery( "select change_id from changes where dest_project_name ='" + project.getName() + "';"); <|endfocus|> List<Change.Id> changeIds = new ArrayList<>(); while (resultSet.next()) { changeIds.add(new Change.Id(resultSet.getInt(1))); } atomicDelete(project, changeIds); conn.commit(); } finally { conn.setAutoCommit(true); } } catch (SQLException e) { try { conn.rollback();
<|startcomment|> Injected constructor should have one parameter per line <|endcomment|> import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.account.GroupBackend; import com.google.gerrit.server.account.GroupControl; import com.google.gerrit.server.config.AllProjectsName; import com.google.gerrit.server.git.MetaDataUpdate; import com.google.gerrit.server.git.ProjectConfig; import com.google.gerrit.server.group.GroupJson; import com.google.gerrit.server.permissions.PermissionBackend; import com.google.gerrit.server.permissions.PermissionBackendException; import com.google.gerrit.server.permissions.RefPermission; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; <|startfocus|> import com.google.inject.Provider; <|endfocus|> import com.google.inject.Singleton; import java.io.IOException; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.errors.RepositoryNotFoundException; @Singleton public class GetAccess implements RestReadView<ProjectResource> { /** Marker value used in {@code Map<?, GroupInfo>} for groups not visible to current user. */ private static final GroupInfo INVISIBLE_SENTINEL = new GroupInfo(); 
<|startcomment|> Name this 'rsrc' to be consistent with the naming in other REST endpoint implementations. <|endcomment|> <|startfocus|> public ProjectAccessInfo apply(ProjectResource resource) { <|endfocus|> ProjectAccessInfo info = new ProjectAccessInfo(); ProjectConfig config = resource.getControl().getProjectState().getConfig(); ProjectControl pc = resource.getControl(); RefControl metaConfigControl = pc.controlForRef(RefNames.REFS_CONFIG); info.local = Maps.newHashMap(); info.ownerOf = Sets.newHashSet(); Map<UUID, Boolean> visibleGroups = new HashMap<>(); for (AccessSection section : config.getAccessSections()) { String name = section.getName(); if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) { if (pc.isOwner()) { info.local.put(name, createAccessSection(section)); info.ownerOf.add(name); } else if (metaConfigControl.isVisible()) { info.local.put(section.getName(), createAccessSection(section)); } } else if (RefConfigSection.isValid(name)) { RefControl rc = pc.controlForRef(name); if (rc.isOwner()) { info.local.put(name, createAccessSection(section)); info.ownerOf.add(name); 
<|startcomment|> Base version method was shorter. Consider to extract rendering of skips lines 75-109 in its own method, e.g. renderSkips(context, skips, lineA, lineB); <|endcomment|>  len - context)); } else if (len > 2 * context + 1) { skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context)); } lineA += len; lineB += len; } else { lineA += current.a() != null ? current.a().length() : 0; lineB += current.b() != null ? current.b().length() : 0; } } <|startfocus|> skips = commentManager.splitSkips(context, skips); <|endfocus|> if (!skips.isEmpty()) { boolean isSideBySide = host.diffScreenType == DiffView.SIDE_BY_SIDE; CodeMirror cmA = null; if (isSideBySide) { cmA = host.getCmFromSide(DisplaySide.A); } CodeMirror cmB = host.getCmFromSide(DisplaySide.B); for (SkippedLine skip : skips) { SkipBar barA = null; SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip); skipBars.add(barB); if (isSideBySide) {
<|startcomment|> Optional: Base. <|endcomment|>  import java.util.List; public class EditScreen extends Screen { interface Binder extends UiBinder<HTMLPanel, EditScreen> {} private static final Binder uiBinder = GWT.create(Binder.class); interface Style extends CssResource { String fullWidth(); String hideOrig(); } private final PatchSet.Id base; private final PatchSet.Id revision; private final String path; private final int startLine; private EditPreferences prefs; private EditPreferencesAction editPrefsAction; private MergeView mv; <|startfocus|> private CodeMirror cmOrig; <|endfocus|> private CodeMirror cmEdit; private HttpResponse<NativeString> content; private HttpResponse<NativeString> baseContent; private EditFileInfo editFileInfo; private JsArray<DiffWebLinkInfo> diffLinks; @UiField Element header; @UiField Element project; @UiField Element filePath; @UiField FlowPanel linkPanel; @UiField Element cursLine; @UiField Element cursCol; @UiField Element dirty; @UiField CheckBox showOriginal; @UiField Button close; @UiField Button save; @UiField Element editor; @UiField Style style; private HandlerRegistration resizeHandler;
<|startcomment|> permissions may be null <|endcomment|>  public boolean equals(Object obj) { if (obj instanceof AccessSectionInfo) { <|startfocus|> return permissions.equals(((AccessSectionInfo) obj).permissions); <|endfocus|> } return false;
<|startcomment|> On second thought we could eliminate GET /changes/<id>/edit request altogether. We retrieve the content of a file for change edit with: GET /changes/<id>/edit/foo The idea is to do the query for the base revision and the content of the base in the same request. Justification: we don't want to call the GET /changes/<id>/edit to retrieve the base revision and to retrieve the content of the base in second request. This UI needs this shortcut, so the probability is high, that every UI would need it. So the way to go is to extend the current get chenge edit content request and accept base parameter: GET /changes/<id>/edit/foo&base Something like that (untested): http://paste.openstack.org/show/495379 Then we would just pass this argument to the existing method: ChangeEditApi.get(revision, path, true /*base*/, [...] The change to the existing request should be done in its own change. <|endcomment|>  } })); if (revision.get() == 0) { ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() { @Override public void onSuccess(EditFileInfo editInfo) { editFileInfo = editInfo; } @Override public void onFailure(Throwable e) { } })); if (prefs.showBase()) { <|startfocus|> ChangeApi.edit(revision.getParentKey().get(), group1.addFinal(new AsyncCallback<EditInfo>() { <|endfocus|> @Override public void onSuccess(final EditInfo result) { ChangeEditApi.getFileContent(revision.getParentKey().get(), result.baseRevision(), path, new HttpCallback<NativeString>() { @Override public void onSuccess(HttpResponse<NativeString> fc) { baseContent = fc; group3.done(); } @Override public void onFailure(Throwable caught) { } }); } @Override public void onFailure(Throwable caught) { } })); } else { group1.done(); }
<|startcomment|> Why 'read'? <|endcomment|>  AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo(); accessInfo.deduction.put(AccessSection.GLOBAL_CAPABILITIES, accessSectionInfo); setApiUser(user); exception.expect(BadRequestException.class); gApi.projects().name(allProjects.get()).access(accessInfo); } @Test public void removeGlobalCapabilityAsAdmin() throws Exception { AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")); ProjectAccessInput accessInfo = newProjectAccessChangeInfo(); AccessSectionInfo accessSectionInfo = newAccessSectionInfo(); <|startfocus|> PermissionInfo read = newPermissionInfo(); read.rules.put( <|endfocus|> adminGroup.getGroupUUID().get(), null); accessSectionInfo.permissions.put(Permission.PUSH_SIGNED_TAG, read); // Add and validate first as removing existing privileges such as // administrateServer would break upcoming tests accessInfo.addition.put(AccessSection.GLOBAL_CAPABILITIES, accessSectionInfo); setApiUser(admin); ProjectAccessInfo updatedAccessSectionInfo = gApi.projects().name(allProjects.get()).access(accessInfo); assertThat(updatedAccessSectionInfo.local.get( AccessSection.GLOBAL_CAPABILITIES).permissions.keySet())
<|startcomment|> nit: unneeded blank line <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.client; <|startfocus|> <|endfocus|> import java.util.Objects; public class ProjectWatchInfo { public String project; public String filter; public Boolean notifyNewChanges; public Boolean notifyNewPatchSets; public Boolean notifyAllComments; public Boolean notifySubmittedChanges; public Boolean notifyAbandonedChanges; @Override public boolean equals(Object obj) { if (obj instanceof ProjectWatchInfo) { ProjectWatchInfo w = (ProjectWatchInfo) obj; if (!Objects.equals(project, w.project)) { return false; } if (!Objects.equals(filter, w.filter)) { return false;
<|startcomment|> Unnecessary? <|endcomment|> import static com.google.common.base.Preconditions.checkArgument; import static com.google.common.base.Preconditions.checkNotNull; import static com.google.common.base.Preconditions.checkState; import static java.nio.charset.StandardCharsets.UTF_8; import com.google.common.collect.Iterables; import com.google.common.collect.LinkedListMultimap; import com.google.common.collect.ListMultimap; import com.google.common.net.HttpHeaders; import org.eclipse.jgit.util.RawParseUtils; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintWriter; import java.nio.charset.Charset; <|startfocus|> import java.util.Collection; <|endfocus|> import java.util.Locale; import javax.servlet.ServletOutputStream; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletResponse; /** Simple fake implementation of {@link HttpServletResponse}. */ public class FakeHttpServletResponse implements HttpServletResponse { private final ByteArrayOutputStream actualBody = new ByteArrayOutputStream(); private final ListMultimap<String, String> headers = LinkedListMultimap.create(); private int status = 200; private boolean committed; private ServletOutputStream outputStream; private PrintWriter writer; public FakeHttpServletResponse() { } @Override
<|startcomment|> nit: long lines <|endcomment|>  String commitMessage = ChangeIdUtil.insertId(input.subject, id); if (Boolean.TRUE.equals(info.signedOffBy)) { commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName)); } RevCommit c; if (!Strings.isNullOrEmpty(input.merge)) { // create a merge commit try { <|startfocus|> RevCommit sourceCommit = resolveCommitFromString(input.merge, git, rw); MergeUtil mergeUtil = mergeUtilFactory.create(rsrc.getControl().getProjectState()); <|endfocus|> c = mergeUtil .createMergeCommit(git, oi, mergeTip, sourceCommit, author, commitMessage, rw); } catch (MergeIdenticalTreeException e) { throw new UpdateException("merge failed: " + e.getMessage()); } } else { // create an empty commit c = newCommit(oi, rw, author, mergeTip, commitMessage); } Change.Id changeId = new Change.Id(seq.nextChangeId()); ChangeInserter ins = changeInserterFactory.create(changeId, c, refName) .setValidatePolicy(CommitValidators.Policy.GERRIT);
<|startcomment|> Can this be inlined to one statement, and remove the need for the 'change2' intermediate variable? <|endcomment|>  } @Test @TestProjectInput(createEmptyCommit = false) public void mergeFromDeleteBranch() throws Exception { // push a change for random branch pushFactory.create(db, user.getIdent(), testRepo).to("refs/heads/random"); // push a change for review PushOneCommit change2 = pushFactory .create(db, user.getIdent(), testRepo, "small fix", "a.txt", "2"); PushOneCommit.Result change2result = change2.to("refs/for/master"); // delete the remote random branch <|startfocus|> gApi.projects() .name(project.get()) .branch("random") .delete(); <|endfocus|> // approve and submit the change submit(change2result.getChangeId(), new SubmitInput(), ResourceConflictException.class, "nothing to merge, probably caused by missing dependencies", false); } } 
<|startcomment|> This can be an else block. <|endcomment|>  } else { for (PermissionRule r : p.getRules()) { config.remove(config.getAccessSection(section.getName()), p, r); } } } } // Apply additions for (AccessSection section : additions) { String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); if (isGlobalCapabilities) { checkGlobalCapabilityPermissions(config.getName()); <|startfocus|> } if (!isGlobalCapabilities) { <|endfocus|> if (!AccessSection.isValid(name)) { throw new BadRequestException(""); } if (!projectControl.controlForRef(name).isOwner()) { throw new AuthException("You are not allowed to edit permissions" + "for ref: " + name); } RefControl.validateRefPattern(name); } AccessSection currentAccessSection = config.getAccessSection(section.getName()); // Check all permissions for soundness for (Permission p : section.getPermissions()) { if (isGlobalCapabilities && !GlobalCapability.isCapability(p.getName())) {
<|startcomment|> @Nullable? <|endcomment|> import com.google.gerrit.server.git.ProjectConfig; import org.eclipse.jgit.junit.TestRepository; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevObject; import org.eclipse.jgit.revwalk.RevTree; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.transport.RefSpec; import java.util.concurrent.atomic.AtomicInteger; public abstract class AbstractSubmoduleSubscription extends AbstractDaemonTest { protected TestRepository<?> createProjectWithPush(String name, <|startfocus|> Project.NameKey parent) throws Exception { <|endfocus|> Project.NameKey project = createProject(name, parent); grant(Permission.PUSH, project, "refs/heads/*"); grant(Permission.SUBMIT, project, "refs/for/refs/heads/*"); return cloneProject(project); } protected TestRepository<?> createProjectWithPush(String name) throws Exception { return createProjectWithPush(name, null); } private static AtomicInteger contentCounter = new AtomicInteger(0); protected ObjectId pushChangeTo(TestRepository<?> repo, String ref, String message, String topic) throws Exception {
<|startcomment|> If that's the case, it's confusing to call it "ref", which implies that only ref names are valid. The technical term for the input here is a "commit-ish". I think "source" or "commit" would be ok alternatives. <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // package com.google.gerrit.extensions.common; public class MergeInput { <|startfocus|> // sourceRef could be any git object references expression <|endfocus|> // @see org.eclipse.jgit.lib.Repository#resolve(String) public String sourceRef; // merge-strategy name of the merge strategy (optional) // @see org.eclipse.jgit.merge.MergeStrategy public String mergeStrategy; } 
<|startcomment|> "mergeWithMissingChange"? <|endcomment|>  PushOneCommit.Result change3 = createChange(testRepo, "stable", "test","a.txt", "3", ""); submitWithConflict(change3.getChangeId(), "Failed to submit 1 change due to the following problems:\n" + "Change " + change3.getPatchSetId().getParentKey().get() + ": depends on change that was not submitted"); } @Test @TestProjectInput(createEmptyCommit = false) <|startfocus|> public void mergeFromDeleteDraft() throws Exception { // push a change for random branch <|endfocus|> PushOneCommit.Result draftResult = createDraftChange(); // push a change for review PushOneCommit.Result changeResult = createChange(); // delete the remote random branch gApi.changes().id(draftResult.getChangeId()).delete(); // approve and submit the change submit(changeResult.getChangeId(), new SubmitInput(), ResourceConflictException.class, "nothing to merge, probably caused by missing dependencies", false); } } 
<|startcomment|> Forgot to map field skipUnchanged <|endcomment|>  update.manualReview : def.manualReview; ud.retainHeader = update.retainHeader != null ? update.retainHeader : def.retainHeader; ud.showLineEndings = update.showLineEndings != null ? update.showLineEndings : def.showLineEndings; ud.showTabs = update.showTabs != null ? update.showTabs : def.showTabs; ud.showWhitespaceErrors = update.showWhitespaceErrors != null ? update.showWhitespaceErrors : def.showWhitespaceErrors; ud.skipDeleted = update.skipDeleted != null ? <|startfocus|> update.skipDeleted : def.skipDeleted; <|endfocus|> ud.skipUncommented = update.skipUncommented != null ? update.skipUncommented : def.skipUncommented; ud.syntaxHighlighting = update.syntaxHighlighting != null ? update.syntaxHighlighting : def.syntaxHighlighting; ud.hideTopMenu = update.hideTopMenu != null ? update.hideTopMenu : def.hideTopMenu; ud.autoHideDiffTableHeader = update.autoHideDiffTableHeader != null ? update.autoHideDiffTableHeader : def.autoHideDiffTableHeader; ud.hideLineNumbers = update.hideLineNumbers != null ? update.hideLineNumbers : def.hideLineNumbers; ud.renderEntireFile = update.renderEntireFile != null ?
<|startcomment|> No need for public Done <|endcomment|> <|startfocus|> public GetDiffPreferences(GitRepositoryManager gitManager, AllUsersName allUsersName) { <|endfocus|> this.allUsersName = allUsersName; this.gitManager = gitManager;
<|startcomment|> This assertion is redundant; it will be checked anyway in the call at line 56. <|endcomment|>  update.lineLength = newLineLength; RestResponse r = adminRestSession.put("/config/server/preferences.diff", update); r.assertOK(); DiffPreferencesInfo result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class); assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength); r = adminRestSession.get("/config/server/preferences.diff"); r.assertOK(); result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class); assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength); <|startfocus|> DiffPreferencesInfo expectedDPI = DiffPreferencesInfo.defaults(); expectedDPI.lineLength = newLineLength; assertEquals(result, expectedDPI); <|endfocus|> } public void assertEquals(DiffPreferencesInfo n, DiffPreferencesInfo o) throws IllegalAccessException { for (Field field : n.getClass().getDeclaredFields()) { if (skipField(field)) { continue; } Object nO = field.get(n); Object oO = field.get(o); System.out.println(field.getName()); Class type = field.getType();
<|startcomment|> Blank line missing. <|endcomment|>  private void addRef(PushOne e, String ref) { e.addRef(ref); postEvent(e, ref); <|startfocus|> <|endfocus|>
<|startcomment|> nit: Long line. Or is the margin 100 columns for this project? <|endcomment|> import org.eclipse.jgit.revwalk.RevTree; import org.eclipse.jgit.treewalk.TreeWalk; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; class ReadmeHelper { private static final Logger log = LoggerFactory.getLogger(ReadmeHelper.class); private final ObjectReader reader; private final GitilesView view; private final RevTree rootTree; private final MarkdownConfig config; private String readmePath; private ObjectId readmeId; <|startfocus|> ReadmeHelper(GitilesView view, MarkdownConfig config, ObjectReader reader, RevTree rootTree) { <|endfocus|> this.reader = reader; this.view = view; this.rootTree = rootTree; this.config = config; } void scanTree(RevTree tree) throws MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, IOException { if (config.render) { TreeWalk tw = new TreeWalk(reader); tw.setRecursive(false); tw.addTree(tree); while (tw.next() && !isPresent()) { considerEntry(tw); } } } void considerEntry(TreeWalk tw) { if (config.render
<|startcomment|> GerritCallback <|endcomment|>  public void onClick(final ClickEvent event) { final Boolean oldVal = info.notify(type); info.notify(type, cbox.getValue()); cbox.setEnabled(false); <|startfocus|> JsArray<ProjectWatchInfo> a = JsArray.createArray().cast(); a.push(info); AccountApi.updateWatchedProjects("self", a, new AsyncCallback<JsArray<ProjectWatchInfo>>() { <|endfocus|> @Override public void onSuccess(JsArray<ProjectWatchInfo> watchedProjects) { cbox.setEnabled(true); } @Override public void onFailure(Throwable caught) { cbox.setEnabled(true); info.notify(type, oldVal); cbox.setValue(oldVal); } });
<|startcomment|> merge.source <|endcomment|>  commit.setParentId(mergeTip); } commit.setAuthor(authorIdent); commit.setCommitter(authorIdent); commit.setMessage(commitMessage); return rw.parseCommit(insert(oi, commit)); } private static RevCommit newMergeCommit(Repository repo, ObjectInserter oi, RevWalk rw, MergeUtil mergeUtil, RevCommit mergeTip, MergeInput merge, PersonIdent authorIdent, String commitMessage) throws RestApiException, IOException { if (Strings.isNullOrEmpty(merge.source)) { throw new BadRequestException( <|startfocus|> "source in merge must be non-empty"); <|endfocus|> } try { RevCommit sourceCommit = rw.parseCommit(repo.resolve(merge.source)); // default merge strategy from project settings String mergeStrategy = mergeUtil.mergeStrategyName(); if (!Strings.isNullOrEmpty(merge.strategy)) { // override by user input mergeStrategy = merge.strategy; } return rw.parseCommit(MergeUtil .createMergeCommit(repo, oi, mergeTip, sourceCommit, mergeStrategy, authorIdent, commitMessage)); } catch (AmbiguousObjectException | IncorrectObjectTypeException | IllegalArgumentException e) {
<|startcomment|> nit: line too long <|endcomment|>  exception.expect(AuthException.class); exception.expectMessage("Cannot create tag \"" + R_TAGS + "test\""); tag(input.ref).create(input); } @Test public void createAnnotatedTagNotAllowed() throws Exception { block(Permission.PUSH_TAG, REGISTERED_USERS, R_TAGS + "*"); TagInput input = new TagInput(); input.ref = "test"; input.message = "annotation"; exception.expect(AuthException.class); <|startfocus|> exception.expectMessage("Cannot create annotated tag \"" + R_TAGS + "test\""); <|endfocus|> tag(input.ref).create(input); } @Test public void createSignedTagNotSupported() throws Exception { TagInput input = new TagInput(); input.ref = "test"; input.message = SIGNED_ANNOTATION; exception.expect(MethodNotAllowedException.class); exception.expectMessage("Cannot create signed tag \"" + R_TAGS + "test\""); tag(input.ref).create(input); } @Test public void mismatchedInput() throws Exception { TagInput input = new TagInput(); input.ref = "test"; exception.expect(BadRequestException.class);
<|startcomment|> nit: missing spaces around '=' <|endcomment|> import java.io.InputStreamReader; public class ValidatorTest { @Test public void validateTopLevelDomains() throws Exception { try (InputStream in = this.getClass().getResourceAsStream("tlds-alpha-by-domain.txt")) { if (in == null) { throw new Exception("TLD list not found"); } BufferedReader r = new BufferedReader(new InputStreamReader(in)); String tld; EmailValidator validator = EmailValidator.getInstance(); while ((tld=r.readLine()) != null) { <|startfocus|> if (tld.startsWith("#") || tld.startsWith("XN--")) { <|endfocus|> // Ignore comments and non-latin domains continue; } String test = "test@example." + tld.toLowerCase(); assert_() .withFailureMessage("failed to validate TLD \"" + test + "\"") .that(validator.isValid(test)) .isTrue(); } } } } 
<|startcomment|> Why these specific exception types? What are the errors you're trying to deal with here? This smells like an actual bug and not like a "missing change". Also, never drop exceptions on the floor without at least logging them. <|endcomment|>  // but still >1. for (List<Change.Id> batch : Iterables.partition(ids, 30)) { for (Change change : unwrap(db).changes().get(batch)) { notes.add(createFromChangeOnlyWhenNoteDbDisabled(change)); } } return notes; } private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException { Set<Change.Id> ids = scan(repo); List<ChangeNotes> changeNotes = new ArrayList<>(ids.size()); for (Change.Id id : ids) { <|startfocus|> changeNotes.add(create(db, project, id)); <|endfocus|> } return changeNotes; } public static Set<Change.Id> scan(Repository repo) throws IOException { Map<String, Ref> refs = repo.getRefDatabase().getRefs(RefNames.REFS_CHANGES); Set<Change.Id> ids = new HashSet<>(refs.size()); for (Ref r : refs.values()) { Change.Id id = Change.Id.fromRef(r.getName()); if (id != null) {
<|startcomment|> Assert you have the right message as well. <|endcomment|>  // Create change as admin PushOneCommit push = pushFactory.create( db, admin.getIdent(), adminTestRepo); PushOneCommit.Result r1 = push.to("refs/for/master"); r1.assertOkStatus(); // Fetch change GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps"); userTestRepo.reset("ps"); // Amend change as user PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo); <|startfocus|> r2.assertErrorStatus(); <|endfocus|> } @Test public void createNewSetPatchWithPermission() throws Exception { // Clone separate repositories of the same project as admin and as user TestRepository<InMemoryRepository> adminTestRepo = cloneProject(project, admin); TestRepository<InMemoryRepository> userTestRepo = cloneProject(project, user); // Create change as admin PushOneCommit push = pushFactory.create( db, admin.getIdent(), adminTestRepo); PushOneCommit.Result r1 = push.to("refs/for/master"); r1.assertOkStatus(); // Fetch change
<|startcomment|> Revert <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.change; <|startfocus|> <|endfocus|> import static com.google.common.base.MoreObjects.firstNonNull; import static com.google.common.base.Preconditions.checkNotNull; import static com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId; import static com.google.gerrit.server.change.PutDraftComment.side; import static com.google.gerrit.server.notedb.ReviewerStateInternal.REVIEWER; import static java.nio.charset.StandardCharsets.UTF_8; import com.google.auto.value.AutoValue; import com.google.common.base.MoreObjects; import com.google.common.base.Strings; import com.google.common.collect.ImmutableMap; import com.google.common.collect.Ordering;
<|startcomment|> Harmless but not necessary <|endcomment|> import com.google.gerrit.testutil.InMemoryModule; import com.google.gerrit.testutil.InMemoryRepositoryManager; import com.google.inject.Guice; import com.google.inject.Inject; import com.google.inject.Injector; import com.google.inject.Provider; import com.google.inject.util.Providers; import org.eclipse.jgit.internal.storage.dfs.InMemoryRepository; import org.eclipse.jgit.junit.TestRepository; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.transport.ReceiveCommand; import org.junit.After; import org.junit.Before; import org.junit.Test; <|startfocus|> /** Unit test for {@link BatchUpdate} */ <|endfocus|> public class BatchUpdateTest { @Inject private AccountManager accountManager; @Inject private IdentifiedUser.GenericFactory userFactory; @Inject private InMemoryDatabase schemaFactory; @Inject private InMemoryRepositoryManager repoManager; @Inject private SchemaCreator schemaCreator; @Inject private ThreadLocalRequestContext requestContext; @Inject private BatchUpdate.Factory batchUpdateFactory; private LifecycleManager lifecycle; private ReviewDb db; private TestRepository<InMemoryRepository> repo; private Project.NameKey project; private IdentifiedUser user; @Before public void setUp() throws Exception {
<|startcomment|> unused import <|endcomment|> import com.google.gwtorm.server.OrmException; import com.google.gwtorm.server.SchemaFactory; import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.util.Providers; import org.eclipse.jgit.api.Git; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.errors.RepositoryNotFoundException; import org.eclipse.jgit.internal.storage.dfs.InMemoryRepository; import org.eclipse.jgit.junit.TestRepository; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.PersonIdent; <|startfocus|> import org.eclipse.jgit.lib.RefUpdate; <|endfocus|> import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.transport.Transport; import org.junit.AfterClass; import org.junit.Rule; import org.junit.rules.ExpectedException; import org.junit.rules.TemporaryFolder; import org.junit.rules.TestRule; import org.junit.runner.Description; import org.junit.runner.RunWith; import org.junit.runners.model.Statement; import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.regex.Pattern; @RunWith(ConfigSuite.class)
<|startcomment|> Misplaced <|endcomment|> <|startfocus|> kage com.google.gerrit.server.query; // Copyright (C) 2014 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. import com.google.auto.value.AutoValue; import com.google.gerrit.common.Nullable; import java.util.List; /** Results of a query over entities. */ @AutoValue public abstract class QueryResult<T> { static <T> QueryResult<T> create(@Nullable String query, Predicate<T> predicate, int limit, List<T> entites) { boolean more; if (entites.size() > limit) {
<|startcomment|> This method is getting too long, move all the submodule stuff into a separate method. <|endcomment|>  final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create(); final Set<ObjectId> tips = new HashSet<ObjectId>(); for (final Ref r : repo.getAllRefs().values()) { tips.add(r.getObjectId()); } int commitOrder = 0; for (final Change chg : submitted) { final Change.Id changeId = chg.getId(); if (chg.currentPatchSetId() == null) { <|startfocus|> commits.put(changeId, CodeReviewCommit .error(CommitMergeStatus.NO_PATCH_SET)); <|endfocus|> continue; } final PatchSet ps; try { ps = db.patchSets().get(chg.currentPatchSetId()); } catch (OrmException e) { throw new MergeException("Cannot query the database", e); } if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) { commits.put(changeId, CodeReviewCommit .error(CommitMergeStatus.NO_PATCH_SET)); continue; } final String idstr = ps.getRevision().get();
<|startcomment|> equalsIgnoreCase <|endcomment|>  } } CurrentUser getUser() throws QueryParseException { try { return self.get(); } catch (ProvisionException e) { throw new QueryParseException(NotSignedInException.MESSAGE, e); } } } private final Arguments args; @Inject AccountQueryBuilder(Arguments args) { super(mydef); this.args = args; } @Operator public Predicate<AccountState> account(String query) <|startfocus|> throws QueryParseException, OrmException { Set<Account.Id> ids = parseAccount(query); List<Predicate<AccountState>> p = Lists.newArrayListWithCapacity(ids.size()); for (Account.Id id : ids) { p.add(new AccountIdPredicate(id)); <|endfocus|> } return Predicate.or(p); } @Operator public Predicate<ChangeData> limit(String limit) throws QueryParseException { return new LimitPredicate<>(FIELD_LIMIT, Integer.parseInt(limit)); } @Override protected Predicate<AccountState> defaultField(String query) throws QueryParseException { try { return account(query); } catch (OrmException e) {
<|startcomment|> This needs to be replaced with the new event. <|endcomment|>  throw new BadRequestException("cannot enter a non-autoVerify agreement"); } AccountGroup.UUID uuid = ca.getAutoVerify().getUUID(); if (uuid == null) { throw new ResourceNotFoundException("autoverify group uuid not found"); } AccountGroup group = groupCache.get(uuid); if (group == null) { throw new ResourceNotFoundException("autoverify group not found"); } Account account = self.get().getAccount(); <|startfocus|> hooks.doClaSignupHook(account, ca.getName()); <|endfocus|> addMembers.addMembers(group.getId(), ImmutableList.of(account.getId())); return agreementName; } } 
<|startcomment|> It seems that this test only verifies that basic push works. The actual functionality as described in the documentation [1], i.e. creating a change for commit that already exists in another branch, is not tested. [1] https://gerrit-review.googlesource.com/Documentation/project-configuration.html#_use_target_branch_when_determining_new_changes_to_open <|endcomment|>  config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE); saveProjectConfig(project, config); PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content"); PushOneCommit.Result r = push.to("refs/for/master"); r.assertOkStatus(); push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent"); r = push.to("refs/for/master"); <|startfocus|> r.assertOkStatus(); <|endfocus|> } @Test public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception { grant(Permission.PUSH, project, "refs/heads/master"); PushOneCommit.Result rBase = pushTo("refs/heads/master"); rBase.assertOkStatus(); gApi.projects() .name(project.get()) .branch("foo") .create(new BranchInput()); PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent"); 
<|startcomment|> aka Functions.toStringFunction (unless for some reason toString() is not the same as name()) <|endcomment|>  if (e.getValue().isEmpty()) { // set notify to 'none' since empty sections are not persisted cfg.setString(PROJECT, e.getKey().toString(), KEY_NOTIFY, NOTIFY_NONE); } else { List<String> notifyValues = FluentIterable.from(e.getValue()) .transform(new Function<NotifyType, String>() { @Override public String apply(NotifyType notify) { return notify.name(); } }).toList(); cfg.setStringList(PROJECT, e.getKey().toString(), KEY_NOTIFY, notifyValues); } <|startfocus|> } <|endfocus|> saveConfig(WATCH_CONFIG, cfg); return true; } private static void clearSection(Config cfg, String section) { for (String subsection : cfg.getSubsections(section)) { cfg.unsetSection(section, subsection); } } @Override public void close() { if (git != null) { git.close(); } } private void checkLoaded() { checkNotNull(projectWatches, "project watches not loaded yet"); } } 
<|startcomment|> You want these usernames and probably the email addresses to be wrapped in name, e.g. name("u" + i) Server state, including users, is shared across test methods within a single test class. This means that if you have multiple test methods they see the same set of created users. If you have multiple tests that do something like trying to add users by username, test B might unexpectedly add a user from group A if the usernames overlap. You're not doing that here obviously, but it's sufficiently annoying to track down when it does happen that we recommend using name(...) as a best practice all the time. <|endcomment|> import com.google.gerrit.extensions.api.changes.ReviewResult; import com.google.gerrit.extensions.client.ReviewerState; import com.google.gerrit.extensions.common.AccountInfo; import com.google.gerrit.extensions.common.ApprovalInfo; import com.google.gerrit.extensions.common.ChangeInfo; import com.google.gerrit.extensions.common.LabelInfo; import com.google.gerrit.extensions.common.ReviewerUpdateInfo; import com.google.gerrit.server.change.PostReviewers; import com.google.gerrit.server.mail.Address; import com.google.gerrit.testutil.FakeEmailSender.Message; import com.google.gson.stream.JsonReader; <|startfocus|> import org.junit.Test; <|endfocus|> import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; public class ChangeReviewersIT extends AbstractDaemonTest { @Test public void addGroupAsReviewer() throws Exception { // Set up two groups, one that is too large too add as reviewer, and one // that is too large to add without confirmation. String largeGroup = createGroup("largeGroup"); String mediumGroup = createGroup("mediumGroup"); int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
<|startcomment|> An uncaught IOException should already just bubble up as a 500. Why did you change this method to no longer throw it? <|endcomment|>  ChangeControl control = rsrc.getControl(); Set<Account> members; try { members = groupMembersFactory.create(control.getUser()).listAccounts( group.getGroupUUID(), control.getProject().getNameKey()); } catch (NoSuchGroupException e) { throw new UnprocessableEntityException(e.getMessage()); } catch (NoSuchProjectException e) { throw new BadRequestException(e.getMessage()); } catch (IOException e) { <|startfocus|> // TODO(logan): return error to client <|endfocus|> throw new UnprocessableEntityException(e.getMessage()); } // if maxAllowed is set to 0, it is allowed to add any number of // reviewers int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS); if (maxAllowed > 0 && members.size() > maxAllowed) { return fail(input.reviewer, MessageFormat.format( ChangeMessages.get().groupHasTooManyMembers, group.getName())); } // if maxWithoutCheck is set to 0, we never ask for confirmation int maxWithoutConfirmation = cfg.getInt("addreviewer",
<|startcomment|> Should we also have String getReason(); like in ChangeAbandonedListener? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.events; import com.google.gerrit.extensions.annotations.ExtensionPoint; import com.google.gerrit.extensions.common.ApprovalInfo; import java.util.Map; /** Notified whenever a vote is removed from a change. */ @ExtensionPoint public interface VoteDeletedListener { interface Event extends RevisionEvent { Map<String, ApprovalInfo> getApprovals(); <|startfocus|> Map<String, ApprovalInfo> getOldApprovals(); <|endfocus|> } void onVoteRemoved(Event event); } 
<|startcomment|> How about ImmutableSet to indicate this shouldn't be mutable. You can use ImmutableEnumSet.copyOf(notifyTypes) in the constructor for both space efficiency and immutability. <|endcomment|>  + "of account %d for project %s: %s", nt, accountId.get(), project, notifyValue)); } notifyTypes.add(notifyType.get()); } } return create(filter, notifyTypes); } public static NotifyValue create(@Nullable String filter, Set<NotifyType> notifyTypes) { return new AutoValue_WatchConfig_NotifyValue(Strings.emptyToNull(filter), notifyTypes); } public abstract @Nullable String filter(); <|startfocus|> public abstract Set<NotifyType> notifyTypes(); <|endfocus|> @Override public String toString() { List<NotifyType> notifyTypes = new ArrayList<>(notifyTypes()); Collections.sort(notifyTypes, new Comparator<NotifyType>() { @Override public int compare(NotifyType nt1, NotifyType nt2) { return nt1.name().compareTo(nt2.name()); }}); StringBuilder notifyValue = new StringBuilder(); notifyValue.append(firstNonNull(filter(), AccountProjectWatch.FILTER_ALL)) .append(" ["); Joiner.on(", ").appendTo(notifyValue, notifyTypes); notifyValue.append("]");
<|startcomment|> If I am not mistaken, then this will try to use port 22 unless a port is set. Is this a good defualt, or should it get mapped to 29418 ? <|endcomment|>  log.error(String.format( "Error updating HEAD of remote repository at %s to %s:\n" + " Exception: %s\n Command: %s\n Output: %s", uri, newHead, e, cmd, errStream), e); return false; } return true; } private URIish toSshUri(URIish uri) throws URISyntaxException { <|startfocus|> if (uri.getHost() != null) { return new URIish(uri.toString().replace("gerrit\\+ssh://", "ssh://")); <|endfocus|> } String rawPath = uri.getRawPath(); if (!rawPath.endsWith("/")) { rawPath = rawPath + "/"; } URIish sshUri = new URIish("ssh://" + rawPath); if (sshUri.getPort() < 0) { sshUri = sshUri.setPort(29418); } return sshUri; } private void execute(String remoteName, URIish uri, String cmd, OutputStream errStream) throws IOException { try { URIish sshUri = toSshUri(uri);
<|startcomment|> Should go after NotesMigration <|endcomment|> import com.google.inject.assistedinject.Assisted; import com.google.inject.assistedinject.AssistedInject; import org.eclipse.jgit.errors.IncorrectObjectTypeException; import org.eclipse.jgit.errors.MissingObjectException; import org.eclipse.jgit.errors.RepositoryNotFoundException; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.PersonIdent; import org.eclipse.jgit.lib.Ref; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.FooterLine; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevWalk; <|startfocus|> import com.google.gerrit.server.notedb.ReviewerStateInternal; <|endfocus|> import java.io.IOException; import java.sql.Timestamp; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set; public class ChangeData { private static final int BATCH_SIZE = 50; public static List<Change> asChanges(List<ChangeData> changeDatas) throws OrmException { List<Change> result = new ArrayList<>(changeDatas.size()); for (ChangeData cd : changeDatas) {
<|startcomment|> does that mean that we enable LFS by default? I would rather have false here... <|endcomment|>  private final LfsRepositoryResolver repoResolver; private final LfsAuthUserProvider userProvider; @Inject LfsApiServlet( ProjectCache projectCache, PermissionBackend permissionBackend, LfsConfigurationFactory lfsConfigFactory, LfsRepositoryResolver repoResolver, LfsAuthUserProvider userProvider) { this.projectCache = projectCache; this.permissionBackend = permissionBackend; this.lfsConfigFactory = lfsConfigFactory; this.repoResolver = repoResolver; this.userProvider = userProvider; } @Override <|startfocus|> protected LargeFileRepository getLargeFileRepository(LfsRequest request, String path, String auth) throws LfsException { <|endfocus|> String pathInfo = path.startsWith("/") ? path : "/" + path; Matcher matcher = URL_PATTERN.matcher(pathInfo); if (!matcher.matches()) { throw new LfsException("no repository at " + pathInfo); } String projName = matcher.group(1); Project.NameKey project = Project.NameKey.parse(ProjectUtil.stripGitSuffix(projName)); ProjectState state = projectCache.get(project); if (state == null || state.getProject().getState() == HIDDEN) {
<|startcomment|> change the log level to debug instead of removing it completely? <|endcomment|>  private Provider<Command> load(Plugin plugin) { if (plugin.getSshInjector() != null) { Key<Command> key = Commands.key(plugin.getName()); try { return plugin.getSshInjector().getProvider(key); } catch (RuntimeException err) { <|startfocus|> /* Plugin did not define its top-level command. */ <|endfocus|> } } return null;
<|startcomment|> not about this change: ImmutableSet would be clearer for these <|endcomment|>  protected void configure() { <|startfocus|> bind(new TypeLiteral<Set<GroupReference>>() {}) <|endfocus|> .annotatedWith(AdministrateServerGroups.class) .toProvider(AdministrateServerGroupsProvider.class) .in(SINGLETON); bind(new TypeLiteral<Set<AccountGroup.UUID>>() {}) .annotatedWith(GitUploadPackGroups.class) .toProvider(GitUploadPackGroupsProvider.class) .in(SINGLETON); bind(new TypeLiteral<Set<AccountGroup.UUID>>() {}) .annotatedWith(GitReceivePackGroups.class) .toProvider(GitReceivePackGroupsProvider.class) .in(SINGLETON); bind(ChangeControl.Factory.class); factory(ProjectControl.AssistedFactory.class);
<|startcomment|> Nit: no space after @ here and below. <|endcomment|>  expectedProjects.add("platform/whee"); expectedProjects.add("platform/added/project"); assertThat(configLoader.getProjectsInScope( "master", "ds_one")).isEqualTo(expectedProjects); } @Test public void getProjectsInScopeTest_setProjects() throws Exception { loadConfig(); Set<String> otherExpectedProjects = new HashSet<String>(); otherExpectedProjects.add("platform/some/project"); otherExpectedProjects.add("platform/other/project"); assertThat(configLoader.getProjectsInScope( "master", "ds_two")).isEqualTo(otherExpectedProjects); } <|startfocus|> @ Test <|endfocus|> public void isSkipMergeTest_noSkip() throws Exception { loadConfig(); assertThat(configLoader.isSkipMerge("ds_two", "ds_three", "bla")).isFalse(); } @ Test public void isSkipMergeTest_blankMerge() throws Exception { loadConfig(); assertThat(configLoader.isSkipMerge( "ds_two", "ds_three", "test test \n \n DO NOT MERGE")).isTrue(); } @ Test public void isSkipMergeTest_blankMergeWithMergeAll() throws Exception { loadConfig();
<|startcomment|> nit: wrap this line <|endcomment|>  String refName = edit.getRefName(); RevCommit prevEdit = edit.getEditCommit(); ObjectId newTree = writeNewTree( op, rw, inserter, prevEdit, reader, file, newFile, content); if (ObjectId.equals(newTree, prevEdit.getTree())) { throw new InvalidChangeOperationException("no changes were made"); } Timestamp now = TimeUtil.nowTs(); <|startfocus|> ObjectId commit = createCommit(me, inserter, prevEdit, newTree, project, now); <|endfocus|> inserter.flush(); return update(repo, me, refName, rw, prevEdit, commit, now); } } private static ObjectId toBlob(ObjectInserter ins, @Nullable RawInput content) throws IOException { if (content == null) { return null; } long len = content.getContentLength(); InputStream in = content.getInputStream(); if (len < 0) { return ins.insert(OBJ_BLOB, ByteStreams.toByteArray(in)); } return ins.insert(OBJ_BLOB, len, in); } 
<|startcomment|> Stray newline. <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.mail; import com.google.gerrit.server.config.SitePaths; <|startfocus|> <|endfocus|> import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.ProvisionException; import com.google.inject.Singleton; import com.google.template.soy.SoyFileSet; import com.google.template.soy.tofu.SoyTofu; import java.io.File; import java.net.URL; /** Configures Soy Tofu object for rendering email templates. */ @Singleton public class SoyTofuProvider implements Provider<SoyTofu> { // Note: will fail to construct the tofu object if this array is empty. private static final String[] TEMPLATES = { "footer.soy", }; 
<|startcomment|> We made it configurable to show job panel or not in change screen. Wouldn't it make sense to extend the configuration and also allow sites/user to configure if jobs summary should be shown or not? <|endcomment|>  public void onSuccess(ConfigInfo info) { <|startfocus|> Plugin.get().panel( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsSummaryPanel.Factory()); <|endfocus|> if (info.showJobsPanel()) { Plugin.get().panel( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, new JobsPanel.Factory()); } if (info.showJobsDropDownPanel()) { Plugin.get().panel( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, new JobsDropDownPanel.Factory()); }
<|startcomment|> When config == null this will jump directly to the line 109 and return a (non-null) repository instance. Instead we must return null in such a case. <|endcomment|>  ProjectUtil.stripGitSuffix(matcher.group(1))); ProjectState state = projectCache.get(project); if (state == null || state.getProject().getState() == HIDDEN) { throw new LfsRepositoryNotFound(project.get()); } if (request.getOperation().equals("upload") && state.getProject().getState() == READ_ONLY) { throw new LfsRepositoryReadOnly(project.get()); } LfsConfigSection config = lfsConfig.getForProject(project); <|startfocus|> if (config != null) { // Only accept requests for projects where LFS is enabled if (!config.getEnabled()) { return null; } <|endfocus|> // For uploads, check object sizes against limit if configured if (request.getOperation().equals("upload")) { Config pluginConfig = pluginConfigFactory.getProjectPluginConfig( state, LfsConfigSection.LFS); long maxObjectSize = config.getMaxObjectSize(); long projectMaxObjectSize = pluginConfig.getLong( LfsConfigSection.LFS, LfsConfigSection.KEY_MAX_OBJECT_SIZE, 0); if (maxObjectSize > 0 && projectMaxObjectSize > 0) {
<|startcomment|> "the caller's" <|endcomment|> <|startfocus|> private Op(String msgTxt, Account account) { this.account = account; <|endfocus|> this.msgTxt = msgTxt;
<|startcomment|> Should this be public? <|endcomment|> <|startfocus|> boolean getWriteJson() { <|endfocus|> return writeJson;
<|startcomment|> long line, wrap <|endcomment|>  for (PatchLineComment c : baseComments) { if (!delete.contains(c.getKey()) && !put.containsKey(c.getKey())) { all.put(c.getPatchSetId(), c); } } for (PatchLineComment c : put.values()) { if (!delete.contains(c.getKey())) { all.put(c.getPatchSetId(), c); } } return all; } <|startfocus|> private void buildNoteJson(ChangeNoteUtil noteUtil, OutputStream out) throws IOException { <|endfocus|> Multimap<PatchSet.Id, PatchLineComment> comments = buildCommentMap(); if (comments.isEmpty() && pushCert == null) { return; } RevisionNoteData data = new RevisionNoteData(); data.comments = new ArrayList<>(comments.size()); for (PatchLineComment plc : PLC_ORDER.sortedCopy(comments.values())) { data.comments.add(new RevisionNoteData.Comment(plc, noteUtil.getServerId())); } data.pushCert = pushCert; try (OutputStreamWriter osw = new OutputStreamWriter(out)) {
<|startcomment|> Nothing gets added to errors, so it will aways be empty. <|endcomment|>  // as no projects contains ".git/": String fname = p.get() + ".git"; ZipEntry e = new ZipEntry(fname); zos.putNextEntry(e); bw.writeBundle(NullProgressMonitor.INSTANCE, zos); zos.closeEntry(); } zos.finish(); } }; } if (!errors.isEmpty()) { StringBuilder sb = new StringBuilder(); for (Exception e : errors) { sb.append(e.getMessage()); } reject(sb.toString()); } return bin; } <|startfocus|> private String reject(final String message) { return message; <|endfocus|> } } 
<|startcomment|> If you @Inject the instance, this shouldn't be necessary. AbstractChangeNotesTest#setUp calls injectMembers after the config instance is set. <|endcomment|>  private boolean testJson() { // Get a fresh instance to make sure the config is right <|startfocus|> ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class); <|endfocus|> return noteUtil.getWriteJson();
<|startcomment|> I think that we now prefer the standard syntax: new ArrayList<>(capacity) <|endcomment|>  public List<LfsConfigSection> getConfigSections() { Config cfg = projectCache.getAllProjects().getConfig(pluginName + ".config").get(); Set<String> namespaces = cfg.getSubsections(LfsConfigSection.LFS); if (!namespaces.isEmpty()) { <|startfocus|> ArrayList<LfsConfigSection> result = Lists.newArrayListWithCapacity(namespaces.size()); <|endfocus|> for (String n : namespaces) { result.add(new LfsConfigSection(cfg, n)); } return result; } return ImmutableList.of();
<|startcomment|> Would injecting Provider<CurrentUser> be a more standard way of getting the caller identity? <|endcomment|> import com.google.inject.Singleton; import java.util.HashMap; import java.util.List; @Singleton public class GetLfsSettings implements RestReadView<ProjectResource> { private final LfsConfig lfsConfig; private final AllProjectsName allProjectsName; @Inject GetLfsSettings(LfsConfig lfsConfig, AllProjectsName allProjectsName) { this.lfsConfig = lfsConfig; this.allProjectsName = allProjectsName; } @Override public LfsSettingsInfo apply(ProjectResource resource) throws RestApiException { <|startfocus|> IdentifiedUser user = resource.getControl().getUser().asIdentifiedUser(); <|endfocus|> if (!(resource.getNameKey().equals(allProjectsName) && user.getCapabilities().canAdministrateServer())) { throw new ResourceNotFoundException(); } LfsSettingsInfo info = new LfsSettingsInfo(); info.backend = lfsConfig.getBackend(); List<LfsConfigSection> configSections = lfsConfig.getConfigSections(); if (!configSections.isEmpty()) { info.namespaces = new HashMap<>(configSections.size()); for (LfsConfigSection section : configSections) { LfsConfigInfo sectionInfo = new LfsConfigInfo();
<|startcomment|> Why 'm'? <|endcomment|>  public final native void showWhitespaceErrors(boolean s) /*-{ this.show_whitespace_errors = s }-*/; public final native void syntaxHighlighting(boolean s) /*-{ this.syntax_highlighting = s }-*/; public final native void hideLineNumbers(boolean s) /*-{ this.hide_line_numbers = s }-*/; public final native void matchBrackets(boolean m) /*-{ this.match_brackets = m }-*/; <|startfocus|> public final native void lineWrapping(boolean m) /*-{ this.line_wrapping = m }-*/; <|endfocus|> public final native void autoCloseBrackets(boolean c) /*-{ this.auto_close_brackets = c }-*/; public final Theme theme() { String s = themeRaw(); return s != null ? Theme.valueOf(s) : Theme.DEFAULT; } private final native String themeRaw() /*-{ return this.theme }-*/; public final KeyMapType keyMapType() { String s = keyMapTypeRaw(); return s != null ? KeyMapType.valueOf(s) : KeyMapType.DEFAULT; }
<|startcomment|> *facepalm* bind(...).toInstance(testConfig) <|endcomment|>  install(new GitModule()); install(NoteDbModule.forTest(testConfig)); bind(AllUsersName.class).toProvider(AllUsersNameProvider.class); bind(String.class).annotatedWith(GerritServerId.class) .toInstance("gerrit"); bind(NotesMigration.class).toInstance(MIGRATION); bind(GitRepositoryManager.class).toInstance(repoManager); bind(ProjectCache.class).toProvider(Providers.<ProjectCache> of(null)); bind(CapabilityControl.Factory.class) .toProvider(Providers.<CapabilityControl.Factory> of(null)); bind(Config.class).annotatedWith(GerritServerConfig.class) <|startfocus|> .toProvider(Providers.of(testConfig)); <|endfocus|> bind(String.class).annotatedWith(AnonymousCowardName.class) .toProvider(AnonymousCowardNameProvider.class); bind(String.class).annotatedWith(CanonicalWebUrl.class) .toInstance("http://localhost:8080/"); bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class) .toInstance(Boolean.FALSE); bind(Realm.class).to(FakeRealm.class); bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON); bind(AccountCache.class).toInstance(accountCache); bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class) .toInstance(serverIdent); bind(GitReferenceUpdated.class) .toInstance(GitReferenceUpdated.DISABLED);
<|startcomment|> It's confusing that "previous assignee" is the account associated with "current assignee", I would have guessed that "previous" and "current" were two different ones. How about Account.Id oldAssigneeId and Account oldAssignee <|endcomment|>  } if (!ctx.getControl().canEditAssignee()) { throw new AuthException("Changing Assignee not permitted"); } ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId()); ChangeNotes notes = update.getNotes().load(); Account.Id currentAssignee = notes.getAssignee(); if (input == null || input.assignee == null) { if (currentAssignee != null) { throw new AuthException("Cannot remove Assignee."); } return false; } <|startfocus|> Account previousAssignee = null; if (currentAssignee != null) { previousAssignee = accountInfosFactory.create().get(currentAssignee); <|endfocus|> } IdentifiedUser newAssigneeUser = accounts.parse(input.assignee); if (currentAssignee != null && currentAssignee.equals(newAssigneeUser.getAccountId())) { newAssignee = previousAssignee; return false; } if (!newAssigneeUser.getAccount().isActive()) { throw new UnprocessableEntityException(String.format( "Account of %s is not active", newAssigneeUser.getUserName())); }
<|startcomment|> This isn't a repeated field, use Iterables.getFirst as in other non-repeated examples. <|endcomment|>  private void decodeStar(ListMultimap<String, IndexableField> doc, ChangeData cd) { Collection<IndexableField> star = doc.get(STAR_FIELD); ListMultimap<Account.Id, String> stars = MultimapBuilder.hashKeys().arrayListValues().build(); for (IndexableField r : star) { <|startfocus|> StarredChangesUtil.StarField starField = StarredChangesUtil.StarField.parse(r.stringValue()); <|endfocus|> if (starField != null) { stars.put(starField.accountId(), starField.label()); } } cd.setStars(stars);
<|startcomment|> account <|endcomment|> import com.google.inject.Inject; public class GetAssignee implements RestReadView<ChangeResource> { private final AccountInfoCacheFactory.Factory accountInfos; @Inject GetAssignee(AccountInfoCacheFactory.Factory accountInfosFactory) { this.accountInfos = accountInfosFactory; } @Override public Response<AccountInfo> apply(ChangeResource rsrc) throws OrmException { Optional<Account.Id> assignee = rsrc.getControl().getNotes().load().getAssignee(); if (assignee.isPresent()) { <|startfocus|> Account assigneeAcc = accountInfos.create().get(assignee.get()); return Response.ok(AccountJson.toAccountInfo(assigneeAcc)); <|endfocus|> } return Response.none(); } } 
<|startcomment|> Should be final. Instead of reassigning in the constructor, either use ?: or a non-final local variable. <|endcomment|> import io.searchbox.core.Delete; import io.searchbox.indices.CreateIndex; import io.searchbox.indices.DeleteIndex; import io.searchbox.indices.IndicesExists; abstract class AbstractElasticIndex<K, V> implements Index<K, V> { private static final String DEFAULT_INDEX_NAME = "gerrit"; private final Schema<V> schema; private final FillArgs fillArgs; private final SitePaths sitePaths; private final Logger log = LoggerFactory.getLogger(AbstractElasticIndex.class); protected final boolean refresh; protected final JestHttpClient client; <|startfocus|> protected String indexName; <|endfocus|> @Inject AbstractElasticIndex(@GerritServerConfig Config cfg, FillArgs fillArgs, SitePaths sitePaths, @Assisted Schema<V> schema) { this.fillArgs = fillArgs; this.sitePaths = sitePaths; this.schema = schema; String url = cfg.getString("index", null, "url"); checkState(!Strings.isNullOrEmpty(url), "index.url must be supplied"); indexName = cfg.getString("index", null, "name"); if (Strings.isNullOrEmpty(indexName)) { indexName = DEFAULT_INDEX_NAME; } 
<|startcomment|> "the assignee of a change is modified"? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.validators; import com.google.gerrit.extensions.annotations.ExtensionPoint; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.client.Change; /** * Listener to provide validation of assignees. */ @ExtensionPoint public interface AssigneeValidationListener { /** <|startfocus|> * Invoked by Gerrit before a new assignee is changed. <|endfocus|> * * @param change the change on which the assignee is changed * @param assignee the new assignee. Null if removed * @throws ValidationException if validation fails */ void validateAssignee(Change change, Account assignee) throws ValidationException; } 
<|startcomment|> Copy paste error? <|endcomment|> import com.google.gerrit.extensions.annotations.ExtensionPoint; import com.google.gerrit.reviewdb.client.Account; import java.util.List; import java.util.Set; /** * Listener to provide reviewer suggestions. * * Invoked by Gerrit a user is searching for a reviewer to add to a change. */ @ExtensionPoint public interface ReviewerSuggestion { /** * Reviewer suggestion. * * @param query The query as typed by the user. Can be an empty string. <|startfocus|> * @param candidates A set of account ids commit event details <|endfocus|> * @return List of suggested reviewers as a tuple of account id and score. */ List<SuggestedReviewer> suggestReviewers(String query, Set<Account.Id> candidates); } 
<|startcomment|> Long line <|endcomment|>  @Test public void assigneeChangeNotes() throws Exception { Change c = newChange(); ChangeUpdate update = newUpdate(c, changeOwner); update.setAssignee(otherUserId); update.commit(); ChangeNotes notes = newNotes(c); assertThat(notes.getChange().getAssignee()).isEqualTo(otherUserId); update = newUpdate(c, changeOwner); update.setAssignee(changeOwner.getAccountId()); update.commit(); notes = newNotes(c); <|startfocus|> assertThat(notes.getChange().getAssignee().get()).isEqualTo(changeOwner.getAccountId()); <|endfocus|> } @Test public void pastAssigneesChangeNotes() throws Exception { Change c = newChange(); ChangeUpdate update = newUpdate(c, changeOwner); update.setAssignee(otherUserId); update.commit(); ChangeNotes notes = newNotes(c); update = newUpdate(c, changeOwner); update.setAssignee(changeOwner.getAccountId()); update.commit(); update = newUpdate(c, changeOwner); update.setAssignee(otherUserId); update.commit(); update = newUpdate(c, changeOwner); update.removeAssignee(); update.commit(); 
<|startcomment|> Now that you've put the Schema in the constructor I'm going to make you do the rest :) This should no longer be a class level constant, it should be a private final field. The Schema that you should pass to the constructor is the assisted injected schema arg on l. 141. <|endcomment|>  || fieldType == FieldType.LONG) { mappingBuilder.addNumber(name); } else if (fieldType == FieldType.PREFIX || fieldType == FieldType.FULL_TEXT || fieldType == FieldType.STORED_ONLY) { mappingBuilder.addString(name); } else { throw new IllegalArgumentException( "Unsupported filed type " + fieldType.getName()); } } MappingProperties mappging = mappingBuilder.build(); openChanges = mappging; closedChanges = mappging; } } <|startfocus|> static final ChangeMapping MAPPING = new ChangeMapping(ChangeSchemaDefinitions.INSTANCE.getLatest()); <|endfocus|> private final String OPEN_CHANGES = "open_changes"; private final String CLOSED_CHANGES = "closed_changes"; private final Provider<ReviewDb> db; private final ElasticQueryBuilder queryBuilder; private final ChangeData.Factory changeDataFactory; private final Gson gson; @AssistedInject ElasticChangeIndex( @GerritServerConfig Config cfg, Provider<ReviewDb> db, ChangeData.Factory changeDataFactory, FillArgs fillArgs, SitePaths sitePaths, @Assisted Schema<ChangeData> schema) {
<|startcomment|> mapping <|endcomment|>  || fieldType == FieldType.FULL_TEXT || fieldType == FieldType.STORED_ONLY) { mappingBuilder.addString(name); } else { throw new IllegalArgumentException( "Unsupported filed type " + fieldType.getName()); } } MappingProperties mappging = mappingBuilder.build(); openChanges = mappging; closedChanges = mappging; } } static final String OPEN_CHANGES = "open_changes"; static final String CLOSED_CHANGES = "closed_changes"; private final Gson gson; <|startfocus|> private final ChangeMapping mappging; <|endfocus|> private final Provider<ReviewDb> db; private final ElasticQueryBuilder queryBuilder; private final ChangeData.Factory changeDataFactory; @AssistedInject ElasticChangeIndex( @GerritServerConfig Config cfg, Provider<ReviewDb> db, ChangeData.Factory changeDataFactory, FillArgs fillArgs, SitePaths sitePaths, @Assisted Schema<ChangeData> schema) { super(cfg, fillArgs, sitePaths, schema); this.db = db; this.changeDataFactory = changeDataFactory; mappging = new ChangeMapping(schema); this.queryBuilder = new ElasticQueryBuilder();
<|startcomment|> nit: usage of final not needed here <|endcomment|> <|startfocus|> public void requestDefaultSuggestions(final Request req, final Callback cb) { // We don't want to deal with a null query, but an empty string instead req.setQuery(""); <|endfocus|> requestSuggestions(req, cb);
<|startcomment|> assume().that(notesMigration.readChanges()).isTrue(); <|endcomment|>  in.onBehalfOf = user.id.toString(); in.label("Verified", 1); exception.expect(AuthException.class); exception.expectMessage( "not permitted to modify label \"Verified\" on behalf of \"" + in.onBehalfOf + '"'); revision.review(in); } @Test public void voteOnBehalfOfWithComment() throws Exception { testVoteOnBehalfOfWithComment(); } @GerritConfig(name = "notedb.writeJson", value = "true") @Test <|startfocus|> public void voteOnBehalfOfWithCommentWritingJson() throws Exception { <|endfocus|> testVoteOnBehalfOfWithComment(); } private void testVoteOnBehalfOfWithComment() throws Exception { allowCodeReviewOnBehalfOf(); PushOneCommit.Result r = createChange(); ReviewInput in = new ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Code-Review", 1); CommentInput ci = new CommentInput(); ci.path = Patch.COMMIT_MSG; ci.side = Side.REVISION; ci.line = 1; ci.message = "message";
<|startcomment|> Maybe sanity check that the current patch set is also a merge? I suppose it's *possible* to convert a non-merge change into a merge change, but it seems much more likely to be user error. <|endcomment|>  throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException { if (merge == null) { throw new BadRequestException("merge must be non-null"); } ChangeControl ctl = req.getControl(); if (!ctl.isVisible(db.get())) { throw new InvalidChangeOperationException( "Base change not found: " + req.getId()); } PatchSet ps = psUtil.current(db.get(), ctl.getNotes()); if (!ctl.canAddPatchSet(db.get())) { <|startfocus|> throw new AuthException("cannot upload patchset"); <|endfocus|> } ChangeData changeData = changeDataFactory.create(db.get(), ctl.getChange()); ProjectControl projectControl = ctl.getProjectControl(); Project.NameKey project = ctl.getChange().getProject(); Branch.NameKey dest = ctl.getChange().getDest(); try (Repository git = gitManager.openRepository(project); ObjectInserter oi = git.newObjectInserter(); RevWalk rw = new RevWalk(oi.newReader())) { ObjectId parentCommit = null;
<|startcomment|> Better log this as error. <|endcomment|>  for (Future<List<SuggestedReviewer>> f : futures) { double weight = weightIterator.next(); for (SuggestedReviewer s : f.get()) { if (reviewerScores.containsKey(s.account)) { reviewerScores.get(s.account).add(s.score * weight); } else { reviewerScores.put(s.account, new MutableDouble(s.score * weight)); } } } } catch (ExecutionException | InterruptedException e) { <|startfocus|> log.warn("Exception while suggesting reviewers", e); <|endfocus|> return ImmutableList.of(); } // Remove change owner reviewerScores.remove(changeNotes.getChange().getOwner()); // Sort results Stream<Entry<Account.Id, MutableDouble>> sorted = reviewerScores.entrySet().stream() .sorted(Collections.reverseOrder(Map.Entry.comparingByValue())); List<Account.Id> sortedSuggestions = sorted .map(Map.Entry::getKey) .collect(Collectors.toList()); return sortedSuggestions; } private Map<Account.Id, MutableDouble> baseRankingForEmptyQuery( double baseWeight) throws OrmException{ // Get the user's last 50 changes, check reviewers
<|startcomment|> nit: line too long <|endcomment|>  this.json = json; } @Override public ChangeInfo apply(RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException { final ChangeControl control = revision.getControl(); int parentIndex = input.parentNumber == null ? 0 : input.parentNumber - 1; if (input.message == null || input.message.trim().isEmpty()) { throw new BadRequestException("message must be non-empty"); <|startfocus|> } else if (input.destination == null || input.destination.trim().isEmpty()) { <|endfocus|> throw new BadRequestException("destination must be non-empty"); } else if (parentIndex < 0) { throw new BadRequestException("parent number must be positive if specified"); } @SuppressWarnings("resource") ReviewDb db = dbProvider.get(); if (!control.isVisible(db)) { throw new AuthException("Cherry pick not permitted"); } ProjectControl projectControl = control.getProjectControl(); Capable capable = projectControl.canPushToAtLeastOneRef(); if (capable != Capable.OK) {
<|startcomment|> If this would really be a regex then we would have to use: serveRegex(...) But it is not a regex it is just a regular urlPattern. <|endcomment|>  protected void configureServlets() { serveRegex(URL_REGEX).with(LfsApiServlet.class); if (FS.equals(defaultBackend.type)) { LocalLargeFileRepository defRepository = fsRepoFactory.create(defaultBackend); <|startfocus|> serve(defRepository.getServletRegexp()) .with(new LfsFsContentServlet(defRepository)); <|endfocus|> } for (LfsBackend backendCfg : backends.values()) { if (FS.equals(backendCfg.type)) { LocalLargeFileRepository repository = fsRepoFactory.create(backendCfg); serve(repository.getServletRegexp()) .with(new LfsFsContentServlet(repository)); } }
<|startcomment|> Why is this no longer private? <|endcomment|>  static Optional<StatusChangeEvent> parseFromMessage(ChangeMessage message, Change change, Change noteDbChange) { String msg = message.getMessage(); if (msg == null) { return Optional.absent(); } for (Map.Entry<Change.Status, Pattern> e : PATTERNS.entrySet()) { if (e.getValue().matcher(msg).matches()) { return Optional.of(new StatusChangeEvent( message, change, noteDbChange, e.getKey())); } } return Optional.absent(); } <|startfocus|> final Change.Status status; <|endfocus|> private final Change change; private final Change noteDbChange; private StatusChangeEvent(ChangeMessage message, Change change, Change noteDbChange, Change.Status status) { this(message.getPatchSetId(), message.getAuthor(), message.getWrittenOn(), change, noteDbChange, message.getTag(), status); } private StatusChangeEvent(PatchSet.Id psId, Account.Id author, Timestamp when, Change change, Change noteDbChange, String tag, Change.Status status) { super(psId, author, author, when, change.getCreatedOn(), tag);
<|startcomment|> nit: long lines <|endcomment|>  HttpServletResponseRecorder wrappedResponse = new HttpServletResponseRecorder((HttpServletResponse) response); boolean loggedInBefore = session.get().isSignedIn(); CurrentUser currentUser = loggedInBefore ? userProvider.get() : null; chain.doFilter(request, wrappedResponse); boolean loggedInAfter = session.get().isSignedIn(); if (!loggedInBefore && loggedInAfter) { for (WebLoginListener loginListener : webLoginListeners) { currentUser = userProvider.get().asIdentifiedUser(); <|startfocus|> loginListener.onLogin(currentUser.asIdentifiedUser(), httpRequest, wrappedResponse); <|endfocus|> } } else if (loggedInBefore && !loggedInAfter) { for (WebLoginListener loginListener : webLoginListeners) { loginListener.onLogout(currentUser.asIdentifiedUser(), httpRequest, wrappedResponse); } } wrappedResponse.play(); } @Override public void destroy() { } } 
<|startcomment|> These can be replaced with RestApiException <|endcomment|> import com.google.inject.Singleton; import java.io.IOException; @Singleton class ChangeIncludedIn implements RestReadView<ChangeResource> { private Provider<ReviewDb> db; private PatchSetUtil psUtil; private IncludedIn includedIn; @Inject ChangeIncludedIn(Provider<ReviewDb> db, PatchSetUtil psUtil, IncludedIn includedIn) { this.db = db; this.psUtil = psUtil; this.includedIn = includedIn; } @Override <|startfocus|> public IncludedIn.IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException { <|endfocus|> ChangeControl ctl = rsrc.getControl(); PatchSet ps = psUtil.current(db.get(), rsrc.getNotes()); Project.NameKey project = ctl.getProject().getNameKey(); return includedIn.apply(project, ps.getRevision().get()); } } 
<|startcomment|> I would just have a single constant instance of this: public static final FilenameComparator INSTANCE = new FilenameComparator(); private FilenameComparator() {} <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.common.data; import com.google.common.collect.Sets; import com.google.gerrit.reviewdb.client.Patch; import java.util.Comparator; import java.util.Set; <|startfocus|> public class FilenameComparator implements Comparator<String> { <|endfocus|> private static final Set<String> cppHeaderSuffixes = Sets.newHashSet( ".h", ".hxx", ".hpp"); @Override public int compare(final String path1, final String path2) { if (Patch.COMMIT_MSG.equals(path1)) { return -1; } else if (Patch.COMMIT_MSG.equals(path2)) { return 1; } if (Patch.MERGE_LIST.equals(path1)) { return -1; } else if (Patch.MERGE_LIST.equals(path2)) { return 1; } 
<|startcomment|> note that there is REFS_CONFIG constant. <|endcomment|>  refName.substring(11) : ""; ProjectBranchKey pbKey = new ProjectBranchKey(projectName, branchName); if (event.getNewObjectId().equals(ObjectId.zeroId().toString())) { // This happens when there's a branch deletion and possibly other events log.info("Project: " + projectName + <|startfocus|> "\nrefName: " + refName + "\nnewObjectId: " + event.getNewObjectId()); } else if ("refs/meta/config".equals(refName)) { <|endfocus|> // possible change in enabled repos processProjectConfigChange(event); } else if (enabledManifestSource.containsKey(projectName) && enabledManifestSource.get(projectName) .getBranches().contains(branchName)) { processManifestChange(event, projectName, branchName); } else if (subscribedRepos.containsRow(pbKey)) { //updates in subscribed repos // Manifest store and branch Map<String, Map<String, Set< com.amd.gerrit.plugins.manifestsubscription.manifest.Project>>> destinations = subscribedRepos.row(pbKey); for (String store : destinations.keySet()) {
<|startcomment|> This produces wrong location of output artifact: buck-out/gen/gerrit-gwtui/ui_safari.zip/ui_safari.zip It should be: $ buck targets --show_output //gerrit-gwtui:ui_safari | awk '{print $2}' buck-out/gen/gerrit-gwtui/__gwt_binary_ui_safari__/ui_safari.zip That's because native gwt_binary rule puts its output in very special location. See the explanation in TODO on line 62. <|endcomment|>  // TODO(davido): instead of assuming specific Buck's internal // target directory for gwt_binary() artifacts, ask Buck for // the location of user agent permutation GWT zip, e. g.: // $ buck targets --show_output //gerrit-gwtui:ui_safari \ // | awk '{print $2}' <|startfocus|> String child = String.format("%s/__gwt_binary_%s__", pkg, target); BuildSystem.Label label = new BuildSystem.Label(pkg , target + ".zip"); <|endfocus|> File zip = builder.targetPath(label).toFile(); synchronized (this) { try { builder.build(label); } catch (BuildSystem.BuildFailureException e) { e.display(rule, (HttpServletResponse) res); return; } if (!target.equals(lastTarget) || lastTime != zip.lastModified()) { lastTarget = target; lastTime = zip.lastModified(); unpack(zip, unpackedWar.toFile()); } } uaInitialized.add(target); } chain.doFilter(request, res); } @Override
<|startcomment|> Don't import this. ChangeNotes is already imported, so just reference ChangeNotes.Factory explicitly (L45) <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.sshd; import com.google.gerrit.reviewdb.client.Change; import com.google.gerrit.reviewdb.client.Project; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.ChangeFinder; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.change.ChangeResource; import com.google.gerrit.server.change.ChangesCollection; import com.google.gerrit.server.notedb.ChangeNotes; <|startfocus|> import com.google.gerrit.server.notedb.ChangeNotes.Factory; <|endfocus|> import com.google.gerrit.server.project.ChangeControl; import com.google.gerrit.server.project.NoSuchChangeException; import com.google.gerrit.server.project.ProjectControl; import com.google.gerrit.sshd.BaseCommand.UnloggedFailure; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.stream.Collectors; public class ChangeArgumentParser { private final CurrentUser currentUser; private final ChangesCollection changesCollection; private final ChangeFinder changeFinder; private final ReviewDb db;
<|startcomment|> final <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.automerger; import com.google.common.base.Joiner; import java.util.Map; class FailedMergeException extends Exception { <|startfocus|> public Map<String, String> failedMerges; final int maxConflictMessageLength = 10000; <|endfocus|> FailedMergeException(Map<String, String> failedMerges) { this.failedMerges = failedMerges; } public String displayConflicts() { StringBuilder output = new StringBuilder(); output.append("Merge conflict found on "); output.append(failedMergeKeys()); output.append(". Please follow instructions at go/resolveconflict "); output.append("to resolve this merge conflict.\n\n"); for (Map.Entry<String, String> entry : failedMerges.entrySet()) { String branch = entry.getKey();
<|startcomment|> columns() is still documented as @Nullable <|endcomment|>  void copyColumnsTo(Change change) { ChangeColumns c = checkNotNull(columns()); if (c.status() != null) { change.setStatus(c.status()); } change.setKey(c.changeKey()); change.setDest(new Branch.NameKey(change.getProject(), c.branch())); change.setTopic(Strings.emptyToNull(c.topic())); <|startfocus|> change.setCreatedOn(c.createdOn()); <|endfocus|> change.setLastUpdatedOn(c.lastUpdatedOn()); change.setOwner(c.owner()); change.setSubmissionId(c.submissionId()); if (!patchSets().isEmpty()) { change.setCurrentPatchSet( c.currentPatchSetId(), c.subject(), c.originalSubject()); } else { // TODO(dborowitz): This should be an error, but for now it's required for // some tests to pass. change.clearCurrentPatchSet(); }
<|startcomment|> Missing @Override annotation. <|endcomment|> <|startfocus|> public void start(){ <|endfocus|> if (timer == null) { timer = new Timer(); } else { timer.cancel(); } timer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { MailReceiver.this.handleEmails(); } }, 0l, mailSettings.fetchInterval * 1000);
<|startcomment|> Wrong position of static import. Always above all other import statements. <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.httpd.raw; import com.google.common.escape.Escaper; import com.google.common.html.HtmlEscapers; import com.google.gwtexpui.server.CacheHeaders; import org.eclipse.jgit.util.RawParseUtils; import java.io.IOException; import java.io.PrintWriter; import java.nio.file.Path; import javax.servlet.http.HttpServletResponse; <|startfocus|> import static java.nio.charset.StandardCharsets.UTF_8; <|endfocus|> public interface BuildSystem { // Represents a label in either buck or bazel. class Label { protected final String pkg; protected final String name; // Regrettably, buck confounds rule names and artifact names, // and so we have to lug this along. Non-null only for Buck; in that case, // holds the path relative to buck-out/gen/ protected final String artifact; public String fullName() { return "//" + pkg + ":" + name; } @Override
<|startcomment|> wiki-like ... to be consistent with the rest of your comments <|endcomment|>  package com.google.gerrit.server.mail.send; import com.google.gerrit.common.Nullable; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; public class CommentFormatter { public enum BlockType { LIST, PARAGRAPH, PRE_FORMATTED, QUOTE } public static class Block { public BlockType type; public String text; public List<String> items; } /** <|startfocus|> * Take a strimg of comment text that was written using the Wiki-Like format <|endfocus|> * and emit a list of blocks that can be rendered to block-level HTML. This * method does not escape HTML. * * Adapted from the {@code wikify} method found in: * com.google.gwtexpui.safehtml.client.SafeHtml * * @param source The raw, unescaped comment in the Gerrit wiki-like format. * @return List of block objects, each with unescaped comment content. */ public static List<Block> parse(@Nullable String source) { if (source == null || source.isEmpty()) {
<|startcomment|> Unused import. Project is already imported and the code refers explicitly to Project.NameKey. <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.schema; import com.google.gerrit.reviewdb.client.Project; <|startfocus|> import com.google.gerrit.reviewdb.client.Project.NameKey; <|endfocus|> import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.GerritPersonIdent; import com.google.gerrit.server.extensions.events.GitReferenceUpdated; import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.git.MetaDataUpdate; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.lib.PersonIdent; import org.eclipse.jgit.lib.Repository; import java.io.IOException; import java.util.SortedSet; public class Schema_130 extends SchemaVersion { private static final String COMMIT_MSG =
<|startcomment|> Declare this in the same line its set: Module libModule = configInjector.getInstance(moduleClass); <|endcomment|>  return configInjector.getInstance(LibModuleLoader.class).loadModules(); } @Inject LibModuleLoader(@GerritServerConfig Config config, Injector configInjector) { this.config = config; this.configInjector = configInjector; } private List<com.google.inject.Module> loadModules() { return Arrays.stream(config.getStringList("gerrit", null, "installModule")) .map(this::loadModule).collect(toList()); } @SuppressWarnings("unchecked") <|startfocus|> private com.google.inject.Module loadModule(String className) { com.google.inject.Module libModule = null; <|endfocus|> try { Class<com.google.inject.Module> moduleClass = (Class<com.google.inject.Module>) Class.forName(className); libModule = configInjector.getInstance(moduleClass); log.info("Installed {}", className); return libModule; } catch (ClassNotFoundException e) { log.error("Unable to load LibModule " + className, e); throw new RuntimeException(e); } } } 
<|startcomment|> 2016 <|endcomment|> <|startfocus|> Copyright (C) 2012 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.change; import com.google.common.base.Strings; import com.google.gerrit.extensions.restapi.RestReadView; import com.google.inject.Singleton; @Singleton public class GetDescription implements RestReadView<RevisionResource> { @Override public String apply(RevisionResource rsrc) { return Strings.nullToEmpty(rsrc.getPatchSet().getDescription()); } } 
<|startcomment|> nit: unneeded final <|endcomment|>  public static List<Block> parse(@Nullable String source) { if (source == null || source.isEmpty()) { return Collections.emptyList(); } List<Block> result = new ArrayList<>(); <|startfocus|> for (final String p : source.split("\n\n")) { <|endfocus|> if (isQuote(p)) { result.add(makeQuote(p)); } else if (isPreFormat(p)) { result.add(makePre(p)); } else if (isList(p)) { makeList(p, result); } else if (!p.isEmpty()) { result.add(makeParagraph(p)); } } return result;
<|startcomment|> Unused. <|endcomment|>  private static List<String> changeTable(VersionedAccountPreferences v) { List<String> columns = new ArrayList<>(); <|startfocus|> Config cfg = v.getConfig(); <|endfocus|> return Lists.newArrayList(v.getConfig().getStringList( CHANGE_TABLE, null, CHANGE_TABLE_COLUMN));
<|startcomment|> I talked to our DB2 DBA, this should work: SELECT 1 FROM SYSIBM.SYSDUMMY1 see also: [1]. * [1] http://stackoverflow.com/questions/4733356/how-to-test-the-connection-to-a-db2-database <|endcomment|>  public String getValidationQuery() { <|startfocus|> return "select 1 from dual"; <|endfocus|>
<|startcomment|> nit: missing blank lines <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.api.projects; <|startfocus|> import java.util.List; <|endfocus|> public class DeleteTagsInput { public List<String> tags; } 
<|startcomment|> nit: missing space before '{' <|endcomment|>  "Tested-by: Administrator <admin@example.com>"); assertThat(footers).containsExactlyElementsIn(expectedFooters); } @Test public void customCommitFooters() throws Exception{ PushOneCommit.Result change = createChange(); RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() { @Override public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, NameKey destination) { return newCommitMessage + "Custom: " + destination.get(); } }); ChangeInfo actual; <|startfocus|> try{ <|endfocus|> EnumSet<ListChangesOption> options = EnumSet.of( ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS); actual = gApi.changes().id(change.getChangeId()).get(options); } finally { handle.remove(); } List<String> footers = new ArrayList<>(Arrays.asList( actual.revisions.get(change.getCommit().getName()) .commitWithFooters.split("\\n"))); // remove subject + blank line footers.remove(0); footers.remove(0); List<String> expectedFooters = Arrays.asList(
<|startcomment|> These tests are the same when we are now always writing JSON. Just keep the first and inline testVoteOnBehalfOfWithComment. <|endcomment|>  in.label("Verified", 1); exception.expect(AuthException.class); exception.expectMessage( "not permitted to modify label \"Verified\" on behalf of \"" + in.onBehalfOf + '"'); revision.review(in); } @Test public void voteOnBehalfOfWithComment() throws Exception { testVoteOnBehalfOfWithComment(); } <|startfocus|> <|endfocus|> @Test public void voteOnBehalfOfWithCommentWritingJson() throws Exception { assume().that(notesMigration.readChanges()).isTrue(); testVoteOnBehalfOfWithComment(); } private void testVoteOnBehalfOfWithComment() throws Exception { allowCodeReviewOnBehalfOf(); PushOneCommit.Result r = createChange(); ReviewInput in = new ReviewInput(); in.onBehalfOf = user.id.toString(); in.label("Code-Review", 1); CommentInput ci = new CommentInput(); ci.path = Patch.COMMIT_MSG; ci.side = Side.REVISION; ci.line = 1; ci.message = "message"; in.comments = ImmutableMap.of(ci.path, ImmutableList.of(ci));
<|startcomment|> This is no longer needed since the type was changed. <|endcomment|>  } protected LabelInfo() { } } public static class ApprovalInfo extends AccountInfo { public final native boolean hasValue() /*-{ return this.hasOwnProperty('value'); }-*/; public final native short value() /*-{ return this.value || 0; }-*/; <|startfocus|> public final native boolean hasPermittedVotingRange() /*-{ return this.hasOwnProperty('permitted_voting_range'); }-*/; public final native VotingRangeInfo permittedVotingRange() /*-{ return this.permitted_voting_range || 0; }-*/; <|endfocus|> protected ApprovalInfo() { } } public static class VotingRangeInfo extends AccountInfo { public final native short min() /*-{ return this.min || 0; }-*/; public final native short max() /*-{ return this.max || 0; }-*/; protected VotingRangeInfo() { } } public static class EditInfo extends JavaScriptObject { public final native String name() /*-{ return this.name; }-*/; public final native String setName(String n) /*-{ this.name = n; }-*/;
<|startcomment|> nit: missing space after '+' <|endcomment|>  throw new ResourceNotFoundException("patch set not found: " + psId); } ChangeMessage msg; if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) { msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n" +parsedComments.get(0).message, tag); } else { <|startfocus|> msg = ChangeMessagesUtil.newMessage(ctx, "Patch Set " + psId.get() + ":\n(" +parsedComments.size() + (parsedComments.size() > 1 ? " comments)" : " comment)"), tag); <|endfocus|> } changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg); List<Comment> comments = new ArrayList<>(); for (MailComment c : parsedComments) { if (c.type == MailComment.CommentType.CHANGE_MESSAGE) { continue; } String fileName; // The patch set that this comment is based on is different if this // comment was sent in reply to a comment on a previous patch set.
<|startcomment|> Unintended reformatting? <|endcomment|>  import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.ObjectReader; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.notes.NoteMap; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.transport.ReceiveCommand; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.util.concurrent.TimeUnit; <|startfocus|> /** View of the draft comments for a single {@link Change} based on the log of its drafts branch. */ <|endfocus|> public class DraftCommentNotes extends AbstractChangeNotes<DraftCommentNotes> { private static final Logger log = LoggerFactory.getLogger(DraftCommentNotes.class); public interface Factory { DraftCommentNotes create(Change change, Account.Id accountId); DraftCommentNotes createWithAutoRebuildingDisabled( Change.Id changeId, Account.Id accountId); } private final Change change; private final Account.Id author; private final NoteDbUpdateManager.Result rebuildResult; private ImmutableListMultimap<RevId, Comment> comments; private RevisionNoteMap<ChangeRevisionNote> revisionNoteMap; @AssistedInject DraftCommentNotes( Args args,
<|startcomment|> missing function closing parenthesis <|endcomment|>  } }); } /** * @param project Project name. * @param revision SHA1 of the parent revision. * @return Links for patch sets. */ public FluentIterable<WebLinkInfo> getParentLinks(final Project.NameKey project, final String revision) { return filterLinks(parentLinks, new Function<WebLink, WebLinkInfo>() { @Override public WebLinkInfo apply(WebLink webLink) { return ((ParentWebLink)webLink).getParentWebLink(project.get(), revision); } <|startfocus|> }); <|endfocus|> /** * * @param project Project name. * @param revision SHA1 of revision. * @param file File name. * @return Links for files. */ public FluentIterable<WebLinkInfo> getFileLinks(final String project, final String revision, final String file) { return filterLinks(fileLinks, new Function<WebLink, WebLinkInfo>() { @Override public WebLinkInfo apply(WebLink webLink) { return ((FileWebLink)webLink).getFileWebLink(project, revision, file); } });
<|startcomment|> What is the type of this map? <|endcomment|> import com.google.re2j.Pattern; import java.io.IOException; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.yaml.snakeyaml.Yaml; /** The loaded configuration stored in memory. */ public class LoadedConfig { private static final Logger log = LoggerFactory.getLogger(LoadedConfig.class); private final Map<String, Object> global; <|startfocus|> private final Map<String, Map> config; <|endfocus|> private final Map<String, String> defaultManifestInfo; private final Pattern blankMergePattern; private final Pattern alwaysBlankMergePattern; public LoadedConfig() { global = Collections.emptyMap(); config = Collections.emptyMap(); defaultManifestInfo = Collections.emptyMap(); blankMergePattern = Pattern.compile(""); alwaysBlankMergePattern = Pattern.compile(""); } public LoadedConfig( GerritApi gApi, String configProject, String configProjectBranch, String configFilename, List<String> configOptionKeys) throws IOException, RestApiException { log.info(
<|startcomment|> MessageOfTheDayImpl <|endcomment|> import com.google.gerrit.server.config.PluginConfigFactory; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.lib.Config; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; @Singleton class MessageOfTheDayImpl extends MessageOfTheDay { <|startfocus|> private static final Logger log = LoggerFactory.getLogger(MessageOfTheDay.class); <|endfocus|> private static final DateFormat YYYYMMdd = new SimpleDateFormat("YYYYMMdd"); private final File data; private final String id; private final String expiresAt; private final String msg; @Inject public MessageOfTheDayImpl( PluginConfigFactory configFactory, @PluginName String myName, @PluginData File data) { this.data = data; Config cfg = configFactory.getGlobalPluginConfig(myName); id = cfg.getString("message", null, "id"); expiresAt = cfg.getString("message", null, "expiresAt");
<|startcomment|> Optional: could be inlined. <|endcomment|>  } if (input == null) { return Response.none(); } Account.Id accountId = rsrc.getUser().getAccountId(); deleteFromGit(accountId, input); accountCache.evict(accountId); return Response.none(); } private void deleteFromGit(Account.Id accountId, List<ProjectWatchInfo> input) throws IOException, ConfigInvalidException { watchConfig.deleteProjectWatches( accountId, input.stream().map(w -> ProjectWatchKey.create( new Project.NameKey(w.project), w.filter)) <|startfocus|> .collect(toList())); <|endfocus|> } } 
<|startcomment|> Too long line. <|endcomment|>  this.config = gerritConfig; this.maxSubjectLength = nonNegativeInt( MAX_SUBJECT_LENGTH_KEY, DEFAULT_MAX_SUBJECT_LENGTH); this.maxLineLength = nonNegativeInt( MAX_LINE_LENGTH_KEY, DEFAULT_MAX_LINE_LENGTH); this.rejectTooLong = config.getBoolean( COMMIT_MESSAGE_SECTION, REJECT_TOO_LONG_KEY, DEFAULT_REJECT_TOO_LONG); this.longLinesThreshold = nonNegativeInt( LONG_LINES_THRESHOLD_KEY, DEFAULT_LONG_LINES_THRESHOLD); <|startfocus|> this.rejectNoMsgBody = config.getBoolean( COMMIT_MESSAGE_SECTION, REJECT_NO_MSG_BODY_KEY, DEFAULT_REJECT_NO_MSG_BODY); <|endfocus|>
<|startcomment|> ag or g or group. <|endcomment|> <|startfocus|> private static Term idTerm(AccountGroup as) { return idTerm(as.getGroupUUID()); <|endfocus|>
<|startcomment|> missing space after <|endcomment|>  sitePath = Paths.get(path); } if (System.getProperty("gerrit.init") != null) { List<String> pluginsToInstall; String installPlugins = System.getProperty("gerrit.install_plugins"); if (installPlugins == null) { pluginsToInstall = null; } else { pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins); } <|startfocus|> new SiteInitializer( path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext), pluginsToInstall) .init(); <|endfocus|> } try { dbInjector = createDbInjector(); } catch (CreationException ce) { final Message first = ce.getErrorMessages().iterator().next(); final StringBuilder buf = new StringBuilder(); buf.append(first.getMessage()); Throwable why = first.getCause(); while (why != null) { buf.append("\n caused by "); buf.append(why.toString()); why = why.getCause(); } if (first.getCause() != null) { buf.append("\n");
<|startcomment|> Moving this expression into this line just complicates the diff. <|endcomment|>  public String generateToken(String operation, AnyLongObjectId id, int expirationSeconds) { try { byte[] initVector = new byte[IV_LENGTH]; rndm.nextBytes(initVector); Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE); return Base64.encodeBytes(Bytes.concat(initVector, <|startfocus|> cipher.doFinal(String.format("%s-%s-%s", operation, id.name(), timeout(expirationSeconds)).getBytes(StandardCharsets.UTF_8)))); <|endfocus|> } catch (GeneralSecurityException e) { log.error("Token generation failed with error", e); throw new RuntimeException(e); }
<|startcomment|> With this number of static factory methods, maybe the Builder pattern would be a better fit? https://github.com/google/auto/blob/master/value/userguide/builders.md (They're not mutually exclusive--you could leave a smaller handful of simpler factory methods as well.) <|endcomment|> <|startfocus|> public static ExternalId create(String scheme, String id, Account.Id accountId) { return new AutoValue_ExternalId(Key.create(scheme, id), accountId, null, null); <|endfocus|>
<|startcomment|> In config.md you say, "By default the validation will be enabled for all branches.", Here you are mixing two different use cases, no match and no branch restriction. Wouldn't that mean, that with the current implementation, all check would be rejected, unless branch was explicitly defined, which would be a disruptive change and stop working this plugin for all users? Instead, you want to differentiate for two situations: * 1. banches were defined (guessing, this should also respect project inhertiance: if parent project defined stable-.*, and child doesn't override it, then check on master shouldn't be enabled) => match and return the result * 2. brancher were not defined => always true <|endcomment|>  private boolean isEnabledForBranch(ProjectState project, String refName) { String[] refPatterns = pluginCfgFactory.getFromProjectConfigWithInheritance(project, pluginName).getStringList("branch"); for (String refPattern : refPatterns) { if (RefConfigSection.isValid(refPattern) && match(refName, refPattern)) { return true; } } <|startfocus|> return false; <|endfocus|>
<|startcomment|> private static <|endcomment|> <|startfocus|> private boolean match(String refName, String refPattern) { <|endfocus|> return RefPatternMatcher.getMatcher(refPattern).match(refName, null);
<|startcomment|> remove? <|endcomment|> import com.google.inject.Provider; import org.kohsuke.args4j.Argument; import java.util.ArrayList; import java.util.List; public class LfsPluginAuthCommand extends SshCommand { public interface LfsSshPluginAuth { String authorize(CurrentUser user, List<String> args) throws UnloggedFailure, Failure, Exception; } public static class Module extends CommandModule { @Override protected void configure() { command("git-lfs-authenticate").to(LfsPluginAuthCommand.class); DynamicItem.itemOf(binder(), LfsSshPluginAuth.class); } } private static final LfsSshPluginAuth NOT_IMPLEMENTED = new LfsSshPluginAuth() { @Override <|startfocus|> public String authorize(CurrentUser user, List<String> args) <|endfocus|> throws UnloggedFailure, Failure, Exception { throw new Failure(1, "Server configuration error:" + " LFS auth over SSH is not properly configured."); } }; private final LfsSshPluginAuth auth; private final CurrentUser user; @Argument(index = 0, multiValued = true, metaVar = "PARAMS") private List<String> args = new ArrayList<>(); @Inject
<|startcomment|> When pushing over ssh the AuthInfo.auth is set to "not:required" and this throws LfsUnauthorized. <|endcomment|>  Reader r = new BufferedReader( new InputStreamReader(req.getInputStream(), UTF_8)); LfsRequest request = gson.fromJson(r, LfsRequest.class); String path = req.getPathInfo(); res.setContentType(CONTENTTYPE_VND_GIT_LFS_JSON); LargeFileRepository repo = null; try { repo = getLargeFileRepository(request, path, <|startfocus|> new AuthInfo( Charset.forName(MoreObjects.firstNonNull( req.getCharacterEncoding(), Charsets.UTF_8.name())), req.getHeader(HDR_AUTHORIZATION))); <|endfocus|> if (repo == null) { throw new LfsException("unexpected error"); //$NON-NLS-1$ } res.setStatus(SC_OK); TransferHandler handler = TransferHandler .forOperation(request.operation, repo, request.objects); gson.toJson(handler.process(), w); } catch (LfsValidationError e) { sendError(res, w, SC_UNPROCESSABLE_ENTITY, e.getMessage()); } catch (LfsRepositoryNotFound e) { sendError(res, w, SC_NOT_FOUND, e.getMessage()); } catch (LfsRepositoryReadOnly e) {
<|startcomment|> Can you catch a more specific exception type? <|endcomment|>  // anyway, making change2 not a fast-forward, requiring a rebase. approve(change1.getChangeId()); submit(change2.getChangeId()); try { // change3 has to be manually rebased first before submit. gApi.changes().id(change3.getChangeId()).current().rebase(); submit(change3.getChangeId()); // ...but should fail anyway in validation. assertThat("unrechable").isNull(); <|startfocus|> } catch (Exception e) { assertThat(e.getMessage()).contains("3rd change won't be merged"); <|endfocus|> } } finally { handle.remove(); } } private void assertLatestRevisionHasFooters(PushOneCommit.Result change) throws Exception { RevCommit c = getCurrentCommit(change); assertThat(c.getFooterLines(FooterConstants.CHANGE_ID)).isNotEmpty(); assertThat(c.getFooterLines(FooterConstants.REVIEWED_BY)).isNotEmpty(); assertThat(c.getFooterLines(FooterConstants.REVIEWED_ON)).isNotEmpty(); } private RevCommit getCurrentCommit(PushOneCommit.Result change) throws Exception {
<|startcomment|> Hm, I'm trying to think through why it would be better or worse to call each listener exactly once and passing the whole Map as an argument vs. once per branch. Both are reasonably easy semantics to explain, so I think that bar is met. The main advantage of passing a map is that a listener gets a fuller picture of the situation. There might be multiple branches in the same repo that are being submitted as part of a single submit operation. If you call the listener once per branch, the listener has literally no way to know whether two updates to different branches are happening in the same atomic operation or not. That said, I'm struggling to think of a use case where the listener needs to know about the whole batch at once, so maybe this is not a huge downside. The downside of passing a map is that then the listener has to do the iteration themselves. This isn't a huge downside either IMO. So I guess between the two alternatives, maybe we should just go with the one that you prefer, since you're the plugin author here? Do you have any other thoughts? <|endcomment|> import com.google.gerrit.server.validators.ValidationException; import com.google.inject.Inject; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.transport.ReceiveCommand; import java.util.Map; public class OnSubmitValidators { public interface Factory { OnSubmitValidators create(); } private final DynamicSet<OnSubmitValidationListener> listeners; @Inject OnSubmitValidators(DynamicSet<OnSubmitValidationListener> listeners) { this.listeners = listeners; } public void validate(Project.NameKey project, Repository repo, <|startfocus|> Map<String, ReceiveCommand> commands) throws IntegrationException { <|endfocus|> try { for (String refName : commands.keySet()) { if (refName.startsWith(RefNames.REFS_CHANGES)) continue; ReceiveCommand cmd = commands.get(refName); Arguments args = new Arguments(project, repo, refName, cmd.getOldId(), cmd.getNewId()); for (OnSubmitValidationListener listener : listeners) { listener.preBranchUpdate(args); } } } catch (ValidationException e) { throw new IntegrationException(e.getMessage()); } } } 
<|startcomment|> Wouldn't make more sense to swap the order and check for branch matching before checking for kip-configuration?If it's restricted to one specific branch and we are on different branch, why to bother checking user, groups, and other skip criteria, if I already know that the check is never applied because of branch mismatch? [plugin "uploadvalidator"] branch = refs/heads/stable-42 skipGroup=admin Say 10k users are uploading 1k changes per day and 99% of them go to master, why should I perform all the group membership tests if i already know that the checks should be only be done on stable-42? <|endcomment|>  public boolean isEnabledForRef(Project.NameKey projectName, String refName, String validatorOp) { PluginConfig pluginProjectConfig = pluginCfgFactory.get(projectName); if (pluginProjectConfig == null || canSkipOnRef(pluginProjectConfig, refName, validatorOp)) { return false; } <|startfocus|> String[] refPatterns = pluginProjectConfig.getStringList("branch"); <|endfocus|> if (refPatterns.length == 0) { return true; // Default behavior: no branch-specific config } for (String refPattern : refPatterns) { if (RefConfigSection.isValid(refPattern) && match(refName, refPattern)) { return true; } } return false;
<|startcomment|> nit: should be before LfsObject <|endcomment|> import com.google.gerrit.server.project.ProjectState; import com.google.inject.Inject; import com.google.inject.Singleton; import org.eclipse.jgit.lfs.errors.LfsException; import org.eclipse.jgit.lfs.errors.LfsRepositoryNotFound; import org.eclipse.jgit.lfs.errors.LfsRepositoryReadOnly; import org.eclipse.jgit.lfs.errors.LfsUnauthorized; import org.eclipse.jgit.lfs.errors.LfsUnavailable; import org.eclipse.jgit.lfs.errors.LfsValidationError; import org.eclipse.jgit.lfs.server.LargeFileRepository; import org.eclipse.jgit.lfs.server.LfsObject; <|startfocus|> import org.eclipse.jgit.lfs.server.LfsGerritProtocolServlet; <|endfocus|> import java.util.regex.Matcher; import java.util.regex.Pattern; @Singleton public class LfsApiServlet extends LfsGerritProtocolServlet { private static final long serialVersionUID = 1L; private static final Pattern URL_PATTERN = Pattern.compile(URL_REGEX); private static final String DOWNLOAD = "download"; private static final String UPLOAD = "upload"; private final ProjectCache projectCache; private final LfsConfigurationFactory lfsConfigFactory; private final LfsRepositoryResolver repoResolver; private final LfsAuthUserProvider userProvider; @Inject LfsApiServlet(ProjectCache projectCache, LfsConfigurationFactory lfsConfigFactory,
<|startcomment|> Yeah :-) <|endcomment|>  this.repoManager = repoManager; this.contentTypeUtil = contentTypeUtil; this.validatorConfig = validatorConfig; } static boolean isActive(PluginConfig cfg) { return cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN).length > 0; } @Override public List<CommitValidationMessage> onCommitReceived( CommitReceivedEvent receiveEvent) throws CommitValidationException { try { PluginConfig cfg = cfgFactory .getFromProjectConfigWithInheritance( receiveEvent.project.getNameKey(), pluginName); <|startfocus|> if (isActive(cfg) && validatorConfig.isEnabled( <|endfocus|> receiveEvent.getProjectNameKey(), receiveEvent.getRefName())) { ImmutableMap<String, Pattern> blockedKeywordPatterns = patternCache.getAll(Arrays .asList(cfg.getStringList(KEY_CHECK_BLOCKED_KEYWORD_PATTERN))); try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) { List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit, blockedKeywordPatterns.values(), cfg); if (!messages.isEmpty()) { throw new CommitValidationException( "includes files containing blocked keywords", messages); } } }
<|startcomment|> {@code false} <|endcomment|>  package com.google.gerrit.server.mail; import com.google.gerrit.extensions.annotations.ExtensionPoint; import com.google.gerrit.server.mail.receive.MailMessage; /** * Listener to filter incoming email. * <p> * Invoked by Gerrit for each incoming email. */ @ExtensionPoint public interface MailFilter { /** * Determine if Gerrit should discard or further process the message. * * @param message MailMessage parsed by Gerrit. <|startfocus|> * @return True, if Gerrit should discard the message, false otherise. <|endfocus|> */ boolean shouldDiscardMessage(MailMessage message); } 
<|startcomment|> This is not needed; there are no injected parameters. <|endcomment|>  AuthInfo(String authToken, DateTime expiresAt) { this.authToken = authToken; this.expiresAt = expiresAt; } } private static final Logger log = LoggerFactory.getLogger(LfsAuthTokenHandler.class); private static final int IV_LENGTH = 16; private static final String ALGORITHM = "AES"; private static final int KEY_SIZE = 128; static final DateTimeFormatter DATE_TIME = DateTimeFormat.forPattern("YYYYMMDDHHmmss"); private final SecureRandom random; private final SecretKey key; <|startfocus|> @Inject <|endfocus|> public LfsAuthTokenHandler() { this.random = new SecureRandom(); this.key = generateKey(); } public AuthInfo generateToken(int expirationSeconds, Token input) { try { byte[] initVector = new byte[IV_LENGTH]; random.nextBytes(initVector); Cipher cipher = cipher(initVector, Cipher.ENCRYPT_MODE); DateTime expiresAt = timeout(expirationSeconds); return new AuthInfo(Base64.encodeBytes(Bytes.concat(initVector, cipher.doFinal(input.getValue(expiresAt).getBytes(UTF_8)))), expiresAt);
<|startcomment|> Instead of this comment, rather factor this block out into a 'deleteFromDatabase' method. Also since [1] some changes may exist only in NoteDb, but not in ReviewDb. You should attempt deletion from ReviewDb only for changes for which the PrimaryStorage is not NoteDb. [1] https://gerrit-review.googlesource.com/80930 <|endcomment|>  input.removeAllData = false; } if (input.reason == null) { input.reason = ""; } if (input.removeAllData == null) { input.removeAllData = false; } Comment comment = rsrc.getComment(); String removedCommentMsg = "Comment removed by: " + currentUserProvider.get().getUserName() + "; Reason: " + input.reason; <|startfocus|> if (!(dbProvider.get() instanceof DisabledChangesReviewDbWrapper)) { // Delete from ReviewDb <|endfocus|> PatchLineComment.Key key = new PatchLineComment.Key( new Patch.Key(rsrc.getPatchSet().getId(), comment.key.filename), comment.key.uuid); PatchLineComment patchLineComment = ReviewDbUtil.unwrapDb(dbProvider.get()).patchComments().get(key); if (patchLineComment == null) { throw new ResourceNotFoundException("comment not found: " + key); } if (input.removeAllData) { ReviewDbUtil.unwrapDb(dbProvider.get()).patchComments() .deleteKeys(Collections.singleton(key)); } else {
<|startcomment|> Keep this one as it is an optimization. We don't want to evaluate any of the conditions bellow when skipGroup list is empty. <|endcomment|>  public boolean isEnabledForRef(Project.NameKey projectName, String refName, String validatorOp) { PluginConfig conf = configFactory.get(projectName); return conf != null && isValidConfig(conf, projectName) <|startfocus|> && (!hasCriteria(conf, "ref") || canRef(conf, refName)) <|endfocus|> && (!hasCriteria(conf, "skipGroup") || !canSkipValidation(conf, validatorOp) || !canSkipRef(conf, refName) || !canSkipGroup(conf));
<|startcomment|> This should be changed to com.google.inject.Inject, either in this change or in a separate one. <|endcomment|> import com.google.gerrit.server.git.GitRepositoryManager; import com.google.gerrit.server.patch.PatchList; import com.google.gerrit.server.patch.PatchListCache; import com.google.gerrit.server.patch.PatchListKey; import com.google.gerrit.server.patch.PatchListNotAvailableException; import com.google.gwtorm.server.OrmException; import com.google.inject.Provider; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.Repository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.IOException; import java.util.Set; <|startfocus|> import javax.inject.Inject; <|endfocus|> @Listen public class GitRefListener implements GitReferenceUpdatedListener { private static final Logger logger = LoggerFactory.getLogger(GitRefListener.class); private static final String CHANGES_REF = "refs/changes/"; private final Provider<ReviewDb> db; private final PatchListCache patchListCache; private final GitRepositoryManager repositoryManager; private final AccountResolver accountResolver; private final ReviewerManager reviewerManager; @Inject public GitRefListener(Provider<ReviewDb> db, PatchListCache patchListCache, GitRepositoryManager repositoryManager, AccountResolver accountResolver, ReviewerManager reviewerManager) {
<|startcomment|> Isn't this the same as simply this['trusted']? <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.client.account; import com.google.gwt.core.client.JavaScriptObject; public class ExternalIdInfo extends JavaScriptObject { public final native String identity() /*-{ return this.identity; }-*/; public final native String emailAddress() /*-{ return this.email_address; }-*/; <|startfocus|> public final native boolean trusted() <|endfocus|> /*-{ return this['trusted'] ? true : false; }-*/; public final native boolean canDelete() /*-{ return this['can_delete'] ? true : false; }-*/; protected ExternalIdInfo() { } } 
<|startcomment|> I don't think we need the early-return pattern here. It makes sense in the other method (L75) because that has a lot more code following the check. It would be cleaner to invert the logic and put the call to setProperty inside the if-block. if (!Strings.isNullOrEmpty(s)) { System.setProperty(...); } <|endcomment|>  private static void configureNonProxyHosts() { String s = System.getenv("no_proxy"); if (Strings.isNullOrEmpty(s)) { return; } <|startfocus|> System.setProperty(Protocol.http.name() + ".nonProxyHosts", s.replace(",", "|")); <|endfocus|>
<|startcomment|> would this not fit in the previous line? <|endcomment|>  int expirationSeconds) { LfsFsAuthToken token = new LfsFsAuthToken(operation, id, expirationSeconds); return new AuthInfo(processor.serialize(token), token.expiresAt); } public boolean verifyAuthInfo(String authToken, String operation, AnyLongObjectId id) { Optional<LfsFsAuthToken> token = processor.deserialize(authToken); if (!token.isPresent()) { return false; } return new FsVerifier(token.get(), operation, id).verify(); } <|startfocus|> static class FsProcessor extends LfsAuthToken.Processor<LfsFsAuthToken> { <|endfocus|> @Inject protected FsProcessor(LfsCipher cipher) { super(cipher); } @Override protected List<String> getValues(LfsFsAuthToken token) { List<String> values = new ArrayList<>(3); values.add(token.operation); values.add(token.id.getName()); values.add(token.expiresAt); return values; } @Override protected Optional<LfsFsAuthToken> createToken(List<String> values) { if (values.size() != 3) { return Optional.absent(); } 
<|startcomment|> Why not helper.add("approval", psa); ? <|endcomment|>  protected void addToString(ToStringHelper helper) { <|startfocus|> helper.addValue(psa); <|endfocus|>
<|startcomment|> Why do we need this? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.account; import static com.google.common.truth.Truth.assertThat; import com.google.common.base.Strings; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.JUnit4; <|startfocus|> @RunWith(JUnit4.class) <|endfocus|> public class HashedPasswordTest { @Test public void encodeOneLine() throws Exception { String password = "secret"; HashedPassword hpw = HashedPassword.fromPassword(password); assertThat(hpw.encode()).doesNotContain("\n"); } @Test public void encodeDecode() throws Exception { String password = "secret"; HashedPassword hpw = HashedPassword.fromPassword(password); HashedPassword roundtrip = HashedPassword.decode(hpw.encode()); assertThat(hpw.encode()).isEqualTo(roundtrip.encode()); } @Test public void lengthLimit() throws Exception {
<|startcomment|> 2017 <|endcomment|> <|startfocus|> opyright (C) 2016 The Android Open Source Project <|endfocus|> // //Licensed under the Apache License, Version 2.0 (the "License"); //you may not use this file except in compliance with the License. //You may obtain a copy of the License at // //http://www.apache.org/licenses/LICENSE-2.0 // //Unless required by applicable law or agreed to in writing, software //distributed under the License is distributed on an "AS IS" BASIS, //WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //See the License for the specific language governing permissions and //limitations under the License. package com.google.gerrit.server.schema; import com.google.gerrit.reviewdb.client.AccountExternalId; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.account.HashedPassword; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import java.sql.SQLException; import java.util.List; public class Schema_142 extends SchemaVersion { @Inject Schema_142(Provider<Schema_141> prior) { super(prior); } @Override
<|startcomment|> Change this to Comment. This should safe you some conversions. <|endcomment|>  c.range.endCharacter)); e.setLine(c.range.endLine); } ups.add(e); } del.addAll(drafts.values()); ChangeUpdate update = updateFactory.create(ctrl, TimeUtil.nowTs()); update.setPatchSetId(ps.getId()); plcUtil.deleteComments(db, update, CommentsUtil.toComments(serverId, del)); plcUtil.putComments(db, update, Status.PUBLISHED, CommentsUtil.toComments(serverId, ups)); update.commit(); } <|startfocus|> private Map<String, PatchLineComment> scanDraftComments(ChangeControl ctrl, <|endfocus|> PatchSet ps) throws OrmException { Map<String, PatchLineComment> drafts = Maps.newHashMap(); for (PatchLineComment c : toPatchLineComment(ctrl.getChange().getId(), plcUtil.draftByPatchSetAuthor(db, ps.getId(), ((IdentifiedUser) ctrl.getUser()).getAccountId(), ctrl.getNotes()))) { drafts.put(c.getKey().get(), c); } return drafts; } private Iterable<PatchLineComment> toPatchLineComment(Change.Id changeId, List<Comment> draftByPatchSetAuthor) {
<|startcomment|> admin <|endcomment|>  setApiUser(admin); i.emailFormat = EmailFormat.HTML_PLAINTEXT; gApi.accounts().id(admin.getId().toString()).setPreferences(i); } @Test public void userReceivesHtmlAndPlaintextEmail() throws Exception { // Create change as admin and review as user PushOneCommit.Result r = createChange(); setApiUser(user); gApi.changes() .id(r.getChangeId()) .revision(r.getCommit().name()) .review(ReviewInput.recommend()); <|startfocus|> // Check that user has received only plaintext content <|endfocus|> assertThat(sender.getMessages()).hasSize(1); assertThat(sender.getMessages().get(0).body()).isNotNull(); assertThat(sender.getMessages().get(0).htmlBody()).isNotNull(); } } 
<|startcomment|> This parameter is documented in rest-api-config.txt in the AuthInfo section. If it is removed, also it's documentation should be removed. <|endcomment|>  import com.google.gerrit.extensions.client.AccountFieldName; import com.google.gerrit.extensions.client.AuthType; import com.google.gerrit.extensions.client.GitBasicAuthPolicy; import java.util.List; public class AuthInfo { public AuthType authType; public Boolean useContributorAgreements; public List<AgreementInfo> contributorAgreements; public List<AccountFieldName> editableAccountFields; public String loginUrl; public String loginText; public String switchAccountUrl; public String registerUrl; public String registerText; public String editFullNameUrl; public String httpPasswordUrl; <|startfocus|> public Boolean isGitBasicAuth; <|endfocus|> public GitBasicAuthPolicy gitBasicAuthPolicy; } 
<|startcomment|> redoCommits <|endcomment|>  return new ArrayList<>(); } /** * Redo the commits in the redoList. * * @param repo the target repository. * @param head the parent for the first redo commit. * @param redoList the commits will be redone from the first to the last. * @param targetUUID the uuid of the target comment. * @param newMsg the new message for the target comment. * @throws IOException * @throws ConfigInvalidException */ <|startfocus|> private ObjectId redoCommitList( <|endfocus|> Repository repo, ChangeNotesCommitData head, List<ChangeNotesCommitData> redoList, String targetUUID, String newMsg) throws IOException, ConfigInvalidException { ObjectId parentId = head.commit.getId(); ObjectId curHeadId = parentId; try (ObjectInserter inserter = repo.newObjectInserter()) { for (int i = 0; i < redoList.size(); ++i) { Map<String, Comment> preMap = (i == 0) ? head.commentsMap : redoList.get(i - 1).commentsMap;
<|startcomment|> BinaryResult implements Closeable, so just move this into the implementation of close and you don't need a finally block here. <|endcomment|>  bw.assume(or.getCodeReviewRevWalk().parseCommit(r.getOldId())); } } // This naming scheme cannot produce directory/file conflicts // as no projects contains ".git/": String path = p.get() + ".git"; ByteArrayOutputStream bos = new LimitedByteArrayOutputStream( MAX_BUNDLE_SIZE, 1024); bw.writeBundle(NullProgressMonitor.INSTANCE, bos); f.putEntry(aos, path, bos.toByteArray()); <|startfocus|> } <|endfocus|> } } }; } return bin; } } 
<|startcomment|> This returns a boolean (not Boolean). <|endcomment|>  @Override public Integer get(ChangeData input, FillArgs args) throws OrmException { return input.changedLines().map(c -> c.insertions + c.deletions).orElse(null); } }; public static final FieldDef<ChangeData, String> PRIVATE = new FieldDef.Single<ChangeData, String>( ChangeQueryBuilder.FIELD_PRIVATE, FieldType.EXACT, /*stored*/ false) { @Override public String get(ChangeData input, FillArgs args) throws OrmException { <|startfocus|> Boolean m = input.change().isPrivate(); if (m == null) { return "1"; } return m ? "1" : "0"; <|endfocus|> } }; /** Users who have commented on this change. */ public static final FieldDef<ChangeData, Iterable<Integer>> COMMENTBY = new FieldDef.Repeatable<ChangeData, Integer>( ChangeQueryBuilder.FIELD_COMMENTBY, FieldType.INTEGER, false) { @Override public Iterable<Integer> get(ChangeData input, FillArgs args) throws OrmException { Set<Integer> r = new HashSet<>(); for (ChangeMessage m : input.messages()) {
<|startcomment|> drop. <|endcomment|>  /** Draft inline comments of a user on a change */ public static final String REFS_DRAFT_COMMENTS = "refs/draft-comments/"; /** A change starred by a user */ public static final String REFS_STARRED_CHANGES = "refs/starred-changes/"; /** Sequence counters in NoteDb. */ public static final String REFS_SEQUENCES = "refs/sequences/"; <|startfocus|> /** Delimiter to separate change and account id in refs/users/00/0001/changes/00/0001. */ public static final String PRIVATE_CHANGE_DELIMITER = "changes/"; <|endfocus|> /** * Prefix applied to merge commit base nodes. * * <p>References in this directory should take the form {@code refs/cache-automerge/xx/yyyy...} * where xx is the first two digits of the merge commit's object name, and yyyyy... is the * remaining 38. The reference should point to a treeish that is the automatic merge result of the * merge commit's parents. */ public static final String REFS_CACHE_AUTOMERGE = "refs/cache-automerge/"; 
<|startcomment|> Why is this added? Looking at the tag list there is an empty column at the right [1]. Is it caused by this? [1] http://imgur.com/a/nEBEV <|endcomment|>  table.setWidth(""); table.setText(0, 2, AdminConstants.I.columnTagName()); table.setText(0, 3, AdminConstants.I.columnTagRevision()); FlexCellFormatter fmt = table.getFlexCellFormatter(); fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().iconHeader()); fmt.addStyleName(0, 2, Gerrit.RESOURCES.css().dataHeader()); fmt.addStyleName(0, 3, Gerrit.RESOURCES.css().dataHeader()); <|startfocus|> fmt.addStyleName(0, 4, Gerrit.RESOURCES.css().dataHeader()); <|endfocus|> } Set<String> getCheckedRefs() { Set<String> refs = new HashSet<>(); for (int row = 1; row < table.getRowCount(); row++) { TagInfo k = getRowItem(row); if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) { refs.add(k.ref()); } } return refs; } void setChecked(Set<String> refs) {
<|startcomment|> optional: What about "SetPrivateFlag" or "MarkPrivate"? <|endcomment|> import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.git.BatchUpdate; import com.google.gerrit.server.git.UpdateException; import com.google.gerrit.server.project.ChangeControl; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import com.google.inject.Singleton; import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Singleton public class PutPrivate implements RestModifyView<ChangeResource, PutPrivate.Input>, UiAction<ChangeResource> { <|startfocus|> private static final Logger log = LoggerFactory.getLogger(Abandon.class); <|endfocus|> public static class Input {} private final Provider<ReviewDb> dbProvider; private final BatchUpdate.Factory batchUpdateFactory; private final Provider<CurrentUser> self; @Inject PutPrivate(Provider<ReviewDb> dbProvider, BatchUpdate.Factory batchUpdateFactory, Provider<CurrentUser> self) { this.dbProvider = dbProvider; this.batchUpdateFactory = batchUpdateFactory; this.self = self; } @Override public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, UpdateException {
<|startcomment|> Should we also enter this block is the user is an administrator, because by default admins have all capabilities (with the complete range)? <|endcomment|>  public Object apply(AccountResource resource) throws AuthException { if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) { throw new AuthException("restricted to administrator"); } CapabilityControl cc = resource.getUser().getCapabilities(); Map<String, Object> have = new LinkedHashMap<>(); for (String name : GlobalCapability.getAllNames()) { if (want(name)) { if (GlobalCapability.hasRange(name)) { <|startfocus|> if (cc.hasExplicitRange(name)) { <|endfocus|> have.put(name, new Range(cc.getRange(name))); } } else if (!name.equals(PRIORITY) && cc.canPerform(name)) { have.put(name, true); } } } for (String pluginName : pluginCapabilities.plugins()) { for (String capability : pluginCapabilities.byPlugin(pluginName).keySet()) { String name = String.format("%s-%s", pluginName, capability); if (want(name) && cc.canPerform(name)) { have.put(name, true); } } } 
<|startcomment|> I'm not sure, but this should be "action", only, as this could be not project specific. <|endcomment|>  return maniphestUpdate(taskId, comment, null, null); } /** * Runs the API's 'maniphest.edit' method */ public ManiphestUpdate maniphestUpdate(int taskId, Iterable<String> projects, String project_action) throws ConduitException { return maniphestUpdate(taskId, null, projects, project_action); } /** * Runs the API's 'maniphest.edit' method */ <|startfocus|> public ManiphestUpdate maniphestUpdate(int taskId, String comment, Iterable<String> projects, String project_action) throws ConduitException { <|endfocus|> HashMap<String, Object> params = new HashMap<>(); fillInSession(params); List<Object> list = new ArrayList<>(); List<Object> list2 = new ArrayList<>(); HashMap<String, Object> params2 = new HashMap<>(); HashMap<String, Object> params3 = new HashMap<>(); String comments = "comment"; if (comment != null) { params2.put("type", comments); params2.put("value", comment); } if (projects != null) { params2.put("type", project_action);
<|startcomment|> optional: We normally should try to avoid the use of deep stubs. As also the Javadoc description of this constant mentions, deep stubs should only be used for legacy code. <|endcomment|> import java.util.Set; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.JUnit4; import org.mockito.Mockito; @RunWith(JUnit4.class) public class ConfigLoaderTest { protected GerritApi gApiMock; private ProjectCache projectCacheMock; private ConfigLoader configLoader; private AllProjectsName allProjectsName; @Before public void setUp() throws Exception { <|startfocus|> gApiMock = Mockito.mock(GerritApi.class, Mockito.RETURNS_DEEP_STUBS); projectCacheMock = Mockito.mock(ProjectCache.class, Mockito.RETURNS_DEEP_STUBS); <|endfocus|> Mockito.when(projectCacheMock.checkedGet(Mockito.any(Project.NameKey.class)).getConfig() .getRevision().toString()).thenReturn("fakesha1"); allProjectsName = new AllProjectsName("All-Projects"); mockFile("automerger_config.yaml", "All-Projects", "refs/meta/config", "automerger_config.yaml"); mockFile("default.xml", "platform/manifest", "master", "default.xml"); mockFile("ds_one.xml", "platform/manifest", "ds_one", "default.xml");
<|startcomment|> Please document this new metric in Documentation/metrics.txt. Also it would be good if we could find a better category than "project_control" that fits better with the existing metric categories (see documentation). We normally don't use the class name as category. <|endcomment|>  return c; } if ((need & OWNER) == OWNER && c.isOwner()) { return c; } throw new NoSuchProjectException(nameKey); } } public interface AssistedFactory { ProjectControl create(CurrentUser who, ProjectState ps); } @Singleton protected static class Metrics { final Counter0 claCheckCount; @Inject Metrics(MetricMaker metricMaker) { claCheckCount = metricMaker.newCounter( <|startfocus|> "project_control/cla_check_count", new Description("Total number of CLA check requests") .setRate() .setUnit("requests")); <|endfocus|> } } private final Set<AccountGroup.UUID> uploadGroups; private final Set<AccountGroup.UUID> receiveGroups; private final String canonicalWebUrl; private final CurrentUser user; private final ProjectState state; private final ChangeNotes.Factory changeNotesFactory; private final ChangeControl.Factory changeControlFactory; private final PermissionCollection.Factory permissionFilter; private final Collection<ContributorAgreement> contributorAgreements; private final TagCache tagCache; @Nullable private final SearchingChangeCacheImpl changeCache;
<|startcomment|> don't log the error here, but log it at the topmost call when you see the ConfigInvalidException instead <|endcomment|>  // List all subsections of automerger, split by .. Set<String> subsections = getConfig().getSubsections(pluginName); for (String subsection : subsections) { // Subsections are of the form "fromBranch..toBranch" String[] branchPair = subsection.split(Pattern.quote(BRANCH_DELIMITER)); if (branchPair.length != 2) { <|startfocus|> log.error("Branch pair {} was not split by {}", subsection, BRANCH_DELIMITER); throw new ConfigInvalidException("Branch pair malformed: " + subsection); <|endfocus|> } if (fromBranch.equals(branchPair[0])) { // If fromBranches match, check if project is in both their manifests Set<String> projectsInScope = getProjectsInScope(branchPair[0], branchPair[1]); if (projectsInScope.contains(project)) { downstreamBranches.add(branchPair[1]); } } } return downstreamBranches; } // Returns overriden manifest config if specified, default if not private String getManifestFile() throws ConfigInvalidException { String manifestFile = getConfig().getString("global", null, "manifestFile");
<|startcomment|> remove the return here (otherwise the name is not added) <|endcomment|>  private Set<String> parseNameEmail(String nameEmail) { Set<String> nameEmailParts = new HashSet<>(); try { Address address = Address.parse(nameEmail); if (address.getEmail() != null) { nameEmailParts.add(address.getEmail()); <|startfocus|> return nameEmailParts; <|endfocus|> } } catch (IllegalArgumentException e) { // Fail to extract email address, then use NameEmail parts to query. } nameEmailParts.addAll(SchemaUtil.getNameParts(nameEmail)); return nameEmailParts;
<|startcomment|> Is that formatting what google-java-format is doing here? <|endcomment|>  ProjectControl projectControl, boolean useIndex) throws UnloggedFailure, OrmException { List<ChangeControl> matched = useIndex ? changeFinder.find(id, currentUser) : changeFromNotesFactory(id, currentUser); List<ChangeControl> toAdd = new ArrayList<>(changes.size()); for (ChangeControl ctl : matched) { if (!changes.containsKey(ctl.getId()) && inProject(projectControl, ctl.getProject()) <|startfocus|> && ctl.isVisible(db)) { <|endfocus|> toAdd.add(ctl); } } if (toAdd.isEmpty()) { throw new UnloggedFailure(1, "\"" + id + "\" no such change"); } else if (toAdd.size() > 1) { throw new UnloggedFailure(1, "\"" + id + "\" matches multiple changes"); } ChangeControl ctl = toAdd.get(0); changes.put(ctl.getId(), changesCollection.parse(ctl)); } private List<ChangeControl> changeFromNotesFactory(String id, CurrentUser currentUser) throws OrmException {
<|startcomment|> Trailing s <|endcomment|>  PLUGIN_NAME, pluginDataDir); assertThat(sharedDirectory.toString()).isEqualTo(pluginDataDir.toString()); } @Test public void shouldReturnConfiguredSharedDirectory() throws IOException { File configuredDirectory = tempFolder.newFolder(); when(pluginConfigMock.getString("sharedDirectory")) .thenReturn(configuredDirectory.getAbsolutePath()); Path sharedDirectory = module.getSharedDirectory(pluginConfigFactoryMock, PLUGIN_NAME, pluginDataDir); assertThat(sharedDirectory.toString()).isEqualTo(configuredDirectory.toString()); } @Test <|startfocus|> public void shouldCreateSharedDirectoryIfItDoesNotExists() <|endfocus|> throws IOException { File configuredDirectory = tempFolder.newFolder(); assertThat(configuredDirectory.delete()).isTrue(); when(pluginConfigMock.getString("sharedDirectory")) .thenReturn(configuredDirectory.getAbsolutePath()); Path sharedDirectory = module.getSharedDirectory(pluginConfigFactoryMock, PLUGIN_NAME, pluginDataDir); assertThat(sharedDirectory.toString()).isEqualTo(configuredDirectory.toString()); assertThat(sharedDirectory.toFile().exists()).isTrue(); } @Test(expected = IOException.class) public void shouldThrowAnExceptionIfAnErrorOccurCreatingSharedDirectory() throws IOException {
<|startcomment|> This is specific to replyBinaryResult. Do other reply cases need something similar? skip is allowed to do a partial read, without there having to be a particular reason. Should this do a loop to handle that? Would ServletUtils.consumeRequestBody be useful here? Is this code path only used for '200 OK' responses, or are there also errors where this step could be skipped? What should happen if the read produces an IOException? <|endcomment|>  } if (bin.canGzip() && acceptsGzip(req)) { bin = stackGzip(res, bin); } res.setContentType(bin.getContentType()); long len = bin.getContentLength(); if (0 <= len && len < Integer.MAX_VALUE) { res.setContentLength((int) len); } else if (0 <= len) { res.setHeader("Content-Length", Long.toString(len)); } <|startfocus|> if (req != null) { req.getInputStream().skip(Long.MAX_VALUE); } <|endfocus|> if (req == null || !"HEAD".equals(req.getMethod())) { try (CountingOutputStream dst = new CountingOutputStream(res.getOutputStream())) { bin.writeTo(dst); return dst.getCount(); } } return 0; } finally { appResult.close(); } } private static BinaryResult stackJsonString(HttpServletResponse res, final BinaryResult src) throws IOException { TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, Integer.MAX_VALUE); buf.write(JSON_MAGIC);
<|startcomment|> Why is this needed? <|endcomment|>  * @return Serverinformation of jira */ public JiraServerInfo sysInfo() throws JiraRestException { return (JiraServerInfo) doGet("/rest/api/2/serverInfo", new TypeToken<JiraServerInfo>(){}.getType()); } /** * @return List of all projects we have access to in jira */ public Iterable<JiraProject> getProjects() throws JiraRestException { return (List<JiraProject>) doGet("/rest/api/2/project", <|startfocus|> new TypeToken<List<JiraProject>>(){}.getType()); <|endfocus|> } private JiraTransition.Item getTransitionByName(Iterable<JiraTransition.Item> transitions, String transition) { JiraTransition.Item ret = null; for (JiraTransition.Item t : transitions) { if (transition.equals(t.getName())) { ret = t; break; } } return ret; } /** * Do a simple GET request. */ private Object doGet(String spec, Type typeOfObject) throws JiraRestException { try { URL url = new URL(baseUrl, spec);
<|startcomment|> 2017 <|endcomment|> <|startfocus|> Copyright (C) 2015 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.verifystatus.server; import org.eclipse.jgit.lib.Config.ConfigEnum; public enum JobsSorting implements ConfigEnum { DATE, REPORTER, NAME; @Override public String toConfigValue() { return name().toUpperCase(); } @Override public boolean matchConfigValue(final String in) { return name().equals(in); } } 
<|startcomment|> optional: Could we add a boolean method to the interface ReviewDb instead? <|endcomment|>  @GerritPersonIdent PersonIdent serverIdent, ChangeNotes.Factory changeNotesFactory, ChangeControl.GenericFactory changeControlFactory, ChangeUpdate.Factory changeUpdateFactory, NoteDbUpdateManager.Factory updateManagerFactory, ChangeIndexer indexer, GitReferenceUpdated gitRefUpdated, @Assisted ReviewDb db, @Assisted Project.NameKey project, @Assisted CurrentUser user, @Assisted Timestamp when) { super(repoManager, serverIdent, project, user, when); <|startfocus|> checkArgument( ReviewDbUtil.unwrapDb(db).getClass().getSimpleName().equals("NoChangesReviewDbWrapper"), "NoteDbBatchUpdate may only be used when ReviewDb is disabled for changes"); <|endfocus|> this.changeNotesFactory = changeNotesFactory; this.changeControlFactory = changeControlFactory; this.changeUpdateFactory = changeUpdateFactory; this.updateManagerFactory = updateManagerFactory; this.indexer = indexer; this.gitRefUpdated = gitRefUpdated; this.db = db; this.indexFutures = new ArrayList<>(); } @Override public void execute(BatchUpdateListener listener) throws UpdateException, RestApiException { execute(ImmutableList.of(this), listener, requestId, false); } @Override
<|startcomment|> nit: missing space after. <|endcomment|>  } } catch (IOException e) { throw new IllegalStateException("Cannot bind to " + addressList(), e); } sshDaemonLog.info(String.format("Started Gerrit %s on %s", getVersion(), addressList())); } } private static String format(InetSocketAddress s) { return String.format("%s:%d", s.getAddress().getHostAddress(), s.getPort()); } @Override public synchronized void stop() { <|startfocus|> if(executor != null) { <|endfocus|> executor.shutdownNow(); } if (daemonAcceptor != null) { try { daemonAcceptor.close(true).await(); sshDaemonLog.info("Stopped Gerrit SSHD"); } catch (IOException e) { sshDaemonLog.warn("Exception caught while closing", e); } finally { daemonAcceptor = null; } } } @Override protected void checkConfig() { super.checkConfig(); if (myHostKeys().isEmpty()) { throw new IllegalStateException("No SSHD host key"); } } 
<|startcomment|> This warnign is useful for it is correct. Perhaps we should check for DynamicOptions by this plugin, if any are registered, then omit this warning. <|endcomment|>  private Provider<Command> load(Plugin plugin) { if (plugin.getSshInjector() != null) { Key<Command> key = Commands.key(plugin.getName()); try { return plugin.getSshInjector().getProvider(key); } catch (RuntimeException err) { <|startfocus|> log.debug( String.format("Plugin %s did not define its top-level command", plugin.getName()), err); <|endfocus|> } } return null;
<|startcomment|> Unnecessary {} <|endcomment|>  timeoutMillis = ConfigUtil.getTimeUnit(cfg, "cache", PatchListCacheImpl.INTRA_NAME, "timeout", TimeUnit.MILLISECONDS.convert(5, TimeUnit.SECONDS), TimeUnit.MILLISECONDS); this.key = key; this.args = args; } @Override public IntraLineDiff call() throws Exception { <|startfocus|> Future<IntraLineDiff> result = diffExecutor.submit( new Callable<IntraLineDiff>() { @Override public IntraLineDiff call() throws Exception { return IntraLineLoader.compute(args.aText(), args.bText(), args.edits()); } }); <|endfocus|> try { return result.get(timeoutMillis, TimeUnit.MILLISECONDS); } catch (InterruptedException | TimeoutException e) { log.warn(timeoutMillis + " ms timeout reached for IntraLineDiff" + " in project " + args.project() + " on commit " + args.commit().name() + " for path " + args.path() + " comparing " + key.getBlobA().name() + ".." + key.getBlobB().name()); result.cancel(true);
<|startcomment|> "Work-in-progress"? <|endcomment|>  public static final FooterKey FOOTER_STATUS = new FooterKey("Status"); public static final FooterKey FOOTER_SUBJECT = new FooterKey("Subject"); public static final FooterKey FOOTER_SUBMISSION_ID = new FooterKey("Submission-id"); public static final FooterKey FOOTER_SUBMITTED_WITH = new FooterKey("Submitted-with"); public static final FooterKey FOOTER_TOPIC = new FooterKey("Topic"); public static final FooterKey FOOTER_TAG = new FooterKey("Tag"); <|startfocus|> public static final FooterKey FOOTER_WIP = new FooterKey("Wip"); <|endfocus|> private static final String AUTHOR = "Author"; private static final String BASE_PATCH_SET = "Base-for-patch-set"; private static final String COMMENT_RANGE = "Comment-range"; private static final String FILE = "File"; private static final String LENGTH = "Bytes"; private static final String PARENT = "Parent"; private static final String PARENT_NUMBER = "Parent-number"; private static final String PATCH_SET = "Patch-set"; private static final String REAL_AUTHOR = "Real-author";
<|startcomment|> This is already done above, on lines 39-41, why do it again? Shouldn't this be filtered only if plugins are not empty? <|endcomment|>  public static void load( List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) { if (plugins == null || plugins.isEmpty()) { callback.onSuccess(VoidResult.create()); } plugins = plugins .stream() .filter(p -> p.endsWith(".js")) .collect(Collectors.toList()); if (plugins.isEmpty()) { callback.onSuccess(VoidResult.create()); <|startfocus|> } else { <|endfocus|> self = new PluginLoader(loadTimeout, callback); self.load(plugins); self.startTimers(); self.center(); }
<|startcomment|> Likewise. <|endcomment|>  } return Collections.emptyList(); } @VisibleForTesting List<CommitValidationMessage> performValidation( Repository repo, RevCommit c, RevWalk revWalk, PluginConfig cfg) throws IOException, ExecutionException { List<CommitValidationMessage> messages = new LinkedList<>(); Map<String, ObjectId> content = CommitUtils.getChangedContent(repo, c, revWalk); for (String path : content.keySet()) { ObjectLoader ol = repo.open(content.get(path)); <|startfocus|> if (RawText.isBinary(ol.getBytes())) { continue; <|endfocus|> } try (InputStreamReader isr = new InputStreamReader(ol.openStream(), StandardCharsets.UTF_8)) { if (doesInputStreanContainCR(isr)) { messages.add( new CommitValidationMessage( "found carriage return (CR) character in file: " + path, true)); } } } return messages; } private static boolean doesInputStreanContainCR(InputStreamReader isr) throws IOException { char[] buffer = new char[1024]; int n;
<|startcomment|> protected? <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.query; import java.util.Collection; /** Predicate to filter a field by matching value. */ public abstract class OperatorPredicate<T> extends Predicate<T> { <|startfocus|> private final String name; private final String value; <|endfocus|> public OperatorPredicate(final String name, final String value) { this.name = name; this.value = value; } public String getOperator() { return name; } public String getValue() { return value; } @Override public Predicate<T> copy(final Collection<? extends Predicate<T>> children) { if (!children.isEmpty()) { throw new IllegalArgumentException("Expected 0 children"); } return this; } @Override public int hashCode() { return getOperator().hashCode() * 31 + getValue().hashCode(); } 
<|startcomment|> You missed to include HTTP_LDAP to allowed values. <|endcomment|>  if (ui.yesno(hdr != null, "Get username from custom HTTP header")) { auth.string("Username HTTP header", "httpHeader", "SM_USER"); } else if (hdr != null) { auth.unset("httpHeader"); } auth.string("SSO logout URL", "logoutUrl", null); break; } case LDAP: { auth.select( "Git/HTTP authentication", "gitBasicAuthPolicy", <|startfocus|> GitBasicAuthPolicy.HTTP.toString(), authPolicies(HTTP, LDAP)); <|endfocus|> break; } case OAUTH: { String gitBasicAuth = auth.select( "Git/HTTP authentication", "gitBasicAuthPolicy", GitBasicAuthPolicy.HTTP.toString(), authPolicies(HTTP, OAUTH)); if (gitBasicAuth.equals(GitBasicAuthPolicy.OAUTH)) { ui.message( "*WARNING* Please make sure that your chosen OAuth provider\n" + "supports Git token authentication.\n"); } break; } case CLIENT_SSL_CERT_LDAP: case CUSTOM_EXTENSION: case DEVELOPMENT_BECOME_ANY_ACCOUNT:
<|startcomment|> we usually put the assisted parameter last <|endcomment|> import com.google.inject.assistedinject.AssistedInject; import java.io.IOException; import java.util.Collection; import java.util.Collections; public class AccountIndexerImpl implements AccountIndexer { public interface Factory { AccountIndexerImpl create(AccountIndexCollection indexes); AccountIndexerImpl create(@Nullable AccountIndex index); } private final AccountCache byIdCache; private final DynamicSet<AccountIndexedListener> indexedListener; private final AccountIndexCollection indexes; private final AccountIndex index; @AssistedInject AccountIndexerImpl( AccountCache byIdCache, <|startfocus|> @Assisted AccountIndexCollection indexes, DynamicSet<AccountIndexedListener> indexedListener) { <|endfocus|> this.byIdCache = byIdCache; this.indexedListener = indexedListener; this.indexes = indexes; this.index = null; } @AssistedInject AccountIndexerImpl( AccountCache byIdCache, @Assisted AccountIndex index, DynamicSet<AccountIndexedListener> indexedListener) { this.byIdCache = byIdCache; this.indexedListener = indexedListener; this.indexes = null; this.index = index; } @Override public void index(Account.Id id) throws IOException {
<|startcomment|> missing @param name <|endcomment|>  * @return true if started, otherwise false. * @throws ReindexerAlreadyRunningException */ public synchronized boolean startReindexer(String name, boolean force) throws ReindexerAlreadyRunningException { OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name); validateReindexerNotRunning(reindexer); if (force || !isCurrentIndexVersionLatest(name, reindexer)) { reindexer.start(); return true; } return false; } /** * Activate the latest index if the current index is not already the latest. * <|startfocus|> * @return true if index was activate, otherwise false. <|endfocus|> * @throws ReindexerAlreadyRunningException */ public synchronized boolean activateLatestIndex(String name) throws ReindexerAlreadyRunningException { OnlineReindexer<?, ?, ?> reindexer = reindexers.get(name); validateReindexerNotRunning(reindexer); if (!isCurrentIndexVersionLatest(name, reindexer)) { reindexer.activateIndex(); return true; } return false; } private boolean isCurrentIndexVersionLatest(String name, OnlineReindexer<?, ?, ?> reindexer) {
<|startcomment|> just `return` here, don't need to have a variable here <|endcomment|>  private String parseResponse(HttpResponse response) { HttpEntity entity = response.getEntity(); String asString = ""; if (entity != null) { try { <|startfocus|> asString = EntityUtils.toString(entity); <|endfocus|> } catch (IOException e) { log.error("Error parsing entity", e); } } return asString;
<|startcomment|> Fixing this missing javadoc is unrelated to this change. Do this as a predecessor change? Also, add some description for the parameter :-) <|endcomment|>  * * <p>Implementors can block the upload operation by throwing a ValidationException. The exception's * message text will be reported to the end-user over the client's protocol connection. */ @ExtensionPoint public interface UploadValidationListener { /** * Validate an upload before it begins. * * @param repository The repository * @param project The project * @param remoteHost Remote address/hostname of the user <|startfocus|> * @param up <|endfocus|> * @param wants The list of wanted objects. These may be RevObject or RevCommit if the processor * parsed them. Implementors should not rely on the values being parsed. * @param haves The list of common objects. Empty on an initial clone request. These may be * RevObject or RevCommit if the processor parsed them. Implementors should not rely on the * values being parsed. * @throws ValidationException to block the upload and send a message back to the end-user over * the client's protocol connection. */ default void onPreUpload(
<|startcomment|> nit: blank line after package line <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.common.data; <|startfocus|> import static com.google.gerrit.common.data.PermissionRule.RANGE_PATTERN; <|endfocus|> import java.util.ArrayList; import java.util.Collection; import java.util.List; public class RoleSection { private String name; private List<RolePermission> rolePermissions; public static RolePermission toRolePermission(String rolePermission) { return new RolePermission(rolePermission); } public RoleSection(String name) { this.name = name; this.rolePermissions = new ArrayList<>(4); } public void addRolePermission(RolePermission rp) { rolePermissions.add(rp); } public Collection<RolePermission> getRolePermissions() { return rolePermissions; } 
<|startcomment|> optional: keep this inline: new HttpDelete(getPeerInfo().getDirectUrl() + endpoint), <|endcomment|>  } HttpResult post(String endpoint, String content) throws IOException { PeerInfo info = getPeerInfo(); HttpPost post = new HttpPost(info.getDirectUrl() + endpoint); if (!Strings.isNullOrEmpty(content)) { post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString()); post.setEntity(new StringEntity(content, StandardCharsets.UTF_8)); } return httpClient.execute(post, new HttpResponseHandler()); } HttpResult delete(String endpoint) throws IOException { <|startfocus|> PeerInfo info = getPeerInfo(); <|endfocus|> return httpClient.execute( new HttpDelete(info.getDirectUrl() + endpoint), new HttpResponseHandler()); } private PeerInfo getPeerInfo() throws PeerInfoNotAvailableException { PeerInfo info = peerInfo.get().orNull(); if (info == null) { throw new PeerInfoNotAvailableException(); } return info; } } 
<|startcomment|> why is this needed? Note that String.replace doesn't expect a regex here but just a CharSequence. <|endcomment|>  log.error( String.format( "Error updating HEAD of remote repository at %s to %s:\n" + " Exception: %s\n Command: %s\n Output: %s", uri, newHead, e, cmd, errStream), e); return false; } return true; } private URIish toSshUri(URIish uri) throws URISyntaxException { <|startfocus|> if (uri.getHost() != null) { return new URIish(uri.toString().replace("gerrit\\+ssh://", "ssh://")); <|endfocus|> } String rawPath = uri.getRawPath(); if (!rawPath.endsWith("/")) { rawPath = rawPath + "/"; } URIish sshUri = new URIish("ssh://" + rawPath); if (sshUri.getPort() < 0) { sshUri = sshUri.setPort(29418); } return sshUri; } private int execute(String remoteName, URIish uri, String cmd, OutputStream errStream) throws IOException { try { URIish sshUri = toSshUri(uri);
<|startcomment|> Unintentional change of import order? <|endcomment|> import com.google.inject.Inject; import org.eclipse.jgit.internal.storage.dfs.InMemoryRepository; import org.eclipse.jgit.lib.CommitBuilder; import org.eclipse.jgit.lib.Constants; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.lib.ObjectInserter; import org.eclipse.jgit.lib.PersonIdent; import org.eclipse.jgit.lib.Ref; import org.eclipse.jgit.lib.RefUpdate; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevSort; import org.eclipse.jgit.revwalk.RevWalk; import org.junit.Before; import org.junit.Test; <|startfocus|> import java.io.IOException; import java.util.Collections; import java.util.EnumSet; import java.util.List; import java.util.Optional; import java.util.concurrent.atomic.AtomicInteger; <|endfocus|> public class NoteDbOnlyIT extends AbstractDaemonTest { @Inject private BatchUpdate.Factory globalBatchUpdateFactory; @Inject private RetryHelper retryHelper; @Before public void setUp() throws Exception { assume().that(notesMigration.disableChangeReviewDb()).isTrue(); } @Test public void updateChangeFailureRollsBackRefUpdate() throws Exception { assume().that(notesMigration.fuseUpdates()).isTrue();
<|startcomment|> throwRestApiException <|endcomment|>  } @Override public ChangeApi revert(RevertInput in) throws RestApiException { try { return changeApi.id(revert.apply(change, in)._number); } catch (Exception e) { throwIfPossible(e); throw new RestApiException("Cannot revert change", e); } } @Override public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException { try { return updateByMerge.apply(change, in).value(); <|startfocus|> } catch (Exception e) { throwIfPossible(e); <|endfocus|> throw new RestApiException("Cannot update change by merge", e); } } @Override public List<ChangeInfo> submittedTogether() throws RestApiException { SubmittedTogetherInfo info = submittedTogether( EnumSet.noneOf(ListChangesOption.class), EnumSet.noneOf(SubmittedTogetherOption.class)); return info.changes; } @Override public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) throws RestApiException { return submittedTogether(EnumSet.noneOf(ListChangesOption.class), options); } @Override public SubmittedTogetherInfo submittedTogether(
<|startcomment|> This is nice, but it seems like this wouldn't have caught the issue we had, since this test would have passed. <|endcomment|>  .hasMessageThat() .isEqualTo("invalid change status: newx"); } @Test public void byCommit() throws Exception { TestRepository<Repo> repo = createProject("repo"); ChangeInserter ins = newChange(repo); insert(repo, ins); String sha = ins.getCommit().name(); assertQuery("0000000000000000000000000000000000000000"); for (int i = 0; i <= 36; i++) { String q = sha.substring(0, 40 - i); <|startfocus|> assertQuery(q, ins.getChange()); <|endfocus|> } } @Test public void byOwner() throws Exception { TestRepository<Repo> repo = createProject("repo"); Change change1 = insert(repo, newChange(repo), userId); Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId(); Change change2 = insert(repo, newChange(repo), user2); assertQuery("owner:" + userId.get(), change1); assertQuery("owner:" + user2, change2); String nameEmail = user.asIdentifiedUser().getNameEmail();
<|startcomment|> Are the parentheses needed? <|endcomment|>  private static Set<String> getNameAndEmail(PersonIdent person) { <|startfocus|> return (person == null) <|endfocus|> ? ImmutableSet.of() : ImmutableSet.of( person.getName().toLowerCase(Locale.US), person.getEmailAddress().toLowerCase(Locale.US));
<|startcomment|> Number? Here and below <|endcomment|> import com.google.gerrit.extensions.common.ChangeInfo; import com.google.gerrit.extensions.common.ChangeInput; import com.google.gerrit.extensions.restapi.ResourceNotFoundException; import org.junit.Before; import org.junit.Test; public class ChangeIdIT extends AbstractDaemonTest { private ChangeInfo changeInfo; @Before public void setup() throws Exception { changeInfo = gApi.changes().create(new ChangeInput(project.get(), "master", "msg")).get(); } @Test <|startfocus|> public void projectChangeIdReturnsChange() throws Exception { <|endfocus|> ChangeApi cApi = gApi.changes().id(project.get(), changeInfo._number); assertThat(cApi.get().changeId).isEqualTo(changeInfo.changeId); } @Test public void wrongProjectInProjectChangeIdReturnsNotFound() throws Exception { exception.expect(ResourceNotFoundException.class); exception.expectMessage("Not found: unknown/ /" + changeInfo._number); gApi.changes().id("unknown", changeInfo._number); } @Test public void wrongIdInProjectChangeIdReturnsNotFound() throws Exception { exception.expect(ResourceNotFoundException.class);
<|startcomment|> I feel like there must be some reasonable way to do this without comparing names, like String.class.isAssignableFrom((Class<?>)types[0]) but I also can't justify spending too much time on this, so *shrug*. <|endcomment|>  throw new IllegalArgumentException(e); } } private static Map<String, org.eclipse.jgit.lib.Config> callConfigMapMethod(Method m) { if (m == null) { return ImmutableMap.of(); } checkArgument(Map.class.isAssignableFrom(m.getReturnType()), "%s must return Map", m); Type[] types = ((ParameterizedType) m.getGenericReturnType()).getActualTypeArguments(); checkArgument( <|startfocus|> String.class.getTypeName().equals(types[0].getTypeName()), <|endfocus|> "The map returned by %s must have String as key", m); checkArgument( org.eclipse.jgit.lib.Config.class.getTypeName().equals(types[1].getTypeName()), "The map returned by %s must have Config as value", m); checkArgument((m.getModifiers() & Modifier.STATIC) != 0, "%s must be static", m); checkArgument(m.getParameterTypes().length == 0, "%s must take no parameters", m); try { @SuppressWarnings("unchecked") Map<String, org.eclipse.jgit.lib.Config> configMap =
<|startcomment|> optional: I would prefer to use ImmutableList.of() here and remove the check within getComments(); <|endcomment|>  this.noteId = noteId; } public byte[] getRaw() { checkParsed(); return raw; } public ImmutableList<T> getComments() { checkParsed(); return comments != null ? comments : ImmutableList.of(); } public void parse() throws IOException, ConfigInvalidException { raw = reader.open(noteId, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ); MutableInteger p = new MutableInteger(); trimLeadingEmptyLines(raw, p); if (p.value >= raw.length) { <|startfocus|> comments = null; <|endfocus|> return; } comments = ImmutableList.copyOf(parse(raw, p.value)); } protected abstract List<T> parse(byte[] raw, int offset) throws IOException, ConfigInvalidException; protected void checkParsed() { checkState(raw != null, "revision note not parsed yet"); } } 
<|startcomment|> I don't think that this part is necessary within this test. The test should only be about deleting the same comment multiple times. <|endcomment|>  private static void copy(Comment from, Comment to) { to.side = from.side == null ? Side.REVISION : from.side; to.parent = from.parent; to.line = from.line; to.message = from.message; <|startfocus|> to.range = from.range; <|endfocus|>
<|startcomment|> UnloggedFailure is not thrown any more. <|endcomment|>  private VerifyStatusQueryShell.OutputFormat format = VerifyStatusQueryShell.OutputFormat.PRETTY; @Option(name = "-c", metaVar = "SQL QUERY", usage = "Query to execute") private String query; @Inject VerifyStatusAdminQueryShell(@PluginName String pluginName, Provider<CurrentUser> userProvider, PermissionBackend permissionBackend) { this.pluginName = pluginName; this.userProvider = userProvider; this.permissionBackend = permissionBackend; } @Override <|startfocus|> protected void run() throws AuthException, PermissionBackendException, UnloggedFailure { // Explictly check that current user was granted plugin's own capability, <|endfocus|> // regardless of whether he is administrator or not. permissionBackend.user(userProvider).check( new PluginPermission(pluginName, AccessCiDatabaseCapability.ID)); final VerifyStatusQueryShell shell = factory.create(in, out); shell.setOutputFormat(format); if (query != null) { shell.execute(query); } else { shell.run(); } } } 
<|startcomment|> nit: 'created_on'. <|endcomment|> import com.google.gerrit.reviewdb.client.AccountGroupMemberAudit; import com.google.gerrit.reviewdb.client.AccountGroupMemberAudit.Key; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gwtorm.server.OrmException; import com.google.gwtorm.server.ResultSet; import com.google.inject.Inject; import com.google.inject.Provider; import java.sql.Timestamp; import java.time.LocalDateTime; import java.time.Month; import java.time.ZoneOffset; import java.util.Comparator; import java.util.Optional; /** A schema which adds the 'created on' field to groups. */ <|startfocus|> public class Schema_151 extends SchemaVersion { <|endfocus|> @Inject protected Schema_151(Provider<Schema_150> prior) { super(prior); } @Override protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException { ResultSet<AccountGroup> accountGroups = db.accountGroups().all(); for (AccountGroup accountGroup : accountGroups) { ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId()); Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits) .map(AccountGroupMemberAudit::getKey)
<|startcomment|> I would add fields for description, parent project and name part. If we find that more fields are needed, we can still add them later. <|endcomment|> // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.index.project; import static com.google.gerrit.server.index.FieldDef.exact; import com.google.gerrit.server.index.FieldDef; import com.google.gerrit.server.project.ProjectState; // Code Review: what are the other fields that Gerrit wants to have in the index? <|startfocus|> /** Index schema for projects. */ <|endfocus|> public class ProjectField { /** Gerrit Project Name. */ public static final FieldDef<ProjectState, String> NAME = exact("name").build(p -> p.getProject().getName()); } 
<|startcomment|> else if? <|endcomment|>  if (refEvent.project.getNameKey().equals(allUsersName) && (refEvent.command.getRefName().startsWith(RefNames.REFS_USERS) && !refEvent.command.getRefName().equals(RefNames.REFS_USERS_DEFAULT))) { if (refEvent.command.getType().equals(ReceiveCommand.Type.CREATE)) { if (!refEvent.user.getCapabilities().canAccessDatabase()) { throw new ValidationException("Not allowed to create user branch."); } <|startfocus|> } if (refEvent.command.getType().equals(ReceiveCommand.Type.DELETE)) { <|endfocus|> if (!refEvent.user.getCapabilities().canAccessDatabase()) { throw new ValidationException("Not allowed to delete user branch."); } } } return ImmutableList.of(); } } } 
<|startcomment|> Not used. <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.verifystatus; <|startfocus|> import com.google.gerrit.extensions.api.access.PluginPermission; <|endfocus|> import com.google.gerrit.extensions.config.CapabilityDefinition; class SaveReportCapability extends CapabilityDefinition { static final String ID = "saveVerificationReport"; @Override public String getDescription() { return "Save Verification Report"; } public static String getName(String pluginName) { return pluginName + "-" + ID; } } 
<|startcomment|> Not used. <|endcomment|> import com.google.gerrit.sshd.CommandMetaData; import com.google.gerrit.sshd.SshCommand; import com.google.inject.Inject; import com.google.inject.Provider; import org.kohsuke.args4j.Option; /** Opens a query processor. */ @AdminHighPriorityCommand @RequiresCapability( value = AccessCiDatabaseCapability.ID, fallBackToAdmin = false ) @CommandMetaData(name = "gsql", description = "Administrative interface to CI database") public class VerifyStatusAdminQueryShell extends SshCommand { <|startfocus|> private final String pluginName; private final Provider<CurrentUser> userProvider; <|endfocus|> @Inject private VerifyStatusQueryShell.Factory factory; @Option(name = "--format", usage = "Set output format") private VerifyStatusQueryShell.OutputFormat format = VerifyStatusQueryShell.OutputFormat.PRETTY; @Option(name = "-c", metaVar = "SQL QUERY", usage = "Query to execute") private String query; @Inject VerifyStatusAdminQueryShell(@PluginName String pluginName, Provider<CurrentUser> userProvider) { this.pluginName = pluginName; this.userProvider = userProvider; } @Override protected void run() throws AuthException {
<|startcomment|> Should this TODO stay? <|endcomment|>  return key( new HttpServlet() { private static final long serialVersionUID = 1L; @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException { try { String idString = req.getPathInfo(); if (idString.endsWith("/")) { idString = idString.substring(0, idString.length() - 1); } Change.Id id = Change.Id.parse(idString); <|startfocus|> // TODO(hiesel) Fixme toGerrit(PageLinks.toChange(id, null), req, rsp); <|endfocus|> } catch (IllegalArgumentException err) { rsp.sendError(HttpServletResponse.SC_NOT_FOUND); } }
<|startcomment|> The previous code used the unfused mode. Is the switch to the fused mode deliberate? <|endcomment|>  private StoredConfig gerritConfig; @Before public void setUp() throws Exception { sitePaths = new SitePaths(TempFileUtil.createTempDirectory().toPath()); sitePath = sitePaths.site_path.toString(); gerritConfig = new FileBasedConfig(sitePaths.gerrit_config.toFile(), FS.detect()); } @After public void tearDown() throws Exception { TempFileUtil.cleanup(); } @Test public void rebuildEmptySiteStartingWithNoteDbEnabled() throws Exception { initSite(); <|startfocus|> setNotesMigrationState(NotesMigrationState.NOTE_DB); <|endfocus|> runGerrit("RebuildNoteDb", "-d", sitePath, "--show-stack-trace"); } private void initSite() throws Exception { runGerrit( "init", "-d", sitePath, "--batch", "--no-auto-start", "--skip-plugins", "--show-stack-trace"); } private static void runGerrit(String... args) throws Exception { assertThat(GerritLauncher.mainImpl(args)).isEqualTo(0); } private void setNotesMigrationState(NotesMigrationState state) throws Exception { gerritConfig.load();
<|startcomment|> Not needed any more. <|endcomment|>  /** * User identity for plugin code that needs an identity. * * <p>An InternalUser has no real identity, it acts as the server and can access anything it wants, * anytime it wants, given the JVM's own direct access to data. Plugins may use this when they need * to have a CurrentUser with read permission on anything. * * @see PluginUser */ public class InternalUser extends CurrentUser { public interface Factory { InternalUser create(); } @VisibleForTesting <|startfocus|> @Inject <|endfocus|> public InternalUser() {} @Override public GroupMembership getEffectiveGroups() { return GroupMembership.EMPTY; } @Override public boolean isInternalUser() { return true; } @Override public String toString() { return "InternalUser"; } } 
<|startcomment|> Not used. <|endcomment|> import com.google.gerrit.extensions.annotations.RequiresCapability; import com.google.gerrit.extensions.api.access.PluginPermission; import com.google.gerrit.extensions.restapi.BadRequestException; import com.google.gerrit.extensions.restapi.IdString; import com.google.gerrit.extensions.restapi.ResourceNotFoundException; import com.google.gerrit.extensions.restapi.RestApiException; import com.google.gerrit.extensions.restapi.RestModifyView; import com.google.gerrit.extensions.webui.UiAction; import com.google.gerrit.server.CurrentUser; import com.google.gerrit.server.config.ConfigResource; import com.google.gerrit.server.update.UpdateException; <|startfocus|> import com.google.gerrit.server.permissions.GlobalPermission; <|endfocus|> import com.google.gerrit.server.permissions.PermissionBackend; import com.google.gerrit.server.permissions.PermissionBackendException; import com.google.gerrit.server.project.NoSuchChangeException; import com.google.gerrit.server.project.ProjectResource; import com.google.gerrit.server.validators.ValidationException; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import com.google.inject.Provider; import com.googlesource.gerrit.plugins.importer.ResumeProjectImport.Input; import org.eclipse.jgit.api.errors.GitAPIException; import org.eclipse.jgit.errors.ConfigInvalidException; import java.io.IOException; import java.io.Writer; 
<|startcomment|> optional: Could be omitted. <|endcomment|>  * @param commitMessage for the commit in the notes branch * @return map with those notes from the {@code notes} that were newly created * @throws LockFailureException if committing the notes failed due to a lock failure on the notes * branch * @throws IOException if committing the notes failed for any other reason */ public final NoteMap commitNewNotes( NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) <|startfocus|> throws LockFailureException, IOException { <|endfocus|> this.overwrite = false; commitNotes(notes, notesBranch, commitAuthor, commitMessage); NoteMap newlyCreated = NoteMap.newEmptyMap(); for (Note n : notes) { if (base == null || !base.contains(n)) { newlyCreated.set(n, n.getData()); } } return newlyCreated; } private void commitNotes( NoteMap notes, String notesBranch, PersonIdent commitAuthor, String commitMessage) throws LockFailureException, IOException { try { revWalk = new RevWalk(db); reader = db.newObjectReader();
<|startcomment|> nit: id <|endcomment|>  Set<CodeReviewCommit> added = Sets.newHashSetWithExpectedSize(ops.size()); for (SubmitStrategyOp op : ops) { added.add(op.getCommit()); } // First add ops for any implicitly merged changes. List<CodeReviewCommit> difference = new ArrayList<>(Sets.difference(toMerge, added)); Collections.reverse(difference); for (CodeReviewCommit c : difference) { Change.Id id = c.change().getId(); <|startfocus|> bu.addOp(c.change().getId(), new ImplicitIntegrateOp(args, c)); <|endfocus|> maybeAddTestHelperOp(bu, id); } // Then ops for explicitly merged changes for (SubmitStrategyOp op : ops) { bu.addOp(op.getId(), op); maybeAddTestHelperOp(bu, op.getId()); } } private void maybeAddTestHelperOp(BatchUpdate bu, Change.Id changeId) { if (args.submitInput instanceof TestSubmitInput) { bu.addOp(changeId, new TestHelperOp(changeId, args)); } } protected abstract List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge)
<|startcomment|> The other constructors use a different order of the arguments. Shouldn't we stay consistent? <|endcomment|> <|startfocus|> public ChangeLink(final String text, final Change.Id c, @Nullable final Project.NameKey project) { <|endfocus|> super(text, PageLinks.toChange(project, c)); getElement().setPropertyString("href", permalink(c)); cid = c;
<|startcomment|> set to 0. <|endcomment|>  * nextChangeId()} to create new changes. In order to prevent these operations stepping on one * another, we use this value to skip some predefined sequence numbers. This is strongly * recommended in a running server. * * <p>If the migration takes place offline, there is no race with other threads, and this option <|startfocus|> * may be set to false. However, admins may still choose to use a gap, for example to make it * easier to distinguish changes that were created before and after the NoteDb migration. <|endfocus|> * * @param sequenceGap sequence gap size; must be non-negative, or null to use the value from * {@code noteDb.changes.sequenceBatchSize} in {@code gerrit.config}. * @return this. */ public Builder setSequenceGap(Integer sequenceGap) { this.sequenceGap = sequenceGap; return this; } public NoteDbMigrator build() throws MigrationException { return new NoteDbMigrator( sitePaths, schemaFactory, repoManager, allProjects,
<|startcomment|> [optional] .current() <|endcomment|>  result.assertOkStatus(); merge(result); PushOneCommit.Result srcChange = createChange(); CherryPickInput input = new CherryPickInput(); input.destination = "foo"; input.base = dstChange.getCommit().name(); input.message = srcChange.getCommit().getFullMessage(); ChangeInfo changeInfo = gApi.changes().id(srcChange.getChangeId()).current().cherryPick(input).get(); assertCherryPickResult(changeInfo, input, srcChange.getChangeId()); } @Test public void cherryPickToOpenChangeRevision() throws Exception { <|startfocus|> createBranch(new NameKey(project, "foo")); <|endfocus|> PushOneCommit.Result dstChange = createChange(testRepo, "foo", SUBJECT, "b.txt", "b", "t"); dstChange.assertOkStatus(); PushOneCommit.Result srcChange = createChange(); CherryPickInput input = new CherryPickInput(); input.destination = "foo"; input.base = dstChange.getCommit().name(); input.message = srcChange.getCommit().getFullMessage(); ChangeInfo changeInfo =
<|startcomment|> reads <|endcomment|> import org.apache.commons.net.pop3.POP3SClient; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.BufferedReader; import java.io.IOException; import java.util.ArrayList; import java.util.List; @Singleton public class Pop3MailReceiver extends MailReceiver { private static final Logger log = LoggerFactory.getLogger(Pop3MailReceiver.class); @Inject <|startfocus|> Pop3MailReceiver(EmailSettings mailSettings, MailProcessor mailProcessor, <|endfocus|> WorkQueue workQueue) { super(mailSettings, mailProcessor, workQueue); } /** * handleEmails will open a connection to the mail server, remove emails * where deletion is pending, read new email and close the connection. * @param async Determines if processing messages should happen asynchronous. */ @Override public synchronized void handleEmails(boolean async) { POP3Client pop3; if (mailSettings.encryption != Encryption.NONE) { pop3 = new POP3SClient(mailSettings.encryption.name()); } else { pop3 = new POP3Client(); } if (mailSettings.port > 0) {
<|startcomment|> 'final' was removed from method calls. Please don't reinsert it. <|endcomment|> <|startfocus|> static void call(Button b, final Project.NameKey project) { <|endfocus|> b.setEnabled(false); ChangeApi.createChange( project.get(), RefNames.REFS_CONFIG, null, AdminConstants.I.editConfigMessage(), null, new GerritCallback<ChangeInfo>() { @Override public void onSuccess(ChangeInfo result) { Gerrit.display( Dispatcher.toEditScreen( project, new PatchSet.Id(result.legacyId(), 1), "project.config")); } @Override public void onFailure(Throwable caught) { b.setEnabled(true); super.onFailure(caught); } });
<|startcomment|> This means that if the initial advertising (line 108) of myUrl failed (due to an intermittent network error), we will not try again to advertise myUrl. Reloading the plugin in order to enforce a peer to again join the cluster and thus trigger "viewAccepted" seems to be the only way to recover. Maybe I am wrong here? If my assumption is correct, then I think that advertising of myUrl should be a periodic task running at a fixed rate in a background thread? <|endcomment|>  view.getMembers().size(), view.getMembers()); } if (peerAddress != null && !view.getMembers().contains(peerAddress)) { log.info("viewAccepted(): removed peerInfo"); peerAddress = null; peerInfo = Optional.absent(); } } if (view.size() > 1) { try { channel.send(new Message(null, myUrl)); } catch (Exception e) { <|startfocus|> // channel communication caused an error. Can't do much about // it. <|endfocus|> log.error("Sending a message over jgroups channel {} caused an error", channelName, e); } }
<|startcomment|> No need to store this separately, you can use getValue() or just the protected value field. <|endcomment|> // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.query.change; import com.google.gerrit.server.index.change.ChangeField; import com.google.gwtorm.server.OrmException; import java.util.Objects; public class RevertOfPredicate extends ChangeIndexPredicate { <|startfocus|> protected final String revertOf; <|endfocus|> public RevertOfPredicate(String revertOf) { super(ChangeField.REVERT_OF, revertOf); this.revertOf = revertOf; } @Override public boolean match(ChangeData cd) throws OrmException { return Objects.equals( cd.getRevertOf() != null ? String.valueOf(cd.getRevertOf().get()) : null, revertOf); } @Override public int getCost() { return 1; } } 
<|startcomment|> same here <|endcomment|>  private boolean couldDeleteWhenIn(Change.Status status) { switch (status) { case NEW: case ABANDONED: // New or abandoned changes can be deleted with the right permissions. return true; case MERGED: // Merged changes should never be deleted. return false; case DRAFT: <|startfocus|> // Only administrators may delete. <|endfocus|> return permissionBackend.user(user).testOrFalse(GlobalPermission.ADMINISTRATE_SERVER); } return false;
<|startcomment|> This lined should be removed. <|endcomment|>  } Change.Id changeId = new Change.Id(seq.nextChangeId()); ChangeInserter ins = changeInserterFactory.create(changeId, c, refName); ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get())); String topic = input.topic; if (topic != null) { topic = Strings.emptyToNull(topic.trim()); } ins.setTopic(topic); ins.setDraft(input.status == ChangeStatus.DRAFT); <|startfocus|> ins.setPrivate(input.isPrivate != null && input.isPrivate); <|endfocus|> ins.setWorkInProgress(input.workInProgress != null && input.workInProgress); ins.setGroups(groups); ins.setNotify(input.notify); ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails)); try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) { bu.setRepository(git, rw, oi); bu.insertChange(ins); bu.execute(); } ChangeJson json = jsonFactory.noOptions(); return Response.created(json.format(ins.getChange())); } catch (IllegalArgumentException e) {
<|startcomment|> Use get() here. <|endcomment|>  if (r.hasRange()) { info.max = r.getMax(); info.min = r.getMin(); } AccountGroup.UUID group = r.getGroup().getUUID(); if (group != null) { pInfo.rules.put(group.get(), info); } } accessSectionInfo.permissions.put(p.getName(), pInfo); } return accessSectionInfo; } <|startfocus|> private ProjectControl open(Project.NameKey projectName) throws ResourceNotFoundException, IOException { <|endfocus|> try { return projectControlFactory.validateFor( projectName, ProjectControl.OWNER | ProjectControl.VISIBLE, self.get()); } catch (NoSuchProjectException e) { throw new ResourceNotFoundException(projectName.get()); } } private static Boolean toBoolean(boolean value) { return value ? true : null; } } 
<|startcomment|> You can merge this with the OrmException block. You will have to use the same log message, but I don't think that's a big loss since the log will contain the stack trace anyway. <|endcomment|>  throws UnprocessableEntityException { try { return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id)); } catch (ResourceNotFoundException e) { throw new UnprocessableEntityException(String.format("change %s not found", id.get())); } catch (OrmException e) { log.error("cannot resolve change", e); throw new UnprocessableEntityException("internal server error"); <|startfocus|> } catch (PermissionBackendException e) { log.error("cannot test permissions for change", e); throw new UnprocessableEntityException("internal server error"); <|endfocus|> } } @Singleton public static class Create implements RestModifyView<AccountResource, EmptyInput> { private final Provider<CurrentUser> self; private final StarredChangesUtil starredChangesUtil; private ChangeResource change; @Inject Create(Provider<CurrentUser> self, StarredChangesUtil starredChangesUtil) { this.self = self; this.starredChangesUtil = starredChangesUtil; } public Create setChange(ChangeResource change) { this.change = change; return this; } @Override public Response<?> apply(AccountResource rsrc, EmptyInput in)
<|startcomment|> move into ConfigEntry <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.supermanifest; import static com.google.gerrit.reviewdb.client.RefNames.REFS_HEADS; import com.google.common.base.Strings; import com.google.gerrit.reviewdb.client.Project; import java.net.URI; import java.net.URISyntaxException; import java.util.Objects; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.Repository; <|startfocus|> enum ToolType { Repo, Jiri } <|endfocus|> class ConfigEntry { public static final String SECTION_NAME = "superproject"; Project.NameKey srcRepoKey; String srcRef; URI baseUri; ToolType toolType; String xmlPath; Project.NameKey destRepoKey; boolean recordSubmoduleLabels; // destBranch can be "*" in which case srcRef is ignored. String destBranch; ConfigEntry(Config cfg, String name) throws ConfigInvalidException { String[] parts = name.split(":"); if (parts.length != 2) { throw new ConfigInvalidException(
<|startcomment|> Can you explain why we don't fail anymore in case of invalid JSON attributes? <|endcomment|>  throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson)); } JsonObject jsonObject = userJson.getAsJsonObject(); JsonElement id = jsonObject.get("id"); if (id == null || id.isJsonNull()) { throw new IOException(String.format("Response doesn't contain %s field", "id")); } JsonElement attrListJson = jsonObject.get("attributes"); <|startfocus|> String email = null, name = null, login = null; <|endfocus|> if (attrListJson != null && attrListJson.isJsonArray()) { JsonArray attrJson = attrListJson.getAsJsonArray(); for (JsonElement elem : attrJson) { if (elem == null || !elem.isJsonObject()) { throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", elem)); } JsonObject obj = elem.getAsJsonObject(); String property = getStringElement(obj, "email"); if (property != null) email = property; property = getStringElement(obj, "name");
<|startcomment|> I don't think it's necessary to parse an ObjectId just so we can use hashObjectId instead of hashing the string. <|endcomment|>  accounts.addAll(approvals.values().stream().map(a -> a.getAccountId()).collect(toSet())); accounts.addAll(reviewers.byState(ReviewerStateInternal.REVIEWER)); accounts.addAll(reviewers.byState(ReviewerStateInternal.CC)); } catch (OrmException e) { // This ETag will be invalidated if it loads next time. } accounts .stream() .forEach( a -> hashObjectId( h, ObjectId.fromString(accountCache.get(a).getAccount().getMetaId()), buf)); <|startfocus|> <|endfocus|> ObjectId noteId; try { noteId = getNotes().loadRevision(); } catch (OrmException e) { noteId = null; // This ETag will be invalidated if it loads next time. } hashObjectId(h, noteId, buf); // TODO(dborowitz): Include more NoteDb and other related refs, e.g. drafts // and edits. for (ProjectState p : control.getProjectControl().getProjectState().tree()) { hashObjectId(h, p.getConfig().getRevision(), buf); }
<|startcomment|> never thrown <|endcomment|>  } } private List<RevisionResource> byLegacyPatchSetId(ChangeResource change, String id) throws OrmException { PatchSet ps = psUtil.get( dbProvider.get(), change.getNotes(), new PatchSet.Id(change.getId(), Integer.parseInt(id))); if (ps != null) { return Collections.singletonList(new RevisionResource(change, ps)); } return Collections.emptyList(); } private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) <|startfocus|> throws AuthException, IOException, OrmException { <|endfocus|> Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser()); if (edit.isPresent()) { PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0)); RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit())); ps.setRevision(editRevId); if (revid == null || editRevId.equals(revid)) { return Collections.singletonList(new RevisionResource(change, ps, edit)); } } return Collections.emptyList(); } } 
<|startcomment|> nit: long line <|endcomment|>  @Inject SuggestProjectReviewers( AccountVisibility av, IdentifiedUser.GenericFactory identifiedUserFactory, Provider<ReviewDb> dbProvider, @GerritServerConfig Config cfg, ReviewersUtil reviewersUtil, PermissionBackend permissionBackend) { super(av, identifiedUserFactory, dbProvider, cfg, reviewersUtil); this.permissionBackend = permissionBackend; } @Override public List<SuggestedReviewerInfo> apply(ProjectResource rsrc) throws BadRequestException, OrmException, IOException, ConfigInvalidException { <|startfocus|> return reviewersUtil.suggestReviewers(null, this, rsrc.getProjectState(), getVisibility(rsrc), true); <|endfocus|> } private VisibilityControl getVisibility(final ProjectResource rsrc) { return new VisibilityControl() { @Override public boolean isVisibleTo(Account.Id account) throws OrmException { return permissionBackend .user(identifiedUserFactory.create(account)) .project(rsrc.getNameKey()) .testOrFalse(ProjectPermission.ACCESS); } }; } } 
<|startcomment|> nit: remove punctuation <|endcomment|>  } } p.add(r); } accessSection.getPermissions().add(p); } sections.add(accessSection); } return sections; } /** * Checks that the removals and addition are logically valid, but doesn't check current user's * permission. */ void validateChanges( ProjectControl projectControl, ProjectConfig config, List<AccessSection> removals, List<AccessSection> additions) throws BadRequestException, AuthException, InvalidNameException, PermissionBackendException { <|startfocus|> // Perform permission checks. <|endfocus|> for (AccessSection section : Iterables.concat(additions, removals)) { boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName()); if (isGlobalCapabilities) { if (!allProjects.equals(config.getName())) { throw new BadRequestException( "Cannot edit global capabilities for projects other than " + allProjects.get()); } } } // Perform addition checks for (AccessSection section : additions) { String name = section.getName(); boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(name); 
<|startcomment|> Also unused, removed. <|endcomment|> import java.nio.file.FileVisitOption; import java.nio.file.FileVisitResult; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.SimpleFileVisitor; import java.nio.file.attribute.BasicFileAttributes; import java.util.ArrayList; import java.util.EnumSet; import java.util.List; import org.eclipse.jgit.storage.file.FileBasedConfig; import org.eclipse.jgit.util.FS; class SetupLocalHAReplica { private final SitePaths master; private final FileBasedConfig masterConfig; private final Path sharedDir; <|startfocus|> <|endfocus|> private SitePaths replica; @Inject SetupLocalHAReplica(SitePaths master, InitFlags flags) { this.master = master; this.masterConfig = flags.cfg; this.sharedDir = master.site_path.resolve(DEFAULT_SHARED_DIRECTORY); } void run(SitePaths replica, FileBasedConfig pluginConfig) throws Exception { this.replica = replica; FileUtil.mkdirsOrDie(replica.site_path, "cannot create " + replica.site_path); configureMainSection(pluginConfig); configurePeerInfo(pluginConfig); for (Path dir : listDirsForCopy()) { copyFiles(dir); } 
<|startcomment|> Use rsrc.getUser() instead <|endcomment|>  } @Override public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, UnprocessableEntityException, BadRequestException, InvalidNameException, ResourceConflictException { ProjectControl projectControl = rsrc.getControl(); MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get(); List<AccessSection> removals = setAccess.getAccessSections(input.remove); List<AccessSection> additions = setAccess.getAccessSections(input.add); PermissionBackend.ForRef metaRef = permissionBackend <|startfocus|> .user(projectControl.getUser()) .project(projectControl.getProject().getNameKey()) <|endfocus|> .ref(RefNames.REFS_CONFIG); try { metaRef.check(RefPermission.READ); } catch (AuthException denied) { throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible"); } if (!projectControl.isOwner()) { try { metaRef.check(RefPermission.CREATE_CHANGE); } catch (AuthException denied) { throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG); } } Project.NameKey newParentProjectName =
<|startcomment|> Putting it here breaks "access()" and "access(ProjectAccessInput p)". It should be in line#45. There it will be consistent with line#178. <|endcomment|> import com.google.gerrit.extensions.common.ProjectInfo; import com.google.gerrit.extensions.restapi.NotImplementedException; import com.google.gerrit.extensions.restapi.RestApiException; import java.util.List; public interface ProjectApi { ProjectApi create() throws RestApiException; ProjectApi create(ProjectInput in) throws RestApiException; ProjectInfo get() throws RestApiException; String description() throws RestApiException; void description(DescriptionInput in) throws RestApiException; ProjectAccessInfo access() throws RestApiException; <|startfocus|> AccessCheckInfo checkAccess(AccessCheckInput in) throws RestApiException; <|endfocus|> ProjectAccessInfo access(ProjectAccessInput p) throws RestApiException; ChangeInfo accessChange(ProjectAccessInput p) throws RestApiException; ConfigInfo config() throws RestApiException; ConfigInfo config(ConfigInput in) throws RestApiException; ListRefsRequest<BranchInfo> branches(); ListRefsRequest<TagInfo> tags(); void deleteBranches(DeleteBranchesInput in) throws RestApiException; void deleteTags(DeleteTagsInput in) throws RestApiException; abstract class ListRefsRequest<T extends RefInfo> { protected int limit; protected int start; protected String substring; protected String regex;
<|startcomment|> The fact that this single annotation brings in a Gson dependency is kind of sad, but I also see no way of working around it without changing the client implementations to use a name other than 'default' :/ On the other hand we already depend on Guava and Guice, so it doesn't seem like a big deal. <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.extensions.api.projects; import com.google.common.base.Joiner; import com.google.gerrit.extensions.restapi.Url; import com.google.gson.annotations.SerializedName; import java.util.ArrayList; import java.util.List; public class DashboardInfo { public String id; public String project; public String definingProject; public String ref; public String path; public String description; public String foreach; public String url; <|startfocus|> @SerializedName("default") <|endfocus|> public Boolean isDefault; public String title; public List<DashboardSectionInfo> sections = new ArrayList<>(); public DashboardInfo(String ref, String name) { this.ref = ref; this.path = name; this.id = Joiner.on(':').join(Url.encode(ref), Url.encode(path)); } } 
<|startcomment|> remove <|endcomment|>  } } /** * Authenticate the user, potentially creating a new account if they are new. * * @param who identity of the user, with any details we received about them. * @return the result of authenticating the user. * @throws AccountException the account does not exist, and cannot be created, or exists, but <|startfocus|> * cannot be located, is unabme to be activated or deactivated, or is inactive, or cannot be <|endfocus|> * added to the admin group (only for the first account). */ public AuthResult authenticate(AuthRequest who) throws AccountException, IOException { who = realm.authenticate(who); try { try (ReviewDb db = schema.open()) { ExternalId id = externalIds.get(who.getExternalIdKey()); if (id == null) { // New account, automatically create and return. // return create(db, who); } // Account exists Account act = byIdCache.get(id.accountId()).getAccount();
<|startcomment|> Why to materialize the stream to the set and not just return Stream of account ids? On huge gerrit installation sites we have dozen of thousands of users. <|endcomment|>  * * @return {@code true} if at least one account exists, otherwise {@code false} */ public boolean hasAnyAccount() throws IOException { try (Repository repo = repoManager.openRepository(allUsersName)) { return hasAnyAccount(repo); } } public static boolean hasAnyAccount(Repository repo) throws IOException { return readUserRefs(repo).findAny().isPresent(); } <|startfocus|> public static Set<Account.Id> allIds(Repository repo) throws IOException { return readUserRefs(repo).collect(toSet()); } <|endfocus|> private Stream<Account.Id> readUserRefs() throws IOException { try (Repository repo = repoManager.openRepository(allUsersName)) { return readUserRefs(repo); } } private Account read(Repository allUsersRepository, Account.Id accountId) throws IOException, ConfigInvalidException { AccountConfig accountConfig = new AccountConfig(emailValidator, accountId); accountConfig.load(allUsersRepository); return accountConfig.getAccount(); } private static Stream<Account.Id> readUserRefs(Repository repo) throws IOException { return repo.getRefDatabase() .getRefs(RefNames.REFS_USERS)
<|startcomment|> spaces <|endcomment|>  assertThat(psa.getAccountId()).isEqualTo(otherUserId); assertThat(psa.getLabel()).isEqualTo("Not-For-Long"); assertThat(psa.getValue()).isEqualTo((short) 1); update = newUpdate(c, changeOwner); update.removeApprovalFor(otherUserId, "Not-For-Long"); update.commit(); notes = newNotes(c); <|startfocus|> PatchSetApproval expected = new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen()); expected.setOriginalValue((short) 1); assertThat(notes.getApprovals()) <|endfocus|> .containsExactlyEntriesIn( ImmutableListMultimap.of( psa.getPatchSetId(), expected)); // Add back approval on same label. update = newUpdate(c, otherUser); update.putApproval("Not-For-Long", (short) 2); update.commit(); notes = newNotes(c); psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId())); assertThat(psa.getAccountId()).isEqualTo(otherUserId); assertThat(psa.getLabel()).isEqualTo("Not-For-Long"); assertThat(psa.getValue()).isEqualTo((short) 2);
<|startcomment|> This has to be DynamicItem<ProjectNameLockManager> so that plugins can provide own implementation <|endcomment|>  private final ProjectJson json; private final GitRepositoryManager repoManager; private final DynamicSet<NewProjectCreatedListener> createdListeners; private final ProjectCache projectCache; private final GroupBackend groupBackend; private final ProjectOwnerGroupsProvider.Factory projectOwnerGroups; private final MetaDataUpdate.User metaDataUpdateFactory; private final GitReferenceUpdated referenceUpdated; private final RepositoryConfig repositoryCfg; private final PersonIdent serverIdent; private final Provider<IdentifiedUser> identifiedUser; private final Provider<PutConfig> putConfig; private final AllProjectsName allProjects; <|startfocus|> private final ProjectNameLockManager lockManager; <|endfocus|> private final String name; @Inject CreateProject( Provider<ProjectsCollection> projectsCollection, Provider<GroupsCollection> groupsCollection, ProjectJson json, DynamicSet<ProjectCreationValidationListener> projectCreationValidationListeners, GitRepositoryManager repoManager, DynamicSet<NewProjectCreatedListener> createdListeners, ProjectCache projectCache, GroupBackend groupBackend, ProjectOwnerGroupsProvider.Factory projectOwnerGroups, MetaDataUpdate.User metaDataUpdateFactory, GitReferenceUpdated referenceUpdated, RepositoryConfig repositoryCfg, @GerritPersonIdent PersonIdent serverIdent, Provider<IdentifiedUser> identifiedUser, Provider<PutConfig> putConfig,
<|startcomment|> {@link ReviewDb} (here and below where links can be used) <|endcomment|>  * decide whether open predecessor changes should be included the method must take the submit type * into account (e.g. for changes with submit type "Cherry-Pick" open predecessor changes must not * be included). * * <p>This method is invoked iteratively while new changes to be submitted together are discovered * by expanding the topics of the changes. This method must not do any topic expansion on its own. * <|startfocus|> * @param db ReviewDb instance * @param orm MergeOpRepoManager that should be used to access repositories <|endfocus|> * @param changeSet A set of changes for which it is known that they should be submitted together * @param user The user for which the visibility checks should be performed. * @return the completed set of changes that should be submitted together */ ChangeSet completeWithoutTopic( ReviewDb db, MergeOpRepoManager orm, ChangeSet changeSet, CurrentUser user) throws OrmException, IOException, PermissionBackendException; } 
<|startcomment|> Just to check my understanding: there are two Suppliers.memoize constructs used here, but they are completely different: * 1. materialization of session instance from Provider * 2. Lazy processor.process() invocation on the next line May be add a comment and mention that? HttpSession only creates CloseableHttpClient that is bound to HttpClientProvider. The optimization is here to avoid the creation of CloseableHttpClient in case the processor returns no result for this event? <|endcomment|>  public PostTask( @WebHooksExecutor ScheduledExecutorService executor, Provider<HttpSession> session, EventProcessor processor, @Assisted ProjectEvent event, @Assisted RemoteConfig remote) { this.executor = executor; <|startfocus|> this.remote = remote; <|endfocus|> this.session = Suppliers.memoize(() -> session.get()); this.processor = Suppliers.memoize(() -> processor.process(event, remote));
<|startcomment|> Is this is a new configuration key? Can it be documented in Documentation/config-gerrit.html#gerrit ? Also, this new key is called `favicon`, but the template param is called `faviconPath`. (Assuming it's new) should this one be called `faviconPath`? <|endcomment|>  // path (UrlModule). if (!p.equals("/")) { filter(p).through(XsrfCookieFilter.class); } } filter("/*").through(PolyGerritFilter.class); } @Provides @Singleton @Named(POLYGERRIT_INDEX_SERVLET) HttpServlet getPolyGerritUiIndexServlet( @CanonicalWebUrl @Nullable final Provider<String> canonicalURLProvider, @GerritServerConfig Config cfg) <|startfocus|> throws ServletException { String cdnPath = cfg.getString("httpd", null, "cdnPath"); return new IndexServlet(canonicalURLProvider.get(), cdnPath); <|endfocus|> } @Provides @Singleton PolyGerritUiServlet getPolyGerritUiServlet(@Named(CACHE) Cache<Path, Resource> cache) { return new PolyGerritUiServlet(cache, polyGerritBasePath()); } @Provides @Singleton BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException { return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().builder) : null; } @Provides @Singleton FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
<|startcomment|> Unnecessary change <|endcomment|> <|startfocus|> Copyright (C) 2017 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.documentation; import static com.vladsch.flexmark.profiles.pegdown.Extensions.ALL; import static com.vladsch.flexmark.profiles.pegdown.Extensions.HARDWRAPS; import static com.vladsch.flexmark.profiles.pegdown.Extensions.SUPPRESS_ALL_HTML; import static java.nio.charset.StandardCharsets.UTF_8; import com.google.common.base.Strings; import com.vladsch.flexmark.Extension; import com.vladsch.flexmark.ast.Heading; import com.vladsch.flexmark.ast.Node; import com.vladsch.flexmark.ast.util.TextCollectingVisitor;
<|startcomment|> maybe: is read-only. <|endcomment|>  private final AllUsersName allUsersName; private final Repository allUsersRepo; @Nullable private final MetaDataUpdateFactory metaDataUpdateFactory; /** * @param allUsersName Name of the All-Users repository in which the groups are stored. <|startfocus|> * @param allUsersRepo All-Users repository * @param metaDataUpdateFactory Factory to create a MetaDataUpdate, required for updating the * group owner. Can be {@code null} if the group owner is only read. <|endfocus|> */ public GroupOwnerPermissions( AllUsersName allUsersName, Repository allUsersRepo, @Nullable MetaDataUpdateFactory metaDataUpdateFactory) { this.allUsersName = checkNotNull(allUsersName); this.allUsersRepo = checkNotNull(allUsersRepo); this.metaDataUpdateFactory = metaDataUpdateFactory; } /** * Determines the owner group from the permissions on the group ref. * * @param groupUuid UUID of the group for which the group owner should be read * @return UUID of the owner group, {@code null} if the owner permissions are missing or if owner
<|startcomment|> group <|endcomment|>  super(prior); this.repoManager = repoManager; this.allUsersName = allUsersName; } @Override protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException { @SuppressWarnings("deprecation") RepoSequence.Seed groupSeed = () -> db.nextAccountGroupId(); RepoSequence groupSeq = new RepoSequence( repoManager, GitReferenceUpdated.DISABLED, allUsersName, Sequences.NAME_GROUPS, groupSeed, 1); <|startfocus|> // consume one account ID to ensure that the account sequence is initialized in NoteDb <|endfocus|> groupSeq.next(); } } 
<|startcomment|> Javadoc needs updating. <|endcomment|>  throw new IOException("Unexpected QueryParseException during get()", e); } catch (OrmException e) { throw new IOException(e); } switch (results.size()) { case 0: return Optional.empty(); case 1: return Optional.of(results.get(0)); default: throw new IOException("Multiple results found in index for key " + key + ": " + results); } } /** <|startfocus|> * Get a single field from a document from the index. <|endfocus|> * * @param key document key. * @param opts query options. Options that do not make sense in the context of a single document, * such as start, will be ignored. * @return a collection of the field's values. A collection with cardinality 1 is returned if the * field is not repeated. * @throws IOException */ default Optional<FieldsBundle> getRaw(K key, QueryOptions opts) throws IOException { opts = opts.withStart(0).withLimit(2); List<FieldsBundle> results; try {
<|startcomment|> nit: Aren't those two lines redundant? <|endcomment|>  TestTimeUtil.useSystemTime(); } @Test public void minimalGroupFields() throws Exception { AccountGroup g = newGroup("a"); GroupBundle b = builder().group(g).build(); rebuilder.rebuild(repo, b); assertThat(reload(g)).isEqualTo(b.toInternalGroup()); ImmutableList<CommitInfo> log = log(g); assertThat(log).hasSize(1); assertCommit(log.get(0), "Create group", SERVER_NAME, SERVER_EMAIL); <|startfocus|> assertServerCommit(log.get(0), "Create group"); <|endfocus|> } @Test public void allGroupFields() throws Exception { AccountGroup g = newGroup("a"); g.setDescription("Description"); g.setOwnerGroupUUID(new AccountGroup.UUID("owner")); g.setVisibleToAll(true); GroupBundle b = builder().group(g).build(); rebuilder.rebuild(repo, b); assertThat(reload(g)).isEqualTo(b.toInternalGroup()); ImmutableList<CommitInfo> log = log(g); assertThat(log).hasSize(1); assertServerCommit(log.get(0), "Create group"); } @Test
<|startcomment|> successfully <|endcomment|>  public void connect() { try { channel = new JChannel(); Optional<InetAddress> address = finder.findAddress(); if (address.isPresent()) { channel.getProtocolStack().getTransport().setBindAddress(address.get()); } channel.setReceiver(this); channel.setDiscardOwnMessages(true); channel.connect(jgroupsConfig.clusterName()); <|startfocus|> log.info("Channel {} succesfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName()); <|endfocus|> } catch (Exception e) { log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e); }
<|startcomment|> Thanks for adding some Javadoc descriptions but please don't remove this and the other TODOs completely yet. We need more Javadoc descriptions and I also intend to include more details in them. <|endcomment|> import java.io.IOException; import java.sql.Timestamp; import java.util.Arrays; import java.util.Objects; import java.util.Optional; import java.util.StringJoiner; import java.util.function.Function; import java.util.regex.Pattern; import java.util.stream.Collectors; import java.util.stream.Stream; import org.eclipse.jgit.errors.ConfigInvalidException; import org.eclipse.jgit.lib.CommitBuilder; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.PersonIdent; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevSort; <|startfocus|> // TODO(aliceks): Add Javadoc descriptions to this file. <|endfocus|> public class GroupConfig extends VersionedMetaData { private static final String GROUP_CONFIG_FILE = "group.config"; private static final String MEMBERS_FILE = "members"; private static final String SUBGROUPS_FILE = "subgroups"; private static final Pattern LINE_SEPARATOR_PATTERN = Pattern.compile("\\R"); enum UpdateOwnerPermissionsStrategy { /** Automatically update permissions in {@code refs/meta/config} when group owner changes. */ UPDATE, /**
<|startcomment|> Mention those configuration option in the plugins documentation and may be eve link to: [1]? * [1] https://github.com/javamelody/javamelody/wiki/UserGuide#6-optional-parameters <|endcomment|>  monitoring.init(config); } @Override public void destroy() { monitoring.destroy(); } private boolean canMonitor(HttpServletRequest httpRequest) { if (httpRequest.getRequestURI().equals(monitoring .getJavamelodyUrl(httpRequest))) { return capabilityChecker.canMonitor(); } return true; } static class JavamelodyFilter extends MonitoringFilter { private static String HTTP_TRANSFORM_PATTERN = "http-transform-pattern"; private static String GLOBAL_HTTP_TRANSFORM_PATTERN = "javamelody." + HTTP_TRANSFORM_PATTERN; <|startfocus|> private static String GERRIT_GROUPING = "(\\w+)~(.+)~I([0-9a-f]{40})" //change id triplet <|endfocus|> + "|([0-9a-f]{64})" // Long SHA for LFS + "|([0-9a-f]{40})" // SHA-1 + "|([0-9A-F]{32})" // GWT cache ID + "|(?<=files/)(.+)/" //review fiels part + "|(?<=/projects/)(.+)/" //project name + "|(?<=/accounts/)(.+)/" // account id
<|startcomment|> nit: this isn't used when we hit any of the if conditions and return. Hence it can be moved closer to config.commit(md). I think it would also increase readability. <|endcomment|>  super(prior); this.repoManager = repoManager; this.allUsersName = allUsersName; this.systemGroupBackend = systemGroupBackend; this.serverUser = serverUser; } @Override protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException { try (Repository git = repoManager.openRepository(allUsersName); MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) { md.getCommitBuilder().setAuthor(serverUser); md.getCommitBuilder().setCommitter(serverUser); <|startfocus|> md.setMessage(COMMIT_MSG); <|endfocus|> ProjectConfig config = ProjectConfig.read(md); AccessSection users = config.getAccessSection( RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", false); if (users == null) { // default permission was removed return; } Permission permission = users.getPermission(Permission.LABEL + "Code-Review", false); if (permission == null) { // default permission was removed return; } else if (permission.getExclusiveGroup()) { // default permission was modified return;
<|startcomment|> nit: remove and use "ref.getObjectId()" directly below. <|endcomment|>  private void readGroupNames( Repository repo, RefDatabase db, List<ConsistencyProblemInfo> problems, BiMap<AccountGroup.UUID, String> result) throws IOException { Ref ref = db.exactRef(RefNames.REFS_GROUPNAMES); if (ref == null) { problems.add( new ConsistencyProblemInfo( readGroups ? ConsistencyProblemInfo.Status.ERROR : ConsistencyProblemInfo.Status.WARNING, String.format("ref %s does not exist", RefNames.REFS_GROUPNAMES))); return; } <|startfocus|> ObjectId nameId = ref.getObjectId(); <|endfocus|> try (RevWalk rw = new RevWalk(repo)) { NoteMap nm = NoteMap.read(rw.getObjectReader(), rw.parseCommit(nameId)); for (Note note : nm) { ObjectLoader ld = rw.getObjectReader().open(note.getData()); byte[] data = ld.getCachedBytes(); try { GroupReference gRef = GroupNameNotes.getFromNoteData(data); ObjectId nameKey = GroupNameNotes.getNoteKey(new NameKey(gRef.getName())); if (!Objects.equals(nameKey, note)) {
<|startcomment|> It would be nice if you got rid of the nested ifs per suggestions in PS1 (and also the additional "lostEventCounter == 1" that spans from nestling it). This is enough: } else if (lostEventCount++ % 10 == 0) { LOGGER.warn("Event queue is full. Number of events lost since queue became full: " + errorCounter); } The ++ will be evaluated after the comparison is done. Which means it will log on the first lost event (which we want). <|endcomment|>  public void onEvent(Event event) { if (!publisherThread.isAlive()) { ensurePublisherThreadStarted(); } if (queue.offer(event)) { if (lostEventCount > 0) { LOGGER.warn("Event queue is no longer full, {} events were lost", lostEventCount); lostEventCount = 0; <|startfocus|> } } else { if (lostEventCount++ % 10 == 0) { LOGGER.error("Event queue is full, lost {} event(s)", lostEventCount); } <|endfocus|> }
<|startcomment|> It is better to use: name("user") here and name("user") + @example.com for the email because it guarantees a unique name based on the test method. <|endcomment|>  String g = createGroup("users"); gApi.groups().id(g).addMembers("user"); assertMembers(g, user); gApi.groups().id(g).removeMembers("user"); assertNoMembers(g); } @Test public void cachedGroupsForMemberAreUpdatedOnMemberAdditionAndRemoval() throws Exception { String username = name("user"); Account.Id accountId = accountOperations.newAccount().username(username).create(); // Fill the cache for the observed account. <|startfocus|> groupIncludeCache.getGroupsWithMember(accountId); <|endfocus|> String groupName = createGroup("users"); AccountGroup.UUID groupUuid = new AccountGroup.UUID(gApi.groups().id(groupName).get().id); gApi.groups().id(groupName).addMembers(username); Collection<AccountGroup.UUID> groupsWithMemberAfterAddition = groupIncludeCache.getGroupsWithMember(accountId); assertThat(groupsWithMemberAfterAddition).contains(groupUuid); gApi.groups().id(groupName).removeMembers(username); Collection<AccountGroup.UUID> groupsWithMemberAfterRemoval = groupIncludeCache.getGroupsWithMember(accountId); assertThat(groupsWithMemberAfterRemoval).doesNotContain(groupUuid); } @Test
<|startcomment|> I would do this here, so people can't confuse newEmail and email where you did this below. (or better: if whatever provides this value sanitizes it directly, so other parts of gerrit can't forget to sanitize it.) <|endcomment|>  @Inject CreateEmail( Provider<CurrentUser> self, Realm realm, PermissionBackend permissionBackend, AuthConfig authConfig, AccountManager accountManager, RegisterNewEmailSender.Factory registerNewEmailFactory, PutPreferred putPreferred, OutgoingEmailValidator validator, @Assisted String email) { this.self = self; this.realm = realm; this.permissionBackend = permissionBackend; this.accountManager = accountManager; this.registerNewEmailFactory = registerNewEmailFactory; this.putPreferred = putPreferred; this.validator = validator; <|startfocus|> this.email = email; <|endfocus|> this.isDevMode = authConfig.getAuthType() == DEVELOPMENT_BECOME_ANY_ACCOUNT; } @Override public Response<EmailInfo> apply(AccountResource rsrc, EmailInput input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException, MethodNotAllowedException, IOException, ConfigInvalidException, PermissionBackendException { if (input == null) { input = new EmailInput(); } if (self.get() != rsrc.getUser() || input.noConfirmation) { permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT); } 
<|startcomment|> Actually, we should log the inconsistency here and not above. At this moment, the group is loaded directly from NoteDb as we evicted the cache in line 104. When retrieving the 'oldGroup', it can already be contained in the cache and hence the group isn't even read from NoteDb. <|endcomment|>  } else { // The UUID here is read from group name notes. If it fails to load from group // cache, there exists an inconsistency. GroupsNoteDbConsistencyChecker.logConsistencyProblemAsWarning( "Group with UUID %s from group name notes is failed to load from group ref", uuid); } Optional<InternalGroup> internalGroup = groupCache.get(uuid); if (internalGroup.isPresent()) { index.replace(internalGroup.get()); } else { <|startfocus|> index.delete(uuid); <|endfocus|> } verboseWriter.println("Reindexed " + desc); done.incrementAndGet(); } catch (Exception e) { failed.incrementAndGet(); throw e; } return null; }); addErrorListener(future, desc, progress, ok); futures.add(future); } try { Futures.successfulAsList(futures).get(); } catch (ExecutionException | InterruptedException e) { log.error("Error waiting on group futures", e); return new SiteIndexer.Result(sw, false, 0, 0); } progress.endTask();
<|startcomment|> "logs" or "the log" <|endcomment|> kage com.google.gerrit.sshd; import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Retention; import java.lang.annotation.Target; /** <|startfocus|> * Annotation tagged on a field of a ssh command to indicate the value must be hidden from log. <|endfocus|> */ @Target({FIELD}) @Retention(RUNTIME) public @interface SensitiveData { } 
<|startcomment|> The test name "groupNameNoteIsMissing" would probably be clearer. The 'NoteDataBlob' part confuses me. <|endcomment|> import java.util.List; import org.junit.Test; public class GroupsNoteDbConsistencyCheckerTest extends AbstractGroupTest { @Test public void groupNamesRefIsMissing() throws Exception { List<ConsistencyProblemInfo> problems = GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes( allUsersRepo, "g-1", new AccountGroup.UUID("uuid-1")); assertThat(problems) .containsExactly(warning("Group with name 'g-1' doesn't exist in the list of all names")); } @Test <|startfocus|> public void groupNameNoteDataBlobIsMissing() throws Exception { GroupTestUtil.updateGroupFile(allUsersRepo, serverIdent, RefNames.REFS_GROUPNAMES, "a", "c"); <|endfocus|> List<ConsistencyProblemInfo> problems = GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes( allUsersRepo, "g-1", new AccountGroup.UUID("uuid-1")); assertThat(problems) .containsExactly(warning("Group with name 'g-1' doesn't exist in the list of all names")); } @Test public void groupNameNoteIsConsistent() throws Exception {
<|startcomment|> We cannot tell this for sure. If rate limit is high enough this may not necessarily happen. <|endcomment|>  } private Holder(RateLimiter l, int burstPermits) { this(l); this.burstPermits = burstPermits; gracePermits.set(burstPermits); } RateLimiter get() { return l; } int getBurstPermits() { return burstPermits; } /* * The grace period ensures that a burst of requests can be served * as the first interaction with the back-end server. Without the * grace period, particularly the Gerrit web interface would * display an unexpected error. */ <|startfocus|> boolean inGracePeriod() { if (gracePermits.get() < 0) return false; <|endfocus|> return gracePermits.getAndDecrement() > 0; } private static final Holder createWithBurstyRateLimiter(Optional<RateLimit> limit) { return new Holder( RateLimitUploadListener.createSmoothBurstyRateLimiter( limit.get().getRatePerSecond(), limit.get().getMaxBurstSeconds()), (int) (limit.get().getMaxBurstSeconds() * limit.get().getRatePerSecond())); } } 
<|startcomment|> throwIfUnchecked? <|endcomment|>  // don't do it automatically. Let the end user decide whether they want to retry. return execute(updateFactory, action, RetryerBuilder.<T>newBuilder().build()); } return execute( updateFactory, action, opts, t -> { if (t instanceof UpdateException) { t = t.getCause(); } return t instanceof LockFailureException; }); } catch (Throwable t) { <|startfocus|> Throwables.throwIfInstanceOf(t, RuntimeException.class); <|endfocus|> Throwables.throwIfInstanceOf(t, UpdateException.class); Throwables.throwIfInstanceOf(t, RestApiException.class); throw new UpdateException(t); } } private <I, O> O execute( I input, Action<I, O> action, Options opts, Predicate<Throwable> exceptionPredicate) throws Throwable { MetricListener listener = new MetricListener(); try { RetryerBuilder<O> retryerBuilder = createRetryerBuilder(opts, exceptionPredicate); retryerBuilder.withRetryListener(listener); return execute(input, action, retryerBuilder.build()); } finally { metrics.attemptCounts.record(listener.getAttemptCount()); } } 
<|startcomment|> We usually use static import for Collectors methods. I see, though, it is not done consistenly (and should be fixed): $ git grep "Collectors\." | grep -v import | wc -l 20 <|endcomment|>  } s.add(a); pm.update(1); } return s; } } private Map<String, AccountSetter> getFields(ReviewDb db) throws SQLException { JdbcSchema schema = (JdbcSchema) db; Connection connection = schema.getConnection(); Set<String> columns = schema.getDialect().listColumns(connection, TABLE); return ACCOUNT_FIELDS_MAP .entrySet() .stream() .filter(e -> columns.contains(e.getKey())) <|startfocus|> .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); <|endfocus|> } private void updateAccountInNoteDb(Repository allUsersRepo, Account account) throws IOException, ConfigInvalidException { MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo); PersonIdent ident = serverIdent.get(); md.getCommitBuilder().setAuthor(ident); md.getCommitBuilder().setCommitter(ident); AccountConfig accountConfig = new AccountConfig(null, account.getId()); accountConfig.load(allUsersRepo); accountConfig.setAccount(account); accountConfig.commit(md); } private interface AccountSetter {
<|startcomment|> readNoteData? <|endcomment|>  * exists */ private static ExternalId remove( RevWalk rw, NoteMap noteMap, ExternalId.Key extIdKey, Account.Id expectedAccountId) throws IOException, ConfigInvalidException { ObjectId noteId = extIdKey.sha1(); if (!noteMap.contains(noteId)) { return null; } <|startfocus|> ObjectId noteData = noteMap.get(noteId); byte[] raw = rw.getObjectReader().open(noteData, OBJ_BLOB).getCachedBytes(MAX_NOTE_SZ); ExternalId extId = ExternalId.parse(noteId.name(), raw, noteData); <|endfocus|> if (expectedAccountId != null) { checkState( expectedAccountId.equals(extId.accountId()), "external id %s should be removed for account %s," + " but external id belongs to account %s", extIdKey.get(), expectedAccountId.get(), extId.accountId().get()); } noteMap.remove(noteId); return extId; } private void checkExternalIdsDontExist(Collection<ExternalId> extIds) throws OrmDuplicateKeyException, IOException {
<|startcomment|> R <|endcomment|>  */ public Set<Account> listAccounts(AccountGroup.UUID groupUUID) throws IOException { if (SystemGroupBackend.PROJECT_OWNERS.equals(groupUUID)) { throw new IllegalStateException("listAccounts called with PROJECT_OWNERS argument"); } try { return listAccounts(groupUUID, null, new HashSet<AccountGroup.UUID>()); } catch (NoSuchProjectException e) { throw new IllegalStateException(e); } } /** <|startfocus|> * recursively enumerate the members of the given group. The project should be specified so the <|endfocus|> * PROJECT_OWNERS magical group can be expanded. */ public Set<Account> listAccounts(AccountGroup.UUID groupUUID, Project.NameKey project) throws NoSuchProjectException, IOException { return listAccounts(groupUUID, project, new HashSet<AccountGroup.UUID>()); } private Set<Account> listAccounts( final AccountGroup.UUID groupUUID, @Nullable final Project.NameKey project, final Set<AccountGroup.UUID> seen) throws NoSuchProjectException, IOException { if (SystemGroupBackend.PROJECT_OWNERS.equals(groupUUID)) { return getProjectOwners(project, seen); }
<|startcomment|> Same as above: "Executing action {} on issue {}", actionName, "issueKey <|endcomment|>  } return false; } catch (RedmineException e) { log.error(e.getMessage(), e); throw new IOException(e); } } public void doPerformAction(final String issueKey, final String actionName) throws IOException, RedmineException { Integer statusId = getStatusId(actionName); if (statusId != null) { <|startfocus|> log.debug("Executing action " + actionName + " on issue " + issueKey); <|endfocus|> Issue issue = IssueFactory.create(convertIssueId(issueKey)); issue.setStatusId(statusId); mgr.getIssueManager().update(issue); } else { log.error("Action " + actionName + " not found within available actions"); throw new RedmineException("Action " + actionName + " not executable on issue " + issueKey); } } public String healthCheckAccess() throws IOException { try { User user = mgr.getUserManager().getCurrentUser(); final String result = "{\"status\"=\"ok\",\"username\"=\"" + user.getLogin() + "\"}";
<|startcomment|> For this one I would probably allow the caller to pass a Map and then call copyOf on the next line. <|endcomment|> <|startfocus|> public Config save(ImmutableMap<ProjectWatchKey, Set<NotifyType>> projectWatches) { this.projectWatches = projectWatches; <|endfocus|> for (String projectName : cfg.getSubsections(PROJECT)) { cfg.unsetSection(PROJECT, projectName); } ListMultimap<String, String> notifyValuesByProject = MultimapBuilder.hashKeys().arrayListValues().build(); for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : projectWatches.entrySet()) { NotifyValue notifyValue = NotifyValue.create(e.getKey().filter(), e.getValue()); notifyValuesByProject.put(e.getKey().project().get(), notifyValue.toString()); } for (Map.Entry<String, Collection<String>> e : notifyValuesByProject.asMap().entrySet()) { cfg.setStringList(PROJECT, e.getKey(), KEY_NOTIFY, new ArrayList<>(e.getValue())); } return cfg;
<|startcomment|> canForcePerform <|endcomment|>  public void unblockInLocalForceEditTopicName_Fails() { block(parent, EDIT_TOPIC_NAME, ANONYMOUS_USERS, "refs/heads/*"); allow(local, EDIT_TOPIC_NAME, DEVS, "refs/heads/*").setForce(true); ProjectControl u = user(local, REGISTERED_USERS); <|startfocus|> assertThat(u.controlForRef("refs/heads/master").canPerform(Permission.EDIT_TOPIC_NAME)) <|endfocus|> .named("u can't edit topic name") .isFalse();
<|startcomment|> I would flip this if/then statement around: "If the preference is omitted in the config file, then the default value for the preference is used." The way you have it here, it is ambiguous what happens when the configured default value changes. <|endcomment|>  * * <p>The config file has separate sections for general, diff and edit preferences: * * <pre> * [general] * showSiteHeader = false * [diff] * hideTopMenu = true * [edit] * lineLength = 80 * </pre> * * <p>The parameter names match the names that are used in the preferences REST API. * <|startfocus|> * <p>If the value for a preference is the same as the default value for this preference, it is * omitted in the config file. <|endfocus|> * * <p>Defaults for preferences that apply for all accounts can be configured in the {@code * refs/users/default} branch in the {@code All-Users} repository. The config for the default * preferences must be provided to this class so that it can read default values from it. * * <p>The preferences are lazily parsed. */ public class PreferencesConfig { private static final Logger log = LoggerFactory.getLogger(PreferencesConfig.class); 
<|startcomment|> nit: normally we don't import Factory classes, but rather user PermissionCollection.Factory. It's because we have so many Factory classes and if you just see "Factory" as type you don't know which one it is. <|endcomment|> import com.google.gerrit.server.account.CapabilityCollection; import com.google.gerrit.server.account.GroupMembership; import com.google.gerrit.server.account.ListGroupMembership; import com.google.gerrit.server.config.AllProjectsName; import com.google.gerrit.server.config.AllProjectsNameProvider; import com.google.gerrit.server.config.AllUsersName; import com.google.gerrit.server.config.AllUsersNameProvider; import com.google.gerrit.server.config.SitePaths; import com.google.gerrit.server.git.ProjectConfig; import com.google.gerrit.server.index.SingleVersionModule.SingleVersionListener; <|startfocus|> import com.google.gerrit.server.permissions.PermissionCollection.Factory; <|endfocus|> import com.google.gerrit.server.project.ProjectCache; import com.google.gerrit.server.project.ProjectState; import com.google.gerrit.server.project.RefPattern; import com.google.gerrit.server.project.testing.Util; import com.google.gerrit.server.rules.PrologEnvironment; import com.google.gerrit.server.rules.RulesCache; import com.google.gerrit.server.schema.SchemaCreator; import com.google.gerrit.server.util.RequestContext; import com.google.gerrit.server.util.ThreadLocalRequestContext; import com.google.gerrit.testing.InMemoryDatabase; import com.google.gerrit.testing.InMemoryModule; import com.google.gerrit.testing.InMemoryRepositoryManager; import com.google.inject.Guice;
<|startcomment|> needs <|endcomment|>  public abstract String toString(); @Override public boolean evaluatesTrivially() { <|startfocus|> // PermissionBackendCondition need to contact PermissionBackend so trivial evaluation is not <|endfocus|> // possible. return false;
<|startcomment|> The predicate function can be replaced with this one liner lambda expression below: Collectors.groupingBy((in) -> {return in.owner.name.equals(user.getUserName().get());}) <|endcomment|>  LfsVerifyLocksResponse verifyLocks(Project.NameKey project, final CurrentUser user) { log.debug("Verify list of locks for {} project and user {}", project, user); LfsProjectLocks locks = projectLocks.getUnchecked(project); Function<LfsLock, Boolean> isOurs = new Function<LfsLock, Boolean>() { @Override public Boolean apply(LfsLock input) { return input.owner.name.equals(user.getUserName().get()); } }; Map<Boolean, List<LfsLock>> groupByOurs = <|startfocus|> locks.getLocks().stream().collect(Collectors.groupingBy(isOurs)); <|endfocus|> return new LfsVerifyLocksResponse(groupByOurs.get(true), groupByOurs.get(false), null);
<|startcomment|> Maybe adding this missing license header should be done in a separate commit and you could add all the missing ones, not only this one. <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. <|startfocus|> package com.googlesource.gerrit.plugins.its.jira.restapi; <|endfocus|> import com.google.inject.Inject; public class JiraRestApiProvider { private JiraRestApi.Factory jiraRestApiFactory; @Inject public JiraRestApiProvider(JiraRestApi.Factory jiraRestApiFactory) { this.jiraRestApiFactory = jiraRestApiFactory; } @SuppressWarnings("unchecked") public <T> JiraRestApi<T> get(Class<T> classOfT, String classPrefix) { return (JiraRestApi<T>) jiraRestApiFactory.create(classOfT, classPrefix); } public JiraRestApi<JiraIssue> getIssue() { return get(JiraIssue.class, "/issue");
<|startcomment|> unrelated change? I'm fine with this change but would prefer if it's in a separate commit, with its own commit message. <|endcomment|>  public Builder copyFrom(GitilesView other) { if (type == Type.DOC && other.type == Type.ROOTED_DOC) { type = Type.ROOTED_DOC; } hostName = other.hostName; servletPath = other.servletPath; switch (type) { case HOST_INDEX: repositoryPrefix = other.repositoryPrefix; break; case LOG: case DIFF: oldRevision = other.oldRevision; <|startfocus|> // $FALL-THROUGH$ <|endfocus|> case PATH: case DOC: case ROOTED_DOC: case ARCHIVE: case BLAME: case SHOW: path = other.path; // $FALL-THROUGH$ case REVISION: revision = other.revision; // $FALL-THROUGH$ case DESCRIBE: case REFS: case REPOSITORY_INDEX: repositoryName = other.repositoryName; // $FALL-THROUGH$ default: break; } if (other.type == type) { // Only copy params for matching type. params.putAll(other.params); if (type == Type.ARCHIVE) { extension = other.extension; } } return this;
<|startcomment|> Delete these lines if they are not needed <|endcomment|>  allow(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*"); block(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*"); block(parent, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*"); ProjectControl u = user(local, DEVS); PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review"); <|startfocus|> //assertCanVote(-1, range); //assertCanVote(1, range); <|endfocus|> assertCannotVote(-2, range); assertCannotVote(2, range);
<|startcomment|> See LfsAuthToken - it produces time in UTC <|endcomment|> <|startfocus|> public static LfsDateTime instance() { return new LfsDateTime(ZoneOffset.systemDefault()); <|endfocus|>
<|startcomment|> Use curly braces as in lines 178-180? <|endcomment|>  ListeningExecutorService getBatchIndexExecutor( @GerritServerConfig Config config, WorkQueue workQueue) { if (batchExecutor != null) { return batchExecutor; } int batchThreads = this.threads; <|startfocus|> if (batchThreads <= 0) batchThreads = config.getInt("index", null, "batchThreads", 0); <|endfocus|> if (batchThreads <= 0) { batchThreads = Runtime.getRuntime().availableProcessors(); } return MoreExecutors.listeningDecorator(workQueue.createQueue(batchThreads, "Index-Batch"));
<|startcomment|> This is no longer used. <|endcomment|> import static com.ericsson.gerrit.plugins.highavailability.Configuration.URL_KEY; import static com.ericsson.gerrit.plugins.highavailability.Configuration.USER_KEY; import static com.ericsson.gerrit.plugins.highavailability.Configuration.WEBSESSION_SECTION; import static com.google.common.truth.Truth.assertThat; import static java.util.concurrent.TimeUnit.SECONDS; import static org.junit.Assert.assertEquals; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import com.google.gerrit.server.config.PluginConfigFactory; import com.google.gerrit.server.config.SitePaths; <|startfocus|> import com.google.inject.ProvisionException; <|endfocus|> import java.io.IOException; import java.nio.file.Path; import java.nio.file.Paths; import org.eclipse.jgit.lib.Config; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.junit.MockitoJUnitRunner; @RunWith(MockitoJUnitRunner.class) public class ConfigurationTest { private static final String PASS = "fakePass"; private static final String USER = "fakeUser"; private static final String URL = "fakeUrl"; private static final String EMPTY = ""; private static final int TIMEOUT = 5000;
<|startcomment|> I think we can safely drop this case and not send a notification email. It really seems like a case that only applies to spammers (no Gerrit account exists for the specified user) <|endcomment|>  warnInboundEmailRejected( message, String.format( "Address %s could not be matched to a unique account. It was matched to %s. Will delete message.", metadata.author, accountIds)); return; } Account.Id accountId = accountIds.iterator().next(); Optional<AccountState> accountState = accountCache.get(accountId); if (!accountState.isPresent()) { log.warn(String.format("Mail: Account %s doesn't exist. Will delete message.", accountId)); <|startfocus|> warnInboundEmailRejected( message, String.format("Mail: Account %s doesn't exist. Will delete message.", accountId)); <|endfocus|> return; } if (!accountState.get().getAccount().isActive()) { log.warn(String.format("Mail: Account %s is inactive. Will delete message.", accountId)); warnInboundEmailRejected( message, String.format("Mail: Account %s is inactive. Will delete message.", accountId)); return; } persistComments(buf, message, metadata, accountId); } 
<|startcomment|> I have even a better idea, why we don't just say: !IndexCollection.class.isAssignableFrom(type) instead, and let the compiler to do the check? <|endcomment|>  private boolean shouldCopy(Key<?> key) { if (copyConfigKeys.contains(key)) { return false; } Class<?> type = key.getTypeLiteral().getRawType(); if (LifecycleListener.class.isAssignableFrom(type) // This is needed for secondary index to work from plugin listeners <|startfocus|> && !is("com.google.gerrit.index.IndexCollection", type)) { <|endfocus|> return false; } if (StartPluginListener.class.isAssignableFrom(type)) { return false; } if (StopPluginListener.class.isAssignableFrom(type)) { return false; } if (MetricMaker.class.isAssignableFrom(type)) { return false; } if (type.getName().startsWith("com.google.inject.")) { return false; } if (is("org.apache.sshd.server.Command", type)) { return false; } if (is("javax.servlet.Filter", type)) { return false; } if (is("javax.servlet.ServletContext", type)) { return false; } if (is("javax.servlet.ServletRequest", type)) {
<|startcomment|> Copyright for new files should be AOSP. (I know it's Ericsson on some of the files that were brought in from the separate plugins, but since then newly added files are AOSP). <|endcomment|> <|startfocus|> Copyright (C) 2018 GerritForge Ltd <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.ericsson.gerrit.plugins.highavailability; import com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexTs; import com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexTs.IndexName; import com.google.gerrit.reviewdb.client.Account; import com.google.gerrit.reviewdb.server.ReviewDb; import com.google.gerrit.server.index.account.AccountIndexer; import com.google.gerrit.server.util.OneOffRequestContext; import com.google.gwtorm.server.OrmException; import com.google.gwtorm.server.ResultSet; import com.google.inject.Inject; import java.io.IOException;
<|startcomment|> 2018. <|endcomment|> <|startfocus|> Copyright (C) 2013 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.its.base.workflow; import static com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.ACTION_KEY; import static com.googlesource.gerrit.plugins.its.base.workflow.RulesConfigReader.RULE_SECTION; import static org.easymock.EasyMock.expect; import static org.easymock.EasyMock.isA; import com.google.common.collect.FluentIterable; import com.google.common.collect.ImmutableList; import com.google.gerrit.extensions.config.FactoryModule; import com.google.gerrit.reviewdb.client.Project;
<|startcomment|> Why would someone have to specify wildcards on the front to presumably overcome auto-anchoring, and then anchor the back? <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.uploadvalidator; import static com.google.common.truth.Truth.assertThat; import static com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG; import org.junit.Test; public class EmailWhitelistTest { private static final String[] emailWhitelist = { <|startfocus|> ".*@example.com$", "testing.com", "tester@testing.com", ".*google.com", "tester@gerrit.*" <|endfocus|> }; @Test public void testEmailValid() throws Exception { assertThat(EmailWhitelistValidator.performValidation("tester@example.com", emailWhitelist)) .isTrue(); assertThat(EmailWhitelistValidator.performValidation("tester@testing.com", emailWhitelist)) .isTrue(); assertThat(EmailWhitelistValidator.performValidation("tester@google.com", emailWhitelist)) .isTrue(); assertThat(EmailWhitelistValidator.performValidation("tester@gerrit.net", emailWhitelist)) .isTrue(); } @Test public void testEmailInvalid() throws Exception { assertThat(EmailWhitelistValidator.performValidation("test@android.com", emailWhitelist)) .isFalse();
<|startcomment|> To be inlined <|endcomment|>  jiraPassword = config.getString(pluginName, null, GERRIT_CONFIG_PASSWORD); if (jiraUrl == null || jiraUsername == null || jiraPassword == null) { throw new RuntimeException(format(ERROR_MSG, pluginName)); } } /** * The Jira url to connect to. * * @return the jira url * @throws MalformedURLException */ <|startfocus|> public URL getJiraUrl() throws MalformedURLException { URL serverUrl = new URL(CharMatcher.is('/').trimFrom(jiraUrl) + "/"); return serverUrl; <|endfocus|> } /** * The username to connect to a Jira server. * * @return the username */ public String getUsername() { return jiraUsername; } /** * The password to connect to a Jira server. * * @return the password */ public String getPassword() { return jiraPassword; } } 
<|startcomment|> @Edwin: Is this OK to do? It seems sane to me for the result of the submittability decision as the behavior is preserved (one OK means you can submit) but I am slightly worried that we miss some side cases (e.g. showing additional conditions on the change screen that were not met, but are also optional). <|endcomment|>  } else if ("may".equals(status.name())) { lbl.status = SubmitRecord.Label.Status.MAY; } else if ("impossible".equals(status.name())) { lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE; } else { return invalidResult(submitRule, submitRecord); } } catch (UserTermExpected e) { return invalidResult(submitRule, submitRecord, e.getMessage()); } } if (rec.status == SubmitRecord.Status.OK) { <|startfocus|> return Collections.singletonList(rec); <|endfocus|> } } Collections.reverse(out); return out;
<|startcomment|> Consistency of rules literals <|endcomment|>  Capture<Config> capturedConfig = createCapture(); expect(rulesConfigReader.getRulesFromConfig(and(capture(capturedConfig), isA(Config.class)))) .andReturn(ImmutableList.of()) .once(); replayMocks(); createRuleBase(); assertInConfig(rules, capturedConfig); } public void testGlobalRuleBaseFilesAreLoaded() throws IOException { injectRuleBase("[rule \"rule2\"]\n\taction = action2", RuleBaseKind.GLOBAL); injectRuleBase("[rule \"rule3\"]\n\taction = action3", RuleBaseKind.ITS); <|startfocus|> Property property1 = createMock(Property.class); expect(property1.getKey()).andReturn(PROJECT_KEY); expect(property1.getValue()).andReturn(TEST_PROJECT); Collection<Property> properties = ImmutableList.of(property1); <|endfocus|> Rule rule2 = createMock(Rule.class); ActionRequest actionRequest2 = createMock(ActionRequest.class); List<ActionRequest> rule2Match = ImmutableList.of(actionRequest2); expect(rule2.actionRequestsFor(properties)).andReturn(rule2Match); Rule rule3 = createMock(Rule.class); ActionRequest actionRequest3 = createMock(ActionRequest.class); 
<|startcomment|> The default should be 'true' here. We only want to refrain from logging when users call the REST endpoint. <|endcomment|>  /** * Stable identifier for options passed to a particular submit rule evaluator. * * <p>Used to test whether it is ok to reuse a cached list of submit records. Does not include a * change or patch set ID; callers are responsible for checking those on their own. */ @AutoValue public abstract class SubmitRuleOptions { public static final SubmitRuleOptions DEFAULT_OPTIONS = new AutoValue_SubmitRuleOptions.Builder() .allowClosed(false) .skipFilters(false) <|startfocus|> .logErrors(false) <|endfocus|> .rule(null) .build(); public static Builder builder() { return DEFAULT_OPTIONS.toBuilder(); } public abstract boolean allowClosed(); public abstract boolean skipFilters(); public abstract boolean logErrors(); @Nullable public abstract String rule(); public abstract Builder toBuilder(); @AutoValue.Builder public abstract static class Builder { public abstract SubmitRuleOptions.Builder allowClosed(boolean allowClosed); public abstract SubmitRuleOptions.Builder skipFilters(boolean skipFilters); public abstract SubmitRuleOptions.Builder rule(@Nullable String rule); 
<|startcomment|> typo: pre-submit <|endcomment|> import com.google.gerrit.reviewdb.client.PatchSetApproval; import com.google.gerrit.server.project.ProjectCache; import com.google.gerrit.server.project.ProjectState; import com.google.gerrit.server.project.SubmitRuleOptions; import com.google.gerrit.server.query.change.ChangeData; import com.google.gwtorm.server.OrmException; import com.google.inject.Inject; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; /** <|startfocus|> * Java implementation of Gerrit's default pre-submti rules behavior: check if the labels have the <|endfocus|> * correct values, according to the {@link LabelFunction} they are attached to. * * <p>As this behavior is also implemented by the Prolog rules system, we skip it if at least one * project in the hierarchy has a {@code rules.pl} file. */ public final class DefaultSubmitRule implements SubmitRule { public static class Module extends FactoryModule { @Override public void configure() { bind(SubmitRule.class) .annotatedWith(Exports.named("DefaultRules")) .to(DefaultSubmitRule.class); }
<|startcomment|> Does <|endcomment|>  handler = new ForwardedIndexChangeHandler(indexerMock, schemaFactoryMock); } @Test public void changeIsIndexed() throws Exception { setupChangeAccessRelatedMocks(CHANGE_EXISTS); handler.index(id, Operation.INDEX); verify(indexerMock, times(1)).index(dbMock, change); } @Test public void changeIsDeletedFromIndex() throws Exception { handler.index(id, Operation.DELETE); verify(indexerMock, times(1)).delete(id); } @Test <|startfocus|> public void changeToIndexDoNotExist() throws Exception { <|endfocus|> setupChangeAccessRelatedMocks(CHANGE_DOES_NOT_EXIST); handler.index(id, Operation.INDEX); verify(indexerMock, times(1)).delete(id); } @Test public void schemaThrowsExceptionWhenLookingUpForChange() throws Exception { setupChangeAccessRelatedMocks(CHANGE_EXISTS, THROW_ORM_EXCEPTION); exception.expect(OrmException.class); handler.index(id, Operation.INDEX); } @Test public void indexerThrowsNoSuchChangeExceptionTryingToPostChange() throws Exception { doThrow(new NoSuchChangeException(id)).when(schemaFactoryMock).open(); handler.index(id, Operation.INDEX); verify(indexerMock, times(1)).delete(id); } @Test
<|startcomment|> nit: we prefer a static import of toList() <|endcomment|>  private static List<PatchSetApproval> getApprovalsForLabel( List<PatchSetApproval> approvals, LabelType t) { return approvals .stream() .filter(input -> input.getLabel().equals(t.getLabelId().get())) <|startfocus|> .collect(Collectors.toList()); <|endfocus|>
<|startcomment|> please inline this instead of having it in a method. <|endcomment|>  throws PermissionBackendException, ResourceConflictException, AuthException, IOException { checkPermission(user, resource, ProjectPermission.ACCESS); checkPermission(user, resource, ProjectPermission.WRITE_CONFIG); try (MetaDataUpdate md = metaDataUpdateFactory.create(resource.getNameKey(), user.get().asIdentifiedUser())) { configTranslator.applyTo(inConfig, resource.getProjectState()); resource.getProjectState().getConfig().commit(md); projectCache.evict(resource.getNameKey()); } return configTranslator.convertFrom(resource.getProjectState()); } <|startfocus|> private void checkPermission( Provider<CurrentUser> user, ProjectResource resource, ProjectPermission permission) throws PermissionBackendException, AuthException { permissionBackend.user(user).project(resource.getNameKey()).check(permission); } <|endfocus|> } 
<|startcomment|> Inline with L127, avoiding the extra variable name used only once <|endcomment|>  private boolean isJiraConnectSuccessful() { ui.message("Checking Jira connectivity ... "); try { <|startfocus|> Class<JiraServerInfo> classPrefix = JiraServerInfo.class; new JiraRestApi<>(jiraUrl, jiraUsername, jiraPassword, classPrefix, "/serverInfo/").ping(); <|endfocus|> ui.message("[OK]\n"); return true; } catch (IOException e) { ui.message("*FAILED* (%s)\n", e.toString()); return false; }
<|startcomment|> ExternalId extId = optionalExtId.orElseThrow(() -> new ResourceNotFoundException()); <|endcomment|>  String newPassword; if (input.generate) { newPassword = generate(); } else if (input.httpPassword == null) { newPassword = null; } else { // Only administrators can explicitly set the password. permissionBackend.currentUser().check(GlobalPermission.ADMINISTRATE_SERVER); newPassword = input.httpPassword; } return apply(rsrc.getUser(), newPassword); } // Used by the admin console plugin // TODO(dpursehouse): Replace comment with @UsedAt public Response<String> apply(IdentifiedUser user, String newPassword) <|startfocus|> throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, <|endfocus|> ConfigInvalidException { String userName = user.getUserName().orElseThrow(() -> new ResourceConflictException("username must be set")); Optional<ExternalId> optionalExtId = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, userName)); ExternalId extId = optionalExtId.orElseThrow(ResourceNotFoundException::new); accountsUpdateProvider .get() .update( "Set HTTP Password via API", extId.accountId(), u -> u.updateExternalId( ExternalId.createWithPassword(
<|startcomment|> this can be removed after applying Patrick' comment <|endcomment|> import java.nio.file.Path; import java.sql.SQLException; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.List; import java.util.Map.Entry; import java.util.concurrent.ScheduledFuture; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; @Singleton class SQLStore implements EventStore, LifecycleListener { private static final Logger log = LoggerFactory.getLogger(SQLStore.class); private static final String H2_DB_SUFFIX = ".h2.db"; <|startfocus|> private final Provider<CurrentUser> userProvider; <|endfocus|> private SQLClient eventsDb; private SQLClient localEventsDb; private final int maxAge; private final int maxTries; private final int waitTime; private final int connectTime; private boolean online = true; private boolean copyLocal; private final ScheduledExecutorService pool; private final PermissionBackend permissionBackend; private ScheduledFuture<?> checkConnTask; private Path localPath; @Inject SQLStore(Provider<CurrentUser> userProvider, EventsLogConfig cfg, @EventsDb SQLClient eventsDb, @LocalEventsDb SQLClient localEventsDb, @EventPool ScheduledExecutorService pool,
<|startcomment|> redundant as you already imported this statically <|endcomment|>  private static String refPermissionName(RefPermission refPermission) { // Within this class, it's programmer error to call this method on a // RefPermission that isn't associated with a permission name. return DefaultPermissionMappings.refPermissionName(refPermission) <|startfocus|> .orElseThrow(() -> new IllegalStateException()); <|endfocus|>
<|startcomment|> Declare one variable per line <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.config; import java.util.Objects; public class ConfigKey { <|startfocus|> public final String section, subsection, name; <|endfocus|> public ConfigKey(String section, String subsection, String name) { this.section = section; this.subsection = subsection; this.name = name; } public ConfigKey(String section, String name) { this.section = section; this.subsection = null; this.name = name; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode());
<|startcomment|> We have to remember to change this if I4219b9dcf is merged before this change. <|endcomment|>  KeyPair keyPair = sshKeyPairs.get(username); if (keyPair == null) { keyPair = genSshKey(); authorizedKeys.addKey( account.accountId(), publicKey(keyPair, account.preferredEmail().orElse(null))); sshKeyCache.evict(username); sshKeyPairs.put(username, keyPair); } return Optional.of(keyPair); } public static KeyPair genSshKey() throws JSchException { JSch jsch = new JSch(); <|startfocus|> return KeyPair.genKeyPair(jsch, KeyPair.RSA); <|endfocus|> } public static String publicKey(KeyPair sshKey, @Nullable String comment) throws UnsupportedEncodingException { ByteArrayOutputStream out = new ByteArrayOutputStream(); sshKey.writePublicKey(out, comment); return out.toString(US_ASCII.name()).trim(); } public static byte[] privateKey(KeyPair keyPair) { ByteArrayOutputStream out = new ByteArrayOutputStream(); keyPair.writePrivateKey(out); return out.toByteArray(); } } 
<|startcomment|> ResourceConflictException <|endcomment|>  .to("refs/for/foo"); String t2 = project.get() + "~foo~" + r2.getChangeId(); gApi.changes().id(t2).abandon(); CherryPickInput in = new CherryPickInput(); in.destination = "foo"; in.message = r1.getCommit().getFullMessage(); try { gApi.changes().id(t1).current().cherryPick(in); <|startfocus|> fail("did not get ResourceNotFoundException"); <|endfocus|> } catch (ResourceConflictException e) { assertThat(e.getMessage()) .isEqualTo( "Cannot create new patch set of change " + info(t2)._number + " because it is abandoned"); } gApi.changes().id(t2).restore(); gApi.changes().id(t1).current().cherryPick(in); assertThat(get(t2, ALL_REVISIONS).revisions).hasSize(2); assertThat(gApi.changes().id(t2).current().file(FILE_NAME).content().asString()).isEqualTo("a"); } @Test public void cherryPickMergeRelativeToDefaultParent() throws Exception {
<|startcomment|> Nit: enum names are ALL_CAPS. <|endcomment|> // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.cache; import static java.lang.annotation.ElementType.TYPE; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.Target; @Retention(RUNTIME) @Target(TYPE) @Inherited public @interface CacheImpl { enum Type { <|startfocus|> Memory, Persistent <|endfocus|> } Type type(); } 
<|startcomment|> log.warn("Cannot invalidate cache {}", name, e); <|endcomment|>  void invalidateAll() { PgSqlHandle c = null; try { c = acquire(); try (Statement s = c.conn.createStatement()) { s.executeUpdate(qInvalidateAll); } bloomFilter = newBloomFilter(); } catch (SQLException e) { <|startfocus|> log.warn("Cannot invalidate cache " + name, e); <|endfocus|> c = close(c); } finally { release(c); }
<|startcomment|> Very unusual hierarchy. I would expect this to follow the same structure of the caches in Gerrit: - Cache (interface) - CacheImpl (implementation) - CacheRefresherListener (implement listener and refresh cache) Here you are mixing up all the three of them in a single class, no SRP <|endcomment|> import com.google.inject.Inject; import com.google.inject.Module; import com.google.inject.Singleton; import com.google.inject.TypeLiteral; import com.google.inject.name.Named; import com.googlesource.gerrit.plugins.its.base.GlobalRulesFileName; import com.googlesource.gerrit.plugins.its.base.PluginRulesFileName; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutionException; import org.eclipse.jgit.lib.Config; import org.slf4j.Logger; import org.slf4j.LoggerFactory; <|startfocus|> @Singleton public class ItsRulesProjectCache implements GitReferenceUpdatedListener { private static final Logger log = LoggerFactory.getLogger(ItsRulesProjectCache.class); private static final String CACHE_NAME = "itsRulesProjectCache"; <|endfocus|> private final LoadingCache<Project.NameKey, List<Rule>> cache; @Inject ItsRulesProjectCache(@Named(CACHE_NAME) LoadingCache<Project.NameKey, List<Rule>> cache) { this.cache = cache; } List<Rule> get(Project.NameKey projectName) { try { return cache.get(projectName); } catch (ExecutionException e) {
<|startcomment|> Optional: Could use prepare statement with bind variable. <|endcomment|>  return ret; } public void delete(Project project) throws OrmException { // TODO(davido): Why not to use 1.7 features? // http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.20.3.2 Connection conn = ((JdbcSchema) db).getConnection(); try { conn.setAutoCommit(false); try { <|startfocus|> java.sql.ResultSet resultSet = conn.createStatement() .executeQuery( "select change_id from changes where dest_project_name ='" + project.getName() + "';"); <|endfocus|> List<Change.Id> changeIds = new ArrayList<>(); while (resultSet.next()) { changeIds.add(new Change.Id(resultSet.getInt(1))); } atomicDelete(project, changeIds); conn.commit(); } finally { conn.setAutoCommit(true); } } catch (SQLException e) { try { conn.rollback(); } catch (SQLException ex) { throw new OrmException(ex); } throw new OrmException(e); } } 
<|startcomment|> do we need to adjust the URL here? <|endcomment|> import org.mockito.junit.MockitoJUnitRunner; @RunWith(MockitoJUnitRunner.class) @SuppressWarnings({"unchecked", "rawtypes"}) public class JiraRestApiTest { private static final String ISSUE_CLASS_PREFIX = "/issue/"; private static final String USERNAME = "user"; private static final String PASSWORD = "pass"; private URL url; private JiraRestApi restApi; @Test public void testJiraServerInfoForNonRootJiraUrl() throws Exception { <|startfocus|> url = adjustUrlPath(new URL("http://jira.mycompany.com/myroot/")); <|endfocus|> restApi = new JiraRestApi(url, USERNAME, PASSWORD, JiraIssue.class, ISSUE_CLASS_PREFIX); String jiraApiUrl = restApi.getBaseUrl().toString(); assertThat(jiraApiUrl).startsWith(url.toString()); } @Test public void testJiraServerInfoForNonRootJiraUrlNotEndingWithSlash() throws Exception { url = adjustUrlPath(new URL("http://jira.mycompany.com/myroot")); restApi = new JiraRestApi(url, USERNAME, PASSWORD, JiraIssue.class, ISSUE_CLASS_PREFIX); String jiraApiUrl = restApi.getBaseUrl().toString();
<|startcomment|> Should be "log". See I4e6f8a5b685113bf5c26e6ad3d86954c258dc2ce <|endcomment|> import com.google.gerrit.extensions.annotations.PluginName; import com.google.gerrit.extensions.events.AccountIndexedListener; import com.google.gerrit.extensions.events.ChangeIndexedListener; import com.google.gerrit.extensions.events.GroupIndexedListener; import com.google.gerrit.extensions.events.ProjectIndexedListener; import com.google.inject.Inject; import java.util.Collections; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.Executor; import org.eclipse.jgit.lib.ObjectId; import org.slf4j.Logger; import org.slf4j.LoggerFactory; class IndexEventHandler <|startfocus|> implements ChangeIndexedListener, AccountIndexedListener, GroupIndexedListener, ProjectIndexedListener { <|endfocus|> private static final Logger log = LoggerFactory.getLogger(IndexEventHandler.class); private final Executor executor; private final Forwarder forwarder; private final String pluginName; private final Set<IndexTask> queuedTasks = Collections.newSetFromMap(new ConcurrentHashMap<>()); private final ChangeCheckerImpl.Factory changeChecker; @Inject IndexEventHandler( @IndexExecutor Executor executor, @PluginName String pluginName, Forwarder forwarder, ChangeCheckerImpl.Factory changeChecker) { this.forwarder = forwarder; this.executor = executor;
<|startcomment|> Constant name convention <|endcomment|>  @Singleton public class PasswordEncryption { private static final SecureRandom secureRandom = new SecureRandom(); private static final int keyLength = 128; private static final int iterationCount = 1000; private static final String algorithm = "AES"; private static final String hashAlgorithm = "PBKDF2WithHmacSHA512"; private static final String transformation = "AES/CBC/PKCS5Padding"; private static final String SECTION = "encryption"; private static final String KEY = "passwordKey"; private static final String delimiter = ":"; <|startfocus|> <|endfocus|> private final SecureStore secureStore; @Inject public PasswordEncryption(SecureStore secureStore) { this.secureStore = secureStore; } public String encrypt(String password) { if (Strings.isNullOrEmpty(getKeyFromConfig())) { byte[] saltBytes = newSalt(); SecretKeySpec key; try { key = createSecretKey(password.toCharArray(), saltBytes, iterationCount, keyLength); String keyStr = base64Encode(key.getEncoded()); secureStore.set(SECTION, null, KEY, keyStr); return encrypt(password, key);
<|startcomment|> Are we no longer logging to this separate logger? I don't see how this functionality is being replicated on the Flogger side. <|endcomment|> import java.util.Set; import org.eclipse.jgit.api.GarbageCollectCommand; import org.eclipse.jgit.api.Git; import org.eclipse.jgit.errors.RepositoryNotFoundException; import org.eclipse.jgit.lib.Config; import org.eclipse.jgit.lib.ConfigConstants; import org.eclipse.jgit.lib.NullProgressMonitor; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.lib.TextProgressMonitor; import org.eclipse.jgit.storage.pack.PackConfig; public class GarbageCollection { private static final FluentLogger logger = FluentLogger.forEnclosingClass(); <|startfocus|> public static final String LOG_NAME = "gc_log"; <|endfocus|> private final GitRepositoryManager repoManager; private final GarbageCollectionQueue gcQueue; private final GcConfig gcConfig; private final DynamicSet<GarbageCollectorListener> listeners; public interface Factory { GarbageCollection create(); } @Inject GarbageCollection( GitRepositoryManager repoManager, GarbageCollectionQueue gcQueue, GcConfig config, DynamicSet<GarbageCollectorListener> listeners) { this.repoManager = repoManager; this.gcQueue = gcQueue; this.gcConfig = config; this.listeners = listeners; } public GarbageCollectionResult run(List<Project.NameKey> projectNames) {
<|startcomment|> Is there any reason to keep this method and to not directly use toByteString()? Did you notice that the order of the parameters of both methods is different? <|endcomment|>  b.setStatus(STATUS_CONVERTER.reverse().convert(cols.status())).setHasStatus(true); } b.setIsPrivate(cols.isPrivate()) .setWorkInProgress(cols.workInProgress()) .setReviewStarted(cols.reviewStarted()); if (cols.revertOf() != null) { b.setRevertOf(cols.revertOf().get()).setHasRevertOf(true); } return b.build(); } <|startfocus|> @VisibleForTesting static <T> ByteString encodeToByteString(ProtobufCodec<T> codec, T object) { return toByteString(object, codec); } <|endfocus|> private static ReviewerSetEntryProto toReviewerSetEntry( Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> c) { return ReviewerSetEntryProto.newBuilder() .setState(REVIEWER_STATE_CONVERTER.reverse().convert(c.getRowKey())) .setAccountId(c.getColumnKey().get()) .setTimestamp(c.getValue().getTime()) .build(); } private static ReviewerByEmailSetEntryProto toReviewerByEmailSetEntry( Table.Cell<ReviewerStateInternal, Address, Timestamp> c) { return ReviewerByEmailSetEntryProto.newBuilder()
<|startcomment|> Here and for otherCommit: Maybe call copy() on it so that using this method erroneously outside of tests doesn't additionally introduce strange issues. <|endcomment|>  static ConflictKey createWithoutNormalization( <|startfocus|> ObjectId commit, ObjectId otherCommit, SubmitType submitType, boolean contentMerge) { return new AutoValue_ConflictKey(commit, otherCommit, submitType, contentMerge); <|endfocus|>
<|startcomment|> Here and below: Path#getFileName() only takes the last element in the path. Hence, relativization of the path is wasted effort. <|endcomment|>  .add(site.logs_dir) .add(site.plugins_dir) .add(site.db_dir) .add(site.data_dir) .add(site.mail_dir) .add(site.static_dir) .add(site.index_dir) .add(site.secure_config) .build(); // Safeguard: before running the init command, none of the above files should exist for (Path path : pathsToCheck) { <|startfocus|> assertThat(path.toFile().exists()) .named(site.site_path.relativize(path).getFileName() + " exists") .isFalse(); <|endfocus|> } Init ls = new Init(site.site_path); int exitCode = ls.main(new String[] {"-b"}); assertThat(exitCode).named("Init exit code").isEqualTo(0); for (Path path : pathsToCheck) { assertThat(path.toFile().exists()) .named(site.site_path.relativize(path).getFileName() + " exists") .isTrue(); } } } 
<|startcomment|> Why not replace the PHRASE_PREFIX enum with MATCH_PHRASE_PREFIX, since this method is the only place it's actually used? Same below. <|endcomment|>  private final Object text; private Type type; /** Constructs a new text query. */ MatchQueryBuilder(String name, Object text) { this.name = name; this.text = text; } /** Sets the type of the text query. */ MatchQueryBuilder type(Type type) { this.type = type; return this; } @Override protected void doXContent(XContentBuilder builder) throws IOException { <|startfocus|> switch (type) { case PHRASE_PREFIX: builder.startObject("match_phrase_prefix"); break; case PHRASE: default: builder.startObject("match_phrase"); } builder.field(name, text); builder.endObject(); <|endfocus|> } } 
<|startcomment|> Nit: trailing blank. <|endcomment|>  private void rescheduleIndex(final String id, final Optional<Object> maybeBody, int retryCount) { int retryInterval = configuration.index().retryInterval(); int maxTries = configuration.index().maxTries(); <|startfocus|> if(retryCount >= maxTries) { <|endfocus|> log.error("Change {} could not be indexed after {} retries. *CHANGE INDEX IS STALE*"); return; } log.warn("Retrying for the #{} time to index Change {} after {} msecs", retryCount, id, retryInterval); indexExecutor.schedule(() -> { try { doIndex(id, maybeBody); } catch (Exception e) { log.warn("Change {} could not be indexed", id, e); } }, retryInterval, TimeUnit.MILLISECONDS);
<|startcomment|> projectName? <|endcomment|>  break; } return ret; } private CommitValidationMessage commitValidationFailure(String synopsis, String details) throws CommitValidationException { CommitValidationMessage ret = new CommitValidationMessage(synopsis + "\n" + details, false); if (itsConfig.getItsAssociationPolicy() == ItsAssociationPolicy.MANDATORY) { throw new CommitValidationException(synopsis, Collections.singletonList(ret)); } return ret; } @Override public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException { <|startfocus|> Project.NameKey project = receiveEvent.getProjectNameKey(); ItsConfig.setCurrentProjectName(project); <|endfocus|> if (itsConfig.isEnabled(project, receiveEvent.getRefName())) { return validCommit(project, receiveEvent.commit); } return Collections.emptyList(); } } 
<|startcomment|> modify? <|endcomment|>  } @Override public List<ReviewerFilterSection> apply(ProjectResource rsrc, Input input) throws RestApiException, PermissionBackendException { Project.NameKey projectName = rsrc.getNameKey(); ReviewersConfig.ForProject cfg = config.forProject(projectName); if (cfg == null) { throw new ResourceNotFoundException("Project" + projectName.get() + " not found"); } PermissionBackend.WithUser userPermission = permissionBackend.user(rsrc.getUser()); <|startfocus|> if (!userPermission.project(rsrc.getNameKey()).testOrFalse(ProjectPermission.WRITE_CONFIG) <|endfocus|> && !userPermission.testOrFalse(new PluginPermission(pluginName, MODIFY_REVIEWERS_CONFIG))) { throw new AuthException("not allowed to modify reviewers config"); } try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) { if (input.action == Action.ADD) { validateReviewer(input.reviewer); } try { StringBuilder message = new StringBuilder(pluginName).append(" plugin: "); cfg.load(md); if (input.action == Action.ADD) { message .append("Add reviewer ")
<|startcomment|> Hold on ... you test what you have entered here? Just test: assertTrue(itsConfig.getItsProjectName().isEmpty()) <|endcomment|>  public void testGetItsProjectNull() { String[] branches = {}; setupIsEnabled("true", null, null, branches); ItsConfig itsConfig = createItsConfig(); replayMocks(); <|startfocus|> assertNull(itsConfig.getItsProjectName(new Project.NameKey("testProject")).orElse(null)); <|endfocus|>
<|startcomment|> Are you sure this is background work? By calling invalidate(), we presumably remove the old value contained in the cache. Refresh calls CacheLoader#load (and not reload) if the old value isn't present. Although the implementation of LoadingCache#refresh in LocalCache internally calls a method called loadAsync() at some point, I don't see any code adding asynchronism for the CacheLoader#load case. The Javadoc of LoadingCache#refresh seems to support that assessment. If refresh is a synchronous load call, do we still want to call it here? <|endcomment|>  } private ProjectState strictCheckedGet(Project.NameKey projectName) throws Exception { return byName.get(projectName.get()); } @Override public void evict(Project p) throws IOException { evict(p.getNameKey()); } @Override public void evict(Project.NameKey p) throws IOException { if (p != null) { byName.invalidate(p.get()); <|startfocus|> // Cache is only manually evicted when we know the value changed, so go ahead and kick off // background work to refresh it. byName.refresh(p.get()); <|endfocus|> } indexer.get().index(p); } @Override public void remove(Project p) throws IOException { remove(p.getNameKey()); } @Override public void remove(Project.NameKey name) throws IOException { listLock.lock(); try { list.put( ListKey.ALL, ImmutableSortedSet.copyOf(Sets.difference(list.get(ListKey.ALL), ImmutableSet.of(name)))); } catch (ExecutionException e) { logger.atWarning().withCause(e).log("Cannot list available projects");
<|startcomment|> checkNotNull(deletedBy). We've all done it, but it's still always embarrassing to see something like "removed by: null" in real data :) <|endcomment|> <|startfocus|> public static String createNewChangeMessage(String deletedBy) { <|endfocus|> return "Change message removed by: " + deletedBy;
<|startcomment|> nit: its <|endcomment|>  public static final FieldDef<ProjectData, Iterable<String>> NAME_PART = prefix("name_part").buildRepeatable(p -> SchemaUtil.getNameParts(p.getProject().getName())); public static final FieldDef<ProjectData, Iterable<String>> ANCESTOR_NAME = exact("ancestor_name").buildRepeatable(p -> p.getParentNames()); /** * All values of all refs that were used in the course of indexing this document. This covers <|startfocus|> * {@code refs/meta/config} of the current project and all of it's parents. <|endfocus|> * * <p>Emitted as UTF-8 encoded strings of the form {@code project:ref/name:[hex sha]}. */ public static final FieldDef<ProjectData, Iterable<byte[]>> REF_STATE = storedOnly("ref_state") .buildRepeatable( projectData -> { List<byte[]> result = new ArrayList<>(); result.add(toRefState(projectData.getProject())); projectData.getParents().forEach(p -> result.add(toRefState(p.getProject()))); return result; }); 
<|startcomment|> The only caller is ChangeJson, so I think this should stay as 'test' <|endcomment|>  } /** * Checks if removing the given reviewer is OK. Does not check if removing any approvals the * reviewer might have given is OK. * * @throws AuthException if this user is not allowed to remove this approval. * @throws PermissionBackendException on failure of permission checks. */ public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, Account.Id reviewer) throws PermissionBackendException, AuthException { checkRemoveReviewer(notes, currentUser, reviewer, 0); } <|startfocus|> public void checkRemoveReviewer( <|endfocus|> ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, OrmException, AuthException { if (canRemoveReviewerWithoutPermissionCheck( permissionBackend, cd.change(), currentUser, reviewer, value)) { return; } permissionBackend .user(currentUser) .change(cd) .database(dbProvider) .check(ChangePermission.REMOVE_REVIEWER); } private void checkRemoveReviewer( ChangeNotes notes, CurrentUser currentUser, Account.Id reviewer, int val) throws PermissionBackendException, AuthException { if (canRemoveReviewerWithoutPermissionCheck(
<|startcomment|> Long line? <|endcomment|>  * the user. * @throws ServiceUnavailableException if working in offline mode */ @Override public List<String> queryChangeEvents(String query) throws EventsLogException { if (!online) { throw new ServiceUnavailableException(); } List<SQLEntry> entries = new ArrayList<>(); for (Entry<String, Collection<SQLEntry>> entry : eventsDb.getEvents(query).asMap().entrySet()) { String projectName = entry.getKey(); try { permissionBackend <|startfocus|> .user(userProvider.get()) <|endfocus|> .project(new Project.NameKey(projectName)) .check(ProjectPermission.ACCESS); entries.addAll(entry.getValue()); } catch (AuthException e) { // Ignore } catch (PermissionBackendException e) { log.warn("Cannot check project access permission", e); } } return sortedEventsFromEntries(entries); } private List<String> sortedEventsFromEntries(List<SQLEntry> entries) { Collections.sort(entries); List<String> events = new ArrayList<>(); for (SQLEntry entry : entries) { events.add(entry.getEvent()); } return events;
<|startcomment|> 2018 <|endcomment|> <|startfocus|> Copyright (C) 2014 The Android Open Source Project <|endfocus|> // // Licensed under the Apache License, Version 2.0 (the "License"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.acceptance.rest.project; import static com.google.common.truth.Truth.assertThat; import static com.google.gerrit.acceptance.GitUtil.getChangeId; import static com.google.gerrit.acceptance.GitUtil.pushHead; import com.google.gerrit.acceptance.AbstractDaemonTest; import com.google.gerrit.acceptance.RestResponse; import com.google.gerrit.extensions.common.FileInfo; import com.google.gson.reflect.TypeToken; import java.lang.reflect.Type; import java.util.Map; import org.eclipse.jgit.revwalk.RevCommit;
<|startcomment|> I think 'trace' should be converted to atFiner() <|endcomment|>  if (needFindOwners && !Config.getAlwaysShowButton()) { needFindOwners = false; // Show button only if some owner is found. try (Repository repo = repoManager.openRepository(change.getProject())) { OwnersDb db = Cache.getInstance() .get( projectCache.get(resource.getProject()), accountCache, emails, repo, changeData); <|startfocus|> logger.atInfo().log("getDescription db key = %s", db.key); <|endfocus|> needFindOwners = db.getNumOwners() > 0; } } return new Description() .setLabel("Find Owners") .setTitle("Find owners to add to Reviewers list") .setVisible(needFindOwners); } catch (IOException | OrmException e) { logger.atSevere().withCause(e).log("Exception for %s", Config.getChangeId(changeData)); throw new IllegalStateException(e); }
<|startcomment|> Why use nanos if rounding here to millis and seconds? <|endcomment|>  newLastIndexTs = itemTs.get(); } } } catch (Exception e) { log.error("Unable to reindex {} {}", itemNameString, c, e); errors++; } } long elapsed = System.nanoTime() - startTs; if (count > 0) { log.info( "{} {}s reindexed in {} msec ({}/sec), {} failed", count, itemNameString, <|startfocus|> elapsed / 1000000L, (count * 1000L) / (elapsed / 1000000L), <|endfocus|> errors); } else if (errors > 0) { log.info("{} {}s failed to reindex", errors, itemNameString); } else { log.debug("Scanning finished"); } indexTs.update(itemName, newLastIndexTs.toLocalDateTime()); } } catch (Exception e) { log.error("Unable to scan " + itemNameString + "s", e); } finally { Context.setForwardedEvent(false); } }
<|startcomment|> Use withCause & format string <|endcomment|>  // REJECTED, and the return value is 'false' private boolean validRefOperation(ReceiveCommand cmd) { RefOperationValidators refValidators = refValidatorsFactory.create(getProject(), user, cmd); try { messages.addAll(refValidators.validateForRefOperation()); } catch (RefOperationValidationException e) { messages.addAll(Lists.newArrayList(e.getMessages())); reject(cmd, e.getMessage()); return false; } return true; } <|startfocus|> /** * Validates the commits that a regular push brings in. * * <p>On validation failure, the command is rejected. */ private void validateRegularPushCommits(Branch.NameKey branch, ReceiveCommand cmd) <|endfocus|> throws PermissionBackendException { if (!RefNames.REFS_CONFIG.equals(cmd.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET_PATTERN.matcher(cmd.getRefName()).matches()) && pushOptions.containsKey(PUSH_OPTION_SKIP_VALIDATION)) { if (projectState.is(BooleanProjectConfig.USE_SIGNED_OFF_BY)) {
<|startcomment|> Instead of adding this method, the call to controlForRef should be inlined at the call site as it is for other endpoint implementations. <|endcomment|>  public BranchResource(ProjectControl control, BranchInfo branchInfo) { super(control); this.branchInfo = branchInfo; } public BranchInfo getBranchInfo() { return branchInfo; } public Branch.NameKey getBranchKey() { return new Branch.NameKey(getNameKey(), branchInfo.ref); } @Override public String getRef() { return branchInfo.ref; } <|startfocus|> public RefControl getRefControl() { return getControl().controlForRef(new Branch.NameKey(getNameKey(), branchInfo.ref)); } <|endfocus|> @Override public String getRevision() { return branchInfo.revision; } } 
<|startcomment|> Do we really need to calculate the current time inside the loop? Isn't enough if we calculated once at the start of the method? <|endcomment|>  logger.warn("Error trying to clean the archived git repository: {}", path, e); } } } private List<Path> listOverdueFiles(long duration) { List<Path> files = new ArrayList<>(); File targetDir = config.getArchiveFolder().toFile(); for (File repo : targetDir.listFiles()) { try { FileTime lastModifiedTime = Files.getLastModifiedTime(repo.toPath()); <|startfocus|> FileTime nowTime = FileTime.fromMillis(TimeMachine.now().toEpochMilli()); <|endfocus|> FileTime expires = FileTime.fromMillis(lastModifiedTime.toMillis() + duration); if (nowTime.compareTo(expires) > 0) { files.add(repo.toPath()); } } catch (IOException e) { logger.warn("Error trying to get last modified time for file: {} ", repo.toPath(), e); } } return files; } } 
<|startcomment|> Is there a reason this should be an interface instead of a concrete class? It would allow you add a constructor instead of creating an anonymous implementation on line 184. <|endcomment|> import java.util.SortedSet; import java.util.TreeSet; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.atomic.AtomicReference; /** * A set of members that can be modified as plugins reload. * * <p>DynamicSets are always mapped as singletons in Guice. Sets store Providers internally, and * resolve the provider to an instance on demand. This enables registrations to decide between * singleton and non-singleton members. */ public class DynamicSet<T> implements Iterable<T> { <|startfocus|> public interface Entry<T> { String getPluginName(); <|endfocus|> Provider<T> getProvider(); } /** * Declare a singleton {@code DynamicSet<T>} with a binder. * * <p>Sets must be defined in a Guice module before they can be bound: * * <pre> * DynamicSet.setOf(binder(), Interface.class); * DynamicSet.bind(binder(), Interface.class).to(Impl.class); * </pre> * * @param binder a new binder created in the module.
<|startcomment|> Blank line missing. <|endcomment|> // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.its.jira; import com.google.gerrit.extensions.api.projects.ConfigValue; import com.google.gerrit.server.config.ProjectConfigEntry; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraURL; import java.net.MalformedURLException; /** A {@link ProjectConfigEntry} for the Jira url. */ class JiraUrlProjectConfigEntry extends ProjectConfigEntry { <|startfocus|> public static final String INVALID_URL_MSG = "******* Invalid URL *******"; <|endfocus|> /** * Builds a @{link ProjectConfigEntry}. * * @param displayName the display name */ JiraUrlProjectConfigEntry(String displayName) { super(displayName, ""); } /** * Take the input value and encrypt it to save in the project config. * * @param configValue the original value * @return encrypted text */ @Override public ConfigValue preUpdate(ConfigValue configValue) { if (configValue.value != null && !configValue.value.isEmpty()) { try {
<|startcomment|> Extra blank line. <|endcomment|> import org.mockito.Mock; import org.mockito.junit.MockitoJUnitRunner; import com.google.gerrit.reviewdb.client.Project; @RunWith(MockitoJUnitRunner.class) public class JiraItsServerTest { private static final Project.NameKey PROJECT_NAMEKEY = new Project.NameKey("project"); @Mock private JiraConfig jiraConfig; @Mock private JiraItsFacade itsFacade; @Mock private JiraItsServerCache serverCache; @Mock private JiraItsServerInfo jiraItsServerInfo; @Rule public ExpectedException expectedException = ExpectedException.none(); private JiraItsServer jiraItsServer; <|startfocus|> <|endfocus|> @Test public void testValidServerInfoIsreturnedFromTheCache() throws Exception { when(jiraItsServerInfo.isValid()).thenReturn(true); when(serverCache.get(PROJECT_NAMEKEY.get())).thenReturn(jiraItsServerInfo); jiraItsServer = new JiraItsServer(jiraConfig, itsFacade, serverCache); jiraItsServer.getFacade(PROJECT_NAMEKEY); verify(jiraConfig).addCommentLinksSection(PROJECT_NAMEKEY, jiraItsServerInfo); verify(itsFacade).setJiraServerInstance(jiraItsServerInfo); } @Test public void testGetDefaultServerInfo() throws Exception { when(jiraItsServerInfo.isValid()).thenReturn(false).thenReturn(true);
<|startcomment|> uid, per L90? <|endcomment|>  } JsonElement userJson = JSON.newGson().fromJson(response.getBody(), JsonElement.class); if (log.isDebugEnabled()) { log.debug("User info response: {}", response.getBody()); } if (userJson.isJsonObject()) { JsonObject jsonObject = userJson.getAsJsonObject(); JsonElement id = jsonObject.get("uid"); if (id == null || id.isJsonNull()) { <|startfocus|> throw new IOException(String.format("Response doesn't contain id field")); <|endfocus|> } JsonElement email = jsonObject.get("email"); JsonElement name = jsonObject.get("name"); return new OAuthUserInfo( AV_PROVIDER_PREFIX + id.getAsString(), null, email.getAsString(), name.getAsString(), id.getAsString()); } throw new IOException(String.format("Invalid JSON '%s': not a JSON Object", userJson)); } @Override public OAuthToken getAccessToken(OAuthVerifier rv) { Verifier vi = new Verifier(rv.getValue());
<|startcomment|> It looks like this means changeViewUrl will return "/project/+/#" when hasUrl is false. Is that actually a reasonable thing to output? <|endcomment|>  public String webUrl() { String u = canonicalWebUrlProvider.get(); if (u == null) { u = "/"; } <|startfocus|> return u; <|endfocus|>
<|startcomment|> @Nullable <|endcomment|> <|startfocus|> public PublicKeyStore(Repository repo, SubkeyToMasterKeyCache subkeyCache) { <|endfocus|> this.repo = repo; this.subkeyCache = subkeyCache; toAdd = new HashMap<>(); toRemove = new HashSet<>();
<|startcomment|> I've seen this called "CheckedFunction", so this could be "ExtensionCheckedFunction" or "CheckedExtensionFunction" <|endcomment|>  * * <p>The call* methods execute an extension and deliver a result back to the caller. */ public class PluginContext<T> { private static final FluentLogger logger = FluentLogger.forEnclosingClass(); @FunctionalInterface public interface ExtensionImplConsumer<T> { void run(T t) throws Exception; } @FunctionalInterface public interface ExtensionImplFunction<T, R> { R call(T input); } @FunctionalInterface <|startfocus|> public interface ExtensionImplFunctionAllowingException<T, R, X extends Exception> { <|endfocus|> R call(T input) throws X; } @FunctionalInterface public interface ExtensionConsumer<T extends Extension<?>> { void run(T extension) throws Exception; } @FunctionalInterface public interface ExtensionFunction<T extends Extension<?>, R> { R call(T extension); } @FunctionalInterface public interface ExtensionFunctionAllowingException< T extends Extension<?>, R, X extends Exception> { R call(T extension) throws X; } /** * Opens a new trace context for invoking a plugin extension. *
<|startcomment|> This is now unused and should be removed. <|endcomment|> import com.google.gerrit.server.project.ProjectControl; import com.google.gerrit.sshd.SshScope.Context; import com.google.inject.Inject; import java.io.IOException; import org.apache.sshd.server.Environment; import org.eclipse.jgit.errors.RepositoryNotFoundException; import org.eclipse.jgit.lib.Repository; import org.kohsuke.args4j.Argument; public abstract class AbstractGitCommand extends BaseCommand { @Argument(index = 0, metaVar = "PROJECT.git", required = true, usage = "project name") protected ProjectControl projectControl; <|startfocus|> @Inject private SshScope sshScope; <|endfocus|> @Inject private GitRepositoryManager repoManager; @Inject private SshSession session; @Inject private SshScope.Context context; @Inject private IdentifiedUser user; @Inject private IdentifiedUser.GenericFactory userFactory; protected Repository repo; protected Project project; @Override public void start(final Environment env) { Context ctx = context.subContext(newSession(), context.getCommandLine()); startThreadWithContext( ctx, new ProjectCommandRunnable() { @Override public void executeParseCommand() throws Exception { parseCommandLine(); } @Override
<|startcomment|> It wasn't immediately obvious to me that this means it is configured in AbstractDaemonTest. I was looking at the code below and couldn't see how it gets configured. Maybe make this comment a bit more explicit? <|endcomment|>  gApi.changes().id(change.changeId).current().review(ReviewInput.approve()); gApi.changes().id(change.changeId).current().submit(new SubmitInput()); // Revert is not allowed when CLA is required but not signed setApiUser(user); setUseContributorAgreements(InheritableBoolean.TRUE); exception.expect(AuthException.class); exception.expectMessage("Contributor Agreement"); gApi.changes().id(change.changeId).revert(); } @Test public void revertExcludedProjectChangeWithoutCLA() throws Exception { <|startfocus|> // Contributor agreements configured with excludeProjects = ExcludedProject <|endfocus|> assume().that(isContributorAgreementsEnabled()).isTrue(); // Create a change succeeds when agreement is not required setUseContributorAgreements(InheritableBoolean.FALSE); // Project name includes test method name which contains ExcludedProject ChangeInfo change = gApi.changes().create(newChangeInput()).get(); // Approve and submit it setApiUser(admin); gApi.changes().id(change.changeId).current().review(ReviewInput.approve()); gApi.changes().id(change.changeId).current().submit(new SubmitInput()); 
<|startcomment|> Boolean can be null. Same on line 142. <|endcomment|>  private void onEvent(ChangeEvent event) { ChangeInfo c = event.getChange(); <|startfocus|> if (config.ignoreWip() && c.workInProgress) { <|endfocus|> return; } if (config.ignorePrivate() && c.isPrivate) { return; } Project.NameKey projectName = new Project.NameKey(c.project); List<ReviewerFilterSection> sections = getSections(projectName); if (sections.isEmpty()) { return; } AccountInfo uploader = event.getWho(); int changeNumber = c._number; try { Set<String> reviewers = findReviewers(changeNumber, sections); if (reviewers.isEmpty()) { return; } final Runnable task = byConfigFactory.create( c, resolver.resolve(reviewers, projectName, changeNumber, uploader)); workQueue.getDefaultQueue().submit(task); } catch (QueryParseException e) { log.warn( "Could not add default reviewers for change {} of project {}, filter is invalid: {}", changeNumber, projectName.get(), e.getMessage());
<|startcomment|> Indent? <|endcomment|>  + "commentlink.bugzilla must have either link or html")); } @Test public void readAllProjectsBaseConfigFromSitePaths() throws Exception { ProjectConfig cfg = factory.create(ALL_PROJECTS); cfg.load(db); assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)) .isEqualTo(InheritableBoolean.INHERIT); <|startfocus|> Files.write( sitePaths.etc_dir.resolve(ALL_PROJECTS_CONFIG), ImmutableList.of("[receive]", "requireChangeId = false")); <|endfocus|> cfg.load(db); assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)) .isEqualTo(InheritableBoolean.FALSE); } @Test public void readOtherProjectIgnoresAllProjectsBaseConfig() throws Exception { ProjectConfig cfg = factory.create(new Project.NameKey("test")); cfg.load(db); assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)) .isEqualTo(InheritableBoolean.INHERIT); Files.write( sitePaths.etc_dir.resolve(ALL_PROJECTS_CONFIG), ImmutableList.of("[receive]", "requireChangeId = false")); cfg.load(db);
<|startcomment|> Nit: superfluous blank. <|endcomment|>  private void reindexProjects() throws Exception { if (noReindex) { return; } // Reindex all projects, so that we bootstrap the project index for new installations List<String> reindexArgs = ImmutableList.of( "--site-path", getSitePath().toString(), "--threads", Integer.toString(1), "--index", ProjectSchemaDefinitions.NAME); getConsoleUI().message("Init complete, reindexing projects with:"); <|startfocus|> getConsoleUI().message(" reindex " + reindexArgs.stream().collect(joining(" "))); <|endfocus|> Reindex reindexPgm = new Reindex(); reindexPgm.main(reindexArgs.stream().toArray(String[]::new)); } private static boolean nullOrEmpty(List<?> list) { return list == null || list.isEmpty(); } } 
<|startcomment|> I guess this blank line is what causes the code style check to fail. <|endcomment|> // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.update; <|startfocus|> <|endfocus|> import com.google.common.annotations.VisibleForTesting; import com.google.gerrit.server.git.LockFailureException; import java.io.IOException; import org.eclipse.jgit.internal.JGitText; import org.eclipse.jgit.lib.BatchRefUpdate; import org.eclipse.jgit.lib.NullProgressMonitor; import org.eclipse.jgit.lib.RefUpdate; import org.eclipse.jgit.lib.Repository; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.transport.ReceiveCommand; /** Static utilities for working with JGit's ref update APIs. */ public class RefUpdateUtil { /**
<|startcomment|> I would push this check down into DefaultQuotaBackend#request to avoid having it twice. <|endcomment|>  private final QuotaRequestContext requestContext; private WithResource( CurrentUser user, Optional<Project.NameKey> project, Optional<Change.Id> change, Optional<Account.Id> account) { requestContext = QuotaRequestContext.builder() .user(user) .project(project) .change(change) .account(account) .build(); } @Override <|startfocus|> public QuotaResponse.Aggregated request(String quotaGroup, long numTokens) { checkState(numTokens > 0, "numTokens must be a positive, non-zero long"); return DefaultQuotaBackend.this.request(quotaGroup, requestContext, numTokens, true); <|endfocus|> } @Override public QuotaResponse.Aggregated requestNoDeduction(String quotaGroup, long numTokens) { checkState(numTokens > 0, "numTokens must be a positive, non-zero long"); return DefaultQuotaBackend.this.request(quotaGroup, requestContext, numTokens, false); } } private QuotaResponse.Aggregated request( String quotaGroup, QuotaRequestContext requestContext, long numTokens, boolean deduct) { List<QuotaEnforcer> enforcers = ImmutableList.copyOf(quotaEnforcers);
<|startcomment|> This might be confusing for users, because I don't think it's possible to add more during the init step. <|endcomment|>  private void configureCacheSection() { ui.header("Cache section"); promptAndSetString( "Cache thread pool size", CACHE_SECTION, THREAD_POOL_SIZE_KEY, numberToString(DEFAULT_THREAD_POOL_SIZE)); promptAndSetString( <|startfocus|> "Cache pattern (optional); multiply this line to add more", <|endfocus|> CACHE_SECTION, PATTERN_KEY, null);
<|startcomment|> Long line? <|endcomment|> package com.googlesource.gerrit.plugins.replication; import com.google.common.collect.Multimap; import com.google.gerrit.reviewdb.client.Project.NameKey; import com.google.gerrit.server.git.WorkQueue; import java.nio.file.Path; import java.util.List; import java.util.Optional; import org.eclipse.jgit.transport.URIish; public interface ReplicationConfig { enum FilterType { PROJECT_CREATION, PROJECT_DELETION, ALL } List<Destination> getDestinations(FilterType filterType); <|startfocus|> Multimap<Destination, URIish> getURIs(Optional<String> remoteName, NameKey projectName, FilterType filterType); <|endfocus|> boolean isReplicateAllOnPluginStart(); boolean isDefaultForceUpdate(); boolean isEmpty(); Path getEventsDirectory(); int shutdown(); void startup(WorkQueue workQueue); } 
<|startcomment|> Unused. <|endcomment|> import com.google.inject.AbstractModule; import com.google.inject.Inject; import com.google.inject.Injector; import com.google.inject.Key; import com.google.inject.TypeLiteral; import java.io.IOException; import org.eclipse.jgit.errors.ConfigInvalidException; /** Husk of an in-memory ReviewDb implementation. */ // TODO(dborowitz): Inline callers to get their own darn schemaCreator. public class InMemoryDatabase implements SchemaFactory<ReviewDb> { /** Drop the database from memory; does nothing if the instance was null. */ public static void drop(InMemoryDatabase db) {} <|startfocus|> private final ReviewDbSchemaCreator schemaCreator; <|endfocus|> private final SchemaFactory<ReviewDb> schemaFactory; private boolean created; @Inject InMemoryDatabase(Injector injector) throws OrmException { Injector childInjector = injector.createChildInjector( new AbstractModule() { @Override protected void configure() { switch (IndexModule.getIndexType(injector)) { case LUCENE: install(new LuceneIndexModuleOnInit()); break; case ELASTICSEARCH: install(new ElasticIndexModuleOnInit()); break; default:
<|startcomment|> Remove this line. <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. <|startfocus|> // WARNING: NoteDbUpdateManager cares about the package name RestApiServlet lives in. <|endfocus|> package com.google.gerrit.httpd.restapi; import com.google.gerrit.extensions.restapi.RestResource; import com.google.gerrit.server.account.AccountResource; import com.google.gerrit.server.change.ChangeResource; import com.google.gerrit.server.project.ProjectResource; import com.google.gerrit.server.quota.QuotaBackend; import com.google.gerrit.server.quota.QuotaException; import com.google.gerrit.util.http.RequestUtil; import javax.inject.Inject; import javax.servlet.http.HttpServletRequest; /** * Enforces quota on specific REST API endpoints. * * <p>Examples: * * <ul>
<|startcomment|> Should this be renamed to 'function' now? <|endcomment|>  short i = 0; ArrayList<LabelValue> result = new ArrayList<>(); // Fill in any missing values with empty text. while (i < values.size()) { while (v < values.get(i).getValue()) { result.add(new LabelValue(v++, "")); } v++; result.add(values.get(i++)); } result.trimToSize(); return Collections.unmodifiableList(result); } protected String name; <|startfocus|> protected LabelFunction functionName; <|endfocus|> protected boolean copyMinScore; protected boolean copyMaxScore; protected boolean copyAllScoresOnMergeFirstParentUpdate; protected boolean copyAllScoresOnTrivialRebase; protected boolean copyAllScoresIfNoCodeChange; protected boolean copyAllScoresIfNoChange; protected boolean allowPostSubmit; protected boolean ignoreSelfApproval; protected short defaultValue; protected List<LabelValue> values; protected short maxNegative; protected short maxPositive; private transient boolean canOverride; private transient List<String> refPatterns; private transient Map<Short, LabelValue> byValue; protected LabelType() {} 
<|startcomment|> should be the destination branch here, not the magic branch. <|endcomment|>  // patch-set ChangeData destChangeData = destChanges.get(0); Change destChange = destChangeData.change(); insertPatchSet( bu, repo, destChange, pullRequestCommit, destChangeData.notes(), pullRequestMesage); return destChange.getId(); } // Change key not found on destination branch. We can create a new // change. return createNewChange( db, bu, changeKey, project.getNameKey(), destRef, pullRequestOwner, pullRequestCommit, <|startfocus|> "refs/for/" + destinationBranch, <|endfocus|> pullRequestMesage, topic); } private List<ChangeData> queryChangesForSha1(String pullRequestSha1) { QueryResult<ChangeData> results; try { results = qp.get().query(changeQuery.commit(pullRequestSha1)); return results.entities(); } catch (OrmException | QueryParseException e) { LOG.error( "Invalid SHA1 " + pullRequestSha1 + ": cannot query changes for this pull request", e); return Collections.emptyList(); } } private void insertPatchSet( BatchUpdate bu, Repository git,
<|startcomment|> Do we need to exclude the "meta refs" or they are meant to be included? <|endcomment|>  throws PermissionBackendException { Map<String, Ref> filteredRefs = new HashMap<>(); Map<String, Ref> defaultFilteredRefs = defaultForProject.filter(refs, repo, opts); // FIXME: can we filter the closed refs here? Set<String> openChangesRefs = openChangesByScan(repo); for (String changeKey : defaultFilteredRefs.keySet()) { <|startfocus|> if (!changeKey.startsWith("refs/changes") || isOpen(openChangesRefs, changeKey)) { <|endfocus|> filteredRefs.put(changeKey, defaultFilteredRefs.get(changeKey)); } } return filteredRefs; } private boolean isOpen(Set<String> openChangesRefs, String changeKey) { String changeRefWithoutPatchset = changeKey.substring(0, changeKey.lastIndexOf('/') + 1); return openChangesRefs.contains(changeRefWithoutPatchset); } @Override public BooleanCondition testCond(ProjectPermission perm) { return defaultForProject.testCond(perm); } @Override public String resourcePath() { return defaultForProject.resourcePath(); } private Set<String> openChangesByScan(Repository repo) { Set<String> result = new HashSet<>();
<|startcomment|> For forward compatibility it would be better to pass the entire Configuration object here, or at least the entire index() part of it. <|endcomment|> <|startfocus|> protected ForwardedIndexingHandler(int lockStripes) { idLocks = Striped.lock(lockStripes); <|endfocus|>
<|startcomment|> An Optional would have been equally easy to convert into a Set. I do not see the point of starting using again null values with risks of NPEs and cluttering the code if conditional "!=null" <|endcomment|>  public Set<PeerInfo> get() { <|startfocus|> return peerInfo != null ? ImmutableSet.of(peerInfo) : ImmutableSet.of(); <|endfocus|>
<|startcomment|> Keep individual imports and avoid wildcards. <|endcomment|> // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.googlesource.gerrit.plugins.its.jira; <|startfocus|> import static java.net.HttpURLConnection.*; <|endfocus|> import com.google.gson.Gson; import com.google.inject.Inject; import com.googlesource.gerrit.plugins.its.base.its.InvalidTransitionException; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraComment; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraIssue; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraProject; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApi; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraRestApiProvider; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraServerInfo; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraTransition; import com.googlesource.gerrit.plugins.its.jira.restapi.JiraVersion;
<|startcomment|> finish sentence. <|endcomment|>  * There is no guarantee that additional fields are populated, although they can be. * * @param project project to read. * @param changeId change ID to read * @param metaId object ID of the meta branch to read. This is only used to ensure consistency. It * does not allow for reading non-current meta versions. * @return change data <|startfocus|> * @throws IllegalArgumentException in case <|endfocus|> */ public ChangeData getChangeData(Project.NameKey project, Change.Id changeId, ObjectId metaId) { Key key = new AutoValue_ChangeRefCache_Key(project, changeId, metaId); CachedChange cached = cache.getUnchecked(key); if (cached == null) { throw new IllegalArgumentException("no change found for key " + key); } ChangeData cd = changeDataFactory.create(cached.change()); cd.setReviewers(cached.reviewers()); return cd; } public void bootstrapIfNecessary(Project.NameKey project) { if (!gerritOptions.enableMasterFeatures()) {
<|startcomment|> same here. <|endcomment|>  + " recommended for debugging only") private List<String> projects = new ArrayList<>(); @Option( name = "--skip-project", usage = "Rebuild all projects except these; incompatible with the --project and --change") private List<String> skipProjects = new ArrayList<>(); @Option( name = "--change", usage = <|startfocus|> "Only rebuild these changes, do no other migration; incompatible with --project and --skip-project;" + " recommended for debugging only") <|endfocus|> private List<Integer> changes = new ArrayList<>(); @Option( name = "--force", usage = "Force rebuilding changes where ReviewDb is still the source of truth, even if they" + " were previously migrated") private boolean force; @Option(name = "--trial", usage = TRIAL_USAGE) private boolean trial; @Option( name = "--sequence-gap", usage = "gap in change sequence numbers between last ReviewDb number and first NoteDb number;"
<|startcomment|> String[] ignoreUser <|endcomment|>  public void onEvent(Event event) { if (!(event instanceof PatchSetCreatedEvent)) { return; } PatchSetCreatedEvent e = (PatchSetCreatedEvent) event; Project.NameKey projectName = e.getProjectNameKey(); int maxReviewers; String ignoreSubjectRegEx; <|startfocus|> String ignoreFileRegEx; <|endfocus|> try { maxReviewers = cfg.getFromProjectConfigWithInheritance(projectName, pluginName) .getInt("maxReviewers", 3); ignoreSubjectRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName) .getString("ignoreSubjectRegEx", ""); ignoreFileRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName) .getString("ignoreFileRegEx", ""); } catch (NoSuchProjectException x) { log.error(x.getMessage(), x); return; } if (maxReviewers <= 0) { return; } try (Repository git = repoManager.openRepository(projectName); RevWalk rw = new RevWalk(git); ReviewDb reviewDb = schemaFactory.open()) { Change.Id changeId = new Change.Id(e.change.get().number);
<|startcomment|> Now unused. <|endcomment|>  public class ReviewersByBlame implements Runnable { private static final Logger log = LoggerFactory.getLogger(ReviewersByBlame.class); private final PluginConfig pluginConfig; private final RevCommit commit; private final Change change; private final PatchSet ps; private final Repository repo; private final int maxReviewers; private final String ignoreFileRegEx; private final String[] ignoredUsers; private final Emails emails; private final AccountCache accountCache; private final PatchListCache patchListCache; <|startfocus|> private final Provider<PostReviewers> reviewersProvider; private final ChangesCollection changes; <|endfocus|> public interface Factory { ReviewersByBlame create( RevCommit commit, Change change, PatchSet ps, int maxReviewers, Repository repo, String ignoreFileRegEx, String[] ignoredUsers); } @Inject public ReviewersByBlame( final Emails emails, final AccountCache accountCache, final ChangesCollection changes, final Provider<PostReviewers> reviewersProvider, final PatchListCache patchListCache, @Assisted final RevCommit commit, @Assisted final Change change, @Assisted final PatchSet ps, @Assisted final int maxReviewers,
<|startcomment|> Can you also add a test that tries to create a change on a non-existing branch, to ensure that this produces the same error? <|endcomment|>  Iterator<ChangeMessageInfo> messageIterator = changeInfo.messages.iterator(); String expectedMessage = String.format("Patch Set 1: Cherry Picked from commit %s.", revCommit.getName()); assertThat(messageIterator.next().message).isEqualTo(expectedMessage); RevisionInfo revInfo = changeInfo.revisions.get(changeInfo.currentRevision); assertThat(revInfo).isNotNull(); assertThat(revInfo.commit.message).isEqualTo(input.message + "\n"); } @Test <|startfocus|> public void createChangeOnAnInvisibleBranchNotPermitted() throws Exception { createBranch(new NameKey(project, "foo")); block("refs/heads/foo", READ, REGISTERED_USERS); <|endfocus|> requestScopeOperations.setApiUser(user.id); ChangeInput input = newChangeInput(ChangeStatus.NEW); input.branch = "foo"; exception.expect(AuthException.class); gApi.changes().create(input); } private ChangeInput newChangeInput(ChangeStatus status) { ChangeInput in = new ChangeInput(); in.project = project.get(); in.branch = "master"; in.subject = "Empty change"; in.topic = "support-gerrit-workflow-in-browser";
<|startcomment|> Is it potentially confusing if they typed "only_exts" and didn't see that operator in the response? I think we can punt on this for now. I have some ideas for how to improve this error message generation in general, it's pretty copy/paste heavy at the moment. <|endcomment|>  } throw new QueryParseException("'extension' operator is not supported by change index version"); } @Operator public Predicate<ChangeData> only_exts(String extList) throws QueryParseException { return only_extensions(extList); } @Operator public Predicate<ChangeData> only_extensions(String extList) throws QueryParseException { if (args.getSchema().hasField(ChangeField.ONLY_EXTENSIONS)) { return new FileExtensionListPredicate(extList); } throw new QueryParseException( <|startfocus|> "'only_extensions' operator is not supported by change index version"); <|endfocus|> } @Operator public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException { Set<Account.Id> accounts = null; AccountGroup.UUID group = null; // Parse for: // label:CodeReview=1,user=jsmith or // label:CodeReview=1,jsmith or // label:CodeReview=1,group=android_approvers or // label:CodeReview=1,android_approvers // user/groups without a label will first attempt to match user // Special case: votes by owners can be tracked with ",owner":
<|startcomment|> When is this false? I don't think skipping the event firing is the right thing to do? <|endcomment|>  throw new IOException(result.name()); } } protected void onUpdated(RefUpdate update, Args args) { if (update.getResult() == RefUpdate.Result.FAST_FORWARD) { tagCache.updateFastForward( project, update.getName(), update.getOldObjectId(), args.newObjectId); } if (userProvider.get().isIdentifiedUser()) { <|startfocus|> Optional<AccountState> accountState = accountCache.get(userProvider.get().getAccountId()); gitRefUpdated.fire(project, update, accountState.get()); <|endfocus|> } } } } 
<|startcomment|> This is unneeded restriction and is major use-case: User open GWT UI project list and type substring query. This can be easily expressed with secondary index inname:<foo> predicate. So that I thought that we can relax this restriction here, and add something like this below in stateToQuery() method: if (!isNullOrEmpty(matchSubstring)) { queries.add(String.format("inname:%s", matchSubstring)); } But then I ran tests with this change and realized, that tests are failing: ListProjectsIT#listProjectsWithSubstring(). What is going on? For the project named: com.google.gerrit.acceptance.rest.project.ListProjectsIT_listProjectsWithSubstring_project-awesome search for "some" substring does not produce a match. Why is that? Because getNameParts#getNameParts(name) produces these parts: [com, rest, awesome, listprojectsit, acceptance, project, google, listprojectswithsubstring, gerrit] So that there is a "awesome" part and "some" part is missing and we don't have a match. Given that we PG UI already behaves like that, it's really confusing in 2.16 that GWT UI produces different matches for the same feature: "substring search" in memory and inname:<foo> predicate. So that one option (in this or next change) could be to harmonize these different behavior, swap to using secondary index for list project with substring and document how the part divider in Lucene index works. Note, that with this Test "adaptation" it passes: [1]. * [1] http://paste.openstack.org/show/744523 <|endcomment|>  private Optional<String> expressAsProjectsQuery() { return !all && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && isNullOrEmpty(matchSubstring) && type == FilterType.ALL <|startfocus|> && isNullOrEmptyList(showBranch) <|endfocus|> ? Optional.of(stateToQuery()) : Optional.empty();
<|startcomment|> To <|endcomment|>  assertThatNameList(gApi.projects().list().withLimit(i).get()).hasSize(i); } } private List<Project.NameKey> createProjects(String prefix, int numProjects) { return IntStream.range(0, numProjects) .mapToObj( i -> { String projectName = prefix + i; try { return createProject(projectName); } catch (RestApiException e) { throw new IllegalStateException("Unable to create project " + projectName, e); } <|startfocus|> }) .collect(toList()); <|endfocus|> } @Test public void listProjectsWithPrefix() throws Exception { Project.NameKey someProject = createProject("some-project"); Project.NameKey someOtherProject = createProject("some-other-project"); createProject("project-awesome"); String p = name("some"); assertBadRequest(gApi.projects().list().withPrefix(p).withRegex(".*")); assertBadRequest(gApi.projects().list().withPrefix(p).withSubstring(p)); assertThatNameList(filter(gApi.projects().list().withPrefix(p).get())) .containsExactly(someOtherProject, someProject)
<|startcomment|> Why not call this AggregatedCheckState? Are you proposing to change the term? <|endcomment|> // limitations under the License. package com.google.gerrit.server.notedb; import com.google.common.collect.ImmutableListMultimap; import java.util.Map; /** * Combined state of multiple checks on a change. * * <p>This state combines multiple {@link CheckState}s together with the required/optional bit * associated with each check. * * <p>Ordering is not significant in this class, but for consistency's sake the ordering matches * {@code CheckState} where applicable. */ public enum CombinedCheckState { <|startfocus|> /** All relevant checks terminated, and at least one required check failed. */ <|endfocus|> FAILED, /** * All relevant checks terminated, and at least one optional check failed, but no required checks * failed. */ WARNING, /** * At least one relevant check is in a non-terminated state ({@code CheckState#NOT_STARTED}, * {@code CheckState#SCHEDULED}, {@code CheckState#RUNNING}). Some checks may have terminated, * whether successfully or unsuccessfully. */ IN_PROGRESS, 
<|startcomment|> Use variable from above? <|endcomment|>  public void onGroupIndexed(String groupUUID) { if (!Context.isForwardedEvent()) { <|startfocus|> IndexGroupTask task = new IndexGroupTask(groupUUID); <|endfocus|> if (queuedTasks.add(task)) { executor.execute(task); } }
<|startcomment|> This is an implementation detail. Sometimes it makes sense to mention such details. For this class, I think we should rather describe what's happening (e.g. "A CacheSerializer for Protobuf messages."). <|endcomment|> // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. package com.google.gerrit.server.cache.serialize; import com.google.protobuf.InvalidProtocolBufferException; import com.google.protobuf.MessageLite; import com.google.protobuf.Parser; <|startfocus|> /** Serializer that uses Protobuf's serializer and parser. */ <|endfocus|> public class ProtobufSerializer<T extends MessageLite> implements CacheSerializer<T> { private final Parser<T> parser; public ProtobufSerializer(Parser<T> parser) { this.parser = parser; } @Override public byte[] serialize(T object) { return object.toByteArray(); } @Override public T deserialize(byte[] in) { try { return parser.parseFrom(in); } catch (InvalidProtocolBufferException e) { throw new IllegalArgumentException("Failed to deserialize object", e); } } } 
<|startcomment|> this is not always populated. make it an optional? <|endcomment|>  Project.NameKey projectName, Repository repository, CheckerUuid checkerUuid) throws IOException, ConfigInvalidException { CheckerConfig checkerConfig = new CheckerConfig(checkerUuid); checkerConfig.load(projectName, repository); return checkerConfig; } public static CheckerConfig loadForChecker( Project.NameKey projectName, Repository repository, String ref) throws IOException, ConfigInvalidException { CheckerConfig checkerConfig = new CheckerConfig(ref); checkerConfig.load(projectName, repository); return checkerConfig; } private final String ref; <|startfocus|> private CheckerUuid checkerUuid; <|endfocus|> private Optional<Checker> loadedChecker = Optional.empty(); private Optional<CheckerCreation> checkerCreation = Optional.empty(); private Optional<CheckerUpdate> checkerUpdate = Optional.empty(); private Optional<Checker.Builder> updatedCheckerBuilder = Optional.empty(); private Config config; private boolean isLoaded = false; private CheckerConfig(String ref) { checkArgument(CheckerRef.isRefsCheckers(ref), "expected checker ref: %s", ref); this.ref = ref; } private CheckerConfig(CheckerUuid checkerUuid) { this(CheckerRef.refsCheckers(requireNonNull(checkerUuid))); this.checkerUuid = checkerUuid;
<|startcomment|> Please remove tabs from code. All tabs should be 4 spaces. <|endcomment|>  public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { super.onCharacteristicChanged(gatt, characteristic); <|startfocus|> CALeGattCharacteristicChangedCallback(gatt, characteristic, characteristic.getValue()); <|endfocus|>
<|startcomment|> Why do we have "started1" and not just "started"? <|endcomment|>  private FelixManager(Context ctx) { <|startfocus|> LogEx("Felix is started1!!"); context = ctx; mObserver = new ArrayList<FileObserver>(); String mexportbundle = "/storage/emulated/0/Download"; <|endfocus|> Map configMap = new HashMap(); String mCacheDir = ctx.getDir("org.osgi.framework.storage", Context.MODE_WORLD_WRITEABLE).toString(); configMap.put("org.osgi.framework.storage", mCacheDir); configMap.put("felix.auto.deploy.dir", mexportbundle); configMap.put("felix.embedded.execution", "true"); configMap.put("org.osgi.service.http.port", "9990"); configMap.put("org.osgi.framework.startlevel.beginning", "5"); configMap.put("felix.bootdelegation.implicit", "false"); configMap.put("felix.service.urlhandlers", "false"); configMap.put(Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA, ANDROID_FRAMEWORK_PACKAGES); LogEx("Felix is started2!!"); try { m_felix = new Felix(configMap); m_felix.init(); m_felix.start(); for (org.osgi.framework.Bundle b : m_felix.getBundleContext() .getBundles()) {
<|startcomment|> It will be good to add a note on what this file is doing <|endcomment|> // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= /// @file OnPutBelkinplug.java <|startfocus|> /// @brief <|endfocus|> package org.oic.android; import java.util.List; import org.iotivity.base.OcHeaderOption; import org.iotivity.base.OcRepresentation; import org.iotivity.base.OcResource; import android.util.Log; public class OnPutBelkinplug implements OcResource.OnPutListener { final private static String TAG = "OnPut"; public void onPutCompleted(List<OcHeaderOption> options, OcRepresentation rep) { Log.i(TAG, "PUT request was successful"); MainActivity.belkinplug.m_name = rep.getValueString("name"); MainActivity.belkinplug.m_power = rep.getValueString("power");
<|startcomment|> Please remove '[in]' tags <|endcomment|>  * ******************************************************************/ /** * @file IFindGroupListener.java * * @brief This file provides interface for getting group discovery status. * */ package org.iotivity.service.tm; import org.iotivity.base.OcResource; /** * @interface IFindGroupListener * @brief Provides interface for getting group discovery status. */ public interface IFindGroupListener { /** * This callback method will be called to notify whether group is found or * not. <|startfocus|> * * @param[in] resource - URI of resource. <|endfocus|> */ public void onGroupFindCallback(OcResource resource); } 
<|startcomment|> Please remove '[in]' tags <|endcomment|>  OCStackResult result; if (null == diagnosticsListener) { result = OCStackResult.OC_STACK_LISTENER_NOT_SET; } else { result = thingsManagerInterfaceObj.factoryReset(resource); Log.i(LOG_TAG, "factoryReset" + result.name()); } return result; } /** * API for adding a new ActionSet onto a specific resource. <|startfocus|> * * @param[in] resource - resource pointer of the group resource * @param[in] actionSet - pointer of ActionSet * <|endfocus|> * @return OCStackResult - OC_STACK_OK on success, otherwise a failure error * code. * * @pre Listener should be set using @ref setActionListener API. * * @post Listener @ref IActionListener::onPutResponseCallback will be * notified when the response of PUT operation arrives. * * <pre> * Sample code: * public void createActionSet_AllBulbOff() { * ActionSet actionSet = new ActionSet(); * Vector<Capability> listOfCap;
<|startcomment|> Please remove '[in]' tags <|endcomment|>  OCStackResult result; if (null == resourceListener) { result = OCStackResult.OC_STACK_ERROR; } else { int ordinal = ThingsManagerNativeInterface.findCandidateResources( resourceTypes, waitTime); result = OCStackResult.values()[ordinal]; } return result; } /** * API for subscribing child's state. Listener * * @ref ISubscribePresenceListener::onPresenceCallback will be notified for * resource presence status <|startfocus|> * * @param[in] resource - collection resource for subscribing presence of all <|endfocus|> * child resources * * @return OCStackResult - return value of this API. It returns OC_STACK_OK * if success. * */ public OCStackResult subscribeCollectionPresence(OcResource resource) throws OcException { String LOG_TAG = this.getClass().getSimpleName(); OCStackResult result = null; if (null == presenceListener) { result = OCStackResult.OC_STACK_ERROR; } else { int ordinal = ThingsManagerNativeInterface .subscribeCollectionPresence(resource);
<|startcomment|> There is a new overloaded function of leaveGroup(): leaveGroup(const std::shared_ptr< OCResource > resource, std::string collectionResourceType, OCResourceHandle resourceHandle). Please refer to programmer's guide of TM and add the new api. <|endcomment|> <|startfocus|> public OCStackResult leaveGroup(String resourceType, <|endfocus|> OcResourceHandle resourceHandle) { OCStackResult result; result = thingsManagerInterfaceObj.leaveGroup(resourceType, resourceHandle); Log.i(LOG_TAG, "leaveGroup" + result.name()); return result;
<|startcomment|> Remove trailing whitespaces <|endcomment|>  * capability.status = "off"; * listOfCap = new Vector<Capability>(); * listOfCap.add(capability); * * action.listOfCapability = listOfCap; * listOfAction = new Vector<Action>(); * listOfAction.add(action); * } * * actionSet.actionsetName = BULBOFF; * actionSet.listOfAction = listOfAction; * String URI = foundResources.getUri(); <|startfocus|> * String host = foundResources.getHost(); * <|endfocus|> * OCStackResult result = OCStackResult.values()[30]; * * try { * result = thingsManagerObj.addActionSet(foundResources, actionSet); * } catch (OcException e) { * e.printStackTrace(); * } * * if (OCStackResult.OC_STACK_OK != result) { * Log.e(LOG_TAG, "Error while calling addActionSet : " + result.name()); * } else {
<|startcomment|> change to lower case <|endcomment|>  WifiManager.WIFI_STATE_UNKNOWN) == WifiManager.WIFI_STATE_DISABLED) { CaIpStateDisabled(); } else if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) { ConnectivityManager manager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo nwInfo = manager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if(nwInfo.isConnected()) { CaIpStateEnabled(); } } } }; <|startfocus|> private native static void CaIpStateEnabled(); private native static void CaIpStateDisabled(); <|endfocus|> } 
<|startcomment|> change to lower case <|endcomment|>  private native static void CaRegisterBluetoothLeAdvertiseCallback(AdvertiseCallback callback); // BluetoothGattServerCallback private native static void CaLeGattServerConnectionStateChangeCallback( BluetoothDevice device, int status, int newState); private native static void CaLeGattServerServiceAddedCallback(int status, BluetoothGattService service); private native static void CaLeGattServerCharacteristicReadRequestCallback( BluetoothDevice device, int requestId, int offset, BluetoothGattCharacteristic characteristic, byte[] data); <|startfocus|> private native static void CaLeGattServerCharacteristicWriteRequestCallback( <|endfocus|> BluetoothDevice device, int requestId, BluetoothGattCharacteristic characteristic, byte[] data, boolean preparedWrite, boolean responseNeeded, int offset, byte[] value); private native static void CaLeGattServerDescriptorReadRequestCallback( BluetoothDevice device, int requestId, int offset, BluetoothGattDescriptor descriptor); public native static void CaLeGattServerDescriptorWriteRequestCallback( BluetoothDevice device, int requestId, BluetoothGattDescriptor descriptor, boolean preparedWrite, boolean responseNeeded, int offset, byte[] value); private native static void CaLeGattServerExecuteWriteCallback(BluetoothDevice device, int requestId, boolean execute); 
<|startcomment|> to maintain consistency, use capitals everywhere <|endcomment|> import java.util.ArrayList; import java.util.List; import java.util.UUID; import android.bluetooth.BluetoothAdapter; import android.bluetooth.BluetoothDevice; import android.bluetooth.BluetoothGatt; import android.bluetooth.BluetoothGattCallback; import android.bluetooth.BluetoothGattCharacteristic; import android.bluetooth.BluetoothGattDescriptor; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.util.Log; public class CaLeClientInterface { private static String SERVICE_UUID = "713d0000-503e-4c75-ba94-3148f18d941e"; <|startfocus|> private static String LOG_TAG = "Sample_Service : CaLeClientInterface"; <|endfocus|> private CaLeClientInterface(Context context) { caLeRegisterLeScanCallback(mLeScanCallback); caLeRegisterGattCallback(mGattCallback); registerIntentFilter(context); } public static void getLeScanCallback() { caLeRegisterLeScanCallback(mLeScanCallback); } public static void getLeGattCallback() { caLeRegisterGattCallback(mGattCallback); } private static IntentFilter registerIntentFilter(Context context) { IntentFilter filter = new IntentFilter(); filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
<|startcomment|> please remove tabs <|endcomment|>  * @param qualityOfService quality of service */ //Avoid breaking building java samples due to persistent storage SVR DB changes. public PlatformConfig(Activity activity, Context context, ServiceType serviceType, ModeType modeType, String ipAddress, int port, QualityOfService qualityOfService) { this(activity,context,serviceType,modeType,ipAddress,port,qualityOfService, ""); } public Context getContext() { return mContext; } public Activity getActivity() { return mActivity; } <|startfocus|> <|endfocus|> public ServiceType getServiceType() { return mServiceType; } public ModeType getModeType() { return mModeType; } public String getIpAddress() { return mIpAddress; } public int getPort() { return mPort; } public QualityOfService getQualityOfService() { return mQualityOfService; } public String getSvrDbPath() { return mSvrDbPath; } } 
<|startcomment|> Not a good name <|endcomment|>  * Resource type value to be set * @param resourceInterface * Interface value to be set * */ public Builder(String resourceURI, String resourceType, String resourceInterface) { this.resourceURI = resourceURI; this.resourceType = resourceType; this.resourceInterface = resourceInterface; } /** * Sets the discoverable(OC_DISCOVERABLE) property for the resource. * * @param flag * Whether to be discovered or not * */ <|startfocus|> public void setDiscoverable(boolean flag) { discovervableFlag = flag; <|endfocus|> } /** * Sets the observable(OC_OBSERVABLE) property of the resource. * * @param flag * Whether to be observed or not * */ public void setObservable(boolean flag) { observableFlag = flag; } /** * API for setting attributes of the resource. * * @param attributes * Resource Attributes to set * * {@link RCSResourceAttributes} */ public void setAttributes(RCSResourceAttributes attributes) { this.attributes = attributes;
<|startcomment|> Remove the log if not required or change it to debug or info log <|endcomment|>  this.nativeSetAttributeDouble(key, value); } /** * API for setting a particular attribute value as a boolean * * @param key * name of attribute(used to map the attribute value). * @param value * boolean value to be mapped against the key. * * The thread-safety for attributes is taken care internally. */ public void setAttribute(String key, boolean value) { <|startfocus|> Log.e(LOG_TAG, "setAttribute (double) called "); <|endfocus|> this.nativeSetAttributeBool(key, value); } /** * API for setting a particular attribute value as a String * * @param key * name of attribute(used to map the attribute value). * @param value * String value to be mapped against the key. * * The thread-safety for attributes is taken care internally. */ public void setAttribute(String key, String value) { Log.e(LOG_TAG, "setAttribute (String) called "); this.nativeSetAttributeString(key, value); } /**
<|startcomment|> change to lowercase <|endcomment|>  public void unlinkDevicesListener(List<ProvisionResult> ProvisionResultList, int hasError); } /** * provisionCredentialsListener can be registered with provisionCredentialsListener * call. * Listener notified asynchronously. */ public interface ProvisionCredentialsListener { public void provisionCredentialsListener(List<ProvisionResult> ProvisionResultList, int hasError); } /** * provisionAclListener can be registered with provisionAclListener * call. * Listener notified asynchronously. */ public interface ProvisionAclListener { <|startfocus|> public void provisionAclListener(List<ProvisionResult> ProvisionResultList, <|endfocus|> int hasError); } /** * provisionPairwiseDevicesListener can be registered with provisionPairwiseDevicesListener * call. * Listener notified asynchronously. */ public interface ProvisionPairwiseDevicesListener { public void provisionPairwiseDevicesListener(List<ProvisionResult> ProvisionResultList, int hasError); } /** Method to get List of device ID of devices linked with invoking device. * * @return Sring List List of device id's of linked devices. */ public native List<String> getLinkedDevices(); /**
<|startcomment|> List is preferable <|endcomment|> <|startfocus|> public void setResources(String[] resources) { <|endfocus|> this.resources = resources;
<|startcomment|> Not required <|endcomment|>  * <p/> * **************************************************************** */ package org.iotivity.service.easysetup; import java.io.IOException; import org.iotivity.service.easysetup.core.BleConnection; import org.iotivity.service.easysetup.core.EasySetupService; import org.iotivity.service.easysetup.core.EasySetupStatus; import org.iotivity.service.easysetup.core.EnrolleeDevice; import org.iotivity.service.easysetup.core.EnrolleeState; import org.iotivity.service.easysetup.core.IpOnBoardingConnection; import org.iotivity.service.easysetup.impl.BLEOnBoardingConfig; import org.iotivity.service.easysetup.impl.EnrolleeDeviceFactory; <|startfocus|> import org.iotivity.service.easysetup.impl.WiFiOnBoardingConfig; <|endfocus|> import org.iotivity.service.easysetup.impl.WiFiProvConfig; import android.app.Activity; import android.bluetooth.BluetoothAdapter; import android.bluetooth.BluetoothManager; import android.content.Context; import android.content.Intent; import android.net.wifi.WifiConfiguration; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.ProgressBar; import android.widget.TextView; import android.widget.Toast; public class BLEActivity extends Activity { 
<|startcomment|> Please check the sequence of finalize and dispose. <|endcomment|>  * does not exist. * @throws SimulatorException * This exception will be thrown for other errors. */ public native void notifyAllObservers() throws InvalidArgsException, SimulatorException; private native int startResourceAutomation(int typeOfAutomation, IAutomation listener) throws InvalidArgsException, SimulatorException; private native int startAttributeAutomation(String attrName, int typeOfAutomation, IAutomation listener) throws InvalidArgsException, SimulatorException; @Override protected void finalize() throws Throwable { <|startfocus|> super.finalize(); dispose(); <|endfocus|> } private native void dispose(); } 
<|startcomment|> change to lowercase <|endcomment|>  private boolean invokeBeam; private CaNfcInterface(Context context, Activity activity) { Log.d(MYTAG, "NFC registerNfcReceiver"); mContext = context; mActivity = activity; mAdapter = NfcAdapter.getDefaultAdapter(mContext); if(mAdapter == null) { Log.e(MYTAG, "Failed to get the Adapter"); return; } } private native static void caNativeNfcPacketReceived(byte[] receivedData); <|startfocus|> private native static NdefMessage CaNativeNfcCreateNdefMessage(byte[] sendData); private native static boolean CaNativeNfcInvokeBeam(); <|endfocus|> @Override public NdefMessage createNdefMessage(NfcEvent event) { Log.d(MYTAG, "NFC createNdefMessage"); return mMessage; } public void processSendRquest(byte[] sendData) { Log.d(MYTAG, "NFC processSendRquest IN"); mMessage = CaNativeNfcCreateNdefMessage(sendData); invokeBeam = CaNativeNfcInvokeBeam(); if(!invokeBeam ) { Log.e(MYTAG, "NFC Beam error"); } } public void CaNfcInitialize() { Log.d(MYTAG, "CaNfcInitialize"); 
<|startcomment|> Is this import required? <|endcomment|>  * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * ******************************************************************/ package org.iotivity.ca; <|startfocus|> import java.nio.charset.Charset; <|endfocus|> import java.util.ArrayList; import android.annotation.TargetApi; import android.app.Activity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.app.PendingIntent; import android.content.IntentFilter.MalformedMimeTypeException; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.net.wifi.WifiManager; import android.nfc.NdefMessage; import android.nfc.NdefRecord; import android.nfc.NfcAdapter; import android.nfc.NfcEvent; import android.os.Build; import android.os.Parcelable; import android.util.Log; import android.widget.Toast; 
<|startcomment|> Does this only work with LE? What about IP and BT? <|endcomment|>  /** * Method stop connection manager service. * this method must be called, when Application is destroied. */ public synchronized static void stopManagerService() throws OcException { CaInterface.caManagerTerminate(); isConnectionManagerInitialized = false; } /** * Method set device information for Auto-Connection. * this method has to be called before FindResource is called. * @param address LE address of scanned bluetooth device. */ public synchronized static void setAutoConnectionDevice(String address) throws OcException { <|startfocus|> if (isConnectionManagerInitialized) { CaInterface.caManagerSetAutoConnectionDeviceInfo(address); } <|endfocus|> } /** * Method unset device information for Auto-Connection. * @param address LE address of scanned bluetooth device. */ public synchronized static void unsetAutoConnectionDevice(String address) throws OcException { if (isConnectionManagerInitialized) { CaInterface.caManagerUnsetAutoConnectionDeviceInfo(address); } } /** * Interface for connection manager state listener. * Event listeners are notified asynchronously. */
<|startcomment|> Per project coding standards should have declarations on individual lines. <|endcomment|>  private final long SCAN_PERIOD = 10000; private BluetoothLeScanner mLEScanner; private ScanSettings settings = null; private List<ScanFilter> filters = null; private BluetoothGatt mGatt = null; private ArrayList<String> items = null; private ArrayList<BluetoothDevice> mBluetoothDevices = null; private ArrayAdapter<String> adapter = null; private boolean isScanning = false; private boolean isBTSelected = false; <|startfocus|> private Button btButton, leButton; <|endfocus|> @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_bluetooth, container, false); btButton = (Button) rootView.findViewById(R.id.btn_bt); btButton.setOnClickListener(scanButtonListener(true)); leButton = (Button) rootView.findViewById(R.id.btn_le); leButton.setOnClickListener(scanButtonListener(false)); ListView listView = (ListView) rootView.findViewById(R.id.list_view); items = new ArrayList<String>();
<|startcomment|> avoid magic literals <|endcomment|>  private void initOcPlatform(ModeType type) { <|startfocus|> PlatformConfig cfg = new PlatformConfig(mActivity, mContext, ServiceType.IN_PROC, type, "0.0.0.0", 0, qos); <|endfocus|> OcPlatform.Configure(cfg);
<|startcomment|> Please make sure that variable names follow the naming convention: https://source.android.com/source/code-style.html#follow-field-naming-conventions <|endcomment|>  private QualityOfService qos = QualityOfService.LOW; LinearLayout serverLayout; LinearLayout clientLayout; TextView resourceText; TextView actionLog; TextView resultLog; ToggleButton qosToggle; Button registerButton; Button getButton; Button putButton; Button largeButton; Button discoverIPButton; Button discoverBTButton; Button discoverLEButton; Button discoverTCPButton; Button discoverNFCButton; private String mLargeData; private boolean mState; private long start_time; private long end_time; <|startfocus|> private final double MILLI_PER_SEC = 1000.0; <|endfocus|> @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mActivity = getActivity(); mContext = mActivity.getBaseContext(); } View.OnClickListener getButtonListener() { return new View.OnClickListener() { @Override public void onClick(View view) { if (foundResource != null) { start_time = System.currentTimeMillis(); sendGetToFoundResource(Common.STATE_GET); } else {
<|startcomment|> Unnecessary empty lines <|endcomment|>  private Button btnTitle; private Button btnBody; private Button btnSend; private Button btnStart; private Button btnStop; private Button btnAccept; private Button btnSync; private EditText editTextTitle; private EditText editTextBody; private static TextView TvLog; private static int notiId = 100; private static int subCnt = 0; private boolean isStarted = false; private String consumerId; private NotiListener mNotiListener = null; private ProviderProxy mProviderProxy = null; <|startfocus|> <|endfocus|> public static Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case MESSAGE_SUBSCRIPTION: String subscriber = (String) msg.obj; if(subscriber != null) TvLog.append("Recv-Sub(" + subCnt++ + ") " + subscriber + "\n"); break; case MESSAGE_SYNC: String sync = (String) msg.obj; if(sync != null) TvLog.append("Sync-Read(#" + sync + ")\n"); break; default: break;
<|startcomment|> ES_CLOUD_ENROLLEE_FOUND looks better .. otherwise looks not cohesive with ESCloudProvState <|endcomment|>  * * **************************************************************** */ package org.iotivity.service.easysetup.mediator; /** * It defines various states of the cloud provisioning during easy setup process */ public enum ESCloudProvState { /** * Some error occurs during cloud data provisioning */ ES_CLOUD_PROVISIONING_ERROR(-1), /** * Cloud data provisioning is successfully done */ ES_CLOUD_PROVISIONING_SUCCESS(0), /** * Target enrollee which needs a cloud provisioning is found in a network */ <|startfocus|> ES_ENROLLEE_FOUND(1), <|endfocus|> /** * Target enrollee which needs a cloud provisioning is NOT found in a network */ ES_ENROLLEE_NOT_FOUND(2); private int value; private ESCloudProvState(int value) { this.value = value; } public int getValue() { return value; } public static ESCloudProvState fromInt(int i) { for (ESCloudProvState b : ESCloudProvState.values()) { if (b.getValue() == i) { return b; } } return null; } }; 
<|startcomment|> there are many points to create XmlReader. put the xmlReader variable as member variable of class. <|endcomment|>  public KafkaConsumerWrapper(String zookeeperAddress, String brokerAddress, Topic consumer) { mTopicName = consumer.getName().replace("/", "."); mZookeeper = zookeeperAddress; mBroker = brokerAddress; mInternalConsumer = consumer; <|startfocus|> XmlReader xmlReader = new XmlReader(); <|endfocus|> mZkClient = new ZkClient(zookeeperAddress, xmlReader.getKafkaSessionTimeout(), xmlReader.getKafkaConnectTimeout(), ZKStringSerializer$.MODULE$); mZkUtils = new ZkUtils(mZkClient, new ZkConnection(zookeeperAddress), false);
<|startcomment|> need handling two or more filters <|endcomment|>  if (tableName == null || doc == null) return false; String key1 = null; String key2 = null; key1 = keyField.get(0); key2 = keyField.get(1); MongoCollection<Document> collection = db.getCollection(tableName); if (collection .findOneAndReplace( Filters.and(Filters.eq(key1, doc.get(key1)), Filters.eq(key2, doc.get(key2))), doc) == null) { collection.insertOne(doc); } return true; } <|startfocus|> public Boolean updateRecord(String tableName, String keyField, Document doc) { <|endfocus|> if (tableName == null || keyField == null || doc == null) return false; Object value = doc.get(keyField); MongoCollection<Document> collection = db.getCollection(tableName); if (collection.findOneAndReplace(Filters.eq(keyField, value), doc) == null) { Log.w("updateRecord failed! tableName: " + tableName + ", keyFiled: " + keyField + ", value: " + value); return false;
<|startcomment|> how about you modify this like belown? if(~~~~~~){ .... }else throw new IntenralServerErrorException(...); return responsePayload; <|endcomment|>  new HashSet<String>(Arrays.asList(uuid)), null, uuid, null, gtype); TypeCastingManager<GroupTable> typeGroup = new TypeCastingManager<GroupTable>(); if (AccountDBManager.getInstance().insertRecord(Constants.GROUP_TABLE, typeGroup.convertObjectToMap(newGroupTable))) { mGroups.put(gid, new Group(gid)); Log.v(mGroups.toString()); responsePayload.put(Constants.REQ_GROUP_ID, gid); return responsePayload; } throw new InternalServerErrorException( "MongoDB is not operating in insertRecord"); } <|startfocus|> public boolean deleteGroup(String gmid, String gid) { <|endfocus|> ArrayList<HashMap<String, Object>> result = AccountDBManager .getInstance().selectRecord(Constants.GROUP_TABLE, Constants.REQ_GROUP_ID, gid); if (result.size() == 1) { if (gmid.equals(result.get(0).get(Constants.REQ_GROUP_MASTER_ID))) { if (AccountDBManager.getInstance().deleteRecord( Constants.GROUP_TABLE, Constants.REQ_GROUP_ID, gid)) { mGroups.remove(gid); return true; } throw new InternalServerErrorException(
<|startcomment|> use the name as policy <|endcomment|>  public void onClick(View v) { switch (v.getId()) { case R.id.BtnStart: { if (isStarted == false) { Log.i(TAG, "Start NS Provider Service"); TvLog.setText("Start NS-Provider\n"); <|startfocus|> boolean access = true; // ptovider controls the acceptance of consumers mProviderProxy.Start(access); <|endfocus|> isStarted = true; } else { Log.e(TAG, "NS Provider Service had already started"); } } break; case R.id.BtnAccept: { if(isStarted == false) { Log.e(TAG, "Fail to request Accept"); break; } } break; case R.id.BtnCreateNoti: { String id = Integer.toString(notiId); // generate notificaion ID String title = editTextTitle.getText().toString(); String body = editTextBody.getText().toString(); if(isStarted == false) { Log.e(TAG, "Fail to send NSMessage"); break; } 
<|startcomment|> whitespace should be removed <|endcomment|>  /* resource url for account */ public static final String ACCOUNT_URI = "account"; public static final String SESSION_URI = "session"; public static final String DEVICE_URI = "device"; public static final String TOKEN_REFRESH_URI = "tokenrefresh"; /* resource url for acl */ public static final String PROV_URI = "prov"; public static final String CRED_URI = "cred"; public static final String CERT_URI = "cert"; <|startfocus|> <|endfocus|> /* resource uri to publish, update, delete resource info */ public static final String RD_URI = "rd"; /* resource uri for keep-alive */ public static final String KEEP_ALIVE_URI = "ping"; /* resource uri to discover resource info */ public static final String WELL_KNOWN_URI = "res"; /* resource uri for resource presence */ public static final String RES_PRESENCE_URI = "ad"; /* resource uri for device presence */ public static final String DEVICE_PRESENCE_URI = "prs"; 
<|startcomment|> TC needs to check other exceptions... <|endcomment|>  * @target 1. void setAutoNotifyPolicy(AutoNotifyPolicy policy) * 2. AutoNotifyPolicy getAutoNotifyPolicy() * @test_data policy = NEVER, ALWAYS and UPDATED * @pre_condition 1. Builder class should be initialized 2. Resource object * should be built * @procedure 1. Perform setAutoNotifyPolicy() and getAutoNotifyPolicy() API with multiple policies * @post_condition None <|startfocus|> * @expected Should not occur exception. <|endfocus|> **/ public void testSetGetAutoNotifyPolicy_SQV_P() { try { m_ResourceObject.setAutoNotifyPolicy(AutoNotifyPolicy.NEVER); m_ResourceObject.getAutoNotifyPolicy(); } catch (RcsException e) { fail("Exception occurs when calling getAutoNotifyPolicy API with NEVER."); } try { m_ResourceObject.setAutoNotifyPolicy(AutoNotifyPolicy.ALWAYS); m_ResourceObject.getAutoNotifyPolicy(); } catch (RcsException e) { fail("Exception occurs when calling getAutoNotifyPolicy API with ALWAYS."); } try { m_ResourceObject.setAutoNotifyPolicy(AutoNotifyPolicy.UPDATED); m_ResourceObject.getAutoNotifyPolicy();
<|startcomment|> I think that using values of Constants file is better. <|endcomment|>  countInvite.set(false); // invite user callback Mockito.doAnswer(new Answer<Object>() { @Override public CoapResponse answer(InvocationOnMock invocation) throws Throwable { Object[] args = invocation.getArguments(); CoapResponse resp = (CoapResponse) args[0]; latchInviteUser.countDown(); // check observe notification response if (latchInviteUser.getCount() == 0) { <|startfocus|> assertTrue(methodCheck(resp, ResponseStatus.CONTENT)); assertTrue(hashmapCheck(resp, "invite")); assertTrue(inviteInfoCheck(resp.getPayload(), "invite", TEST_GROUP_ID, TEST_INVITED_USER)); countInvite.set(true); <|endfocus|> } return resp; } }).when(mockInviteUser).sendResponse(Mockito.anyObject()); getInvitation(TEST_INVITE_USER, mockInviteUser, Observe.SUBSCRIBE); sendInvitation(TEST_GROUP_ID, TEST_INVITED_USER); await().atMost(2, SECONDS).untilTrue(countInvite); assertTrue(latchInviteUser.await(2L, SECONDS)); } @Test public void testInvitedUserObserveInvitation() throws Exception { CountDownLatch latchInvitedUser = new CountDownLatch(2); 
<|startcomment|> if "getGroupTable.getGtype()" is null, the upside code does not need to be run. therefore, how about you change this one and upside code? <|endcomment|>  GroupTable getGroupTable = new GroupTable(); getGroupTable = mTypeGroup.convertMaptoObject(element, getGroupTable); if (getGroupTable.getMidlist() == null) { throw new BadRequestException("midList is invalid in Group"); } HashSet<String> midListSet = new HashSet<String>( (Collection<? extends String>) getGroupTable.getMidlist()); <|startfocus|> if (getGroupTable.getGtype() == null) { throw new InternalServerErrorException("gtype is empty"); } <|endfocus|> if (midListSet.contains(uuid) && getGroupTable.getGtype() .equals(Constants.REQ_GTYPE_PUBLIC)) { gidList.add(getGroupTable.getGid()); } } responsePayload.put(Constants.KEYFIELD_GIDLIST, gidList); return responsePayload; } public void addGroupMember(String gid, HashSet<String> midlist) { getGroup(gid).addMember(midlist); } public void addGroupDevice(String gid, HashSet<String> dilist) { getGroup(gid).addDevice(dilist); } public void removeGroupMember(String gid, HashSet<String> midlist) { 
<|startcomment|> it will be encoded in while block. So, i think that it is better to declare out of while block. <|endcomment|>  private void notifyToSubscriber( HashMap<String, Object> notifiyBtyePayloadData) { synchronized (mSubscribers) { Iterator<String> iterator = mSubscribers.keySet().iterator(); while (iterator.hasNext()) { String key = iterator.next(); GroupSubscriber groupSubscriber = mSubscribers.get(key); groupSubscriber.mSubscriber.sendResponse( MessageBuilder.createResponse(groupSubscriber.mRequest, ResponseStatus.CONTENT, ContentFormat.APPLICATION_CBOR, <|startfocus|> mCbor.encodingPayloadToCbor( notifiyBtyePayloadData))); <|endfocus|> } }
<|startcomment|> please remove it <|endcomment|>  private boolean verifyGroupTableDi(String di) { GroupTable groupTable = getGroupTable(); if (groupTable.getDilist() == null) { return false; } <|startfocus|> HashSet<String> diListSet = new HashSet<String>( <|endfocus|> (Collection<? extends String>) groupTable.getDilist()); if (!diListSet.contains(di)) { return false; } return true;
<|startcomment|> please remove this line, if you not need. <|endcomment|> import org.iotivity.cloud.base.protocols.IRequest; import org.iotivity.cloud.base.protocols.IResponse; import org.iotivity.cloud.base.protocols.MessageBuilder; import org.iotivity.cloud.base.protocols.enums.ContentFormat; import org.iotivity.cloud.base.protocols.enums.ResponseStatus; import org.iotivity.cloud.base.resource.Resource; import org.iotivity.cloud.util.Cbor; public class AclVerifyResource extends Resource { private Cbor<HashMap<String, Object>> mCbor = new Cbor<>(); <|startfocus|> private TypeCastingManager<AclTable> mTypeAcl = new TypeCastingManager<AclTable>(); <|endfocus|> public AclVerifyResource() { super(Arrays.asList(Constants.PREFIX_OIC, Constants.ACL_URI, Constants.VERIFY_URI)); } @Override public void onDefaultRequestReceived(Device srcDevice, IRequest request) throws ServerException { IResponse response = null; switch (request.getMethod()) { case POST: break; case GET: response = handleGetRequest(request); break; case DELETE: break; default: throw new BadRequestException(request.getMethod() + " request type is not supported"); } srcDevice.sendResponse(response); } 
<|startcomment|> LINK? <|endcomment|>  public static final String PLATFORM_MODEL_NO = "Model Number"; public static final String PLATFORM_DATE_OF_MANUFAC = "Date of Manufacture"; public static final String PLATFORM_VERSION = "Version"; public static final String PLATFORM_OS_VERSION = "OS Version"; public static final String PLATFORM_HARDWARE_VERSION = "HardWare Version"; public static final String PLATFORM_FIRMWARE_VERSION = "Firmware Version"; <|startfocus|> public static final String PLATFORM_SUPPORT_URL = "Support Link"; <|endfocus|> public static final String PLATFORM_SYSTEM_TIME = "System Time"; public static final String BASELINE_INTERFACE = "oic.if.baseline"; public static final String LINKS_LIST_INTERFACE = "oic.if.ll"; public static final String BATCH_INTERFACE = "oic.if.b"; public static final String LINK_BATCH_INTERFACE = "oic.if.lb"; public static final String READ_ONLY_INTERFACE = "oic.if.r"; public static final String READ_WRITE_INTERFACE = "oic.if.rw";
<|startcomment|> it seems like "a map including attribute name and values." is better <|endcomment|>  * Method to add values for properties to the group on account server. * * @param groupId Group ID to add property values. * @param propertyValue OCRepresentation info that has pairs of property and value. * Defined properties on the OCF spec are [members, masters, devices, * resources, links] so far. (2016/10/19) * @param onPostListener event handler The event handler will be invoked with a map of * attribute name and values. <|startfocus|> * * @return Returns ::OC_STACK_OK if success <|endfocus|> */ public void addPropertyValueToGroup(String groupId, OcRepresentation propertyValue, OnPostListener onPostListener) throws OcException { this.addPropertyValueToGroup0(groupId, propertyValue, onPostListener); } private native void addPropertyValueToGroup0(String groupId, OcRepresentation propertyValue, OnPostListener onPostListener) throws OcException; /** * Method to delete values for properties from the group on account server. *
<|startcomment|> As above, you have to change. <|endcomment|>  .get(searchType.get(0)); if (values == null) { result.put(searchType.get(0), new ArrayList<String>( Arrays.asList(searchType.get(1)))); } else { System.out.println("values : " + values); System.out.println("searchType.get(1) : " + searchType.get(1)); values.removeAll(Arrays.asList(searchType.get(1))); values.addAll(Arrays.asList(searchType.get(1))); <|startfocus|> System.out.println("values : " + values); <|endfocus|> result.put(searchType.get(0), values); } } return result; } private ArrayList<String> getSearchType(String criteria) { ArrayList<String> searchType = new ArrayList<String>( Arrays.asList(criteria.split("="))); String searchKey = searchType.get(0); String searchValue = searchType.get(1); if (searchKey == null || searchValue == null) { throw new BadRequestException("search key or value is null"); } return searchType; } public enum SearchOperation { AND, OR } 
<|startcomment|> exceed 100 char <|endcomment|>  if (!isBtPairingInitialized) { CaInterface.caBtPairingInitialize(context, listener); isBtPairingInitialized = true; } } /** * stop bluetooth pairing service. */ public synchronized static void stopBtPairingService() { if (isBtPairingInitialized) { CaInterface.caBtPairingTerminate(); isBtPairingInitialized = false; } } /** * start bluetooth device scan. * <|startfocus|> * @throws OcException If bluetooth pairing has not been initialized. Check that startBtPairingService has been called. <|endfocus|> */ public synchronized static void startScan() throws OcException { CaInterface.initCheckForBtPairingUtil(); CaInterface.caBtPairingStartScan(); } /** * stop bluetooth device scan. * * @throws OcException If bluetooth pairing has not been initialized. Check that startBtPairingService has been called. */ public synchronized static void stopScan() throws OcException { CaInterface.initCheckForBtPairingUtil(); CaInterface.caBtPairingStopScan(); } /** * create bond * * @param device bluetooth device
<|startcomment|> Should probably also add the @Depricated java annotation as well. see: https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html <|endcomment|>  resProperty |= prop.getValue(); } return OcPlatform.registerResource1(resourceUri, resourceTypeName, resourceInterface, entityHandler, resProperty); } private static native OcResourceHandle registerResource1( String resourceUri, String resourceTypeName, String resourceInterface, EntityHandler entityHandler, int resourceProperty) throws OcException; /** * Register Device Info * * @deprecated use setPropertyValue instead * * @param ocDeviceInfo object containing all the device specific information * @throws OcException if failure <|startfocus|> */ <|endfocus|> public static void registerDeviceInfo( OcDeviceInfo ocDeviceInfo) throws OcException { OcPlatform.initCheck(); OcPlatform.registerDeviceInfo0( ocDeviceInfo.getDeviceName(), ocDeviceInfo.getDeviceTypes().toArray( new String[ocDeviceInfo.getDeviceTypes().size()] ) ); } private static native void registerDeviceInfo0( String deviceName, String[] deviceTypes ) throws OcException; /** * Set param Info * * @throws OcException on failure */ public static void setPropertyValue(
<|startcomment|> This name might be misleading. It(0.0.0.0) means all available IP <|endcomment|> import org.iotivity.base.OcConnectivityType; import org.iotivity.base.OcException; import org.iotivity.base.ModeType; import org.iotivity.base.ErrorCode; import org.iotivity.base.QualityOfService; import org.iotivity.base.PlatformConfig; import org.iotivity.base.ServiceType; import static org.iotivity.test.ic.tc.helper.ICHelperStaticUtil.*; import static org.iotivity.test.ic.tc.helper.ICMessageQueue.*; import org.iotivity.test.ic.tc.helper.ICMessageQueue; public class ICMessageQueueTest extends AndroidTestCase { <|startfocus|> private static final String ALL_INTERFACE_TYPE = "0.0.0.0"; <|endfocus|> QualityOfService m_qualityOfService; OcResource m_ocResource; OcRepresentation m_rep = new OcRepresentation(); OnMQTopicCreatedListener m_onTopicCreatedListener = new OnMQTopicCreatedListener() { public void onTopicResourceCreated( OcResource m_myResource) { } public void onCreateTopicFailed( Throwable ex, String m_uri) { } }; OnMQTopicFoundListener m_onTopicFoundListener = new OnMQTopicFoundListener() {
<|startcomment|> redundant space <|endcomment|>  } } /** * @since 2017-01-24 * @see string SignUp() API * @see string SignIn() API * @see string SignOut() API * @objective Test 'deleteResourceFromRD' positively to delete resource from * RD * @target OCStackResult deleteResourceFromRD(const std::string& host, * OCConnectivityType <|startfocus|> * connectivityType, * OC::ResourceHandles& resourceHandles, * DeleteResourceCallback callback) <|endfocus|> * @test_data 1. host Host address 2. connectivityType CT_DEFAULT as * connectivity 3. callback onPublish as callback * @pre_condition constructAccountManagerObject(host, connectivity_type), * SignUp(), SignIn() API * @procedure 1. Perform string publishResourceToRD() API 2. Perform string * deleteResourceFromRD() API 3. Check ALL APIs work properly * @post_condition SignOut
<|startcomment|> Maybe not needed on Windows (there is no connectivity_abstraction.dll). <|endcomment|>  package org.iotivity.base; import org.iotivity.ca.CaInterface; import java.util.EnumSet; import java.util.Iterator; import java.util.List; /** * This class contains the main entrance/functionality of the product. To set a custom * configuration, the implementer must make a call to OcPlatform.Configure before the first usage * of a method in this class. */ public final class OcPlatform { static { System.loadLibrary("gnustl_shared"); <|startfocus|> System.loadLibrary("connectivity_abstraction"); System.loadLibrary("oc_logger"); System.loadLibrary("octbstack"); System.loadLibrary("oc"); <|endfocus|> if (0 != BuildConfig.SECURED) { System.loadLibrary("ocprovision"); } System.loadLibrary("ocstack-jni"); } /** * Default interface */ public static final String DEFAULT_INTERFACE = "oic.if.baseline"; /** * Used in discovering (GET) links to other resources of a collection */ public static final String LINK_INTERFACE = "oic.if.ll"; /**
<|startcomment|> space to be removed <|endcomment|>  public String getAuthenticationCode(String htmlbody) { <|startfocus|> String auth_token = htmlbody.substring(htmlbody.indexOf("<a href=") + 1, <|endfocus|> htmlbody.indexOf("a>")); String authcode = auth_token.substring( auth_token.indexOf("?code=") + "?code=".length(), auth_token.indexOf("\">")); return authcode;
<|startcomment|> Hmmmm (2/2) <|endcomment|>  private static boolean mTickerAddSpace; SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data, NotificationManager nManager) { Resources r = context.getResources(); // Prepare all the output metadata mParams = data; mImageTime = System.currentTimeMillis(); String imageDate = new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date(mImageTime)); mImageFileName = String.format(SCREENSHOT_FILE_NAME_TEMPLATE, imageDate); final PackageManager pm = context.getPackageManager(); <|startfocus|> ActivityInfo info = AbcUtils.getRunningActivityInfo(context); <|endfocus|> if (info != null) { CharSequence appName = pm.getApplicationLabel(info.applicationInfo); if (appName != null) { String appNameString = appName.toString().replaceAll("\\s+", "_"); mImageFileName = String.format(SCREENSHOT_FILE_NAME_TEMPLATE_APPNAME, appNameString, imageDate); } } mScreenshotDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), SCREENSHOTS_DIR_NAME); mImageFilePath = new File(mScreenshotDir, mImageFileName).getAbsolutePath(); // Create the large notification icon
<|startcomment|> and that too <|endcomment|>  @Override public void handleMessage(Message msg) { synchronized (mScreenshotLock) { if (mScreenshotConnection == myConn) { mContext.unbindService(mScreenshotConnection); mScreenshotConnection = null; mHandler.removeCallbacks(mScreenshotTimeout); } } } }; msg.replyTo = new Messenger(h); msg.arg1 = msg.arg2 = 0; /* wait for the dialog box to close */ try { <|startfocus|> Thread.sleep(1000); <|endfocus|> } catch (InterruptedException ie) { } /* take the screenshot */ try { messenger.send(msg); } catch (RemoteException e) { } }
<|startcomment|> PreferenceGroup? <|endcomment|>  mKeyboardSettingsCategory.addPreference(currentIme); } // Build hard keyboard and game controller preference categories. mIm = (InputManager)getActivity().getSystemService(Context.INPUT_SERVICE); updateInputDevices(); mStylusIconEnabled = (CheckBoxPreference) findPreference(KEY_STYLUS_ICON_ENABLED); mStylusGestures = (PreferenceScreen) findPreference(KEY_STYLUS_GESTURES); // remove stylus preference for non stylus devices if (!getResources().getBoolean(com.android.internal.R.bool.config_stylusGestures)) { <|startfocus|> PreferenceCategory pointerSettingsCategory = (PreferenceGroup) <|endfocus|> findPreference(KEY_POINTER_SETTINGS_CATEGORY); if(pointerSettingsCategory != null) { pointerSettingsCategory.removePreference(mStylusGestures); pointerSettingsCategory.removePreference(mStylusIconEnabled); } } // Spell Checker final Intent intent = new Intent(Intent.ACTION_MAIN); intent.setClass(getActivity(), SpellCheckersSettingsActivity.class); final SpellCheckersPreference scp = ((SpellCheckersPreference)findPreference( "spellcheckers_settings")); if (scp != null) { scp.setFragmentIntent(this, intent); } mHandler = new Handler(); mSettingsObserver = new SettingsObserver(mHandler, getActivity());
<|startcomment|> no reason to have this proteced - would make it private <|endcomment|>  private final int SAFE_MEDIA_VOLUME_ACTIVE = 3; private Integer mSafeMediaVolumeState; private int mMcc = 0; // mSafeMediaVolumeIndex is the cached value of config_safe_media_volume_index property private int mSafeMediaVolumeIndex; // mSafeMediaVolumeDevices lists the devices for which safe media volume is enforced, private final int mSafeMediaVolumeDevices = AudioSystem.DEVICE_OUT_WIRED_HEADSET | AudioSystem.DEVICE_OUT_WIRED_HEADPHONE; // mManualSafeMediaVolume overrides the built-in safe media volume <|startfocus|> boolean mManualSafeMediaVolume; <|endfocus|> // mMusicActiveMs is the cumulative time of music activity since safe volume was disabled. // When this time reaches UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX, the safe media volume is re-enabled // automatically. mMusicActiveMs is rounded to a multiple of MUSIC_ACTIVE_POLL_PERIOD_MS. private int mMusicActiveMs; private static final int UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX = (20 * 3600 * 1000); // 20 hours private static final int MUSIC_ACTIVE_POLL_PERIOD_MS = 60000; // 1 minute polling interval
<|startcomment|> Method does not override or implement a method from a supertype. <|endcomment|>  // It's already there, so the same as persisting return true; } Settings.Secure.putInt(getContext().getContentResolver(), getKey(), value ? 1 : 0); return true; } return false; } @Override protected boolean getPersistedBoolean(boolean defaultReturnValue) { if (!shouldPersist()) { return defaultReturnValue; } return Settings.Secure.getInt(getContext().getContentResolver(), getKey(), defaultReturnValue ? 1 : 0) != 0; } <|startfocus|> @Override <|endfocus|> protected boolean isPersisted() { // Using getString instead of getInt so we can simply check for null // instead of catching an exception. (All values are stored as strings.) return Settings.Secure.getString(getContext().getContentResolver(), getKey()) != null; } } 
<|startcomment|> spare tab <|endcomment|>  public boolean equals (Object o) { OperatorInfo s; try { s = (OperatorInfo) o; } catch (ClassCastException ex) { return false; } if (o == null) { return false; } <|startfocus|> <|endfocus|> return mOperatorAlphaLong.equals(s.getOperatorAlphaLong()) && mOperatorAlphaShort.equals(s.getOperatorAlphaShort()) && mOperatorNumeric.equals(s.getOperatorNumeric());
<|startcomment|> in this case it might be better to not use the theme value but to add a different color <|endcomment|>  SlidingTabStrip(Context context) { this(context, null); } SlidingTabStrip(Context context, AttributeSet attrs) { super(context, attrs); setWillNotDraw(false); final float density = getResources().getDisplayMetrics().density; TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.colorPrimary, outValue, true); final int themeBackgroundColor = outValue.data; setBackgroundColor(themeBackgroundColor); <|startfocus|> context.getTheme().resolveAttribute(R.attr.textColorPrimary, outValue, true); mTextPrimaryColor = outValue.data; <|endfocus|> mTextPrimaryColorDisabled = setColorAlpha(mTextPrimaryColor, DISABLED_TAB_TEXT_COLOR_ALPHA); mDefaultTabColorizer = new SimpleTabColorizer(); mDefaultTabColorizer.setIndicatorColors(DEFAULT_SELECTED_INDICATOR_COLOR); mDefaultTabColorizer.setDividerColors(setColorAlpha(mTextPrimaryColor, DEFAULT_DIVIDER_COLOR_ALPHA)); setSelectedIndicatorColors(mTextPrimaryColor); mSelectedIndicatorThickness = (int) (SELECTED_INDICATOR_THICKNESS_DIPS * density); mSelectedIndicatorPaint = new Paint(); mDividerHeight = DEFAULT_DIVIDER_HEIGHT; mDividerPaint = new Paint();
<|startcomment|> you still may want to disable this - why you remove the possibility for this from the user? <|endcomment|>  Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, doubleTapOnHomeBehavior == 1 ? ACTION_APP_SWITCH : ACTION_NOTHING); mHomeDoubleTapAction.setValue(Integer.toString(homeDoubleTapAction)); mHomeDoubleTapAction.setSummary(mHomeDoubleTapAction.getEntry()); mHomeDoubleTapAction.setOnPreferenceChangeListener(this); mKeySettings.put(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, homeDoubleTapAction); mHomeWake = (CheckBoxPreference) findPreference(BUTTON_HOME_WAKE); <|startfocus|> if (!res.getBoolean(R.bool.config_show_homeWake) || mPersistHomeWakeSupport) { <|endfocus|> mKeysHomeCategory.removePreference(mHomeWake); } else { mHomeWake.setChecked(Settings.System.getInt(resolver, Settings.System.HOME_BUTTON_WAKE, 0) != 0); } mHomeAnswerCall = (CheckBoxPreference) findPreference(BUTTON_HOME_ANSWERS_CALL); if (!Utils.isVoiceCapable(getActivity())) { mKeysHomeCategory.removePreference(mHomeAnswerCall); } else { mHomeAnswerCall.setChecked(Settings.System.getInt(resolver, Settings.System.HOME_BUTTON_ANSWER, 0) != 0); } } else { prefScreen.removePreference(mKeysHomeCategory); } 
<|startcomment|> this one is extra now, i missed it before (wasn't paying attention, only looked at the indentation) <|endcomment|>  if (swapKeys && (rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_180) && config.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR) { direction = keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_LOWER : ADJUST_RAISE; } } int flags = FLAG_SHOW_UI | FLAG_VIBRATE; adjustSuggestedStreamVolume( keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, FLAG_SHOW_UI | FLAG_VIBRATE); <|startfocus|> } <|endfocus|> break; case KeyEvent.KEYCODE_VOLUME_MUTE: if (event.getRepeatCount() == 0) { MediaSessionLegacyHelper.getHelper(getContext()) .sendVolumeKeyEvent(event, false); } break;
<|startcomment|> fails: undefined <|endcomment|>  public void update() { <|startfocus|> mFingerprintWakeUnlock = Settings.System.getIntForUser( mContext.getContentResolver(), Settings.System.FINGERPRINT_WAKE_UNLOCK, 0, mCurrentUserId) == 1; <|endfocus|>
<|startcomment|> not needed <|endcomment|>  mEnabledPref.setOnPreferenceChangeListener(this); mPulsePref = (SystemSettingSwitchPreference)prefSet.findPreference(BATTERY_PULSE_PREF); mPulsePref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_PULSE, mBatteryLightEnabled ? 1 : 0) != 0); mPulsePref.setOnPreferenceChangeListener(this); <|startfocus|> mOnlyFullPref = (SystemSettingSwitchPreference)prefSet.findPreference(BATTERY_LIGHT_ONLY_FULL_PREF); mOnlyFullPref.setChecked(Settings.System.getInt(resolver, Settings.System.BATTERY_LIGHT_ONLY_FULLY_CHARGED, 0) != 0); mOnlyFullPref.setOnPreferenceChangeListener(this); <|endfocus|> // Does the Device support changing battery LED colors? if (getResources().getBoolean(com.android.internal.R.bool.config_multiColorBatteryLed)) { setHasOptionsMenu(true); // Low, Medium and full color preferences mLowColorPref = (BatteryLightPreference) prefSet.findPreference(LOW_COLOR_PREF); mLowColorPref.setOnPreferenceChangeListener(this); mMediumColorPref = (BatteryLightPreference) prefSet.findPreference(MEDIUM_COLOR_PREF); mMediumColorPref.setOnPreferenceChangeListener(this); mFullColorPref = (BatteryLightPreference) prefSet.findPreference(FULL_COLOR_PREF);
<|startcomment|> indentation wrong <|endcomment|>  } } } private synchronized void updateLedPulse() { mLed.updateLightsLocked(); } private final class Led { private final Light mBatteryLight; private final int mBatteryLedOn; private final int mBatteryLedOff; private final int mFastThreshold = 7500000; private boolean isFastCharging; protected void FastCharge(int mWatt) { if (mWatt > mFastThreshold & mFastChargingLedEnabled){ isFastCharging = true; updateLightsLocked(); <|startfocus|> }else{ isFastCharging = false; updateLightsLocked(); } <|endfocus|> } public Led(Context context, LightsManager lights) { mBatteryLight = lights.getLight(LightsManager.LIGHT_ID_BATTERY); mBatteryLedOn = context.getResources().getInteger( com.android.internal.R.integer.config_notificationsBatteryLedOn); mBatteryLedOff = context.getResources().getInteger( com.android.internal.R.integer.config_notificationsBatteryLedOff); // Does the device supports changing battery LED colors? mMultiColorLed = context.getResources().getBoolean( com.android.internal.R.bool.config_multiColorBatteryLed); // Does the device supports fast charging
<|startcomment|> not sure if you want to log all of this <|endcomment|>  * is routed through bluetooth, a wired headset, or the speaker; the user requested, received a * request for, or is in a video call; or the phone is horizontal while in a call. */ private synchronized void updateProximitySensorMode() { final int audioRoute = mAudioModeProvider.getAudioState().getRoute(); if (mIsProximitySensorDisabled) { <|startfocus|> LogUtil.i("ProximitySensor.updateProximitySensorMode", "Proximity sensor is disabled by user!"); <|endfocus|> return; } boolean screenOnImmediately = (CallAudioState.ROUTE_WIRED_HEADSET == audioRoute || CallAudioState.ROUTE_SPEAKER == audioRoute || CallAudioState.ROUTE_BLUETOOTH == audioRoute || mIsAttemptingVideoCall || mIsVideoCall); // We do not keep the screen off when the user is outside in-call screen and we are // horizontal, but we do not force it on when we become horizontal until the // proximity sensor goes negative. final boolean horizontal = (mOrientation == AccelerometerListener.ORIENTATION_HORIZONTAL); screenOnImmediately |= !mUiShowing && horizontal; 
<|startcomment|> To make it as easy to see I would simply comment out that and just add mInNightMode=true <|endcomment|>  */ @Deprecated public Builder(Context context) { this(context, (Notification) null); } /** * @hide */ public Builder(Context context, Notification toAdopt) { mContext = context; Resources res = mContext.getResources(); mTintActionButtons = res.getBoolean(R.bool.config_tintNotificationActionButtons); if (res.getBoolean(R.bool.config_enableNightMode)) { Configuration currentConfig = res.getConfiguration(); mInNightMode = (currentConfig.uiMode & Configuration.UI_MODE_NIGHT_MASK) <|startfocus|> == Configuration.UI_MODE_NIGHT_YES; <|endfocus|> } // UI_MODE_NIGHT doesnt seem to be ready, so just listen to config mInNightMode = res.getBoolean(R.bool.config_enableNightMode); if (toAdopt == null) { mN = new Notification(); if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) { mN.extras.putBoolean(EXTRA_SHOW_WHEN, true); } mN.priority = PRIORITY_DEFAULT; mN.visibility = VISIBILITY_PRIVATE; } else { mN = toAdopt; if (mN.actions != null) {
<|startcomment|> Something went wrong here missing some stuff <|endcomment|>  } case MotionEvent.ACTION_CANCEL: break; case MotionEvent.ACTION_UP: if (mBackActionScheduled) { Utils.sendKeycode(KeyEvent.KEYCODE_BACK); } else { endQuickScrub(true /* animate */); } break; } // Proxy motion events to launcher if not handled by quick scrub or back action // Proxy motion events up/cancel that would be sent after long press on any nav button if (!mQuickScrubActive && !mBackActionScheduled <|startfocus|> && (mAllowGestureDetection || action == MotionEvent.ACTION_CANCEL <|endfocus|> proxyMotionEvents(event);
<|startcomment|> Are you using these services? <|endcomment|>  @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected CodecService codecService; @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected ComponentConfigService componentConfigService; @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected CordConfigService cordConfigService; @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected NetworkConfigRegistry networkConfig; @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected FlowRuleService flowRuleService; <|startfocus|> @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected GroupService groupService; @Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY) protected DeviceService deviceService; <|endfocus|> protected McastListener listener = new InternalMulticastListener(); private InternalNetworkConfigListener configListener = new InternalNetworkConfigListener(); //TODO: move this to a ec map private Map<GroupKey, Integer> groups = Maps.newConcurrentMap(); private ApplicationId appId; private ApplicationId coreAppId; private int mcastVlan = DEFAULT_MCAST_VLAN; @Property(name = "vlanEnabled", boolValue = DEFAULT_VLAN_ENABLED, label = "Use vlan for multicast traffic?") private boolean vlanEnabled = DEFAULT_VLAN_ENABLED; 
<|startcomment|> I'd recommend creating a SubscriberId class (which right now will just wrap a String) to use as the datatype here. That way if you want to change the internal representation of a subscriber ID later on, you don't have to change the API. <|endcomment|>  */ void removeSubscriber(ConnectPoint port); /** * Provisions flows for HSIA service for the specific subscriber. * * @param subscriberId Identification of the subscriber * @return true is successful false otherwise */ public boolean provisionHsia(String subscriberId); /** * Removes flows for HSIA service for the specific subscriber. * * @param subscriberId Identification of the subscriber * @return true is successful false otherwise */ <|startfocus|> public boolean deleteHsia(String subscriberId); <|endfocus|> /** * Returns information about the provisioned subscribers. * * @return subscribers */ Collection<Map.Entry<ConnectPoint, Map.Entry<VlanId, VlanId>>> getSubscribers(); /** * Returns the map of configured OLTs. * * @return a map */ Map<DeviceId, AccessDeviceData> fetchOlts(); } 
<|startcomment|> Who is SBO? What is a VERRUE? <|endcomment|>  public void setInput(IWorkbenchPart part_p, ISelection selection_p) { <|startfocus|> // VERRUE : see SBo for more detailed explanations <|endfocus|> if (selection_p instanceof StructuredSelection) { EObject selection = CapellaAdapterHelper.resolveSemanticObject(((StructuredSelection) selection_p).getFirstElement()); if (selection instanceof CapellaElement) { if (selection.eClass().equals(CsPackage.eINSTANCE.getPart())) { boolean allowMultiplePart = TriStateBoolean.True.equals(CapellaProjectHelper.isReusableComponentsDriven((Part) selection)); if (!allowMultiplePart) { AbstractType type = ((Part) selection).getAbstractType(); if ((type != null) && !(type instanceof ConfigurationItem)) { super.setInput(part_p, new StructuredSelection(type)); loadData((CapellaElement) type); return; } } } loadData((CapellaElement) selection); } } super.setInput(part_p, selection_p);
<|startcomment|> naming rule <|endcomment|> <|startfocus|> public CapellaNavigatorLabelProvider(TransactionalEditingDomain editingDomain, AdapterFactory adapterFactory_p) { super(editingDomain, adapterFactory_p); <|endfocus|>
<|startcomment|> Javadoc <|endcomment|>  * @version $Revision: 168 $ */ public class MSModel extends SModel implements IMSModel { /** * Default constructor. */ public MSModel() { super(); } /** * {@inheritDoc} */ @Override public String getName() { return GenericAbstractSElement.getName(getBase_Package()); } /** * {@inheritDoc} */ @Override public String getUUID() { return GenericAbstractSElement.getUUID(getBase_Package()); } <|startfocus|> <|endfocus|> @Override public EList<ISBlock> getOwnedSBlocksList() { EList<ISBlock> vSBlocksList = new BasicEList<ISBlock>(); Package vPackage = getBase_Package(); if (vPackage != null) { /* * Look for all elements stereotyped SBlock and get them */ for (Element vElement : vPackage.getOwnedElements()) { if ((vElement instanceof Class) && (UMLUtil.getStereotypeApplication(vElement, SBlock.class) != null)) { vSBlocksList.add((SBlock) UMLUtil.getStereotypeApplication(vElement, SBlock.class)); } } } 
<|startcomment|> _p <|endcomment|> <|startfocus|> public static ImageDescriptor getImageDescriptor(String key_p) { return AbstractUIPlugin.imageDescriptorFromPlugin(getPluginId(), key_p); <|endfocus|>
<|startcomment|> _p <|endcomment|> <|startfocus|> public boolean covers(IDifference difference_p) { if (difference_p instanceof IElementRelativeDifference) { IElementRelativeDifference diff = (IElementRelativeDifference) difference_p; <|endfocus|> if (diff instanceof IReferenceValuePresence) { if (CsPackage.Literals.PART__OWNED_ABSTRACT_TYPE.equals(((IReferenceValuePresence) diff).getFeature())) { return true; } } } return false;
<|startcomment|> Copyright should be updated <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2014 Thales Global Services S.A.S. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Thales Global Services S.A.S - initial API and implementation ******************************************************************************/ package org.polarsys.kitalpha.ad.viewpoint.dsl.as.model.vpdiagram.impl; import java.util.Collection; import org.eclipse.emf.common.notify.NotificationChain; import org.eclipse.emf.common.util.EList; import org.eclipse.emf.ecore.EClass; import org.eclipse.emf.ecore.InternalEObject; import org.eclipse.emf.ecore.util.EObjectContainmentEList; import org.eclipse.emf.ecore.util.InternalEList; import org.polarsys.kitalpha.ad.viewpoint.dsl.as.model.vpdiagram.AbstractEdge; import org.polarsys.kitalpha.ad.viewpoint.dsl.as.model.vpdiagram.EdgeDescription; import org.polarsys.kitalpha.ad.viewpoint.dsl.as.model.vpdiagram.VpdiagramPackage; /** * <!-- begin-user-doc -->
<|startcomment|> comment <|endcomment|>  * @param resourceSet_p * @return a {@link List} of resources if found, an empty one otherwise. */ public static List<Resource> getAvailableODesignFile(ResourceSet resourceSet_p) { List<Resource> resources = new ArrayList<Resource>(); for (Resource resource : resourceSet_p.getResources()) { if (resource.getURI().toString().endsWith(ODESIGN_EXT)) { <|startfocus|> //if ( resource.getURI().fileExtension().equals(ODESIGN_EXT) ) { <|endfocus|> resources.add(resource); } } return resources; } /** * Get all the {@link DiagramDescription} defined into a given odesign {@link Resource} * @param resources_p * @return */ public static List<DiagramDescription> getAllDiagramDescription(List<Resource> resources_p) { List<DiagramDescription> result = new ArrayList<DiagramDescription>(); for (Resource current : resources_p) { result.addAll(getAllDiagramDescription(current)); } return result; } /**
<|startcomment|> Copyright must be update <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2017 Thales Global Services S.A.S. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Thales Global Services S.A.S - initial API and implementation ******************************************************************************/ package org.polarsys.kitalpha.richtext.widget.editor.intf; import org.polarsys.kitalpha.richtext.common.intf.MDERichTextWidget; /** * @author Faycal Abka * */ public interface MDERichTextEditorCallback { void saveWorkspaceResource(MDERichTextWidget widget); boolean isWorkspaceResourceDirty(MDERichTextWidget widget); /** * * Register the widget as a listener for the save of workspace resource. */ void registerWorkspaceResourceSaveListener(MDERichTextWidget widget); } 
<|startcomment|> to test. this preference is also customisable through windows/preference/sirius/diagram. using setValue may prevent user to use it. uc: user set preference, then restart, the preference shall be the user one, not the one used in initialiser. <|endcomment|>  preferenceStore.setDefault(IMonitorFileSyncPreferences.PREFERENCE_ENABLE_FILE_SYNC_MONITORING, false); // Set Sirius UI preferences // required since Sirius 5.1 since default behavior is not welcome IPreferenceStore siriusUiPreferenceStore = SiriusEditPlugin.getPlugin().getPreferenceStore(); siriusUiPreferenceStore.setValue(SiriusUIPreferencesKeys.PREF_SAVE_WHEN_NO_EDITOR.name(), false); siriusUiPreferenceStore.setValue(SiriusUIPreferencesKeys.PREF_RELOAD_ON_LAST_EDITOR_CLOSE.name(), false); <|startfocus|> siriusUiPreferenceStore.setValue(SiriusUIPreferencesKeys.PREF_DISPLAY_VSM_USER_FIXED_COLOR_IN_PALETTE.name(), false); <|endfocus|>
<|startcomment|> wrong copyright.. :( <|endcomment|> ***************************************************************************** <|startfocus|> * Copyright (c) 2018 Thales Global Services S.A.S. <|endfocus|> * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: * Thales Global Services S.A.S - initial API and implementation *******************************************************************************/ package org.polarsys.capella.test.recrpl.ju.testcases.fragmented; import static org.junit.Assert.assertNotEquals; import java.util.Arrays; import java.util.HashMap; import org.eclipse.emf.ecore.EObject; import org.polarsys.capella.common.re.CatalogElement; import org.polarsys.capella.common.re.helpers.ReplicableElementExt; import org.polarsys.capella.test.recrpl.ju.model.Fragmented; public class CreateRPLOnFragmentedModel extends Fragmented { @Override public void performTest() throws Exception { HashMap<String, String> recToLayerMap = new HashMap<>(); recToLayerMap.put(OA_REC_ID, OA_LAYER_ID); recToLayerMap.put(SA_REC_ID, SA_LAYER_ID);
<|startcomment|> This should be a Set type, since the .contains method on line 48 is costly for List type. <|endcomment|>  public IStatus validate(IValidationContext ctx) { EObject eObj = ctx.getTarget(); EMFEventType eType = ctx.getEventType(); if (eType == EMFEventType.NULL) { if (eObj instanceof AbstractFunction) { AbstractFunction abstractFunction = (AbstractFunction) eObj; List<State> functionStates = abstractFunction.getAvailableInStates(); List<State> allChainStates = new ArrayList<State>(); String chainName = "FunctionalChain"; <|startfocus|> for (FunctionalChain chain : abstractFunction.getInvolvingFunctionalChains()) { allChainStates.addAll(chain.getAvailableInStates()); chainName = chain.eClass().getName(); } <|endfocus|> boolean ok = allChainStates.isEmpty(); if (!ok) { for (State state : functionStates) { if (allChainStates.contains(state)) { ok = true; break; } } } if (!ok) { return ctx.createFailureStatus(new Object[] { abstractFunction.getName(), chainName }); } } } return ctx.createSuccessStatus();
<|startcomment|> Use java naming convention <|endcomment|> import org.polarsys.capella.docgen.configuration.ui.viewer.providers.SessionContentProvider; /** * Wizard page to select capella element for XHTML generation. */ @SuppressWarnings("restriction") public class SelectElementsWizardPage extends WizardPage { /** * Session. */ private Session _session; /** * Widgets. */ <|startfocus|> private Text _fileText; private CapellaNavigatorPatternFilter _patternFilter; private GenerationContainerCheckedTreeViewer _leftTreeViewer; private GenerationContainerCheckedTreeViewer _rightTreeViewer; private Button _btnLoad; private Button _btnSave; <|endfocus|> /** * Constructor for SelectElementsWizardPage. * * @param pageName */ public SelectElementsWizardPage(ISelection selection_p) { super("selectElementWizardPage"); //$NON-NLS-1$ setTitle(Messages.SelectElementsWizardPage_0); setDescription(Messages.SelectElementsWizardPage_1); setMessage(Messages.SelectElementsWizardPage_2, IMessageProvider.INFORMATION); initSession(selection_p); } /** * Init session from selected aird file. * * @param selection_p * ISelection */ protected void initSession(ISelection selection_p) {
<|startcomment|> All this code should be reverted. If tomorow the context.getElement() function changes your code is no longer valid. <|endcomment|>  context.getElement(sourceFunction, exchange); if (context.getElement(sourceFunction, exchange) instanceof AbstractFunction && EcoreUtil.isAncestor(aView, bView) && (!context.getDiagramElements(sourceFunction).contains(aView))) { sourceContainerView = context.getDDiagram(); } if (context.getElement(targetFunction, exchange) instanceof AbstractFunction && EcoreUtil.isAncestor(bView, aView) && (!context.getDiagramElements(targetFunction).contains(bView))) { targetContainerView = context.getDDiagram(); } <|startfocus|> <|endfocus|> } // If preferred source is not a node (null, or diagram), we need to // display best parent function of the source // (port or OperationalActivity) if (sourceView == null) { if (sourceContainerView instanceof AbstractDNode) { sourceView = (AbstractDNode) sourceContainerView; } else { sourceView = showDFAbstractFunction(sourceFunction, context.getBestContainer(sourceFunction), context); } } // If preferred source is not a node (null, or diagram), we need to // display best parent function of the source